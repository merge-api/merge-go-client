// Code generated by Fern. DO NOT EDIT.

package hris

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type IssuesListRequest struct {
	AccountToken *string `json:"-" url:"account_token,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// If included, will only include issues whose most recent action occurred before this time
	EndDate                 *string `json:"-" url:"end_date,omitempty"`
	EndUserOrganizationName *string `json:"-" url:"end_user_organization_name,omitempty"`
	// If provided, will only return issues whose first incident time was after this datetime.
	FirstIncidentTimeAfter *time.Time `json:"-" url:"first_incident_time_after,omitempty"`
	// If provided, will only return issues whose first incident time was before this datetime.
	FirstIncidentTimeBefore *time.Time `json:"-" url:"first_incident_time_before,omitempty"`
	// If true, will include muted issues
	IncludeMuted    *string `json:"-" url:"include_muted,omitempty"`
	IntegrationName *string `json:"-" url:"integration_name,omitempty"`
	// If provided, will only return issues whose last incident time was after this datetime.
	LastIncidentTimeAfter *time.Time `json:"-" url:"last_incident_time_after,omitempty"`
	// If provided, will only return issues whose last incident time was before this datetime.
	LastIncidentTimeBefore *time.Time `json:"-" url:"last_incident_time_before,omitempty"`
	// If provided, will only include issues pertaining to the linked account passed in.
	LinkedAccountId *string `json:"-" url:"linked_account_id,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// If included, will only include issues whose most recent action occurred after this time
	StartDate *string `json:"-" url:"start_date,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// * `ONGOING` - ONGOING
	// * `RESOLVED` - RESOLVED
	Status *IssuesListRequestStatus `json:"-" url:"status,omitempty"`
}

type IssuesListRequestStatus string

const (
	IssuesListRequestStatusOngoing  IssuesListRequestStatus = "ONGOING"
	IssuesListRequestStatusResolved IssuesListRequestStatus = "RESOLVED"
)

func NewIssuesListRequestStatusFromString(s string) (IssuesListRequestStatus, error) {
	switch s {
	case "ONGOING":
		return IssuesListRequestStatusOngoing, nil
	case "RESOLVED":
		return IssuesListRequestStatusResolved, nil
	}
	var t IssuesListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssuesListRequestStatus) Ptr() *IssuesListRequestStatus {
	return &i
}

type Issue struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// * `ONGOING` - ONGOING
	// * `RESOLVED` - RESOLVED
	Status            *IssueStatus           `json:"status,omitempty" url:"status,omitempty"`
	ErrorDescription  string                 `json:"error_description" url:"error_description"`
	EndUser           map[string]interface{} `json:"end_user,omitempty" url:"end_user,omitempty"`
	FirstIncidentTime *time.Time             `json:"first_incident_time,omitempty" url:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time             `json:"last_incident_time,omitempty" url:"last_incident_time,omitempty"`
	IsMuted           *bool                  `json:"is_muted,omitempty" url:"is_muted,omitempty"`
	ErrorDetails      []string               `json:"error_details,omitempty" url:"error_details,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Issue) GetId() *string {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *Issue) GetStatus() *IssueStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *Issue) GetErrorDescription() string {
	if i == nil {
		return ""
	}
	return i.ErrorDescription
}

func (i *Issue) GetEndUser() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.EndUser
}

func (i *Issue) GetFirstIncidentTime() *time.Time {
	if i == nil {
		return nil
	}
	return i.FirstIncidentTime
}

func (i *Issue) GetLastIncidentTime() *time.Time {
	if i == nil {
		return nil
	}
	return i.LastIncidentTime
}

func (i *Issue) GetIsMuted() *bool {
	if i == nil {
		return nil
	}
	return i.IsMuted
}

func (i *Issue) GetErrorDetails() []string {
	if i == nil {
		return nil
	}
	return i.ErrorDetails
}

func (i *Issue) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	type embed Issue
	var unmarshaler = struct {
		embed
		FirstIncidentTime *internal.DateTime `json:"first_incident_time,omitempty"`
		LastIncidentTime  *internal.DateTime `json:"last_incident_time,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Issue(unmarshaler.embed)
	i.FirstIncidentTime = unmarshaler.FirstIncidentTime.TimePtr()
	i.LastIncidentTime = unmarshaler.LastIncidentTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Issue) MarshalJSON() ([]byte, error) {
	type embed Issue
	var marshaler = struct {
		embed
		FirstIncidentTime *internal.DateTime `json:"first_incident_time,omitempty"`
		LastIncidentTime  *internal.DateTime `json:"last_incident_time,omitempty"`
	}{
		embed:             embed(*i),
		FirstIncidentTime: internal.NewOptionalDateTime(i.FirstIncidentTime),
		LastIncidentTime:  internal.NewOptionalDateTime(i.LastIncidentTime),
	}
	return json.Marshal(marshaler)
}

func (i *Issue) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// * `ONGOING` - ONGOING
// * `RESOLVED` - RESOLVED
type IssueStatus struct {
	IssueStatusEnum IssueStatusEnum
	String          string

	typ string
}

func (i *IssueStatus) GetIssueStatusEnum() IssueStatusEnum {
	if i == nil {
		return ""
	}
	return i.IssueStatusEnum
}

func (i *IssueStatus) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typ = "IssueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	if i.typ == "IssueStatusEnum" || i.IssueStatusEnum != "" {
		return json.Marshal(i.IssueStatusEnum)
	}
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	if i.typ == "IssueStatusEnum" || i.IssueStatusEnum != "" {
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	}
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// * `ONGOING` - ONGOING
// * `RESOLVED` - RESOLVED
type IssueStatusEnum string

const (
	IssueStatusEnumOngoing  IssueStatusEnum = "ONGOING"
	IssueStatusEnumResolved IssueStatusEnum = "RESOLVED"
)

func NewIssueStatusEnumFromString(s string) (IssueStatusEnum, error) {
	switch s {
	case "ONGOING":
		return IssueStatusEnumOngoing, nil
	case "RESOLVED":
		return IssueStatusEnumResolved, nil
	}
	var t IssueStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatusEnum) Ptr() *IssueStatusEnum {
	return &i
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty" url:"next,omitempty"`
	Previous *string  `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedIssueList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedIssueList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedIssueList) GetResults() []*Issue {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedIssueList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedIssueList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedIssueList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedIssueList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedIssueList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
