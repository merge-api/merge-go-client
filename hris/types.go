// This file was auto-generated by Fern from our API Definition.

package hris

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/merge-api/merge-go-client/core"
	time "time"
)

type AccountDetails struct {
	Id                      *string       `json:"id,omitempty"`
	Integration             *string       `json:"integration,omitempty"`
	IntegrationSlug         *string       `json:"integration_slug,omitempty"`
	Category                *CategoryEnum `json:"category,omitempty"`
	EndUserOriginId         *string       `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName *string       `json:"end_user_organization_name,omitempty"`
	EndUserEmailAddress     *string       `json:"end_user_email_address,omitempty"`
	Status                  *string       `json:"status,omitempty"`
	WebhookListenerUrl      *string       `json:"webhook_listener_url,omitempty"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool   `json:"is_duplicate,omitempty"`
	AccountType *string `json:"account_type,omitempty"`
	// The time at which account completes the linking flow.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetails(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The LinkedAccount Object
//
// ### Description
//
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
//
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                             `json:"id"`
	Category                *CategoryEnum                      `json:"category,omitempty"`
	Status                  AccountDetailsAndActionsStatusEnum `json:"status,omitempty"`
	StatusDetail            *string                            `json:"status_detail,omitempty"`
	EndUserOriginId         *string                            `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                             `json:"end_user_organization_name"`
	EndUserEmailAddress     string                             `json:"end_user_email_address"`
	// The tenant or domain the customer has provided access to.
	Subdomain          *string `json:"subdomain,omitempty"`
	WebhookListenerUrl string  `json:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty"`
	AccountType string                               `json:"account_type"`
	CompletedAt time.Time                            `json:"completed_at"`

	_rawJSON json.RawMessage
}

func (a *AccountDetailsAndActions) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetailsAndActions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetailsAndActions(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetailsAndActions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name"`
	Categories               []CategoriesEnum  `json:"categories,omitempty"`
	Image                    *string           `json:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty"`
	Color                    string            `json:"color"`
	Slug                     string            `json:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountDetailsAndActionsIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetailsAndActionsIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetailsAndActionsIntegration(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetailsAndActionsIntegration) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// - `COMPLETE` - COMPLETE
// - `INCOMPLETE` - INCOMPLETE
// - `RELINK_NEEDED` - RELINK_NEEDED
// - `IDLE` - IDLE
type AccountDetailsAndActionsStatusEnum string

const (
	AccountDetailsAndActionsStatusEnumComplete     AccountDetailsAndActionsStatusEnum = "COMPLETE"
	AccountDetailsAndActionsStatusEnumIncomplete   AccountDetailsAndActionsStatusEnum = "INCOMPLETE"
	AccountDetailsAndActionsStatusEnumRelinkNeeded AccountDetailsAndActionsStatusEnum = "RELINK_NEEDED"
	AccountDetailsAndActionsStatusEnumIdle         AccountDetailsAndActionsStatusEnum = "IDLE"
)

func NewAccountDetailsAndActionsStatusEnumFromString(s string) (AccountDetailsAndActionsStatusEnum, error) {
	switch s {
	case "COMPLETE":
		return AccountDetailsAndActionsStatusEnumComplete, nil
	case "INCOMPLETE":
		return AccountDetailsAndActionsStatusEnumIncomplete, nil
	case "RELINK_NEEDED":
		return AccountDetailsAndActionsStatusEnumRelinkNeeded, nil
	case "IDLE":
		return AccountDetailsAndActionsStatusEnumIdle, nil
	}
	var t AccountDetailsAndActionsStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountDetailsAndActionsStatusEnum) Ptr() *AccountDetailsAndActionsStatusEnum {
	return &a
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name"`
	// Optional. This shortened name appears in places with limited space, usually in conjunction with the platform's logo (e.g., Merge Link menu).<br><br>Example: <i>Workforce Now (in lieu of ADP Workforce Now), SuccessFactors (in lieu of SAP SuccessFactors)</i>
	AbbreviatedName *string `json:"abbreviated_name,omitempty"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty"`
	// Company logo in rectangular shape.
	Image *string `json:"image,omitempty"`
	// Company logo in square shape.
	SquareImage *string `json:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]interface{} `json:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty"`
	// Category or categories this integration is in beta status for.
	CategoryBetaStatus map[string]interface{} `json:"category_beta_status,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountIntegration(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountIntegration) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountToken struct {
	AccountToken string              `json:"account_token"`
	Integration  *AccountIntegration `json:"integration,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountToken) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountToken(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountToken) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// - `SAVINGS` - SAVINGS
// - `CHECKING` - CHECKING
type AccountTypeEnum string

const (
	AccountTypeEnumSavings  AccountTypeEnum = "SAVINGS"
	AccountTypeEnumChecking AccountTypeEnum = "CHECKING"
)

func NewAccountTypeEnumFromString(s string) (AccountTypeEnum, error) {
	switch s {
	case "SAVINGS":
		return AccountTypeEnumSavings, nil
	case "CHECKING":
		return AccountTypeEnumChecking, nil
	}
	var t AccountTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountTypeEnum) Ptr() *AccountTypeEnum {
	return &a
}

type AdvancedMetadata struct {
	Id           string        `json:"id"`
	DisplayName  *string       `json:"display_name,omitempty"`
	Description  *string       `json:"description,omitempty"`
	IsRequired   *bool         `json:"is_required,omitempty"`
	IsCustom     *bool         `json:"is_custom,omitempty"`
	FieldChoices []interface{} `json:"field_choices,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AdvancedMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler AdvancedMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdvancedMetadata(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdvancedMetadata) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AsyncPassthroughReciept struct {
	AsyncPassthroughReceiptId string `json:"async_passthrough_receipt_id"`

	_rawJSON json.RawMessage
}

func (a *AsyncPassthroughReciept) UnmarshalJSON(data []byte) error {
	type unmarshaler AsyncPassthroughReciept
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AsyncPassthroughReciept(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AsyncPassthroughReciept) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuditLogEvent struct {
	Id *string `json:"id,omitempty"`
	// The User's full name at the time of this Event occurring.
	UserName *string `json:"user_name,omitempty"`
	// The User's email at the time of this Event occurring.
	UserEmail *string `json:"user_email,omitempty"`
	// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
	//
	// - `ADMIN` - ADMIN
	// - `DEVELOPER` - DEVELOPER
	// - `MEMBER` - MEMBER
	// - `API` - API
	// - `SYSTEM` - SYSTEM
	// - `MERGE_TEAM` - MERGE_TEAM
	Role      *AuditLogEventRole `json:"role,omitempty"`
	IpAddress string             `json:"ip_address"`
	// Designates the type of event that occurred.
	//
	// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
	// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
	// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
	// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
	// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
	// - `INVITED_USER` - INVITED_USER
	// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
	// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
	// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
	// - `CREATED_DESTINATION` - CREATED_DESTINATION
	// - `DELETED_DESTINATION` - DELETED_DESTINATION
	// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
	// - `CHANGED_SCOPES` - CHANGED_SCOPES
	// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
	// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
	// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
	// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
	// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
	// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
	// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
	// - `RESET_PASSWORD` - RESET_PASSWORD
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
	// - `CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
	// - `DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
	// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
	// - `MUTED_ISSUE` - MUTED_ISSUE
	// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
	// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
	// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
	// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
	// - `END_USER_CREDENTIALS_ACCESSED` - END_USER_CREDENTIALS_ACCESSED
	EventType        *AuditLogEventEventType `json:"event_type,omitempty"`
	EventDescription string                  `json:"event_description"`
	CreatedAt        *time.Time              `json:"created_at,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AuditLogEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AuditLogEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuditLogEvent(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuditLogEvent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Designates the type of event that occurred.
//
// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
// - `MUTED_ISSUE` - MUTED_ISSUE
// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
// - `END_USER_CREDENTIALS_ACCESSED` - END_USER_CREDENTIALS_ACCESSED
type AuditLogEventEventType struct {
	typeName      string
	EventTypeEnum EventTypeEnum
	String        string
}

func NewAuditLogEventEventTypeFromEventTypeEnum(value EventTypeEnum) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "eventTypeEnum", EventTypeEnum: value}
}

func NewAuditLogEventEventTypeFromString(value string) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "string", String: value}
}

func (a *AuditLogEventEventType) UnmarshalJSON(data []byte) error {
	var valueEventTypeEnum EventTypeEnum
	if err := json.Unmarshal(data, &valueEventTypeEnum); err == nil {
		a.typeName = "eventTypeEnum"
		a.EventTypeEnum = valueEventTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventEventType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return json.Marshal(a.EventTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventEventTypeVisitor interface {
	VisitEventTypeEnum(EventTypeEnum) error
	VisitString(string) error
}

func (a *AuditLogEventEventType) Accept(visitor AuditLogEventEventTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return visitor.VisitEventTypeEnum(a.EventTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
//
// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type AuditLogEventRole struct {
	typeName string
	RoleEnum RoleEnum
	String   string
}

func NewAuditLogEventRoleFromRoleEnum(value RoleEnum) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "roleEnum", RoleEnum: value}
}

func NewAuditLogEventRoleFromString(value string) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "string", String: value}
}

func (a *AuditLogEventRole) UnmarshalJSON(data []byte) error {
	var valueRoleEnum RoleEnum
	if err := json.Unmarshal(data, &valueRoleEnum); err == nil {
		a.typeName = "roleEnum"
		a.RoleEnum = valueRoleEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventRole) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return json.Marshal(a.RoleEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventRoleVisitor interface {
	VisitRoleEnum(RoleEnum) error
	VisitString(string) error
}

func (a *AuditLogEventRole) Accept(visitor AuditLogEventRoleVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return visitor.VisitRoleEnum(a.RoleEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The AvailableActions Object
//
// ### Description
//
// The `Activity` object is used to see all available model/operation combinations for an integration.
//
// ### Usage Example
//
// Fetch all the actions available for the `Zenefits` integration.
type AvailableActions struct {
	Integration              *AccountIntegration `json:"integration,omitempty"`
	PassthroughAvailable     bool                `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation   `json:"available_model_operations,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AvailableActions) UnmarshalJSON(data []byte) error {
	type unmarshaler AvailableActions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AvailableActions(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AvailableActions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The BankInfo Object
//
// ### Description
//
// The `BankInfo` object is used to represent the Bank Account information for an Employee.
//
// ### Usage Example
//
// Fetch from the `LIST BankInfo` endpoint and filter by `ID` to show all bank information.
type BankInfo struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee with this bank account.
	Employee *BankInfoEmployee `json:"employee,omitempty"`
	// The account number.
	AccountNumber *string `json:"account_number,omitempty"`
	// The routing number.
	RoutingNumber *string `json:"routing_number,omitempty"`
	// The bank name.
	BankName *string `json:"bank_name,omitempty"`
	// The bank account type
	//
	// - `SAVINGS` - SAVINGS
	// - `CHECKING` - CHECKING
	AccountType *BankInfoAccountType `json:"account_type,omitempty"`
	// When the matching bank object was created in the third party system.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler BankInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankInfo(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankInfo) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The bank account type
//
// - `SAVINGS` - SAVINGS
// - `CHECKING` - CHECKING
type BankInfoAccountType struct {
	typeName        string
	AccountTypeEnum AccountTypeEnum
	String          string
}

func NewBankInfoAccountTypeFromAccountTypeEnum(value AccountTypeEnum) *BankInfoAccountType {
	return &BankInfoAccountType{typeName: "accountTypeEnum", AccountTypeEnum: value}
}

func NewBankInfoAccountTypeFromString(value string) *BankInfoAccountType {
	return &BankInfoAccountType{typeName: "string", String: value}
}

func (b *BankInfoAccountType) UnmarshalJSON(data []byte) error {
	var valueAccountTypeEnum AccountTypeEnum
	if err := json.Unmarshal(data, &valueAccountTypeEnum); err == nil {
		b.typeName = "accountTypeEnum"
		b.AccountTypeEnum = valueAccountTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankInfoAccountType) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "accountTypeEnum":
		return json.Marshal(b.AccountTypeEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankInfoAccountTypeVisitor interface {
	VisitAccountTypeEnum(AccountTypeEnum) error
	VisitString(string) error
}

func (b *BankInfoAccountType) Accept(visitor BankInfoAccountTypeVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "accountTypeEnum":
		return visitor.VisitAccountTypeEnum(b.AccountTypeEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// The employee with this bank account.
type BankInfoEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewBankInfoEmployeeFromString(value string) *BankInfoEmployee {
	return &BankInfoEmployee{typeName: "string", String: value}
}

func NewBankInfoEmployeeFromEmployee(value *Employee) *BankInfoEmployee {
	return &BankInfoEmployee{typeName: "employee", Employee: value}
}

func (b *BankInfoEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		b.typeName = "employee"
		b.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankInfoEmployee) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return json.Marshal(b.String)
	case "employee":
		return json.Marshal(b.Employee)
	}
}

type BankInfoEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (b *BankInfoEmployee) Accept(visitor BankInfoEmployeeVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return visitor.VisitString(b.String)
	case "employee":
		return visitor.VisitEmployee(b.Employee)
	}
}

// # The Benefit Object
//
// ### Description
//
// The `Benefit` object is used to represent a benefit that an employee has enrolled in.
//
// ### Usage Example
//
// Fetch from the `LIST Benefits` endpoint and filter by `ID` to show all benefits.
type Benefit struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee on the plan.
	Employee *BenefitEmployee `json:"employee,omitempty"`
	// The name of the benefit provider.
	ProviderName *string `json:"provider_name,omitempty"`
	// The type of benefit plan
	BenefitPlanType *string `json:"benefit_plan_type,omitempty"`
	// The employee's contribution.
	EmployeeContribution *float64 `json:"employee_contribution,omitempty"`
	// The company's contribution.
	CompanyContribution *float64 `json:"company_contribution,omitempty"`
	// The day and time the benefit started.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The day and time the benefit ended.
	EndDate *time.Time `json:"end_date,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// The employer benefit plan the employee is enrolled in.
	EmployerBenefit *string                `json:"employer_benefit,omitempty"`
	FieldMappings   map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData      []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (b *Benefit) UnmarshalJSON(data []byte) error {
	type unmarshaler Benefit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Benefit(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Benefit) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The employee on the plan.
type BenefitEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewBenefitEmployeeFromString(value string) *BenefitEmployee {
	return &BenefitEmployee{typeName: "string", String: value}
}

func NewBenefitEmployeeFromEmployee(value *Employee) *BenefitEmployee {
	return &BenefitEmployee{typeName: "employee", Employee: value}
}

func (b *BenefitEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		b.typeName = "employee"
		b.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BenefitEmployee) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return json.Marshal(b.String)
	case "employee":
		return json.Marshal(b.Employee)
	}
}

type BenefitEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (b *BenefitEmployee) Accept(visitor BenefitEmployeeVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return visitor.VisitString(b.String)
	case "employee":
		return visitor.VisitEmployee(b.Employee)
	}
}

// - `MEDICAL` - MEDICAL
// - `HEALTH_SAVINGS` - HEALTH_SAVINGS
// - `INSURANCE` - INSURANCE
// - `RETIREMENT` - RETIREMENT
// - `OTHER` - OTHER
type BenefitPlanTypeEnum string

const (
	BenefitPlanTypeEnumMedical       BenefitPlanTypeEnum = "MEDICAL"
	BenefitPlanTypeEnumHealthSavings BenefitPlanTypeEnum = "HEALTH_SAVINGS"
	BenefitPlanTypeEnumInsurance     BenefitPlanTypeEnum = "INSURANCE"
	BenefitPlanTypeEnumRetirement    BenefitPlanTypeEnum = "RETIREMENT"
	BenefitPlanTypeEnumOther         BenefitPlanTypeEnum = "OTHER"
)

func NewBenefitPlanTypeEnumFromString(s string) (BenefitPlanTypeEnum, error) {
	switch s {
	case "MEDICAL":
		return BenefitPlanTypeEnumMedical, nil
	case "HEALTH_SAVINGS":
		return BenefitPlanTypeEnumHealthSavings, nil
	case "INSURANCE":
		return BenefitPlanTypeEnumInsurance, nil
	case "RETIREMENT":
		return BenefitPlanTypeEnumRetirement, nil
	case "OTHER":
		return BenefitPlanTypeEnumOther, nil
	}
	var t BenefitPlanTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BenefitPlanTypeEnum) Ptr() *BenefitPlanTypeEnum {
	return &b
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoriesEnum string

const (
	CategoriesEnumHris        CategoriesEnum = "hris"
	CategoriesEnumAts         CategoriesEnum = "ats"
	CategoriesEnumAccounting  CategoriesEnum = "accounting"
	CategoriesEnumTicketing   CategoriesEnum = "ticketing"
	CategoriesEnumCrm         CategoriesEnum = "crm"
	CategoriesEnumMktg        CategoriesEnum = "mktg"
	CategoriesEnumFilestorage CategoriesEnum = "filestorage"
)

func NewCategoriesEnumFromString(s string) (CategoriesEnum, error) {
	switch s {
	case "hris":
		return CategoriesEnumHris, nil
	case "ats":
		return CategoriesEnumAts, nil
	case "accounting":
		return CategoriesEnumAccounting, nil
	case "ticketing":
		return CategoriesEnumTicketing, nil
	case "crm":
		return CategoriesEnumCrm, nil
	case "mktg":
		return CategoriesEnumMktg, nil
	case "filestorage":
		return CategoriesEnumFilestorage, nil
	}
	var t CategoriesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoriesEnum) Ptr() *CategoriesEnum {
	return &c
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoryEnum string

const (
	CategoryEnumHris        CategoryEnum = "hris"
	CategoryEnumAts         CategoryEnum = "ats"
	CategoryEnumAccounting  CategoryEnum = "accounting"
	CategoryEnumTicketing   CategoryEnum = "ticketing"
	CategoryEnumCrm         CategoryEnum = "crm"
	CategoryEnumMktg        CategoryEnum = "mktg"
	CategoryEnumFilestorage CategoryEnum = "filestorage"
)

func NewCategoryEnumFromString(s string) (CategoryEnum, error) {
	switch s {
	case "hris":
		return CategoryEnumHris, nil
	case "ats":
		return CategoryEnumAts, nil
	case "accounting":
		return CategoryEnumAccounting, nil
	case "ticketing":
		return CategoryEnumTicketing, nil
	case "crm":
		return CategoryEnumCrm, nil
	case "mktg":
		return CategoryEnumMktg, nil
	case "filestorage":
		return CategoryEnumFilestorage, nil
	}
	var t CategoryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryEnum) Ptr() *CategoryEnum {
	return &c
}

type CommonModelScopeApi struct {
	// The common models you want to update the scopes for
	CommonModels []*IndividualCommonModelScopeDeserializer `json:"common_models,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommonModelScopeApi) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonModelScopeApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonModelScopeApi(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonModelScopeApi) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommonModelScopesBodyRequest struct {
	ModelId        string               `json:"model_id"`
	EnabledActions []EnabledActionsEnum `json:"enabled_actions,omitempty"`
	DisabledFields []string             `json:"disabled_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommonModelScopesBodyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonModelScopesBodyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonModelScopesBodyRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonModelScopesBodyRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// # The Company Object
//
// ### Description
//
// The `Company` object is used to represent a company within the HRIS / Payroll system.
//
// ### Usage Example
//
// Fetch from the `LIST Companies` endpoint and filter by `ID` to show all companies.
type Company struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The company's legal name.
	LegalName *string `json:"legal_name,omitempty"`
	// The company's display name.
	DisplayName *string `json:"display_name,omitempty"`
	// The company's Employer Identification Numbers.
	Eins []*string `json:"eins,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Company) UnmarshalJSON(data []byte) error {
	type unmarshaler Company
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Company(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Company) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// - `AF` - Afghanistan
// - `AX` - Åland Islands
// - `AL` - Albania
// - `DZ` - Algeria
// - `AS` - American Samoa
// - `AD` - Andorra
// - `AO` - Angola
// - `AI` - Anguilla
// - `AQ` - Antarctica
// - `AG` - Antigua and Barbuda
// - `AR` - Argentina
// - `AM` - Armenia
// - `AW` - Aruba
// - `AU` - Australia
// - `AT` - Austria
// - `AZ` - Azerbaijan
// - `BS` - Bahamas
// - `BH` - Bahrain
// - `BD` - Bangladesh
// - `BB` - Barbados
// - `BY` - Belarus
// - `BE` - Belgium
// - `BZ` - Belize
// - `BJ` - Benin
// - `BM` - Bermuda
// - `BT` - Bhutan
// - `BO` - Bolivia
// - `BQ` - Bonaire, Sint Eustatius and Saba
// - `BA` - Bosnia and Herzegovina
// - `BW` - Botswana
// - `BV` - Bouvet Island
// - `BR` - Brazil
// - `IO` - British Indian Ocean Territory
// - `BN` - Brunei
// - `BG` - Bulgaria
// - `BF` - Burkina Faso
// - `BI` - Burundi
// - `CV` - Cabo Verde
// - `KH` - Cambodia
// - `CM` - Cameroon
// - `CA` - Canada
// - `KY` - Cayman Islands
// - `CF` - Central African Republic
// - `TD` - Chad
// - `CL` - Chile
// - `CN` - China
// - `CX` - Christmas Island
// - `CC` - Cocos (Keeling) Islands
// - `CO` - Colombia
// - `KM` - Comoros
// - `CG` - Congo
// - `CD` - Congo (the Democratic Republic of the)
// - `CK` - Cook Islands
// - `CR` - Costa Rica
// - `CI` - Côte d'Ivoire
// - `HR` - Croatia
// - `CU` - Cuba
// - `CW` - Curaçao
// - `CY` - Cyprus
// - `CZ` - Czechia
// - `DK` - Denmark
// - `DJ` - Djibouti
// - `DM` - Dominica
// - `DO` - Dominican Republic
// - `EC` - Ecuador
// - `EG` - Egypt
// - `SV` - El Salvador
// - `GQ` - Equatorial Guinea
// - `ER` - Eritrea
// - `EE` - Estonia
// - `SZ` - Eswatini
// - `ET` - Ethiopia
// - `FK` - Falkland Islands (Malvinas)
// - `FO` - Faroe Islands
// - `FJ` - Fiji
// - `FI` - Finland
// - `FR` - France
// - `GF` - French Guiana
// - `PF` - French Polynesia
// - `TF` - French Southern Territories
// - `GA` - Gabon
// - `GM` - Gambia
// - `GE` - Georgia
// - `DE` - Germany
// - `GH` - Ghana
// - `GI` - Gibraltar
// - `GR` - Greece
// - `GL` - Greenland
// - `GD` - Grenada
// - `GP` - Guadeloupe
// - `GU` - Guam
// - `GT` - Guatemala
// - `GG` - Guernsey
// - `GN` - Guinea
// - `GW` - Guinea-Bissau
// - `GY` - Guyana
// - `HT` - Haiti
// - `HM` - Heard Island and McDonald Islands
// - `VA` - Holy See
// - `HN` - Honduras
// - `HK` - Hong Kong
// - `HU` - Hungary
// - `IS` - Iceland
// - `IN` - India
// - `ID` - Indonesia
// - `IR` - Iran
// - `IQ` - Iraq
// - `IE` - Ireland
// - `IM` - Isle of Man
// - `IL` - Israel
// - `IT` - Italy
// - `JM` - Jamaica
// - `JP` - Japan
// - `JE` - Jersey
// - `JO` - Jordan
// - `KZ` - Kazakhstan
// - `KE` - Kenya
// - `KI` - Kiribati
// - `KW` - Kuwait
// - `KG` - Kyrgyzstan
// - `LA` - Laos
// - `LV` - Latvia
// - `LB` - Lebanon
// - `LS` - Lesotho
// - `LR` - Liberia
// - `LY` - Libya
// - `LI` - Liechtenstein
// - `LT` - Lithuania
// - `LU` - Luxembourg
// - `MO` - Macao
// - `MG` - Madagascar
// - `MW` - Malawi
// - `MY` - Malaysia
// - `MV` - Maldives
// - `ML` - Mali
// - `MT` - Malta
// - `MH` - Marshall Islands
// - `MQ` - Martinique
// - `MR` - Mauritania
// - `MU` - Mauritius
// - `YT` - Mayotte
// - `MX` - Mexico
// - `FM` - Micronesia (Federated States of)
// - `MD` - Moldova
// - `MC` - Monaco
// - `MN` - Mongolia
// - `ME` - Montenegro
// - `MS` - Montserrat
// - `MA` - Morocco
// - `MZ` - Mozambique
// - `MM` - Myanmar
// - `NA` - Namibia
// - `NR` - Nauru
// - `NP` - Nepal
// - `NL` - Netherlands
// - `NC` - New Caledonia
// - `NZ` - New Zealand
// - `NI` - Nicaragua
// - `NE` - Niger
// - `NG` - Nigeria
// - `NU` - Niue
// - `NF` - Norfolk Island
// - `KP` - North Korea
// - `MK` - North Macedonia
// - `MP` - Northern Mariana Islands
// - `NO` - Norway
// - `OM` - Oman
// - `PK` - Pakistan
// - `PW` - Palau
// - `PS` - Palestine, State of
// - `PA` - Panama
// - `PG` - Papua New Guinea
// - `PY` - Paraguay
// - `PE` - Peru
// - `PH` - Philippines
// - `PN` - Pitcairn
// - `PL` - Poland
// - `PT` - Portugal
// - `PR` - Puerto Rico
// - `QA` - Qatar
// - `RE` - Réunion
// - `RO` - Romania
// - `RU` - Russia
// - `RW` - Rwanda
// - `BL` - Saint Barthélemy
// - `SH` - Saint Helena, Ascension and Tristan da Cunha
// - `KN` - Saint Kitts and Nevis
// - `LC` - Saint Lucia
// - `MF` - Saint Martin (French part)
// - `PM` - Saint Pierre and Miquelon
// - `VC` - Saint Vincent and the Grenadines
// - `WS` - Samoa
// - `SM` - San Marino
// - `ST` - Sao Tome and Principe
// - `SA` - Saudi Arabia
// - `SN` - Senegal
// - `RS` - Serbia
// - `SC` - Seychelles
// - `SL` - Sierra Leone
// - `SG` - Singapore
// - `SX` - Sint Maarten (Dutch part)
// - `SK` - Slovakia
// - `SI` - Slovenia
// - `SB` - Solomon Islands
// - `SO` - Somalia
// - `ZA` - South Africa
// - `GS` - South Georgia and the South Sandwich Islands
// - `KR` - South Korea
// - `SS` - South Sudan
// - `ES` - Spain
// - `LK` - Sri Lanka
// - `SD` - Sudan
// - `SR` - Suriname
// - `SJ` - Svalbard and Jan Mayen
// - `SE` - Sweden
// - `CH` - Switzerland
// - `SY` - Syria
// - `TW` - Taiwan
// - `TJ` - Tajikistan
// - `TZ` - Tanzania
// - `TH` - Thailand
// - `TL` - Timor-Leste
// - `TG` - Togo
// - `TK` - Tokelau
// - `TO` - Tonga
// - `TT` - Trinidad and Tobago
// - `TN` - Tunisia
// - `TR` - Turkey
// - `TM` - Turkmenistan
// - `TC` - Turks and Caicos Islands
// - `TV` - Tuvalu
// - `UG` - Uganda
// - `UA` - Ukraine
// - `AE` - United Arab Emirates
// - `GB` - United Kingdom
// - `UM` - United States Minor Outlying Islands
// - `US` - United States of America
// - `UY` - Uruguay
// - `UZ` - Uzbekistan
// - `VU` - Vanuatu
// - `VE` - Venezuela
// - `VN` - Vietnam
// - `VG` - Virgin Islands (British)
// - `VI` - Virgin Islands (U.S.)
// - `WF` - Wallis and Futuna
// - `EH` - Western Sahara
// - `YE` - Yemen
// - `ZM` - Zambia
// - `ZW` - Zimbabwe
type CountryEnum string

const (
	CountryEnumAf CountryEnum = "AF"
	CountryEnumAx CountryEnum = "AX"
	CountryEnumAl CountryEnum = "AL"
	CountryEnumDz CountryEnum = "DZ"
	CountryEnumAs CountryEnum = "AS"
	CountryEnumAd CountryEnum = "AD"
	CountryEnumAo CountryEnum = "AO"
	CountryEnumAi CountryEnum = "AI"
	CountryEnumAq CountryEnum = "AQ"
	CountryEnumAg CountryEnum = "AG"
	CountryEnumAr CountryEnum = "AR"
	CountryEnumAm CountryEnum = "AM"
	CountryEnumAw CountryEnum = "AW"
	CountryEnumAu CountryEnum = "AU"
	CountryEnumAt CountryEnum = "AT"
	CountryEnumAz CountryEnum = "AZ"
	CountryEnumBs CountryEnum = "BS"
	CountryEnumBh CountryEnum = "BH"
	CountryEnumBd CountryEnum = "BD"
	CountryEnumBb CountryEnum = "BB"
	CountryEnumBy CountryEnum = "BY"
	CountryEnumBe CountryEnum = "BE"
	CountryEnumBz CountryEnum = "BZ"
	CountryEnumBj CountryEnum = "BJ"
	CountryEnumBm CountryEnum = "BM"
	CountryEnumBt CountryEnum = "BT"
	CountryEnumBo CountryEnum = "BO"
	CountryEnumBq CountryEnum = "BQ"
	CountryEnumBa CountryEnum = "BA"
	CountryEnumBw CountryEnum = "BW"
	CountryEnumBv CountryEnum = "BV"
	CountryEnumBr CountryEnum = "BR"
	CountryEnumIo CountryEnum = "IO"
	CountryEnumBn CountryEnum = "BN"
	CountryEnumBg CountryEnum = "BG"
	CountryEnumBf CountryEnum = "BF"
	CountryEnumBi CountryEnum = "BI"
	CountryEnumCv CountryEnum = "CV"
	CountryEnumKh CountryEnum = "KH"
	CountryEnumCm CountryEnum = "CM"
	CountryEnumCa CountryEnum = "CA"
	CountryEnumKy CountryEnum = "KY"
	CountryEnumCf CountryEnum = "CF"
	CountryEnumTd CountryEnum = "TD"
	CountryEnumCl CountryEnum = "CL"
	CountryEnumCn CountryEnum = "CN"
	CountryEnumCx CountryEnum = "CX"
	CountryEnumCc CountryEnum = "CC"
	CountryEnumCo CountryEnum = "CO"
	CountryEnumKm CountryEnum = "KM"
	CountryEnumCg CountryEnum = "CG"
	CountryEnumCd CountryEnum = "CD"
	CountryEnumCk CountryEnum = "CK"
	CountryEnumCr CountryEnum = "CR"
	CountryEnumCi CountryEnum = "CI"
	CountryEnumHr CountryEnum = "HR"
	CountryEnumCu CountryEnum = "CU"
	CountryEnumCw CountryEnum = "CW"
	CountryEnumCy CountryEnum = "CY"
	CountryEnumCz CountryEnum = "CZ"
	CountryEnumDk CountryEnum = "DK"
	CountryEnumDj CountryEnum = "DJ"
	CountryEnumDm CountryEnum = "DM"
	CountryEnumDo CountryEnum = "DO"
	CountryEnumEc CountryEnum = "EC"
	CountryEnumEg CountryEnum = "EG"
	CountryEnumSv CountryEnum = "SV"
	CountryEnumGq CountryEnum = "GQ"
	CountryEnumEr CountryEnum = "ER"
	CountryEnumEe CountryEnum = "EE"
	CountryEnumSz CountryEnum = "SZ"
	CountryEnumEt CountryEnum = "ET"
	CountryEnumFk CountryEnum = "FK"
	CountryEnumFo CountryEnum = "FO"
	CountryEnumFj CountryEnum = "FJ"
	CountryEnumFi CountryEnum = "FI"
	CountryEnumFr CountryEnum = "FR"
	CountryEnumGf CountryEnum = "GF"
	CountryEnumPf CountryEnum = "PF"
	CountryEnumTf CountryEnum = "TF"
	CountryEnumGa CountryEnum = "GA"
	CountryEnumGm CountryEnum = "GM"
	CountryEnumGe CountryEnum = "GE"
	CountryEnumDe CountryEnum = "DE"
	CountryEnumGh CountryEnum = "GH"
	CountryEnumGi CountryEnum = "GI"
	CountryEnumGr CountryEnum = "GR"
	CountryEnumGl CountryEnum = "GL"
	CountryEnumGd CountryEnum = "GD"
	CountryEnumGp CountryEnum = "GP"
	CountryEnumGu CountryEnum = "GU"
	CountryEnumGt CountryEnum = "GT"
	CountryEnumGg CountryEnum = "GG"
	CountryEnumGn CountryEnum = "GN"
	CountryEnumGw CountryEnum = "GW"
	CountryEnumGy CountryEnum = "GY"
	CountryEnumHt CountryEnum = "HT"
	CountryEnumHm CountryEnum = "HM"
	CountryEnumVa CountryEnum = "VA"
	CountryEnumHn CountryEnum = "HN"
	CountryEnumHk CountryEnum = "HK"
	CountryEnumHu CountryEnum = "HU"
	CountryEnumIs CountryEnum = "IS"
	CountryEnumIn CountryEnum = "IN"
	CountryEnumId CountryEnum = "ID"
	CountryEnumIr CountryEnum = "IR"
	CountryEnumIq CountryEnum = "IQ"
	CountryEnumIe CountryEnum = "IE"
	CountryEnumIm CountryEnum = "IM"
	CountryEnumIl CountryEnum = "IL"
	CountryEnumIt CountryEnum = "IT"
	CountryEnumJm CountryEnum = "JM"
	CountryEnumJp CountryEnum = "JP"
	CountryEnumJe CountryEnum = "JE"
	CountryEnumJo CountryEnum = "JO"
	CountryEnumKz CountryEnum = "KZ"
	CountryEnumKe CountryEnum = "KE"
	CountryEnumKi CountryEnum = "KI"
	CountryEnumKw CountryEnum = "KW"
	CountryEnumKg CountryEnum = "KG"
	CountryEnumLa CountryEnum = "LA"
	CountryEnumLv CountryEnum = "LV"
	CountryEnumLb CountryEnum = "LB"
	CountryEnumLs CountryEnum = "LS"
	CountryEnumLr CountryEnum = "LR"
	CountryEnumLy CountryEnum = "LY"
	CountryEnumLi CountryEnum = "LI"
	CountryEnumLt CountryEnum = "LT"
	CountryEnumLu CountryEnum = "LU"
	CountryEnumMo CountryEnum = "MO"
	CountryEnumMg CountryEnum = "MG"
	CountryEnumMw CountryEnum = "MW"
	CountryEnumMy CountryEnum = "MY"
	CountryEnumMv CountryEnum = "MV"
	CountryEnumMl CountryEnum = "ML"
	CountryEnumMt CountryEnum = "MT"
	CountryEnumMh CountryEnum = "MH"
	CountryEnumMq CountryEnum = "MQ"
	CountryEnumMr CountryEnum = "MR"
	CountryEnumMu CountryEnum = "MU"
	CountryEnumYt CountryEnum = "YT"
	CountryEnumMx CountryEnum = "MX"
	CountryEnumFm CountryEnum = "FM"
	CountryEnumMd CountryEnum = "MD"
	CountryEnumMc CountryEnum = "MC"
	CountryEnumMn CountryEnum = "MN"
	CountryEnumMe CountryEnum = "ME"
	CountryEnumMs CountryEnum = "MS"
	CountryEnumMa CountryEnum = "MA"
	CountryEnumMz CountryEnum = "MZ"
	CountryEnumMm CountryEnum = "MM"
	CountryEnumNa CountryEnum = "NA"
	CountryEnumNr CountryEnum = "NR"
	CountryEnumNp CountryEnum = "NP"
	CountryEnumNl CountryEnum = "NL"
	CountryEnumNc CountryEnum = "NC"
	CountryEnumNz CountryEnum = "NZ"
	CountryEnumNi CountryEnum = "NI"
	CountryEnumNe CountryEnum = "NE"
	CountryEnumNg CountryEnum = "NG"
	CountryEnumNu CountryEnum = "NU"
	CountryEnumNf CountryEnum = "NF"
	CountryEnumKp CountryEnum = "KP"
	CountryEnumMk CountryEnum = "MK"
	CountryEnumMp CountryEnum = "MP"
	CountryEnumNo CountryEnum = "NO"
	CountryEnumOm CountryEnum = "OM"
	CountryEnumPk CountryEnum = "PK"
	CountryEnumPw CountryEnum = "PW"
	CountryEnumPs CountryEnum = "PS"
	CountryEnumPa CountryEnum = "PA"
	CountryEnumPg CountryEnum = "PG"
	CountryEnumPy CountryEnum = "PY"
	CountryEnumPe CountryEnum = "PE"
	CountryEnumPh CountryEnum = "PH"
	CountryEnumPn CountryEnum = "PN"
	CountryEnumPl CountryEnum = "PL"
	CountryEnumPt CountryEnum = "PT"
	CountryEnumPr CountryEnum = "PR"
	CountryEnumQa CountryEnum = "QA"
	CountryEnumRe CountryEnum = "RE"
	CountryEnumRo CountryEnum = "RO"
	CountryEnumRu CountryEnum = "RU"
	CountryEnumRw CountryEnum = "RW"
	CountryEnumBl CountryEnum = "BL"
	CountryEnumSh CountryEnum = "SH"
	CountryEnumKn CountryEnum = "KN"
	CountryEnumLc CountryEnum = "LC"
	CountryEnumMf CountryEnum = "MF"
	CountryEnumPm CountryEnum = "PM"
	CountryEnumVc CountryEnum = "VC"
	CountryEnumWs CountryEnum = "WS"
	CountryEnumSm CountryEnum = "SM"
	CountryEnumSt CountryEnum = "ST"
	CountryEnumSa CountryEnum = "SA"
	CountryEnumSn CountryEnum = "SN"
	CountryEnumRs CountryEnum = "RS"
	CountryEnumSc CountryEnum = "SC"
	CountryEnumSl CountryEnum = "SL"
	CountryEnumSg CountryEnum = "SG"
	CountryEnumSx CountryEnum = "SX"
	CountryEnumSk CountryEnum = "SK"
	CountryEnumSi CountryEnum = "SI"
	CountryEnumSb CountryEnum = "SB"
	CountryEnumSo CountryEnum = "SO"
	CountryEnumZa CountryEnum = "ZA"
	CountryEnumGs CountryEnum = "GS"
	CountryEnumKr CountryEnum = "KR"
	CountryEnumSs CountryEnum = "SS"
	CountryEnumEs CountryEnum = "ES"
	CountryEnumLk CountryEnum = "LK"
	CountryEnumSd CountryEnum = "SD"
	CountryEnumSr CountryEnum = "SR"
	CountryEnumSj CountryEnum = "SJ"
	CountryEnumSe CountryEnum = "SE"
	CountryEnumCh CountryEnum = "CH"
	CountryEnumSy CountryEnum = "SY"
	CountryEnumTw CountryEnum = "TW"
	CountryEnumTj CountryEnum = "TJ"
	CountryEnumTz CountryEnum = "TZ"
	CountryEnumTh CountryEnum = "TH"
	CountryEnumTl CountryEnum = "TL"
	CountryEnumTg CountryEnum = "TG"
	CountryEnumTk CountryEnum = "TK"
	CountryEnumTo CountryEnum = "TO"
	CountryEnumTt CountryEnum = "TT"
	CountryEnumTn CountryEnum = "TN"
	CountryEnumTr CountryEnum = "TR"
	CountryEnumTm CountryEnum = "TM"
	CountryEnumTc CountryEnum = "TC"
	CountryEnumTv CountryEnum = "TV"
	CountryEnumUg CountryEnum = "UG"
	CountryEnumUa CountryEnum = "UA"
	CountryEnumAe CountryEnum = "AE"
	CountryEnumGb CountryEnum = "GB"
	CountryEnumUm CountryEnum = "UM"
	CountryEnumUs CountryEnum = "US"
	CountryEnumUy CountryEnum = "UY"
	CountryEnumUz CountryEnum = "UZ"
	CountryEnumVu CountryEnum = "VU"
	CountryEnumVe CountryEnum = "VE"
	CountryEnumVn CountryEnum = "VN"
	CountryEnumVg CountryEnum = "VG"
	CountryEnumVi CountryEnum = "VI"
	CountryEnumWf CountryEnum = "WF"
	CountryEnumEh CountryEnum = "EH"
	CountryEnumYe CountryEnum = "YE"
	CountryEnumZm CountryEnum = "ZM"
	CountryEnumZw CountryEnum = "ZW"
)

func NewCountryEnumFromString(s string) (CountryEnum, error) {
	switch s {
	case "AF":
		return CountryEnumAf, nil
	case "AX":
		return CountryEnumAx, nil
	case "AL":
		return CountryEnumAl, nil
	case "DZ":
		return CountryEnumDz, nil
	case "AS":
		return CountryEnumAs, nil
	case "AD":
		return CountryEnumAd, nil
	case "AO":
		return CountryEnumAo, nil
	case "AI":
		return CountryEnumAi, nil
	case "AQ":
		return CountryEnumAq, nil
	case "AG":
		return CountryEnumAg, nil
	case "AR":
		return CountryEnumAr, nil
	case "AM":
		return CountryEnumAm, nil
	case "AW":
		return CountryEnumAw, nil
	case "AU":
		return CountryEnumAu, nil
	case "AT":
		return CountryEnumAt, nil
	case "AZ":
		return CountryEnumAz, nil
	case "BS":
		return CountryEnumBs, nil
	case "BH":
		return CountryEnumBh, nil
	case "BD":
		return CountryEnumBd, nil
	case "BB":
		return CountryEnumBb, nil
	case "BY":
		return CountryEnumBy, nil
	case "BE":
		return CountryEnumBe, nil
	case "BZ":
		return CountryEnumBz, nil
	case "BJ":
		return CountryEnumBj, nil
	case "BM":
		return CountryEnumBm, nil
	case "BT":
		return CountryEnumBt, nil
	case "BO":
		return CountryEnumBo, nil
	case "BQ":
		return CountryEnumBq, nil
	case "BA":
		return CountryEnumBa, nil
	case "BW":
		return CountryEnumBw, nil
	case "BV":
		return CountryEnumBv, nil
	case "BR":
		return CountryEnumBr, nil
	case "IO":
		return CountryEnumIo, nil
	case "BN":
		return CountryEnumBn, nil
	case "BG":
		return CountryEnumBg, nil
	case "BF":
		return CountryEnumBf, nil
	case "BI":
		return CountryEnumBi, nil
	case "CV":
		return CountryEnumCv, nil
	case "KH":
		return CountryEnumKh, nil
	case "CM":
		return CountryEnumCm, nil
	case "CA":
		return CountryEnumCa, nil
	case "KY":
		return CountryEnumKy, nil
	case "CF":
		return CountryEnumCf, nil
	case "TD":
		return CountryEnumTd, nil
	case "CL":
		return CountryEnumCl, nil
	case "CN":
		return CountryEnumCn, nil
	case "CX":
		return CountryEnumCx, nil
	case "CC":
		return CountryEnumCc, nil
	case "CO":
		return CountryEnumCo, nil
	case "KM":
		return CountryEnumKm, nil
	case "CG":
		return CountryEnumCg, nil
	case "CD":
		return CountryEnumCd, nil
	case "CK":
		return CountryEnumCk, nil
	case "CR":
		return CountryEnumCr, nil
	case "CI":
		return CountryEnumCi, nil
	case "HR":
		return CountryEnumHr, nil
	case "CU":
		return CountryEnumCu, nil
	case "CW":
		return CountryEnumCw, nil
	case "CY":
		return CountryEnumCy, nil
	case "CZ":
		return CountryEnumCz, nil
	case "DK":
		return CountryEnumDk, nil
	case "DJ":
		return CountryEnumDj, nil
	case "DM":
		return CountryEnumDm, nil
	case "DO":
		return CountryEnumDo, nil
	case "EC":
		return CountryEnumEc, nil
	case "EG":
		return CountryEnumEg, nil
	case "SV":
		return CountryEnumSv, nil
	case "GQ":
		return CountryEnumGq, nil
	case "ER":
		return CountryEnumEr, nil
	case "EE":
		return CountryEnumEe, nil
	case "SZ":
		return CountryEnumSz, nil
	case "ET":
		return CountryEnumEt, nil
	case "FK":
		return CountryEnumFk, nil
	case "FO":
		return CountryEnumFo, nil
	case "FJ":
		return CountryEnumFj, nil
	case "FI":
		return CountryEnumFi, nil
	case "FR":
		return CountryEnumFr, nil
	case "GF":
		return CountryEnumGf, nil
	case "PF":
		return CountryEnumPf, nil
	case "TF":
		return CountryEnumTf, nil
	case "GA":
		return CountryEnumGa, nil
	case "GM":
		return CountryEnumGm, nil
	case "GE":
		return CountryEnumGe, nil
	case "DE":
		return CountryEnumDe, nil
	case "GH":
		return CountryEnumGh, nil
	case "GI":
		return CountryEnumGi, nil
	case "GR":
		return CountryEnumGr, nil
	case "GL":
		return CountryEnumGl, nil
	case "GD":
		return CountryEnumGd, nil
	case "GP":
		return CountryEnumGp, nil
	case "GU":
		return CountryEnumGu, nil
	case "GT":
		return CountryEnumGt, nil
	case "GG":
		return CountryEnumGg, nil
	case "GN":
		return CountryEnumGn, nil
	case "GW":
		return CountryEnumGw, nil
	case "GY":
		return CountryEnumGy, nil
	case "HT":
		return CountryEnumHt, nil
	case "HM":
		return CountryEnumHm, nil
	case "VA":
		return CountryEnumVa, nil
	case "HN":
		return CountryEnumHn, nil
	case "HK":
		return CountryEnumHk, nil
	case "HU":
		return CountryEnumHu, nil
	case "IS":
		return CountryEnumIs, nil
	case "IN":
		return CountryEnumIn, nil
	case "ID":
		return CountryEnumId, nil
	case "IR":
		return CountryEnumIr, nil
	case "IQ":
		return CountryEnumIq, nil
	case "IE":
		return CountryEnumIe, nil
	case "IM":
		return CountryEnumIm, nil
	case "IL":
		return CountryEnumIl, nil
	case "IT":
		return CountryEnumIt, nil
	case "JM":
		return CountryEnumJm, nil
	case "JP":
		return CountryEnumJp, nil
	case "JE":
		return CountryEnumJe, nil
	case "JO":
		return CountryEnumJo, nil
	case "KZ":
		return CountryEnumKz, nil
	case "KE":
		return CountryEnumKe, nil
	case "KI":
		return CountryEnumKi, nil
	case "KW":
		return CountryEnumKw, nil
	case "KG":
		return CountryEnumKg, nil
	case "LA":
		return CountryEnumLa, nil
	case "LV":
		return CountryEnumLv, nil
	case "LB":
		return CountryEnumLb, nil
	case "LS":
		return CountryEnumLs, nil
	case "LR":
		return CountryEnumLr, nil
	case "LY":
		return CountryEnumLy, nil
	case "LI":
		return CountryEnumLi, nil
	case "LT":
		return CountryEnumLt, nil
	case "LU":
		return CountryEnumLu, nil
	case "MO":
		return CountryEnumMo, nil
	case "MG":
		return CountryEnumMg, nil
	case "MW":
		return CountryEnumMw, nil
	case "MY":
		return CountryEnumMy, nil
	case "MV":
		return CountryEnumMv, nil
	case "ML":
		return CountryEnumMl, nil
	case "MT":
		return CountryEnumMt, nil
	case "MH":
		return CountryEnumMh, nil
	case "MQ":
		return CountryEnumMq, nil
	case "MR":
		return CountryEnumMr, nil
	case "MU":
		return CountryEnumMu, nil
	case "YT":
		return CountryEnumYt, nil
	case "MX":
		return CountryEnumMx, nil
	case "FM":
		return CountryEnumFm, nil
	case "MD":
		return CountryEnumMd, nil
	case "MC":
		return CountryEnumMc, nil
	case "MN":
		return CountryEnumMn, nil
	case "ME":
		return CountryEnumMe, nil
	case "MS":
		return CountryEnumMs, nil
	case "MA":
		return CountryEnumMa, nil
	case "MZ":
		return CountryEnumMz, nil
	case "MM":
		return CountryEnumMm, nil
	case "NA":
		return CountryEnumNa, nil
	case "NR":
		return CountryEnumNr, nil
	case "NP":
		return CountryEnumNp, nil
	case "NL":
		return CountryEnumNl, nil
	case "NC":
		return CountryEnumNc, nil
	case "NZ":
		return CountryEnumNz, nil
	case "NI":
		return CountryEnumNi, nil
	case "NE":
		return CountryEnumNe, nil
	case "NG":
		return CountryEnumNg, nil
	case "NU":
		return CountryEnumNu, nil
	case "NF":
		return CountryEnumNf, nil
	case "KP":
		return CountryEnumKp, nil
	case "MK":
		return CountryEnumMk, nil
	case "MP":
		return CountryEnumMp, nil
	case "NO":
		return CountryEnumNo, nil
	case "OM":
		return CountryEnumOm, nil
	case "PK":
		return CountryEnumPk, nil
	case "PW":
		return CountryEnumPw, nil
	case "PS":
		return CountryEnumPs, nil
	case "PA":
		return CountryEnumPa, nil
	case "PG":
		return CountryEnumPg, nil
	case "PY":
		return CountryEnumPy, nil
	case "PE":
		return CountryEnumPe, nil
	case "PH":
		return CountryEnumPh, nil
	case "PN":
		return CountryEnumPn, nil
	case "PL":
		return CountryEnumPl, nil
	case "PT":
		return CountryEnumPt, nil
	case "PR":
		return CountryEnumPr, nil
	case "QA":
		return CountryEnumQa, nil
	case "RE":
		return CountryEnumRe, nil
	case "RO":
		return CountryEnumRo, nil
	case "RU":
		return CountryEnumRu, nil
	case "RW":
		return CountryEnumRw, nil
	case "BL":
		return CountryEnumBl, nil
	case "SH":
		return CountryEnumSh, nil
	case "KN":
		return CountryEnumKn, nil
	case "LC":
		return CountryEnumLc, nil
	case "MF":
		return CountryEnumMf, nil
	case "PM":
		return CountryEnumPm, nil
	case "VC":
		return CountryEnumVc, nil
	case "WS":
		return CountryEnumWs, nil
	case "SM":
		return CountryEnumSm, nil
	case "ST":
		return CountryEnumSt, nil
	case "SA":
		return CountryEnumSa, nil
	case "SN":
		return CountryEnumSn, nil
	case "RS":
		return CountryEnumRs, nil
	case "SC":
		return CountryEnumSc, nil
	case "SL":
		return CountryEnumSl, nil
	case "SG":
		return CountryEnumSg, nil
	case "SX":
		return CountryEnumSx, nil
	case "SK":
		return CountryEnumSk, nil
	case "SI":
		return CountryEnumSi, nil
	case "SB":
		return CountryEnumSb, nil
	case "SO":
		return CountryEnumSo, nil
	case "ZA":
		return CountryEnumZa, nil
	case "GS":
		return CountryEnumGs, nil
	case "KR":
		return CountryEnumKr, nil
	case "SS":
		return CountryEnumSs, nil
	case "ES":
		return CountryEnumEs, nil
	case "LK":
		return CountryEnumLk, nil
	case "SD":
		return CountryEnumSd, nil
	case "SR":
		return CountryEnumSr, nil
	case "SJ":
		return CountryEnumSj, nil
	case "SE":
		return CountryEnumSe, nil
	case "CH":
		return CountryEnumCh, nil
	case "SY":
		return CountryEnumSy, nil
	case "TW":
		return CountryEnumTw, nil
	case "TJ":
		return CountryEnumTj, nil
	case "TZ":
		return CountryEnumTz, nil
	case "TH":
		return CountryEnumTh, nil
	case "TL":
		return CountryEnumTl, nil
	case "TG":
		return CountryEnumTg, nil
	case "TK":
		return CountryEnumTk, nil
	case "TO":
		return CountryEnumTo, nil
	case "TT":
		return CountryEnumTt, nil
	case "TN":
		return CountryEnumTn, nil
	case "TR":
		return CountryEnumTr, nil
	case "TM":
		return CountryEnumTm, nil
	case "TC":
		return CountryEnumTc, nil
	case "TV":
		return CountryEnumTv, nil
	case "UG":
		return CountryEnumUg, nil
	case "UA":
		return CountryEnumUa, nil
	case "AE":
		return CountryEnumAe, nil
	case "GB":
		return CountryEnumGb, nil
	case "UM":
		return CountryEnumUm, nil
	case "US":
		return CountryEnumUs, nil
	case "UY":
		return CountryEnumUy, nil
	case "UZ":
		return CountryEnumUz, nil
	case "VU":
		return CountryEnumVu, nil
	case "VE":
		return CountryEnumVe, nil
	case "VN":
		return CountryEnumVn, nil
	case "VG":
		return CountryEnumVg, nil
	case "VI":
		return CountryEnumVi, nil
	case "WF":
		return CountryEnumWf, nil
	case "EH":
		return CountryEnumEh, nil
	case "YE":
		return CountryEnumYe, nil
	case "ZM":
		return CountryEnumZm, nil
	case "ZW":
		return CountryEnumZw, nil
	}
	var t CountryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountryEnum) Ptr() *CountryEnum {
	return &c
}

// # The DataPassthrough Object
//
// ### Description
//
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
//
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method,omitempty"`
	// The path of the request in the third party's platform.
	Path string `json:"path"`
	// An optional override of the third party's base url for the request.
	BaseUrlOverride *string `json:"base_url_override,omitempty"`
	// The data with the request. You must include a `request_format` parameter matching the data's format
	Data *string `json:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]interface{} `json:"headers,omitempty"`
	RequestFormat *RequestFormatEnum     `json:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DataPassthroughRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DataPassthroughRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataPassthroughRequest(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataPassthroughRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModeLog struct {
	LogId         string                `json:"log_id"`
	DashboardView string                `json:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DebugModeLog) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModeLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModeLog(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModeLog) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModelLogSummary struct {
	Url        string `json:"url"`
	Method     string `json:"method"`
	StatusCode int    `json:"status_code"`

	_rawJSON json.RawMessage
}

func (d *DebugModelLogSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModelLogSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModelLogSummary(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModelLogSummary) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The Deduction Object
//
// ### Description
//
// The `Deduction` object is used to represent an array of the wages withheld from total earnings for the purpose of paying taxes.
//
// ### Usage Example
//
// Fetch from the `LIST Deductions` endpoint and filter by `ID` to show all deductions.
type Deduction struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt         *time.Time `json:"modified_at,omitempty"`
	EmployeePayrollRun *string    `json:"employee_payroll_run,omitempty"`
	// The deduction's name.
	Name *string `json:"name,omitempty"`
	// The amount of money that is withheld from an employee's gross pay by the employee.
	EmployeeDeduction *float64 `json:"employee_deduction,omitempty"`
	// The amount of money that is withheld on behalf of an employee by the company.
	CompanyDeduction *float64 `json:"company_deduction,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (d *Deduction) UnmarshalJSON(data []byte) error {
	type unmarshaler Deduction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Deduction(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Deduction) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The Dependent Object
//
// ### Description
//
// The `Dependent` object is used to represent a dependent (e.g. child, spouse, domestic partner, etc) of an `Employee`
//
// ### Usage Example
//
// Fetch from the `LIST Dependents` endpoint and filter by `ID` to show all dependents.
type Dependent struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The dependents's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The dependents's middle name.
	MiddleName *string `json:"middle_name,omitempty"`
	// The dependents's last name.
	LastName *string `json:"last_name,omitempty"`
	// The dependent's relationship to the employee.
	//
	// - `CHILD` - CHILD
	// - `SPOUSE` - SPOUSE
	// - `DOMESTIC_PARTNER` - DOMESTIC_PARTNER
	Relationship *DependentRelationship `json:"relationship,omitempty"`
	// The employee this person is a dependent of.
	Employee *string `json:"employee,omitempty"`
	// The dependent's date of birth.
	DateOfBirth *time.Time `json:"date_of_birth,omitempty"`
	// The dependent's gender.
	//
	// - `MALE` - MALE
	// - `FEMALE` - FEMALE
	// - `NON-BINARY` - NON-BINARY
	// - `OTHER` - OTHER
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Gender *DependentGender `json:"gender,omitempty"`
	// The dependent's phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`
	// The dependents's home address.
	HomeLocation *string `json:"home_location,omitempty"`
	// Whether or not the dependent is a student
	IsStudent *bool `json:"is_student,omitempty"`
	// The dependents's social security number.
	Ssn *string `json:"ssn,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (d *Dependent) UnmarshalJSON(data []byte) error {
	type unmarshaler Dependent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Dependent(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dependent) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The dependent's gender.
//
// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type DependentGender struct {
	typeName   string
	GenderEnum GenderEnum
	String     string
}

func NewDependentGenderFromGenderEnum(value GenderEnum) *DependentGender {
	return &DependentGender{typeName: "genderEnum", GenderEnum: value}
}

func NewDependentGenderFromString(value string) *DependentGender {
	return &DependentGender{typeName: "string", String: value}
}

func (d *DependentGender) UnmarshalJSON(data []byte) error {
	var valueGenderEnum GenderEnum
	if err := json.Unmarshal(data, &valueGenderEnum); err == nil {
		d.typeName = "genderEnum"
		d.GenderEnum = valueGenderEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DependentGender) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "genderEnum":
		return json.Marshal(d.GenderEnum)
	case "string":
		return json.Marshal(d.String)
	}
}

type DependentGenderVisitor interface {
	VisitGenderEnum(GenderEnum) error
	VisitString(string) error
}

func (d *DependentGender) Accept(visitor DependentGenderVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "genderEnum":
		return visitor.VisitGenderEnum(d.GenderEnum)
	case "string":
		return visitor.VisitString(d.String)
	}
}

// The dependent's relationship to the employee.
//
// - `CHILD` - CHILD
// - `SPOUSE` - SPOUSE
// - `DOMESTIC_PARTNER` - DOMESTIC_PARTNER
type DependentRelationship struct {
	typeName         string
	RelationshipEnum RelationshipEnum
	String           string
}

func NewDependentRelationshipFromRelationshipEnum(value RelationshipEnum) *DependentRelationship {
	return &DependentRelationship{typeName: "relationshipEnum", RelationshipEnum: value}
}

func NewDependentRelationshipFromString(value string) *DependentRelationship {
	return &DependentRelationship{typeName: "string", String: value}
}

func (d *DependentRelationship) UnmarshalJSON(data []byte) error {
	var valueRelationshipEnum RelationshipEnum
	if err := json.Unmarshal(data, &valueRelationshipEnum); err == nil {
		d.typeName = "relationshipEnum"
		d.RelationshipEnum = valueRelationshipEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DependentRelationship) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "relationshipEnum":
		return json.Marshal(d.RelationshipEnum)
	case "string":
		return json.Marshal(d.String)
	}
}

type DependentRelationshipVisitor interface {
	VisitRelationshipEnum(RelationshipEnum) error
	VisitString(string) error
}

func (d *DependentRelationship) Accept(visitor DependentRelationshipVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "relationshipEnum":
		return visitor.VisitRelationshipEnum(d.RelationshipEnum)
	case "string":
		return visitor.VisitString(d.String)
	}
}

// # The Earning Object
//
// ### Description
//
// The `Earning` object is used to represent an array of different compensations that an employee receives within specific wage categories.
//
// ### Usage Example
//
// Fetch from the `LIST Earnings` endpoint and filter by `ID` to show all earnings.
type Earning struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt         *time.Time `json:"modified_at,omitempty"`
	EmployeePayrollRun *string    `json:"employee_payroll_run,omitempty"`
	// The amount earned.
	Amount *float64 `json:"amount,omitempty"`
	// The type of earning.
	//
	// - `SALARY` - SALARY
	// - `REIMBURSEMENT` - REIMBURSEMENT
	// - `OVERTIME` - OVERTIME
	// - `BONUS` - BONUS
	Type *EarningType `json:"type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Earning) UnmarshalJSON(data []byte) error {
	type unmarshaler Earning
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Earning(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Earning) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The type of earning.
//
// - `SALARY` - SALARY
// - `REIMBURSEMENT` - REIMBURSEMENT
// - `OVERTIME` - OVERTIME
// - `BONUS` - BONUS
type EarningType struct {
	typeName        string
	EarningTypeEnum EarningTypeEnum
	String          string
}

func NewEarningTypeFromEarningTypeEnum(value EarningTypeEnum) *EarningType {
	return &EarningType{typeName: "earningTypeEnum", EarningTypeEnum: value}
}

func NewEarningTypeFromString(value string) *EarningType {
	return &EarningType{typeName: "string", String: value}
}

func (e *EarningType) UnmarshalJSON(data []byte) error {
	var valueEarningTypeEnum EarningTypeEnum
	if err := json.Unmarshal(data, &valueEarningTypeEnum); err == nil {
		e.typeName = "earningTypeEnum"
		e.EarningTypeEnum = valueEarningTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EarningType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "earningTypeEnum":
		return json.Marshal(e.EarningTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EarningTypeVisitor interface {
	VisitEarningTypeEnum(EarningTypeEnum) error
	VisitString(string) error
}

func (e *EarningType) Accept(visitor EarningTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "earningTypeEnum":
		return visitor.VisitEarningTypeEnum(e.EarningTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// - `SALARY` - SALARY
// - `REIMBURSEMENT` - REIMBURSEMENT
// - `OVERTIME` - OVERTIME
// - `BONUS` - BONUS
type EarningTypeEnum string

const (
	EarningTypeEnumSalary        EarningTypeEnum = "SALARY"
	EarningTypeEnumReimbursement EarningTypeEnum = "REIMBURSEMENT"
	EarningTypeEnumOvertime      EarningTypeEnum = "OVERTIME"
	EarningTypeEnumBonus         EarningTypeEnum = "BONUS"
)

func NewEarningTypeEnumFromString(s string) (EarningTypeEnum, error) {
	switch s {
	case "SALARY":
		return EarningTypeEnumSalary, nil
	case "REIMBURSEMENT":
		return EarningTypeEnumReimbursement, nil
	case "OVERTIME":
		return EarningTypeEnumOvertime, nil
	case "BONUS":
		return EarningTypeEnumBonus, nil
	}
	var t EarningTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EarningTypeEnum) Ptr() *EarningTypeEnum {
	return &e
}

// # The Employee Object
//
// ### Description
//
// The `Employee` object is used to represent any person who has been employed by a company. By default, it returns all employees. To filter for only active employees, set the `employment_status` query parameter to `ACTIVE`.
//
// ### Usage Example
//
// Fetch from the `LIST Employee` endpoint and filter by `ID` to show all employees.
type Employee struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee's number that appears in the third-party integration's UI.
	EmployeeNumber *string `json:"employee_number,omitempty"`
	// The ID of the employee's company.
	Company *EmployeeCompany `json:"company,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty"`
	// The employee's preferred first name.
	PreferredName *string `json:"preferred_name,omitempty"`
	// The employee's full name, to use for display purposes. If a preferred first name is available, the full name will include the preferred first name.
	DisplayFullName *string `json:"display_full_name,omitempty"`
	// The employee's username that appears in the remote UI.
	Username *string               `json:"username,omitempty"`
	Groups   []*EmployeeGroupsItem `json:"groups,omitempty"`
	// The employee's work email.
	WorkEmail *string `json:"work_email,omitempty"`
	// The employee's personal email.
	PersonalEmail *string `json:"personal_email,omitempty"`
	// The employee's mobile phone number.
	MobilePhoneNumber *string `json:"mobile_phone_number,omitempty"`
	// Array of `Employment` IDs for this Employee.
	Employments []*EmployeeEmploymentsItem `json:"employments,omitempty"`
	// The employee's home address.
	HomeLocation *EmployeeHomeLocation `json:"home_location,omitempty"`
	// The employee's work address.
	WorkLocation *EmployeeWorkLocation `json:"work_location,omitempty"`
	// The employee ID of the employee's manager.
	Manager *EmployeeManager `json:"manager,omitempty"`
	// The employee's team.
	Team *EmployeeTeam `json:"team,omitempty"`
	// The employee's pay group
	PayGroup *EmployeePayGroup `json:"pay_group,omitempty"`
	// The employee's social security number.
	Ssn *string `json:"ssn,omitempty"`
	// The employee's gender.
	//
	// - `MALE` - MALE
	// - `FEMALE` - FEMALE
	// - `NON-BINARY` - NON-BINARY
	// - `OTHER` - OTHER
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Gender *EmployeeGender `json:"gender,omitempty"`
	// The employee's ethnicity.
	//
	// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
	// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
	// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
	// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
	// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
	// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
	// - `WHITE` - WHITE
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Ethnicity *EmployeeEthnicity `json:"ethnicity,omitempty"`
	// The employee's filing status as related to marital status.
	//
	// - `SINGLE` - SINGLE
	// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
	// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
	// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
	// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
	MaritalStatus *EmployeeMaritalStatus `json:"marital_status,omitempty"`
	// The employee's date of birth.
	DateOfBirth *time.Time `json:"date_of_birth,omitempty"`
	// The date that the employee was hired, usually the day that an offer letter is signed. If an employee has multiple hire dates from previous employments, this represents the most recent hire date. Note: If you're looking for the employee's start date, refer to the start_date field.
	HireDate *time.Time `json:"hire_date,omitempty"`
	// The date that the employee started working. If an employee was rehired, the most recent start date will be returned.
	StartDate *time.Time `json:"start_date,omitempty"`
	// When the third party's employee was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The employment status of the employee.
	//
	// - `ACTIVE` - ACTIVE
	// - `PENDING` - PENDING
	// - `INACTIVE` - INACTIVE
	EmploymentStatus *EmployeeEmploymentStatus `json:"employment_status,omitempty"`
	// The employee's termination date.
	TerminationDate *time.Time `json:"termination_date,omitempty"`
	// The URL of the employee's avatar image.
	Avatar *string `json:"avatar,omitempty"`
	// Custom fields configured for a given model.
	CustomFields map[string]interface{} `json:"custom_fields,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Employee) UnmarshalJSON(data []byte) error {
	type unmarshaler Employee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Employee(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Employee) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The ID of the employee's company.
type EmployeeCompany struct {
	typeName string
	String   string
	Company  *Company
}

func NewEmployeeCompanyFromString(value string) *EmployeeCompany {
	return &EmployeeCompany{typeName: "string", String: value}
}

func NewEmployeeCompanyFromCompany(value *Company) *EmployeeCompany {
	return &EmployeeCompany{typeName: "company", Company: value}
}

func (e *EmployeeCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueCompany := new(Company)
	if err := json.Unmarshal(data, &valueCompany); err == nil {
		e.typeName = "company"
		e.Company = valueCompany
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeCompany) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "company":
		return json.Marshal(e.Company)
	}
}

type EmployeeCompanyVisitor interface {
	VisitString(string) error
	VisitCompany(*Company) error
}

func (e *EmployeeCompany) Accept(visitor EmployeeCompanyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "company":
		return visitor.VisitCompany(e.Company)
	}
}

// The employment status of the employee.
//
// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type EmployeeEmploymentStatus struct {
	typeName             string
	EmploymentStatusEnum EmploymentStatusEnum
	String               string
}

func NewEmployeeEmploymentStatusFromEmploymentStatusEnum(value EmploymentStatusEnum) *EmployeeEmploymentStatus {
	return &EmployeeEmploymentStatus{typeName: "employmentStatusEnum", EmploymentStatusEnum: value}
}

func NewEmployeeEmploymentStatusFromString(value string) *EmployeeEmploymentStatus {
	return &EmployeeEmploymentStatus{typeName: "string", String: value}
}

func (e *EmployeeEmploymentStatus) UnmarshalJSON(data []byte) error {
	var valueEmploymentStatusEnum EmploymentStatusEnum
	if err := json.Unmarshal(data, &valueEmploymentStatusEnum); err == nil {
		e.typeName = "employmentStatusEnum"
		e.EmploymentStatusEnum = valueEmploymentStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEmploymentStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentStatusEnum":
		return json.Marshal(e.EmploymentStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeEmploymentStatusVisitor interface {
	VisitEmploymentStatusEnum(EmploymentStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeEmploymentStatus) Accept(visitor EmployeeEmploymentStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentStatusEnum":
		return visitor.VisitEmploymentStatusEnum(e.EmploymentStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EmployeeEmploymentsItem struct {
	typeName   string
	String     string
	Employment *Employment
}

func NewEmployeeEmploymentsItemFromString(value string) *EmployeeEmploymentsItem {
	return &EmployeeEmploymentsItem{typeName: "string", String: value}
}

func NewEmployeeEmploymentsItemFromEmployment(value *Employment) *EmployeeEmploymentsItem {
	return &EmployeeEmploymentsItem{typeName: "employment", Employment: value}
}

func (e *EmployeeEmploymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployment := new(Employment)
	if err := json.Unmarshal(data, &valueEmployment); err == nil {
		e.typeName = "employment"
		e.Employment = valueEmployment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEmploymentsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employment":
		return json.Marshal(e.Employment)
	}
}

type EmployeeEmploymentsItemVisitor interface {
	VisitString(string) error
	VisitEmployment(*Employment) error
}

func (e *EmployeeEmploymentsItem) Accept(visitor EmployeeEmploymentsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employment":
		return visitor.VisitEmployment(e.Employment)
	}
}

// The employee's ethnicity.
//
// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// - `WHITE` - WHITE
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeEthnicity struct {
	typeName      string
	EthnicityEnum EthnicityEnum
	String        string
}

func NewEmployeeEthnicityFromEthnicityEnum(value EthnicityEnum) *EmployeeEthnicity {
	return &EmployeeEthnicity{typeName: "ethnicityEnum", EthnicityEnum: value}
}

func NewEmployeeEthnicityFromString(value string) *EmployeeEthnicity {
	return &EmployeeEthnicity{typeName: "string", String: value}
}

func (e *EmployeeEthnicity) UnmarshalJSON(data []byte) error {
	var valueEthnicityEnum EthnicityEnum
	if err := json.Unmarshal(data, &valueEthnicityEnum); err == nil {
		e.typeName = "ethnicityEnum"
		e.EthnicityEnum = valueEthnicityEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEthnicity) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "ethnicityEnum":
		return json.Marshal(e.EthnicityEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeEthnicityVisitor interface {
	VisitEthnicityEnum(EthnicityEnum) error
	VisitString(string) error
}

func (e *EmployeeEthnicity) Accept(visitor EmployeeEthnicityVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "ethnicityEnum":
		return visitor.VisitEthnicityEnum(e.EthnicityEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee's gender.
//
// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeGender struct {
	typeName   string
	GenderEnum GenderEnum
	String     string
}

func NewEmployeeGenderFromGenderEnum(value GenderEnum) *EmployeeGender {
	return &EmployeeGender{typeName: "genderEnum", GenderEnum: value}
}

func NewEmployeeGenderFromString(value string) *EmployeeGender {
	return &EmployeeGender{typeName: "string", String: value}
}

func (e *EmployeeGender) UnmarshalJSON(data []byte) error {
	var valueGenderEnum GenderEnum
	if err := json.Unmarshal(data, &valueGenderEnum); err == nil {
		e.typeName = "genderEnum"
		e.GenderEnum = valueGenderEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeGender) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return json.Marshal(e.GenderEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeGenderVisitor interface {
	VisitGenderEnum(GenderEnum) error
	VisitString(string) error
}

func (e *EmployeeGender) Accept(visitor EmployeeGenderVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return visitor.VisitGenderEnum(e.GenderEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EmployeeGroupsItem struct {
	typeName string
	String   string
	Group    *Group
}

func NewEmployeeGroupsItemFromString(value string) *EmployeeGroupsItem {
	return &EmployeeGroupsItem{typeName: "string", String: value}
}

func NewEmployeeGroupsItemFromGroup(value *Group) *EmployeeGroupsItem {
	return &EmployeeGroupsItem{typeName: "group", Group: value}
}

func (e *EmployeeGroupsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		e.typeName = "group"
		e.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeGroupsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "group":
		return json.Marshal(e.Group)
	}
}

type EmployeeGroupsItemVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (e *EmployeeGroupsItem) Accept(visitor EmployeeGroupsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "group":
		return visitor.VisitGroup(e.Group)
	}
}

// The employee's home address.
type EmployeeHomeLocation struct {
	typeName string
	String   string
	Location *Location
}

func NewEmployeeHomeLocationFromString(value string) *EmployeeHomeLocation {
	return &EmployeeHomeLocation{typeName: "string", String: value}
}

func NewEmployeeHomeLocationFromLocation(value *Location) *EmployeeHomeLocation {
	return &EmployeeHomeLocation{typeName: "location", Location: value}
}

func (e *EmployeeHomeLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typeName = "location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeHomeLocation) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "location":
		return json.Marshal(e.Location)
	}
}

type EmployeeHomeLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeHomeLocation) Accept(visitor EmployeeHomeLocationVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "location":
		return visitor.VisitLocation(e.Location)
	}
}

// The employee ID of the employee's manager.
type EmployeeManager struct {
	typeName string
	String   string
	Employee *Employee
}

func NewEmployeeManagerFromString(value string) *EmployeeManager {
	return &EmployeeManager{typeName: "string", String: value}
}

func NewEmployeeManagerFromEmployee(value *Employee) *EmployeeManager {
	return &EmployeeManager{typeName: "employee", Employee: value}
}

func (e *EmployeeManager) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeManager) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type EmployeeManagerVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmployeeManager) Accept(visitor EmployeeManagerVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The employee's filing status as related to marital status.
//
// - `SINGLE` - SINGLE
// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
type EmployeeMaritalStatus struct {
	typeName          string
	MaritalStatusEnum MaritalStatusEnum
	String            string
}

func NewEmployeeMaritalStatusFromMaritalStatusEnum(value MaritalStatusEnum) *EmployeeMaritalStatus {
	return &EmployeeMaritalStatus{typeName: "maritalStatusEnum", MaritalStatusEnum: value}
}

func NewEmployeeMaritalStatusFromString(value string) *EmployeeMaritalStatus {
	return &EmployeeMaritalStatus{typeName: "string", String: value}
}

func (e *EmployeeMaritalStatus) UnmarshalJSON(data []byte) error {
	var valueMaritalStatusEnum MaritalStatusEnum
	if err := json.Unmarshal(data, &valueMaritalStatusEnum); err == nil {
		e.typeName = "maritalStatusEnum"
		e.MaritalStatusEnum = valueMaritalStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeMaritalStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "maritalStatusEnum":
		return json.Marshal(e.MaritalStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeMaritalStatusVisitor interface {
	VisitMaritalStatusEnum(MaritalStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeMaritalStatus) Accept(visitor EmployeeMaritalStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "maritalStatusEnum":
		return visitor.VisitMaritalStatusEnum(e.MaritalStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee's pay group
type EmployeePayGroup struct {
	typeName string
	String   string
	PayGroup *PayGroup
}

func NewEmployeePayGroupFromString(value string) *EmployeePayGroup {
	return &EmployeePayGroup{typeName: "string", String: value}
}

func NewEmployeePayGroupFromPayGroup(value *PayGroup) *EmployeePayGroup {
	return &EmployeePayGroup{typeName: "payGroup", PayGroup: value}
}

func (e *EmployeePayGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valuePayGroup := new(PayGroup)
	if err := json.Unmarshal(data, &valuePayGroup); err == nil {
		e.typeName = "payGroup"
		e.PayGroup = valuePayGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeePayGroup) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "payGroup":
		return json.Marshal(e.PayGroup)
	}
}

type EmployeePayGroupVisitor interface {
	VisitString(string) error
	VisitPayGroup(*PayGroup) error
}

func (e *EmployeePayGroup) Accept(visitor EmployeePayGroupVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "payGroup":
		return visitor.VisitPayGroup(e.PayGroup)
	}
}

// # The EmployeePayrollRun Object
//
// ### Description
//
// The `EmployeePayrollRun` object is used to represent an employee's pay statement for a specific payroll run.
//
// ### Usage Example
//
// Fetch from the `LIST EmployeePayrollRun` endpoint and filter by `ID` to show all employee payroll runs.
type EmployeePayrollRun struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee whose payroll is being run.
	Employee *EmployeePayrollRunEmployee `json:"employee,omitempty"`
	// The payroll being run.
	PayrollRun *EmployeePayrollRunPayrollRun `json:"payroll_run,omitempty"`
	// The total earnings throughout a given period for an employee before any deductions are made.
	GrossPay *float64 `json:"gross_pay,omitempty"`
	// The take-home pay throughout a given period for an employee after deductions are made.
	NetPay *float64 `json:"net_pay,omitempty"`
	// The day and time the payroll run started.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The day and time the payroll run ended.
	EndDate *time.Time `json:"end_date,omitempty"`
	// The day and time the payroll run was checked.
	CheckDate  *time.Time   `json:"check_date,omitempty"`
	Earnings   []*Earning   `json:"earnings,omitempty"`
	Deductions []*Deduction `json:"deductions,omitempty"`
	Taxes      []*Tax       `json:"taxes,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmployeePayrollRun) UnmarshalJSON(data []byte) error {
	type unmarshaler EmployeePayrollRun
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmployeePayrollRun(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmployeePayrollRun) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The employee whose payroll is being run.
type EmployeePayrollRunEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewEmployeePayrollRunEmployeeFromString(value string) *EmployeePayrollRunEmployee {
	return &EmployeePayrollRunEmployee{typeName: "string", String: value}
}

func NewEmployeePayrollRunEmployeeFromEmployee(value *Employee) *EmployeePayrollRunEmployee {
	return &EmployeePayrollRunEmployee{typeName: "employee", Employee: value}
}

func (e *EmployeePayrollRunEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeePayrollRunEmployee) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type EmployeePayrollRunEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmployeePayrollRunEmployee) Accept(visitor EmployeePayrollRunEmployeeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The payroll being run.
type EmployeePayrollRunPayrollRun struct {
	typeName   string
	String     string
	PayrollRun *PayrollRun
}

func NewEmployeePayrollRunPayrollRunFromString(value string) *EmployeePayrollRunPayrollRun {
	return &EmployeePayrollRunPayrollRun{typeName: "string", String: value}
}

func NewEmployeePayrollRunPayrollRunFromPayrollRun(value *PayrollRun) *EmployeePayrollRunPayrollRun {
	return &EmployeePayrollRunPayrollRun{typeName: "payrollRun", PayrollRun: value}
}

func (e *EmployeePayrollRunPayrollRun) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valuePayrollRun := new(PayrollRun)
	if err := json.Unmarshal(data, &valuePayrollRun); err == nil {
		e.typeName = "payrollRun"
		e.PayrollRun = valuePayrollRun
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeePayrollRunPayrollRun) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "payrollRun":
		return json.Marshal(e.PayrollRun)
	}
}

type EmployeePayrollRunPayrollRunVisitor interface {
	VisitString(string) error
	VisitPayrollRun(*PayrollRun) error
}

func (e *EmployeePayrollRunPayrollRun) Accept(visitor EmployeePayrollRunPayrollRunVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "payrollRun":
		return visitor.VisitPayrollRun(e.PayrollRun)
	}
}

// # The Employee Object
//
// ### Description
//
// The `Employee` object is used to represent any person who has been employed by a company. By default, it returns all employees. To filter for only active employees, set the `employment_status` query parameter to `ACTIVE`.
//
// ### Usage Example
//
// Fetch from the `LIST Employee` endpoint and filter by `ID` to show all employees.
type EmployeeRequest struct {
	// The employee's number that appears in the third-party integration's UI.
	EmployeeNumber *string `json:"employee_number,omitempty"`
	// The ID of the employee's company.
	Company *EmployeeRequestCompany `json:"company,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty"`
	// The employee's preferred first name.
	PreferredName *string `json:"preferred_name,omitempty"`
	// The employee's full name, to use for display purposes. If a preferred first name is available, the full name will include the preferred first name.
	DisplayFullName *string `json:"display_full_name,omitempty"`
	// The employee's username that appears in the remote UI.
	Username *string                      `json:"username,omitempty"`
	Groups   []*EmployeeRequestGroupsItem `json:"groups,omitempty"`
	// The employee's work email.
	WorkEmail *string `json:"work_email,omitempty"`
	// The employee's personal email.
	PersonalEmail *string `json:"personal_email,omitempty"`
	// The employee's mobile phone number.
	MobilePhoneNumber *string `json:"mobile_phone_number,omitempty"`
	// Array of `Employment` IDs for this Employee.
	Employments []*EmployeeRequestEmploymentsItem `json:"employments,omitempty"`
	// The employee's home address.
	HomeLocation *EmployeeRequestHomeLocation `json:"home_location,omitempty"`
	// The employee's work address.
	WorkLocation *EmployeeRequestWorkLocation `json:"work_location,omitempty"`
	// The employee ID of the employee's manager.
	Manager *EmployeeRequestManager `json:"manager,omitempty"`
	// The employee's team.
	Team *EmployeeRequestTeam `json:"team,omitempty"`
	// The employee's pay group
	PayGroup *EmployeeRequestPayGroup `json:"pay_group,omitempty"`
	// The employee's social security number.
	Ssn *string `json:"ssn,omitempty"`
	// The employee's gender.
	//
	// - `MALE` - MALE
	// - `FEMALE` - FEMALE
	// - `NON-BINARY` - NON-BINARY
	// - `OTHER` - OTHER
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Gender *EmployeeRequestGender `json:"gender,omitempty"`
	// The employee's ethnicity.
	//
	// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
	// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
	// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
	// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
	// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
	// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
	// - `WHITE` - WHITE
	// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Ethnicity *EmployeeRequestEthnicity `json:"ethnicity,omitempty"`
	// The employee's filing status as related to marital status.
	//
	// - `SINGLE` - SINGLE
	// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
	// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
	// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
	// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
	MaritalStatus *EmployeeRequestMaritalStatus `json:"marital_status,omitempty"`
	// The employee's date of birth.
	DateOfBirth *time.Time `json:"date_of_birth,omitempty"`
	// The date that the employee was hired, usually the day that an offer letter is signed. If an employee has multiple hire dates from previous employments, this represents the most recent hire date. Note: If you're looking for the employee's start date, refer to the start_date field.
	HireDate *time.Time `json:"hire_date,omitempty"`
	// The date that the employee started working. If an employee was rehired, the most recent start date will be returned.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The employment status of the employee.
	//
	// - `ACTIVE` - ACTIVE
	// - `PENDING` - PENDING
	// - `INACTIVE` - INACTIVE
	EmploymentStatus *EmployeeRequestEmploymentStatus `json:"employment_status,omitempty"`
	// The employee's termination date.
	TerminationDate *time.Time `json:"termination_date,omitempty"`
	// The URL of the employee's avatar image.
	Avatar              *string                `json:"avatar,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmployeeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EmployeeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmployeeRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmployeeRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The ID of the employee's company.
type EmployeeRequestCompany struct {
	typeName string
	String   string
	Company  *Company
}

func NewEmployeeRequestCompanyFromString(value string) *EmployeeRequestCompany {
	return &EmployeeRequestCompany{typeName: "string", String: value}
}

func NewEmployeeRequestCompanyFromCompany(value *Company) *EmployeeRequestCompany {
	return &EmployeeRequestCompany{typeName: "company", Company: value}
}

func (e *EmployeeRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueCompany := new(Company)
	if err := json.Unmarshal(data, &valueCompany); err == nil {
		e.typeName = "company"
		e.Company = valueCompany
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestCompany) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "company":
		return json.Marshal(e.Company)
	}
}

type EmployeeRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompany(*Company) error
}

func (e *EmployeeRequestCompany) Accept(visitor EmployeeRequestCompanyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "company":
		return visitor.VisitCompany(e.Company)
	}
}

// The employment status of the employee.
//
// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type EmployeeRequestEmploymentStatus struct {
	typeName             string
	EmploymentStatusEnum EmploymentStatusEnum
	String               string
}

func NewEmployeeRequestEmploymentStatusFromEmploymentStatusEnum(value EmploymentStatusEnum) *EmployeeRequestEmploymentStatus {
	return &EmployeeRequestEmploymentStatus{typeName: "employmentStatusEnum", EmploymentStatusEnum: value}
}

func NewEmployeeRequestEmploymentStatusFromString(value string) *EmployeeRequestEmploymentStatus {
	return &EmployeeRequestEmploymentStatus{typeName: "string", String: value}
}

func (e *EmployeeRequestEmploymentStatus) UnmarshalJSON(data []byte) error {
	var valueEmploymentStatusEnum EmploymentStatusEnum
	if err := json.Unmarshal(data, &valueEmploymentStatusEnum); err == nil {
		e.typeName = "employmentStatusEnum"
		e.EmploymentStatusEnum = valueEmploymentStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestEmploymentStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentStatusEnum":
		return json.Marshal(e.EmploymentStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeRequestEmploymentStatusVisitor interface {
	VisitEmploymentStatusEnum(EmploymentStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeRequestEmploymentStatus) Accept(visitor EmployeeRequestEmploymentStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentStatusEnum":
		return visitor.VisitEmploymentStatusEnum(e.EmploymentStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EmployeeRequestEmploymentsItem struct {
	typeName   string
	String     string
	Employment *Employment
}

func NewEmployeeRequestEmploymentsItemFromString(value string) *EmployeeRequestEmploymentsItem {
	return &EmployeeRequestEmploymentsItem{typeName: "string", String: value}
}

func NewEmployeeRequestEmploymentsItemFromEmployment(value *Employment) *EmployeeRequestEmploymentsItem {
	return &EmployeeRequestEmploymentsItem{typeName: "employment", Employment: value}
}

func (e *EmployeeRequestEmploymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployment := new(Employment)
	if err := json.Unmarshal(data, &valueEmployment); err == nil {
		e.typeName = "employment"
		e.Employment = valueEmployment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestEmploymentsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employment":
		return json.Marshal(e.Employment)
	}
}

type EmployeeRequestEmploymentsItemVisitor interface {
	VisitString(string) error
	VisitEmployment(*Employment) error
}

func (e *EmployeeRequestEmploymentsItem) Accept(visitor EmployeeRequestEmploymentsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employment":
		return visitor.VisitEmployment(e.Employment)
	}
}

// The employee's ethnicity.
//
// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// - `WHITE` - WHITE
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeRequestEthnicity struct {
	typeName      string
	EthnicityEnum EthnicityEnum
	String        string
}

func NewEmployeeRequestEthnicityFromEthnicityEnum(value EthnicityEnum) *EmployeeRequestEthnicity {
	return &EmployeeRequestEthnicity{typeName: "ethnicityEnum", EthnicityEnum: value}
}

func NewEmployeeRequestEthnicityFromString(value string) *EmployeeRequestEthnicity {
	return &EmployeeRequestEthnicity{typeName: "string", String: value}
}

func (e *EmployeeRequestEthnicity) UnmarshalJSON(data []byte) error {
	var valueEthnicityEnum EthnicityEnum
	if err := json.Unmarshal(data, &valueEthnicityEnum); err == nil {
		e.typeName = "ethnicityEnum"
		e.EthnicityEnum = valueEthnicityEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestEthnicity) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "ethnicityEnum":
		return json.Marshal(e.EthnicityEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeRequestEthnicityVisitor interface {
	VisitEthnicityEnum(EthnicityEnum) error
	VisitString(string) error
}

func (e *EmployeeRequestEthnicity) Accept(visitor EmployeeRequestEthnicityVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "ethnicityEnum":
		return visitor.VisitEthnicityEnum(e.EthnicityEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee's gender.
//
// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeRequestGender struct {
	typeName   string
	GenderEnum GenderEnum
	String     string
}

func NewEmployeeRequestGenderFromGenderEnum(value GenderEnum) *EmployeeRequestGender {
	return &EmployeeRequestGender{typeName: "genderEnum", GenderEnum: value}
}

func NewEmployeeRequestGenderFromString(value string) *EmployeeRequestGender {
	return &EmployeeRequestGender{typeName: "string", String: value}
}

func (e *EmployeeRequestGender) UnmarshalJSON(data []byte) error {
	var valueGenderEnum GenderEnum
	if err := json.Unmarshal(data, &valueGenderEnum); err == nil {
		e.typeName = "genderEnum"
		e.GenderEnum = valueGenderEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestGender) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return json.Marshal(e.GenderEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeRequestGenderVisitor interface {
	VisitGenderEnum(GenderEnum) error
	VisitString(string) error
}

func (e *EmployeeRequestGender) Accept(visitor EmployeeRequestGenderVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return visitor.VisitGenderEnum(e.GenderEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EmployeeRequestGroupsItem struct {
	typeName string
	String   string
	Group    *Group
}

func NewEmployeeRequestGroupsItemFromString(value string) *EmployeeRequestGroupsItem {
	return &EmployeeRequestGroupsItem{typeName: "string", String: value}
}

func NewEmployeeRequestGroupsItemFromGroup(value *Group) *EmployeeRequestGroupsItem {
	return &EmployeeRequestGroupsItem{typeName: "group", Group: value}
}

func (e *EmployeeRequestGroupsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		e.typeName = "group"
		e.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestGroupsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "group":
		return json.Marshal(e.Group)
	}
}

type EmployeeRequestGroupsItemVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (e *EmployeeRequestGroupsItem) Accept(visitor EmployeeRequestGroupsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "group":
		return visitor.VisitGroup(e.Group)
	}
}

// The employee's home address.
type EmployeeRequestHomeLocation struct {
	typeName string
	String   string
	Location *Location
}

func NewEmployeeRequestHomeLocationFromString(value string) *EmployeeRequestHomeLocation {
	return &EmployeeRequestHomeLocation{typeName: "string", String: value}
}

func NewEmployeeRequestHomeLocationFromLocation(value *Location) *EmployeeRequestHomeLocation {
	return &EmployeeRequestHomeLocation{typeName: "location", Location: value}
}

func (e *EmployeeRequestHomeLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typeName = "location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestHomeLocation) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "location":
		return json.Marshal(e.Location)
	}
}

type EmployeeRequestHomeLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeRequestHomeLocation) Accept(visitor EmployeeRequestHomeLocationVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "location":
		return visitor.VisitLocation(e.Location)
	}
}

// The employee ID of the employee's manager.
type EmployeeRequestManager struct {
	typeName string
	String   string
	Employee *Employee
}

func NewEmployeeRequestManagerFromString(value string) *EmployeeRequestManager {
	return &EmployeeRequestManager{typeName: "string", String: value}
}

func NewEmployeeRequestManagerFromEmployee(value *Employee) *EmployeeRequestManager {
	return &EmployeeRequestManager{typeName: "employee", Employee: value}
}

func (e *EmployeeRequestManager) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestManager) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type EmployeeRequestManagerVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmployeeRequestManager) Accept(visitor EmployeeRequestManagerVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The employee's filing status as related to marital status.
//
// - `SINGLE` - SINGLE
// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
type EmployeeRequestMaritalStatus struct {
	typeName          string
	MaritalStatusEnum MaritalStatusEnum
	String            string
}

func NewEmployeeRequestMaritalStatusFromMaritalStatusEnum(value MaritalStatusEnum) *EmployeeRequestMaritalStatus {
	return &EmployeeRequestMaritalStatus{typeName: "maritalStatusEnum", MaritalStatusEnum: value}
}

func NewEmployeeRequestMaritalStatusFromString(value string) *EmployeeRequestMaritalStatus {
	return &EmployeeRequestMaritalStatus{typeName: "string", String: value}
}

func (e *EmployeeRequestMaritalStatus) UnmarshalJSON(data []byte) error {
	var valueMaritalStatusEnum MaritalStatusEnum
	if err := json.Unmarshal(data, &valueMaritalStatusEnum); err == nil {
		e.typeName = "maritalStatusEnum"
		e.MaritalStatusEnum = valueMaritalStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestMaritalStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "maritalStatusEnum":
		return json.Marshal(e.MaritalStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeRequestMaritalStatusVisitor interface {
	VisitMaritalStatusEnum(MaritalStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeRequestMaritalStatus) Accept(visitor EmployeeRequestMaritalStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "maritalStatusEnum":
		return visitor.VisitMaritalStatusEnum(e.MaritalStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee's pay group
type EmployeeRequestPayGroup struct {
	typeName string
	String   string
	PayGroup *PayGroup
}

func NewEmployeeRequestPayGroupFromString(value string) *EmployeeRequestPayGroup {
	return &EmployeeRequestPayGroup{typeName: "string", String: value}
}

func NewEmployeeRequestPayGroupFromPayGroup(value *PayGroup) *EmployeeRequestPayGroup {
	return &EmployeeRequestPayGroup{typeName: "payGroup", PayGroup: value}
}

func (e *EmployeeRequestPayGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valuePayGroup := new(PayGroup)
	if err := json.Unmarshal(data, &valuePayGroup); err == nil {
		e.typeName = "payGroup"
		e.PayGroup = valuePayGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestPayGroup) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "payGroup":
		return json.Marshal(e.PayGroup)
	}
}

type EmployeeRequestPayGroupVisitor interface {
	VisitString(string) error
	VisitPayGroup(*PayGroup) error
}

func (e *EmployeeRequestPayGroup) Accept(visitor EmployeeRequestPayGroupVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "payGroup":
		return visitor.VisitPayGroup(e.PayGroup)
	}
}

// The employee's team.
type EmployeeRequestTeam struct {
	typeName string
	String   string
	Team     *Team
}

func NewEmployeeRequestTeamFromString(value string) *EmployeeRequestTeam {
	return &EmployeeRequestTeam{typeName: "string", String: value}
}

func NewEmployeeRequestTeamFromTeam(value *Team) *EmployeeRequestTeam {
	return &EmployeeRequestTeam{typeName: "team", Team: value}
}

func (e *EmployeeRequestTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		e.typeName = "team"
		e.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestTeam) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "team":
		return json.Marshal(e.Team)
	}
}

type EmployeeRequestTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (e *EmployeeRequestTeam) Accept(visitor EmployeeRequestTeamVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "team":
		return visitor.VisitTeam(e.Team)
	}
}

// The employee's work address.
type EmployeeRequestWorkLocation struct {
	typeName string
	String   string
	Location *Location
}

func NewEmployeeRequestWorkLocationFromString(value string) *EmployeeRequestWorkLocation {
	return &EmployeeRequestWorkLocation{typeName: "string", String: value}
}

func NewEmployeeRequestWorkLocationFromLocation(value *Location) *EmployeeRequestWorkLocation {
	return &EmployeeRequestWorkLocation{typeName: "location", Location: value}
}

func (e *EmployeeRequestWorkLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typeName = "location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeRequestWorkLocation) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "location":
		return json.Marshal(e.Location)
	}
}

type EmployeeRequestWorkLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeRequestWorkLocation) Accept(visitor EmployeeRequestWorkLocationVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "location":
		return visitor.VisitLocation(e.Location)
	}
}

type EmployeeResponse struct {
	Model    *Employee                   `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmployeeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmployeeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmployeeResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmployeeResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The employee's team.
type EmployeeTeam struct {
	typeName string
	String   string
	Team     *Team
}

func NewEmployeeTeamFromString(value string) *EmployeeTeam {
	return &EmployeeTeam{typeName: "string", String: value}
}

func NewEmployeeTeamFromTeam(value *Team) *EmployeeTeam {
	return &EmployeeTeam{typeName: "team", Team: value}
}

func (e *EmployeeTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		e.typeName = "team"
		e.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeTeam) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "team":
		return json.Marshal(e.Team)
	}
}

type EmployeeTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (e *EmployeeTeam) Accept(visitor EmployeeTeamVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "team":
		return visitor.VisitTeam(e.Team)
	}
}

// The employee's work address.
type EmployeeWorkLocation struct {
	typeName string
	String   string
	Location *Location
}

func NewEmployeeWorkLocationFromString(value string) *EmployeeWorkLocation {
	return &EmployeeWorkLocation{typeName: "string", String: value}
}

func NewEmployeeWorkLocationFromLocation(value *Location) *EmployeeWorkLocation {
	return &EmployeeWorkLocation{typeName: "location", Location: value}
}

func (e *EmployeeWorkLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typeName = "location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeWorkLocation) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "location":
		return json.Marshal(e.Location)
	}
}

type EmployeeWorkLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeWorkLocation) Accept(visitor EmployeeWorkLocationVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "location":
		return visitor.VisitLocation(e.Location)
	}
}

// # The EmployerBenefit Object
//
// ### Description
//
// The `Employer Benefit` object is used to represent a benefit plan offered by a company.
//
// ### Usage Example
//
// Fetch from the `LIST EmployerBenefits` endpoint and filter by `ID` to show all EmployerBenefits.
type EmployerBenefit struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The type of benefit plan.
	//
	// - `MEDICAL` - MEDICAL
	// - `HEALTH_SAVINGS` - HEALTH_SAVINGS
	// - `INSURANCE` - INSURANCE
	// - `RETIREMENT` - RETIREMENT
	// - `OTHER` - OTHER
	BenefitPlanType *EmployerBenefitBenefitPlanType `json:"benefit_plan_type,omitempty"`
	// The employer benefit's name - typically the carrier or network name.
	Name *string `json:"name,omitempty"`
	// The employer benefit's description.
	Description *string `json:"description,omitempty"`
	// The employer benefit's deduction code.
	DeductionCode *string `json:"deduction_code,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmployerBenefit) UnmarshalJSON(data []byte) error {
	type unmarshaler EmployerBenefit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmployerBenefit(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmployerBenefit) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The type of benefit plan.
//
// - `MEDICAL` - MEDICAL
// - `HEALTH_SAVINGS` - HEALTH_SAVINGS
// - `INSURANCE` - INSURANCE
// - `RETIREMENT` - RETIREMENT
// - `OTHER` - OTHER
type EmployerBenefitBenefitPlanType struct {
	typeName            string
	BenefitPlanTypeEnum BenefitPlanTypeEnum
	String              string
}

func NewEmployerBenefitBenefitPlanTypeFromBenefitPlanTypeEnum(value BenefitPlanTypeEnum) *EmployerBenefitBenefitPlanType {
	return &EmployerBenefitBenefitPlanType{typeName: "benefitPlanTypeEnum", BenefitPlanTypeEnum: value}
}

func NewEmployerBenefitBenefitPlanTypeFromString(value string) *EmployerBenefitBenefitPlanType {
	return &EmployerBenefitBenefitPlanType{typeName: "string", String: value}
}

func (e *EmployerBenefitBenefitPlanType) UnmarshalJSON(data []byte) error {
	var valueBenefitPlanTypeEnum BenefitPlanTypeEnum
	if err := json.Unmarshal(data, &valueBenefitPlanTypeEnum); err == nil {
		e.typeName = "benefitPlanTypeEnum"
		e.BenefitPlanTypeEnum = valueBenefitPlanTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployerBenefitBenefitPlanType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "benefitPlanTypeEnum":
		return json.Marshal(e.BenefitPlanTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployerBenefitBenefitPlanTypeVisitor interface {
	VisitBenefitPlanTypeEnum(BenefitPlanTypeEnum) error
	VisitString(string) error
}

func (e *EmployerBenefitBenefitPlanType) Accept(visitor EmployerBenefitBenefitPlanTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "benefitPlanTypeEnum":
		return visitor.VisitBenefitPlanTypeEnum(e.BenefitPlanTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// # The Employment Object
//
// ### Description
//
// The `Employment` object is used to represent a job position at a company.
//
// If an integration supports historical tracking of employments, it will be reflected in the data. If not, a new `Employment` object will be created whenever there is a change in job title or pay. The `effective_date` field should be used to order `Employment` objects, with the most recent date corresponding to the latest employment record for an employee.
//
// ### Usage Example
//
// Fetch from the `LIST Employments` endpoint and filter by `ID` to show all employees.
type Employment struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee holding this position.
	Employee *EmploymentEmployee `json:"employee,omitempty"`
	// The position's title.
	JobTitle *string `json:"job_title,omitempty"`
	// The position's pay rate.
	PayRate *float64 `json:"pay_rate,omitempty"`
	// The time period this pay rate encompasses.
	//
	// - `HOUR` - HOUR
	// - `DAY` - DAY
	// - `WEEK` - WEEK
	// - `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
	// - `SEMIMONTHLY` - SEMIMONTHLY
	// - `MONTH` - MONTH
	// - `QUARTER` - QUARTER
	// - `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
	// - `YEAR` - YEAR
	PayPeriod *EmploymentPayPeriod `json:"pay_period,omitempty"`
	// The position's pay frequency.
	//
	// - `WEEKLY` - WEEKLY
	// - `BIWEEKLY` - BIWEEKLY
	// - `MONTHLY` - MONTHLY
	// - `QUARTERLY` - QUARTERLY
	// - `SEMIANNUALLY` - SEMIANNUALLY
	// - `ANNUALLY` - ANNUALLY
	// - `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
	// - `PRO_RATA` - PRO_RATA
	// - `SEMIMONTHLY` - SEMIMONTHLY
	PayFrequency *EmploymentPayFrequency `json:"pay_frequency,omitempty"`
	// The position's currency code.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	PayCurrency *EmploymentPayCurrency `json:"pay_currency,omitempty"`
	// The employment's pay group
	PayGroup *EmploymentPayGroup `json:"pay_group,omitempty"`
	// The position's FLSA status.
	//
	// - `EXEMPT` - EXEMPT
	// - `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
	// - `NONEXEMPT` - NONEXEMPT
	// - `OWNER` - OWNER
	FlsaStatus *EmploymentFlsaStatus `json:"flsa_status,omitempty"`
	// The position's effective date.
	EffectiveDate *time.Time `json:"effective_date,omitempty"`
	// The position's type of employment.
	//
	// - `FULL_TIME` - FULL_TIME
	// - `PART_TIME` - PART_TIME
	// - `INTERN` - INTERN
	// - `CONTRACTOR` - CONTRACTOR
	// - `FREELANCE` - FREELANCE
	EmploymentType *EmploymentEmploymentType `json:"employment_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Employment) UnmarshalJSON(data []byte) error {
	type unmarshaler Employment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Employment(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Employment) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The employee holding this position.
type EmploymentEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewEmploymentEmployeeFromString(value string) *EmploymentEmployee {
	return &EmploymentEmployee{typeName: "string", String: value}
}

func NewEmploymentEmployeeFromEmployee(value *Employee) *EmploymentEmployee {
	return &EmploymentEmployee{typeName: "employee", Employee: value}
}

func (e *EmploymentEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentEmployee) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type EmploymentEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmploymentEmployee) Accept(visitor EmploymentEmployeeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The position's type of employment.
//
// - `FULL_TIME` - FULL_TIME
// - `PART_TIME` - PART_TIME
// - `INTERN` - INTERN
// - `CONTRACTOR` - CONTRACTOR
// - `FREELANCE` - FREELANCE
type EmploymentEmploymentType struct {
	typeName           string
	EmploymentTypeEnum EmploymentTypeEnum
	String             string
}

func NewEmploymentEmploymentTypeFromEmploymentTypeEnum(value EmploymentTypeEnum) *EmploymentEmploymentType {
	return &EmploymentEmploymentType{typeName: "employmentTypeEnum", EmploymentTypeEnum: value}
}

func NewEmploymentEmploymentTypeFromString(value string) *EmploymentEmploymentType {
	return &EmploymentEmploymentType{typeName: "string", String: value}
}

func (e *EmploymentEmploymentType) UnmarshalJSON(data []byte) error {
	var valueEmploymentTypeEnum EmploymentTypeEnum
	if err := json.Unmarshal(data, &valueEmploymentTypeEnum); err == nil {
		e.typeName = "employmentTypeEnum"
		e.EmploymentTypeEnum = valueEmploymentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentEmploymentType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentTypeEnum":
		return json.Marshal(e.EmploymentTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentEmploymentTypeVisitor interface {
	VisitEmploymentTypeEnum(EmploymentTypeEnum) error
	VisitString(string) error
}

func (e *EmploymentEmploymentType) Accept(visitor EmploymentEmploymentTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "employmentTypeEnum":
		return visitor.VisitEmploymentTypeEnum(e.EmploymentTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The position's FLSA status.
//
// - `EXEMPT` - EXEMPT
// - `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
// - `NONEXEMPT` - NONEXEMPT
// - `OWNER` - OWNER
type EmploymentFlsaStatus struct {
	typeName       string
	FlsaStatusEnum FlsaStatusEnum
	String         string
}

func NewEmploymentFlsaStatusFromFlsaStatusEnum(value FlsaStatusEnum) *EmploymentFlsaStatus {
	return &EmploymentFlsaStatus{typeName: "flsaStatusEnum", FlsaStatusEnum: value}
}

func NewEmploymentFlsaStatusFromString(value string) *EmploymentFlsaStatus {
	return &EmploymentFlsaStatus{typeName: "string", String: value}
}

func (e *EmploymentFlsaStatus) UnmarshalJSON(data []byte) error {
	var valueFlsaStatusEnum FlsaStatusEnum
	if err := json.Unmarshal(data, &valueFlsaStatusEnum); err == nil {
		e.typeName = "flsaStatusEnum"
		e.FlsaStatusEnum = valueFlsaStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentFlsaStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "flsaStatusEnum":
		return json.Marshal(e.FlsaStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentFlsaStatusVisitor interface {
	VisitFlsaStatusEnum(FlsaStatusEnum) error
	VisitString(string) error
}

func (e *EmploymentFlsaStatus) Accept(visitor EmploymentFlsaStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "flsaStatusEnum":
		return visitor.VisitFlsaStatusEnum(e.FlsaStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The position's currency code.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type EmploymentPayCurrency struct {
	typeName        string
	PayCurrencyEnum PayCurrencyEnum
	String          string
}

func NewEmploymentPayCurrencyFromPayCurrencyEnum(value PayCurrencyEnum) *EmploymentPayCurrency {
	return &EmploymentPayCurrency{typeName: "payCurrencyEnum", PayCurrencyEnum: value}
}

func NewEmploymentPayCurrencyFromString(value string) *EmploymentPayCurrency {
	return &EmploymentPayCurrency{typeName: "string", String: value}
}

func (e *EmploymentPayCurrency) UnmarshalJSON(data []byte) error {
	var valuePayCurrencyEnum PayCurrencyEnum
	if err := json.Unmarshal(data, &valuePayCurrencyEnum); err == nil {
		e.typeName = "payCurrencyEnum"
		e.PayCurrencyEnum = valuePayCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayCurrency) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payCurrencyEnum":
		return json.Marshal(e.PayCurrencyEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentPayCurrencyVisitor interface {
	VisitPayCurrencyEnum(PayCurrencyEnum) error
	VisitString(string) error
}

func (e *EmploymentPayCurrency) Accept(visitor EmploymentPayCurrencyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payCurrencyEnum":
		return visitor.VisitPayCurrencyEnum(e.PayCurrencyEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The position's pay frequency.
//
// - `WEEKLY` - WEEKLY
// - `BIWEEKLY` - BIWEEKLY
// - `MONTHLY` - MONTHLY
// - `QUARTERLY` - QUARTERLY
// - `SEMIANNUALLY` - SEMIANNUALLY
// - `ANNUALLY` - ANNUALLY
// - `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
// - `PRO_RATA` - PRO_RATA
// - `SEMIMONTHLY` - SEMIMONTHLY
type EmploymentPayFrequency struct {
	typeName         string
	PayFrequencyEnum PayFrequencyEnum
	String           string
}

func NewEmploymentPayFrequencyFromPayFrequencyEnum(value PayFrequencyEnum) *EmploymentPayFrequency {
	return &EmploymentPayFrequency{typeName: "payFrequencyEnum", PayFrequencyEnum: value}
}

func NewEmploymentPayFrequencyFromString(value string) *EmploymentPayFrequency {
	return &EmploymentPayFrequency{typeName: "string", String: value}
}

func (e *EmploymentPayFrequency) UnmarshalJSON(data []byte) error {
	var valuePayFrequencyEnum PayFrequencyEnum
	if err := json.Unmarshal(data, &valuePayFrequencyEnum); err == nil {
		e.typeName = "payFrequencyEnum"
		e.PayFrequencyEnum = valuePayFrequencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayFrequency) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payFrequencyEnum":
		return json.Marshal(e.PayFrequencyEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentPayFrequencyVisitor interface {
	VisitPayFrequencyEnum(PayFrequencyEnum) error
	VisitString(string) error
}

func (e *EmploymentPayFrequency) Accept(visitor EmploymentPayFrequencyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payFrequencyEnum":
		return visitor.VisitPayFrequencyEnum(e.PayFrequencyEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employment's pay group
type EmploymentPayGroup struct {
	typeName string
	String   string
	PayGroup *PayGroup
}

func NewEmploymentPayGroupFromString(value string) *EmploymentPayGroup {
	return &EmploymentPayGroup{typeName: "string", String: value}
}

func NewEmploymentPayGroupFromPayGroup(value *PayGroup) *EmploymentPayGroup {
	return &EmploymentPayGroup{typeName: "payGroup", PayGroup: value}
}

func (e *EmploymentPayGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valuePayGroup := new(PayGroup)
	if err := json.Unmarshal(data, &valuePayGroup); err == nil {
		e.typeName = "payGroup"
		e.PayGroup = valuePayGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayGroup) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "payGroup":
		return json.Marshal(e.PayGroup)
	}
}

type EmploymentPayGroupVisitor interface {
	VisitString(string) error
	VisitPayGroup(*PayGroup) error
}

func (e *EmploymentPayGroup) Accept(visitor EmploymentPayGroupVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "payGroup":
		return visitor.VisitPayGroup(e.PayGroup)
	}
}

// The time period this pay rate encompasses.
//
// - `HOUR` - HOUR
// - `DAY` - DAY
// - `WEEK` - WEEK
// - `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
// - `SEMIMONTHLY` - SEMIMONTHLY
// - `MONTH` - MONTH
// - `QUARTER` - QUARTER
// - `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
// - `YEAR` - YEAR
type EmploymentPayPeriod struct {
	typeName      string
	PayPeriodEnum PayPeriodEnum
	String        string
}

func NewEmploymentPayPeriodFromPayPeriodEnum(value PayPeriodEnum) *EmploymentPayPeriod {
	return &EmploymentPayPeriod{typeName: "payPeriodEnum", PayPeriodEnum: value}
}

func NewEmploymentPayPeriodFromString(value string) *EmploymentPayPeriod {
	return &EmploymentPayPeriod{typeName: "string", String: value}
}

func (e *EmploymentPayPeriod) UnmarshalJSON(data []byte) error {
	var valuePayPeriodEnum PayPeriodEnum
	if err := json.Unmarshal(data, &valuePayPeriodEnum); err == nil {
		e.typeName = "payPeriodEnum"
		e.PayPeriodEnum = valuePayPeriodEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayPeriod) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payPeriodEnum":
		return json.Marshal(e.PayPeriodEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmploymentPayPeriodVisitor interface {
	VisitPayPeriodEnum(PayPeriodEnum) error
	VisitString(string) error
}

func (e *EmploymentPayPeriod) Accept(visitor EmploymentPayPeriodVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "payPeriodEnum":
		return visitor.VisitPayPeriodEnum(e.PayPeriodEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type EmploymentStatusEnum string

const (
	EmploymentStatusEnumActive   EmploymentStatusEnum = "ACTIVE"
	EmploymentStatusEnumPending  EmploymentStatusEnum = "PENDING"
	EmploymentStatusEnumInactive EmploymentStatusEnum = "INACTIVE"
)

func NewEmploymentStatusEnumFromString(s string) (EmploymentStatusEnum, error) {
	switch s {
	case "ACTIVE":
		return EmploymentStatusEnumActive, nil
	case "PENDING":
		return EmploymentStatusEnumPending, nil
	case "INACTIVE":
		return EmploymentStatusEnumInactive, nil
	}
	var t EmploymentStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmploymentStatusEnum) Ptr() *EmploymentStatusEnum {
	return &e
}

// - `FULL_TIME` - FULL_TIME
// - `PART_TIME` - PART_TIME
// - `INTERN` - INTERN
// - `CONTRACTOR` - CONTRACTOR
// - `FREELANCE` - FREELANCE
type EmploymentTypeEnum string

const (
	EmploymentTypeEnumFullTime   EmploymentTypeEnum = "FULL_TIME"
	EmploymentTypeEnumPartTime   EmploymentTypeEnum = "PART_TIME"
	EmploymentTypeEnumIntern     EmploymentTypeEnum = "INTERN"
	EmploymentTypeEnumContractor EmploymentTypeEnum = "CONTRACTOR"
	EmploymentTypeEnumFreelance  EmploymentTypeEnum = "FREELANCE"
)

func NewEmploymentTypeEnumFromString(s string) (EmploymentTypeEnum, error) {
	switch s {
	case "FULL_TIME":
		return EmploymentTypeEnumFullTime, nil
	case "PART_TIME":
		return EmploymentTypeEnumPartTime, nil
	case "INTERN":
		return EmploymentTypeEnumIntern, nil
	case "CONTRACTOR":
		return EmploymentTypeEnumContractor, nil
	case "FREELANCE":
		return EmploymentTypeEnumFreelance, nil
	}
	var t EmploymentTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmploymentTypeEnum) Ptr() *EmploymentTypeEnum {
	return &e
}

// - `READ` - READ
// - `WRITE` - WRITE
type EnabledActionsEnum string

const (
	EnabledActionsEnumRead  EnabledActionsEnum = "READ"
	EnabledActionsEnumWrite EnabledActionsEnum = "WRITE"
)

func NewEnabledActionsEnumFromString(s string) (EnabledActionsEnum, error) {
	switch s {
	case "READ":
		return EnabledActionsEnumRead, nil
	case "WRITE":
		return EnabledActionsEnumWrite, nil
	}
	var t EnabledActionsEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnabledActionsEnum) Ptr() *EnabledActionsEnum {
	return &e
}

// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum string

const (
	EncodingEnumRaw        EncodingEnum = "RAW"
	EncodingEnumBase64     EncodingEnum = "BASE64"
	EncodingEnumGzipBase64 EncodingEnum = "GZIP_BASE64"
)

func NewEncodingEnumFromString(s string) (EncodingEnum, error) {
	switch s {
	case "RAW":
		return EncodingEnumRaw, nil
	case "BASE64":
		return EncodingEnumBase64, nil
	case "GZIP_BASE64":
		return EncodingEnumGzipBase64, nil
	}
	var t EncodingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncodingEnum) Ptr() *EncodingEnum {
	return &e
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`

	_rawJSON json.RawMessage
}

func (e *ErrorValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorValidationProblem(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorValidationProblem) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// - `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
// - `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// - `WHITE` - WHITE
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EthnicityEnum string

const (
	EthnicityEnumAmericanIndianOrAlaskaNative         EthnicityEnum = "AMERICAN_INDIAN_OR_ALASKA_NATIVE"
	EthnicityEnumAsianOrIndianSubcontinent            EthnicityEnum = "ASIAN_OR_INDIAN_SUBCONTINENT"
	EthnicityEnumBlackOrAfricanAmerican               EthnicityEnum = "BLACK_OR_AFRICAN_AMERICAN"
	EthnicityEnumHispanicOrLatino                     EthnicityEnum = "HISPANIC_OR_LATINO"
	EthnicityEnumNativeHawaiianOrOtherPacificIslander EthnicityEnum = "NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER"
	EthnicityEnumTwoOrMoreRaces                       EthnicityEnum = "TWO_OR_MORE_RACES"
	EthnicityEnumWhite                                EthnicityEnum = "WHITE"
	EthnicityEnumPreferNotToDisclose                  EthnicityEnum = "PREFER_NOT_TO_DISCLOSE"
)

func NewEthnicityEnumFromString(s string) (EthnicityEnum, error) {
	switch s {
	case "AMERICAN_INDIAN_OR_ALASKA_NATIVE":
		return EthnicityEnumAmericanIndianOrAlaskaNative, nil
	case "ASIAN_OR_INDIAN_SUBCONTINENT":
		return EthnicityEnumAsianOrIndianSubcontinent, nil
	case "BLACK_OR_AFRICAN_AMERICAN":
		return EthnicityEnumBlackOrAfricanAmerican, nil
	case "HISPANIC_OR_LATINO":
		return EthnicityEnumHispanicOrLatino, nil
	case "NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER":
		return EthnicityEnumNativeHawaiianOrOtherPacificIslander, nil
	case "TWO_OR_MORE_RACES":
		return EthnicityEnumTwoOrMoreRaces, nil
	case "WHITE":
		return EthnicityEnumWhite, nil
	case "PREFER_NOT_TO_DISCLOSE":
		return EthnicityEnumPreferNotToDisclose, nil
	}
	var t EthnicityEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EthnicityEnum) Ptr() *EthnicityEnum {
	return &e
}

// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
// - `MUTED_ISSUE` - MUTED_ISSUE
// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
// - `END_USER_CREDENTIALS_ACCESSED` - END_USER_CREDENTIALS_ACCESSED
type EventTypeEnum string

const (
	EventTypeEnumCreatedRemoteProductionApiKey              EventTypeEnum = "CREATED_REMOTE_PRODUCTION_API_KEY"
	EventTypeEnumDeletedRemoteProductionApiKey              EventTypeEnum = "DELETED_REMOTE_PRODUCTION_API_KEY"
	EventTypeEnumCreatedTestApiKey                          EventTypeEnum = "CREATED_TEST_API_KEY"
	EventTypeEnumDeletedTestApiKey                          EventTypeEnum = "DELETED_TEST_API_KEY"
	EventTypeEnumRegeneratedProductionApiKey                EventTypeEnum = "REGENERATED_PRODUCTION_API_KEY"
	EventTypeEnumInvitedUser                                EventTypeEnum = "INVITED_USER"
	EventTypeEnumTwoFactorAuthEnabled                       EventTypeEnum = "TWO_FACTOR_AUTH_ENABLED"
	EventTypeEnumTwoFactorAuthDisabled                      EventTypeEnum = "TWO_FACTOR_AUTH_DISABLED"
	EventTypeEnumDeletedLinkedAccount                       EventTypeEnum = "DELETED_LINKED_ACCOUNT"
	EventTypeEnumCreatedDestination                         EventTypeEnum = "CREATED_DESTINATION"
	EventTypeEnumDeletedDestination                         EventTypeEnum = "DELETED_DESTINATION"
	EventTypeEnumChangedDestination                         EventTypeEnum = "CHANGED_DESTINATION"
	EventTypeEnumChangedScopes                              EventTypeEnum = "CHANGED_SCOPES"
	EventTypeEnumChangedPersonalInformation                 EventTypeEnum = "CHANGED_PERSONAL_INFORMATION"
	EventTypeEnumChangedOrganizationSettings                EventTypeEnum = "CHANGED_ORGANIZATION_SETTINGS"
	EventTypeEnumEnabledIntegration                         EventTypeEnum = "ENABLED_INTEGRATION"
	EventTypeEnumDisabledIntegration                        EventTypeEnum = "DISABLED_INTEGRATION"
	EventTypeEnumEnabledCategory                            EventTypeEnum = "ENABLED_CATEGORY"
	EventTypeEnumDisabledCategory                           EventTypeEnum = "DISABLED_CATEGORY"
	EventTypeEnumChangedPassword                            EventTypeEnum = "CHANGED_PASSWORD"
	EventTypeEnumResetPassword                              EventTypeEnum = "RESET_PASSWORD"
	EventTypeEnumEnabledRedactUnmappedDataForOrganization   EventTypeEnum = "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount  EventTypeEnum = "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	EventTypeEnumDisabledRedactUnmappedDataForOrganization  EventTypeEnum = "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount EventTypeEnum = "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	EventTypeEnumCreatedIntegrationWideFieldMapping         EventTypeEnum = "CREATED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumCreatedLinkedAccountFieldMapping           EventTypeEnum = "CREATED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumChangedIntegrationWideFieldMapping         EventTypeEnum = "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumChangedLinkedAccountFieldMapping           EventTypeEnum = "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumDeletedIntegrationWideFieldMapping         EventTypeEnum = "DELETED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumDeletedLinkedAccountFieldMapping           EventTypeEnum = "DELETED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumCreatedLinkedAccountCommonModelOverride    EventTypeEnum = "CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE"
	EventTypeEnumChangedLinkedAccountCommonModelOverride    EventTypeEnum = "CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE"
	EventTypeEnumDeletedLinkedAccountCommonModelOverride    EventTypeEnum = "DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE"
	EventTypeEnumForcedLinkedAccountResync                  EventTypeEnum = "FORCED_LINKED_ACCOUNT_RESYNC"
	EventTypeEnumMutedIssue                                 EventTypeEnum = "MUTED_ISSUE"
	EventTypeEnumGeneratedMagicLink                         EventTypeEnum = "GENERATED_MAGIC_LINK"
	EventTypeEnumEnabledMergeWebhook                        EventTypeEnum = "ENABLED_MERGE_WEBHOOK"
	EventTypeEnumDisabledMergeWebhook                       EventTypeEnum = "DISABLED_MERGE_WEBHOOK"
	EventTypeEnumMergeWebhookTargetChanged                  EventTypeEnum = "MERGE_WEBHOOK_TARGET_CHANGED"
	EventTypeEnumEndUserCredentialsAccessed                 EventTypeEnum = "END_USER_CREDENTIALS_ACCESSED"
)

func NewEventTypeEnumFromString(s string) (EventTypeEnum, error) {
	switch s {
	case "CREATED_REMOTE_PRODUCTION_API_KEY":
		return EventTypeEnumCreatedRemoteProductionApiKey, nil
	case "DELETED_REMOTE_PRODUCTION_API_KEY":
		return EventTypeEnumDeletedRemoteProductionApiKey, nil
	case "CREATED_TEST_API_KEY":
		return EventTypeEnumCreatedTestApiKey, nil
	case "DELETED_TEST_API_KEY":
		return EventTypeEnumDeletedTestApiKey, nil
	case "REGENERATED_PRODUCTION_API_KEY":
		return EventTypeEnumRegeneratedProductionApiKey, nil
	case "INVITED_USER":
		return EventTypeEnumInvitedUser, nil
	case "TWO_FACTOR_AUTH_ENABLED":
		return EventTypeEnumTwoFactorAuthEnabled, nil
	case "TWO_FACTOR_AUTH_DISABLED":
		return EventTypeEnumTwoFactorAuthDisabled, nil
	case "DELETED_LINKED_ACCOUNT":
		return EventTypeEnumDeletedLinkedAccount, nil
	case "CREATED_DESTINATION":
		return EventTypeEnumCreatedDestination, nil
	case "DELETED_DESTINATION":
		return EventTypeEnumDeletedDestination, nil
	case "CHANGED_DESTINATION":
		return EventTypeEnumChangedDestination, nil
	case "CHANGED_SCOPES":
		return EventTypeEnumChangedScopes, nil
	case "CHANGED_PERSONAL_INFORMATION":
		return EventTypeEnumChangedPersonalInformation, nil
	case "CHANGED_ORGANIZATION_SETTINGS":
		return EventTypeEnumChangedOrganizationSettings, nil
	case "ENABLED_INTEGRATION":
		return EventTypeEnumEnabledIntegration, nil
	case "DISABLED_INTEGRATION":
		return EventTypeEnumDisabledIntegration, nil
	case "ENABLED_CATEGORY":
		return EventTypeEnumEnabledCategory, nil
	case "DISABLED_CATEGORY":
		return EventTypeEnumDisabledCategory, nil
	case "CHANGED_PASSWORD":
		return EventTypeEnumChangedPassword, nil
	case "RESET_PASSWORD":
		return EventTypeEnumResetPassword, nil
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		return EventTypeEnumEnabledRedactUnmappedDataForOrganization, nil
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		return EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount, nil
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		return EventTypeEnumDisabledRedactUnmappedDataForOrganization, nil
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		return EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount, nil
	case "CREATED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumCreatedIntegrationWideFieldMapping, nil
	case "CREATED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumCreatedLinkedAccountFieldMapping, nil
	case "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumChangedIntegrationWideFieldMapping, nil
	case "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumChangedLinkedAccountFieldMapping, nil
	case "DELETED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumDeletedIntegrationWideFieldMapping, nil
	case "DELETED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumDeletedLinkedAccountFieldMapping, nil
	case "CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE":
		return EventTypeEnumCreatedLinkedAccountCommonModelOverride, nil
	case "CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE":
		return EventTypeEnumChangedLinkedAccountCommonModelOverride, nil
	case "DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE":
		return EventTypeEnumDeletedLinkedAccountCommonModelOverride, nil
	case "FORCED_LINKED_ACCOUNT_RESYNC":
		return EventTypeEnumForcedLinkedAccountResync, nil
	case "MUTED_ISSUE":
		return EventTypeEnumMutedIssue, nil
	case "GENERATED_MAGIC_LINK":
		return EventTypeEnumGeneratedMagicLink, nil
	case "ENABLED_MERGE_WEBHOOK":
		return EventTypeEnumEnabledMergeWebhook, nil
	case "DISABLED_MERGE_WEBHOOK":
		return EventTypeEnumDisabledMergeWebhook, nil
	case "MERGE_WEBHOOK_TARGET_CHANGED":
		return EventTypeEnumMergeWebhookTargetChanged, nil
	case "END_USER_CREDENTIALS_ACCESSED":
		return EventTypeEnumEndUserCredentialsAccessed, nil
	}
	var t EventTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventTypeEnum) Ptr() *EventTypeEnum {
	return &e
}

type ExternalTargetFieldApi struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	IsMapped    *string `json:"is_mapped,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExternalTargetFieldApi) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalTargetFieldApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalTargetFieldApi(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalTargetFieldApi) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalTargetFieldApiResponse struct {
	Benefit            []*ExternalTargetFieldApi `json:"Benefit,omitempty"`
	EmployerBenefit    []*ExternalTargetFieldApi `json:"EmployerBenefit,omitempty"`
	Company            []*ExternalTargetFieldApi `json:"Company,omitempty"`
	EmployeePayrollRun []*ExternalTargetFieldApi `json:"EmployeePayrollRun,omitempty"`
	Employee           []*ExternalTargetFieldApi `json:"Employee,omitempty"`
	Employment         []*ExternalTargetFieldApi `json:"Employment,omitempty"`
	Location           []*ExternalTargetFieldApi `json:"Location,omitempty"`
	PayrollRun         []*ExternalTargetFieldApi `json:"PayrollRun,omitempty"`
	Team               []*ExternalTargetFieldApi `json:"Team,omitempty"`
	TimeOff            []*ExternalTargetFieldApi `json:"TimeOff,omitempty"`
	TimeOffBalance     []*ExternalTargetFieldApi `json:"TimeOffBalance,omitempty"`
	BankInfo           []*ExternalTargetFieldApi `json:"BankInfo,omitempty"`
	PayGroup           []*ExternalTargetFieldApi `json:"PayGroup,omitempty"`
	Group              []*ExternalTargetFieldApi `json:"Group,omitempty"`
	Dependent          []*ExternalTargetFieldApi `json:"Dependent,omitempty"`
	TimesheetEntry     []*ExternalTargetFieldApi `json:"TimesheetEntry,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExternalTargetFieldApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalTargetFieldApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalTargetFieldApiResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalTargetFieldApiResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FieldMappingApiInstance struct {
	Id                *string                             `json:"id,omitempty"`
	IsIntegrationWide *bool                               `json:"is_integration_wide,omitempty"`
	TargetField       *FieldMappingApiInstanceTargetField `json:"target_field,omitempty"`
	RemoteField       *FieldMappingApiInstanceRemoteField `json:"remote_field,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstance) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstance(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstance) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceRemoteField struct {
	RemoteKeyName      *string                                               `json:"remote_key_name,omitempty"`
	Schema             map[string]interface{}                                `json:"schema,omitempty"`
	RemoteEndpointInfo *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo `json:"remote_endpoint_info,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceRemoteField) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceRemoteField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceRemoteField(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceRemoteField) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo struct {
	Method             *string  `json:"method,omitempty"`
	UrlPath            *string  `json:"url_path,omitempty"`
	FieldTraversalPath []string `json:"field_traversal_path,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceResponse struct {
	Benefit            []*FieldMappingApiInstance `json:"Benefit,omitempty"`
	EmployerBenefit    []*FieldMappingApiInstance `json:"EmployerBenefit,omitempty"`
	Company            []*FieldMappingApiInstance `json:"Company,omitempty"`
	EmployeePayrollRun []*FieldMappingApiInstance `json:"EmployeePayrollRun,omitempty"`
	Employee           []*FieldMappingApiInstance `json:"Employee,omitempty"`
	Employment         []*FieldMappingApiInstance `json:"Employment,omitempty"`
	Location           []*FieldMappingApiInstance `json:"Location,omitempty"`
	PayrollRun         []*FieldMappingApiInstance `json:"PayrollRun,omitempty"`
	Team               []*FieldMappingApiInstance `json:"Team,omitempty"`
	TimeOff            []*FieldMappingApiInstance `json:"TimeOff,omitempty"`
	TimeOffBalance     []*FieldMappingApiInstance `json:"TimeOffBalance,omitempty"`
	BankInfo           []*FieldMappingApiInstance `json:"BankInfo,omitempty"`
	PayGroup           []*FieldMappingApiInstance `json:"PayGroup,omitempty"`
	Group              []*FieldMappingApiInstance `json:"Group,omitempty"`
	Dependent          []*FieldMappingApiInstance `json:"Dependent,omitempty"`
	TimesheetEntry     []*FieldMappingApiInstance `json:"TimesheetEntry,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceTargetField struct {
	Name               string `json:"name"`
	Description        string `json:"description"`
	IsOrganizationWide bool   `json:"is_organization_wide"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceTargetField) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceTargetField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceTargetField(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceTargetField) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingInstanceResponse struct {
	Model    *FieldMappingApiInstance    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingInstanceResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingInstanceResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldPermissionDeserializer struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldPermissionDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializer(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializer) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldPermissionDeserializerRequest struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializerRequest(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializerRequest) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// - `EXEMPT` - EXEMPT
// - `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
// - `NONEXEMPT` - NONEXEMPT
// - `OWNER` - OWNER
type FlsaStatusEnum string

const (
	FlsaStatusEnumExempt            FlsaStatusEnum = "EXEMPT"
	FlsaStatusEnumSalariedNonexempt FlsaStatusEnum = "SALARIED_NONEXEMPT"
	FlsaStatusEnumNonexempt         FlsaStatusEnum = "NONEXEMPT"
	FlsaStatusEnumOwner             FlsaStatusEnum = "OWNER"
)

func NewFlsaStatusEnumFromString(s string) (FlsaStatusEnum, error) {
	switch s {
	case "EXEMPT":
		return FlsaStatusEnumExempt, nil
	case "SALARIED_NONEXEMPT":
		return FlsaStatusEnumSalariedNonexempt, nil
	case "NONEXEMPT":
		return FlsaStatusEnumNonexempt, nil
	case "OWNER":
		return FlsaStatusEnumOwner, nil
	}
	var t FlsaStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FlsaStatusEnum) Ptr() *FlsaStatusEnum {
	return &f
}

// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type GenderEnum string

const (
	GenderEnumMale                GenderEnum = "MALE"
	GenderEnumFemale              GenderEnum = "FEMALE"
	GenderEnumNonBinary           GenderEnum = "NON-BINARY"
	GenderEnumOther               GenderEnum = "OTHER"
	GenderEnumPreferNotToDisclose GenderEnum = "PREFER_NOT_TO_DISCLOSE"
)

func NewGenderEnumFromString(s string) (GenderEnum, error) {
	switch s {
	case "MALE":
		return GenderEnumMale, nil
	case "FEMALE":
		return GenderEnumFemale, nil
	case "NON-BINARY":
		return GenderEnumNonBinary, nil
	case "OTHER":
		return GenderEnumOther, nil
	case "PREFER_NOT_TO_DISCLOSE":
		return GenderEnumPreferNotToDisclose, nil
	}
	var t GenderEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenderEnum) Ptr() *GenderEnum {
	return &g
}

// # The Group Object
//
// ### Description
//
// The `Group` object is used to represent any subset of employees across, for example, `DEPARTMENT` or `TEAM`. Employees can be in multiple Groups.
//
// ### Usage Example
//
// Fetch from the `LIST Employee` endpoint and expand groups to view an employee's groups.
type Group struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The parent group for this group.
	ParentGroup *string `json:"parent_group,omitempty"`
	// The group name.
	Name *string `json:"name,omitempty"`
	// The Group type returned directly from the third-party.
	//
	// - `TEAM` - TEAM
	// - `DEPARTMENT` - DEPARTMENT
	// - `COST_CENTER` - COST_CENTER
	// - `BUSINESS_UNIT` - BUSINESS_UNIT
	// - `GROUP` - GROUP
	Type *GroupType `json:"type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// Indicates whether the Group refers to a team in the third party platform. Note that this is an opinionated view based on how Merge observes most organizations representing teams in each third party platform. If your customer uses a platform different from most, there is a chance this will not be correct.
	IsCommonlyUsedAsTeam *bool                  `json:"is_commonly_used_as_team,omitempty"`
	FieldMappings        map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData           []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *Group) UnmarshalJSON(data []byte) error {
	type unmarshaler Group
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Group(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Group) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The Group type returned directly from the third-party.
//
// - `TEAM` - TEAM
// - `DEPARTMENT` - DEPARTMENT
// - `COST_CENTER` - COST_CENTER
// - `BUSINESS_UNIT` - BUSINESS_UNIT
// - `GROUP` - GROUP
type GroupType struct {
	typeName      string
	GroupTypeEnum GroupTypeEnum
	String        string
}

func NewGroupTypeFromGroupTypeEnum(value GroupTypeEnum) *GroupType {
	return &GroupType{typeName: "groupTypeEnum", GroupTypeEnum: value}
}

func NewGroupTypeFromString(value string) *GroupType {
	return &GroupType{typeName: "string", String: value}
}

func (g *GroupType) UnmarshalJSON(data []byte) error {
	var valueGroupTypeEnum GroupTypeEnum
	if err := json.Unmarshal(data, &valueGroupTypeEnum); err == nil {
		g.typeName = "groupTypeEnum"
		g.GroupTypeEnum = valueGroupTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroupType) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "groupTypeEnum":
		return json.Marshal(g.GroupTypeEnum)
	case "string":
		return json.Marshal(g.String)
	}
}

type GroupTypeVisitor interface {
	VisitGroupTypeEnum(GroupTypeEnum) error
	VisitString(string) error
}

func (g *GroupType) Accept(visitor GroupTypeVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "groupTypeEnum":
		return visitor.VisitGroupTypeEnum(g.GroupTypeEnum)
	case "string":
		return visitor.VisitString(g.String)
	}
}

// - `TEAM` - TEAM
// - `DEPARTMENT` - DEPARTMENT
// - `COST_CENTER` - COST_CENTER
// - `BUSINESS_UNIT` - BUSINESS_UNIT
// - `GROUP` - GROUP
type GroupTypeEnum string

const (
	GroupTypeEnumTeam         GroupTypeEnum = "TEAM"
	GroupTypeEnumDepartment   GroupTypeEnum = "DEPARTMENT"
	GroupTypeEnumCostCenter   GroupTypeEnum = "COST_CENTER"
	GroupTypeEnumBusinessUnit GroupTypeEnum = "BUSINESS_UNIT"
	GroupTypeEnumGroup        GroupTypeEnum = "GROUP"
)

func NewGroupTypeEnumFromString(s string) (GroupTypeEnum, error) {
	switch s {
	case "TEAM":
		return GroupTypeEnumTeam, nil
	case "DEPARTMENT":
		return GroupTypeEnumDepartment, nil
	case "COST_CENTER":
		return GroupTypeEnumCostCenter, nil
	case "BUSINESS_UNIT":
		return GroupTypeEnumBusinessUnit, nil
	case "GROUP":
		return GroupTypeEnumGroup, nil
	}
	var t GroupTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GroupTypeEnum) Ptr() *GroupTypeEnum {
	return &g
}

type IndividualCommonModelScopeDeserializer struct {
	ModelName        string                                  `json:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializer `json:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializer            `json:"field_permissions,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializer(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializer) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndividualCommonModelScopeDeserializerRequest struct {
	ModelName        string                                         `json:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializerRequest `json:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializerRequest            `json:"field_permissions,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializerRequest(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializerRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Issue struct {
	Id *string `json:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// - `ONGOING` - ONGOING
	// - `RESOLVED` - RESOLVED
	Status            *IssueStatus           `json:"status,omitempty"`
	ErrorDescription  string                 `json:"error_description"`
	EndUser           map[string]interface{} `json:"end_user,omitempty"`
	FirstIncidentTime *time.Time             `json:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time             `json:"last_incident_time,omitempty"`
	IsMuted           *bool                  `json:"is_muted,omitempty"`
	ErrorDetails      []string               `json:"error_details,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	type unmarshaler Issue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Issue(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Issue) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatus struct {
	typeName        string
	IssueStatusEnum IssueStatusEnum
	String          string
}

func NewIssueStatusFromIssueStatusEnum(value IssueStatusEnum) *IssueStatus {
	return &IssueStatus{typeName: "issueStatusEnum", IssueStatusEnum: value}
}

func NewIssueStatusFromString(value string) *IssueStatus {
	return &IssueStatus{typeName: "string", String: value}
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typeName = "issueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return json.Marshal(i.IssueStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatusEnum string

const (
	IssueStatusEnumOngoing  IssueStatusEnum = "ONGOING"
	IssueStatusEnumResolved IssueStatusEnum = "RESOLVED"
)

func NewIssueStatusEnumFromString(s string) (IssueStatusEnum, error) {
	switch s {
	case "ONGOING":
		return IssueStatusEnumOngoing, nil
	case "RESOLVED":
		return IssueStatusEnumResolved, nil
	}
	var t IssueStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatusEnum) Ptr() *IssueStatusEnum {
	return &i
}

// - `en` - en
// - `de` - de
type LanguageEnum string

const (
	LanguageEnumEn LanguageEnum = "en"
	LanguageEnumDe LanguageEnum = "de"
)

func NewLanguageEnumFromString(s string) (LanguageEnum, error) {
	switch s {
	case "en":
		return LanguageEnumEn, nil
	case "de":
		return LanguageEnumDe, nil
	}
	var t LanguageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LanguageEnum) Ptr() *LanguageEnum {
	return &l
}

type LinkToken struct {
	LinkToken       string  `json:"link_token"`
	IntegrationName *string `json:"integration_name,omitempty"`
	MagicLinkUrl    *string `json:"magic_link_url,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LinkToken) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkToken(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkToken) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request"`

	_rawJSON json.RawMessage
}

func (l *LinkedAccountStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedAccountStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedAccountStatus(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedAccountStatus) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// # The Location Object
//
// ### Description
//
// The `Location` object is used to represent an address that can be associated with an employee.
//
// ### Usage Example
//
// Fetch from the `LIST Locations` endpoint and filter by `ID` to show all office locations.
type Location struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The location's name.
	Name *string `json:"name,omitempty"`
	// The location's phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`
	// Line 1 of the location's street address.
	Street1 *string `json:"street_1,omitempty"`
	// Line 2 of the location's street address.
	Street2 *string `json:"street_2,omitempty"`
	// The location's city.
	City *string `json:"city,omitempty"`
	// The location's state. Represents a region if outside of the US.
	State *string `json:"state,omitempty"`
	// The location's zip code or postal code.
	ZipCode *string `json:"zip_code,omitempty"`
	// The location's country.
	//
	// - `AF` - Afghanistan
	// - `AX` - Åland Islands
	// - `AL` - Albania
	// - `DZ` - Algeria
	// - `AS` - American Samoa
	// - `AD` - Andorra
	// - `AO` - Angola
	// - `AI` - Anguilla
	// - `AQ` - Antarctica
	// - `AG` - Antigua and Barbuda
	// - `AR` - Argentina
	// - `AM` - Armenia
	// - `AW` - Aruba
	// - `AU` - Australia
	// - `AT` - Austria
	// - `AZ` - Azerbaijan
	// - `BS` - Bahamas
	// - `BH` - Bahrain
	// - `BD` - Bangladesh
	// - `BB` - Barbados
	// - `BY` - Belarus
	// - `BE` - Belgium
	// - `BZ` - Belize
	// - `BJ` - Benin
	// - `BM` - Bermuda
	// - `BT` - Bhutan
	// - `BO` - Bolivia
	// - `BQ` - Bonaire, Sint Eustatius and Saba
	// - `BA` - Bosnia and Herzegovina
	// - `BW` - Botswana
	// - `BV` - Bouvet Island
	// - `BR` - Brazil
	// - `IO` - British Indian Ocean Territory
	// - `BN` - Brunei
	// - `BG` - Bulgaria
	// - `BF` - Burkina Faso
	// - `BI` - Burundi
	// - `CV` - Cabo Verde
	// - `KH` - Cambodia
	// - `CM` - Cameroon
	// - `CA` - Canada
	// - `KY` - Cayman Islands
	// - `CF` - Central African Republic
	// - `TD` - Chad
	// - `CL` - Chile
	// - `CN` - China
	// - `CX` - Christmas Island
	// - `CC` - Cocos (Keeling) Islands
	// - `CO` - Colombia
	// - `KM` - Comoros
	// - `CG` - Congo
	// - `CD` - Congo (the Democratic Republic of the)
	// - `CK` - Cook Islands
	// - `CR` - Costa Rica
	// - `CI` - Côte d'Ivoire
	// - `HR` - Croatia
	// - `CU` - Cuba
	// - `CW` - Curaçao
	// - `CY` - Cyprus
	// - `CZ` - Czechia
	// - `DK` - Denmark
	// - `DJ` - Djibouti
	// - `DM` - Dominica
	// - `DO` - Dominican Republic
	// - `EC` - Ecuador
	// - `EG` - Egypt
	// - `SV` - El Salvador
	// - `GQ` - Equatorial Guinea
	// - `ER` - Eritrea
	// - `EE` - Estonia
	// - `SZ` - Eswatini
	// - `ET` - Ethiopia
	// - `FK` - Falkland Islands (Malvinas)
	// - `FO` - Faroe Islands
	// - `FJ` - Fiji
	// - `FI` - Finland
	// - `FR` - France
	// - `GF` - French Guiana
	// - `PF` - French Polynesia
	// - `TF` - French Southern Territories
	// - `GA` - Gabon
	// - `GM` - Gambia
	// - `GE` - Georgia
	// - `DE` - Germany
	// - `GH` - Ghana
	// - `GI` - Gibraltar
	// - `GR` - Greece
	// - `GL` - Greenland
	// - `GD` - Grenada
	// - `GP` - Guadeloupe
	// - `GU` - Guam
	// - `GT` - Guatemala
	// - `GG` - Guernsey
	// - `GN` - Guinea
	// - `GW` - Guinea-Bissau
	// - `GY` - Guyana
	// - `HT` - Haiti
	// - `HM` - Heard Island and McDonald Islands
	// - `VA` - Holy See
	// - `HN` - Honduras
	// - `HK` - Hong Kong
	// - `HU` - Hungary
	// - `IS` - Iceland
	// - `IN` - India
	// - `ID` - Indonesia
	// - `IR` - Iran
	// - `IQ` - Iraq
	// - `IE` - Ireland
	// - `IM` - Isle of Man
	// - `IL` - Israel
	// - `IT` - Italy
	// - `JM` - Jamaica
	// - `JP` - Japan
	// - `JE` - Jersey
	// - `JO` - Jordan
	// - `KZ` - Kazakhstan
	// - `KE` - Kenya
	// - `KI` - Kiribati
	// - `KW` - Kuwait
	// - `KG` - Kyrgyzstan
	// - `LA` - Laos
	// - `LV` - Latvia
	// - `LB` - Lebanon
	// - `LS` - Lesotho
	// - `LR` - Liberia
	// - `LY` - Libya
	// - `LI` - Liechtenstein
	// - `LT` - Lithuania
	// - `LU` - Luxembourg
	// - `MO` - Macao
	// - `MG` - Madagascar
	// - `MW` - Malawi
	// - `MY` - Malaysia
	// - `MV` - Maldives
	// - `ML` - Mali
	// - `MT` - Malta
	// - `MH` - Marshall Islands
	// - `MQ` - Martinique
	// - `MR` - Mauritania
	// - `MU` - Mauritius
	// - `YT` - Mayotte
	// - `MX` - Mexico
	// - `FM` - Micronesia (Federated States of)
	// - `MD` - Moldova
	// - `MC` - Monaco
	// - `MN` - Mongolia
	// - `ME` - Montenegro
	// - `MS` - Montserrat
	// - `MA` - Morocco
	// - `MZ` - Mozambique
	// - `MM` - Myanmar
	// - `NA` - Namibia
	// - `NR` - Nauru
	// - `NP` - Nepal
	// - `NL` - Netherlands
	// - `NC` - New Caledonia
	// - `NZ` - New Zealand
	// - `NI` - Nicaragua
	// - `NE` - Niger
	// - `NG` - Nigeria
	// - `NU` - Niue
	// - `NF` - Norfolk Island
	// - `KP` - North Korea
	// - `MK` - North Macedonia
	// - `MP` - Northern Mariana Islands
	// - `NO` - Norway
	// - `OM` - Oman
	// - `PK` - Pakistan
	// - `PW` - Palau
	// - `PS` - Palestine, State of
	// - `PA` - Panama
	// - `PG` - Papua New Guinea
	// - `PY` - Paraguay
	// - `PE` - Peru
	// - `PH` - Philippines
	// - `PN` - Pitcairn
	// - `PL` - Poland
	// - `PT` - Portugal
	// - `PR` - Puerto Rico
	// - `QA` - Qatar
	// - `RE` - Réunion
	// - `RO` - Romania
	// - `RU` - Russia
	// - `RW` - Rwanda
	// - `BL` - Saint Barthélemy
	// - `SH` - Saint Helena, Ascension and Tristan da Cunha
	// - `KN` - Saint Kitts and Nevis
	// - `LC` - Saint Lucia
	// - `MF` - Saint Martin (French part)
	// - `PM` - Saint Pierre and Miquelon
	// - `VC` - Saint Vincent and the Grenadines
	// - `WS` - Samoa
	// - `SM` - San Marino
	// - `ST` - Sao Tome and Principe
	// - `SA` - Saudi Arabia
	// - `SN` - Senegal
	// - `RS` - Serbia
	// - `SC` - Seychelles
	// - `SL` - Sierra Leone
	// - `SG` - Singapore
	// - `SX` - Sint Maarten (Dutch part)
	// - `SK` - Slovakia
	// - `SI` - Slovenia
	// - `SB` - Solomon Islands
	// - `SO` - Somalia
	// - `ZA` - South Africa
	// - `GS` - South Georgia and the South Sandwich Islands
	// - `KR` - South Korea
	// - `SS` - South Sudan
	// - `ES` - Spain
	// - `LK` - Sri Lanka
	// - `SD` - Sudan
	// - `SR` - Suriname
	// - `SJ` - Svalbard and Jan Mayen
	// - `SE` - Sweden
	// - `CH` - Switzerland
	// - `SY` - Syria
	// - `TW` - Taiwan
	// - `TJ` - Tajikistan
	// - `TZ` - Tanzania
	// - `TH` - Thailand
	// - `TL` - Timor-Leste
	// - `TG` - Togo
	// - `TK` - Tokelau
	// - `TO` - Tonga
	// - `TT` - Trinidad and Tobago
	// - `TN` - Tunisia
	// - `TR` - Turkey
	// - `TM` - Turkmenistan
	// - `TC` - Turks and Caicos Islands
	// - `TV` - Tuvalu
	// - `UG` - Uganda
	// - `UA` - Ukraine
	// - `AE` - United Arab Emirates
	// - `GB` - United Kingdom
	// - `UM` - United States Minor Outlying Islands
	// - `US` - United States of America
	// - `UY` - Uruguay
	// - `UZ` - Uzbekistan
	// - `VU` - Vanuatu
	// - `VE` - Venezuela
	// - `VN` - Vietnam
	// - `VG` - Virgin Islands (British)
	// - `VI` - Virgin Islands (U.S.)
	// - `WF` - Wallis and Futuna
	// - `EH` - Western Sahara
	// - `YE` - Yemen
	// - `ZM` - Zambia
	// - `ZW` - Zimbabwe
	Country *LocationCountry `json:"country,omitempty"`
	// The location's type. Can be either WORK or HOME
	//
	// - `HOME` - HOME
	// - `WORK` - WORK
	LocationType *LocationLocationType `json:"location_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *Location) UnmarshalJSON(data []byte) error {
	type unmarshaler Location
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Location(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Location) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The location's country.
//
// - `AF` - Afghanistan
// - `AX` - Åland Islands
// - `AL` - Albania
// - `DZ` - Algeria
// - `AS` - American Samoa
// - `AD` - Andorra
// - `AO` - Angola
// - `AI` - Anguilla
// - `AQ` - Antarctica
// - `AG` - Antigua and Barbuda
// - `AR` - Argentina
// - `AM` - Armenia
// - `AW` - Aruba
// - `AU` - Australia
// - `AT` - Austria
// - `AZ` - Azerbaijan
// - `BS` - Bahamas
// - `BH` - Bahrain
// - `BD` - Bangladesh
// - `BB` - Barbados
// - `BY` - Belarus
// - `BE` - Belgium
// - `BZ` - Belize
// - `BJ` - Benin
// - `BM` - Bermuda
// - `BT` - Bhutan
// - `BO` - Bolivia
// - `BQ` - Bonaire, Sint Eustatius and Saba
// - `BA` - Bosnia and Herzegovina
// - `BW` - Botswana
// - `BV` - Bouvet Island
// - `BR` - Brazil
// - `IO` - British Indian Ocean Territory
// - `BN` - Brunei
// - `BG` - Bulgaria
// - `BF` - Burkina Faso
// - `BI` - Burundi
// - `CV` - Cabo Verde
// - `KH` - Cambodia
// - `CM` - Cameroon
// - `CA` - Canada
// - `KY` - Cayman Islands
// - `CF` - Central African Republic
// - `TD` - Chad
// - `CL` - Chile
// - `CN` - China
// - `CX` - Christmas Island
// - `CC` - Cocos (Keeling) Islands
// - `CO` - Colombia
// - `KM` - Comoros
// - `CG` - Congo
// - `CD` - Congo (the Democratic Republic of the)
// - `CK` - Cook Islands
// - `CR` - Costa Rica
// - `CI` - Côte d'Ivoire
// - `HR` - Croatia
// - `CU` - Cuba
// - `CW` - Curaçao
// - `CY` - Cyprus
// - `CZ` - Czechia
// - `DK` - Denmark
// - `DJ` - Djibouti
// - `DM` - Dominica
// - `DO` - Dominican Republic
// - `EC` - Ecuador
// - `EG` - Egypt
// - `SV` - El Salvador
// - `GQ` - Equatorial Guinea
// - `ER` - Eritrea
// - `EE` - Estonia
// - `SZ` - Eswatini
// - `ET` - Ethiopia
// - `FK` - Falkland Islands (Malvinas)
// - `FO` - Faroe Islands
// - `FJ` - Fiji
// - `FI` - Finland
// - `FR` - France
// - `GF` - French Guiana
// - `PF` - French Polynesia
// - `TF` - French Southern Territories
// - `GA` - Gabon
// - `GM` - Gambia
// - `GE` - Georgia
// - `DE` - Germany
// - `GH` - Ghana
// - `GI` - Gibraltar
// - `GR` - Greece
// - `GL` - Greenland
// - `GD` - Grenada
// - `GP` - Guadeloupe
// - `GU` - Guam
// - `GT` - Guatemala
// - `GG` - Guernsey
// - `GN` - Guinea
// - `GW` - Guinea-Bissau
// - `GY` - Guyana
// - `HT` - Haiti
// - `HM` - Heard Island and McDonald Islands
// - `VA` - Holy See
// - `HN` - Honduras
// - `HK` - Hong Kong
// - `HU` - Hungary
// - `IS` - Iceland
// - `IN` - India
// - `ID` - Indonesia
// - `IR` - Iran
// - `IQ` - Iraq
// - `IE` - Ireland
// - `IM` - Isle of Man
// - `IL` - Israel
// - `IT` - Italy
// - `JM` - Jamaica
// - `JP` - Japan
// - `JE` - Jersey
// - `JO` - Jordan
// - `KZ` - Kazakhstan
// - `KE` - Kenya
// - `KI` - Kiribati
// - `KW` - Kuwait
// - `KG` - Kyrgyzstan
// - `LA` - Laos
// - `LV` - Latvia
// - `LB` - Lebanon
// - `LS` - Lesotho
// - `LR` - Liberia
// - `LY` - Libya
// - `LI` - Liechtenstein
// - `LT` - Lithuania
// - `LU` - Luxembourg
// - `MO` - Macao
// - `MG` - Madagascar
// - `MW` - Malawi
// - `MY` - Malaysia
// - `MV` - Maldives
// - `ML` - Mali
// - `MT` - Malta
// - `MH` - Marshall Islands
// - `MQ` - Martinique
// - `MR` - Mauritania
// - `MU` - Mauritius
// - `YT` - Mayotte
// - `MX` - Mexico
// - `FM` - Micronesia (Federated States of)
// - `MD` - Moldova
// - `MC` - Monaco
// - `MN` - Mongolia
// - `ME` - Montenegro
// - `MS` - Montserrat
// - `MA` - Morocco
// - `MZ` - Mozambique
// - `MM` - Myanmar
// - `NA` - Namibia
// - `NR` - Nauru
// - `NP` - Nepal
// - `NL` - Netherlands
// - `NC` - New Caledonia
// - `NZ` - New Zealand
// - `NI` - Nicaragua
// - `NE` - Niger
// - `NG` - Nigeria
// - `NU` - Niue
// - `NF` - Norfolk Island
// - `KP` - North Korea
// - `MK` - North Macedonia
// - `MP` - Northern Mariana Islands
// - `NO` - Norway
// - `OM` - Oman
// - `PK` - Pakistan
// - `PW` - Palau
// - `PS` - Palestine, State of
// - `PA` - Panama
// - `PG` - Papua New Guinea
// - `PY` - Paraguay
// - `PE` - Peru
// - `PH` - Philippines
// - `PN` - Pitcairn
// - `PL` - Poland
// - `PT` - Portugal
// - `PR` - Puerto Rico
// - `QA` - Qatar
// - `RE` - Réunion
// - `RO` - Romania
// - `RU` - Russia
// - `RW` - Rwanda
// - `BL` - Saint Barthélemy
// - `SH` - Saint Helena, Ascension and Tristan da Cunha
// - `KN` - Saint Kitts and Nevis
// - `LC` - Saint Lucia
// - `MF` - Saint Martin (French part)
// - `PM` - Saint Pierre and Miquelon
// - `VC` - Saint Vincent and the Grenadines
// - `WS` - Samoa
// - `SM` - San Marino
// - `ST` - Sao Tome and Principe
// - `SA` - Saudi Arabia
// - `SN` - Senegal
// - `RS` - Serbia
// - `SC` - Seychelles
// - `SL` - Sierra Leone
// - `SG` - Singapore
// - `SX` - Sint Maarten (Dutch part)
// - `SK` - Slovakia
// - `SI` - Slovenia
// - `SB` - Solomon Islands
// - `SO` - Somalia
// - `ZA` - South Africa
// - `GS` - South Georgia and the South Sandwich Islands
// - `KR` - South Korea
// - `SS` - South Sudan
// - `ES` - Spain
// - `LK` - Sri Lanka
// - `SD` - Sudan
// - `SR` - Suriname
// - `SJ` - Svalbard and Jan Mayen
// - `SE` - Sweden
// - `CH` - Switzerland
// - `SY` - Syria
// - `TW` - Taiwan
// - `TJ` - Tajikistan
// - `TZ` - Tanzania
// - `TH` - Thailand
// - `TL` - Timor-Leste
// - `TG` - Togo
// - `TK` - Tokelau
// - `TO` - Tonga
// - `TT` - Trinidad and Tobago
// - `TN` - Tunisia
// - `TR` - Turkey
// - `TM` - Turkmenistan
// - `TC` - Turks and Caicos Islands
// - `TV` - Tuvalu
// - `UG` - Uganda
// - `UA` - Ukraine
// - `AE` - United Arab Emirates
// - `GB` - United Kingdom
// - `UM` - United States Minor Outlying Islands
// - `US` - United States of America
// - `UY` - Uruguay
// - `UZ` - Uzbekistan
// - `VU` - Vanuatu
// - `VE` - Venezuela
// - `VN` - Vietnam
// - `VG` - Virgin Islands (British)
// - `VI` - Virgin Islands (U.S.)
// - `WF` - Wallis and Futuna
// - `EH` - Western Sahara
// - `YE` - Yemen
// - `ZM` - Zambia
// - `ZW` - Zimbabwe
type LocationCountry struct {
	typeName    string
	CountryEnum CountryEnum
	String      string
}

func NewLocationCountryFromCountryEnum(value CountryEnum) *LocationCountry {
	return &LocationCountry{typeName: "countryEnum", CountryEnum: value}
}

func NewLocationCountryFromString(value string) *LocationCountry {
	return &LocationCountry{typeName: "string", String: value}
}

func (l *LocationCountry) UnmarshalJSON(data []byte) error {
	var valueCountryEnum CountryEnum
	if err := json.Unmarshal(data, &valueCountryEnum); err == nil {
		l.typeName = "countryEnum"
		l.CountryEnum = valueCountryEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LocationCountry) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "countryEnum":
		return json.Marshal(l.CountryEnum)
	case "string":
		return json.Marshal(l.String)
	}
}

type LocationCountryVisitor interface {
	VisitCountryEnum(CountryEnum) error
	VisitString(string) error
}

func (l *LocationCountry) Accept(visitor LocationCountryVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "countryEnum":
		return visitor.VisitCountryEnum(l.CountryEnum)
	case "string":
		return visitor.VisitString(l.String)
	}
}

// The location's type. Can be either WORK or HOME
//
// - `HOME` - HOME
// - `WORK` - WORK
type LocationLocationType struct {
	typeName         string
	LocationTypeEnum LocationTypeEnum
	String           string
}

func NewLocationLocationTypeFromLocationTypeEnum(value LocationTypeEnum) *LocationLocationType {
	return &LocationLocationType{typeName: "locationTypeEnum", LocationTypeEnum: value}
}

func NewLocationLocationTypeFromString(value string) *LocationLocationType {
	return &LocationLocationType{typeName: "string", String: value}
}

func (l *LocationLocationType) UnmarshalJSON(data []byte) error {
	var valueLocationTypeEnum LocationTypeEnum
	if err := json.Unmarshal(data, &valueLocationTypeEnum); err == nil {
		l.typeName = "locationTypeEnum"
		l.LocationTypeEnum = valueLocationTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LocationLocationType) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "locationTypeEnum":
		return json.Marshal(l.LocationTypeEnum)
	case "string":
		return json.Marshal(l.String)
	}
}

type LocationLocationTypeVisitor interface {
	VisitLocationTypeEnum(LocationTypeEnum) error
	VisitString(string) error
}

func (l *LocationLocationType) Accept(visitor LocationLocationTypeVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "locationTypeEnum":
		return visitor.VisitLocationTypeEnum(l.LocationTypeEnum)
	case "string":
		return visitor.VisitString(l.String)
	}
}

// - `HOME` - HOME
// - `WORK` - WORK
type LocationTypeEnum string

const (
	LocationTypeEnumHome LocationTypeEnum = "HOME"
	LocationTypeEnumWork LocationTypeEnum = "WORK"
)

func NewLocationTypeEnumFromString(s string) (LocationTypeEnum, error) {
	switch s {
	case "HOME":
		return LocationTypeEnumHome, nil
	case "WORK":
		return LocationTypeEnumWork, nil
	}
	var t LocationTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationTypeEnum) Ptr() *LocationTypeEnum {
	return &l
}

// - `SINGLE` - SINGLE
// - `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
// - `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
// - `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
// - `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
type MaritalStatusEnum string

const (
	MaritalStatusEnumSingle                                     MaritalStatusEnum = "SINGLE"
	MaritalStatusEnumMarriedFilingJointly                       MaritalStatusEnum = "MARRIED_FILING_JOINTLY"
	MaritalStatusEnumMarriedFilingSeparately                    MaritalStatusEnum = "MARRIED_FILING_SEPARATELY"
	MaritalStatusEnumHeadOfHousehold                            MaritalStatusEnum = "HEAD_OF_HOUSEHOLD"
	MaritalStatusEnumQualifyingWidowOrWidowerWithDependentChild MaritalStatusEnum = "QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD"
)

func NewMaritalStatusEnumFromString(s string) (MaritalStatusEnum, error) {
	switch s {
	case "SINGLE":
		return MaritalStatusEnumSingle, nil
	case "MARRIED_FILING_JOINTLY":
		return MaritalStatusEnumMarriedFilingJointly, nil
	case "MARRIED_FILING_SEPARATELY":
		return MaritalStatusEnumMarriedFilingSeparately, nil
	case "HEAD_OF_HOUSEHOLD":
		return MaritalStatusEnumHeadOfHousehold, nil
	case "QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD":
		return MaritalStatusEnumQualifyingWidowOrWidowerWithDependentChild, nil
	}
	var t MaritalStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MaritalStatusEnum) Ptr() *MaritalStatusEnum {
	return &m
}

type MetaResponse struct {
	RequestSchema                  map[string]interface{} `json:"request_schema,omitempty"`
	RemoteFieldClasses             map[string]interface{} `json:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus   `json:"status,omitempty"`
	HasConditionalParams           bool                   `json:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                   `json:"has_required_linked_account_params"`

	_rawJSON json.RawMessage
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetaResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// - `GET` - GET
// - `OPTIONS` - OPTIONS
// - `HEAD` - HEAD
// - `POST` - POST
// - `PUT` - PUT
// - `PATCH` - PATCH
// - `DELETE` - DELETE
type MethodEnum string

const (
	MethodEnumGet     MethodEnum = "GET"
	MethodEnumOptions MethodEnum = "OPTIONS"
	MethodEnumHead    MethodEnum = "HEAD"
	MethodEnumPost    MethodEnum = "POST"
	MethodEnumPut     MethodEnum = "PUT"
	MethodEnumPatch   MethodEnum = "PATCH"
	MethodEnumDelete  MethodEnum = "DELETE"
)

func NewMethodEnumFromString(s string) (MethodEnum, error) {
	switch s {
	case "GET":
		return MethodEnumGet, nil
	case "OPTIONS":
		return MethodEnumOptions, nil
	case "HEAD":
		return MethodEnumHead, nil
	case "POST":
		return MethodEnumPost, nil
	case "PUT":
		return MethodEnumPut, nil
	case "PATCH":
		return MethodEnumPatch, nil
	case "DELETE":
		return MethodEnumDelete, nil
	}
	var t MethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodEnum) Ptr() *MethodEnum {
	return &m
}

// # The ModelOperation Object
//
// ### Description
//
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
//
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name"`
	AvailableOperations    []string `json:"available_operations,omitempty"`
	RequiredPostParameters []string `json:"required_post_parameters,omitempty"`
	SupportedFields        []string `json:"supported_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelOperation(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelOperation) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializer struct {
	IsEnabled *bool `json:"is_enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelPermissionDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializer(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializer) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializerRequest struct {
	IsEnabled *bool `json:"is_enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializerRequest(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializerRequest) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The MultipartFormField Object
//
// ### Description
//
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
//
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name"`
	// The data for the form field.
	Data string `json:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// - `RAW` - RAW
	// - `BASE64` - BASE64
	// - `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MultipartFormFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipartFormFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipartFormFieldRequest(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipartFormFieldRequest) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	typeName     string
	EncodingEnum EncodingEnum
	String       string
}

func NewMultipartFormFieldRequestEncodingFromEncodingEnum(value EncodingEnum) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "encodingEnum", EncodingEnum: value}
}

func NewMultipartFormFieldRequestEncodingFromString(value string) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "string", String: value}
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typeName = "encodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return json.Marshal(m.EncodingEnum)
	case "string":
		return json.Marshal(m.String)
	}
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	case "string":
		return visitor.VisitString(m.String)
	}
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAccountDetailsAndActionsList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAccountDetailsAndActionsList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAccountDetailsAndActionsList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAccountDetailsAndActionsList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedAuditLogEventList struct {
	Next     *string          `json:"next,omitempty"`
	Previous *string          `json:"previous,omitempty"`
	Results  []*AuditLogEvent `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAuditLogEventList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAuditLogEventList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAuditLogEventList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAuditLogEventList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedBankInfoList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*BankInfo `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedBankInfoList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedBankInfoList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedBankInfoList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedBankInfoList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedBenefitList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Benefit `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedBenefitList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedBenefitList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedBenefitList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedBenefitList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedCompanyList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Company `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedCompanyList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedCompanyList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedCompanyList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedCompanyList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedDependentList struct {
	Next     *string      `json:"next,omitempty"`
	Previous *string      `json:"previous,omitempty"`
	Results  []*Dependent `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedDependentList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedDependentList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedDependentList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedDependentList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedEmployeeList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*Employee `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedEmployeeList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedEmployeeList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedEmployeeList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedEmployeeList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedEmployeePayrollRunList struct {
	Next     *string               `json:"next,omitempty"`
	Previous *string               `json:"previous,omitempty"`
	Results  []*EmployeePayrollRun `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedEmployeePayrollRunList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedEmployeePayrollRunList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedEmployeePayrollRunList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedEmployeePayrollRunList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedEmployerBenefitList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*EmployerBenefit `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedEmployerBenefitList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedEmployerBenefitList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedEmployerBenefitList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedEmployerBenefitList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedEmploymentList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*Employment `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedEmploymentList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedEmploymentList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedEmploymentList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedEmploymentList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedGroupList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Group `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedGroupList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedGroupList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedGroupList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedGroupList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedIssueList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedIssueList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedIssueList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedIssueList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedLocationList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*Location `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedLocationList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedLocationList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedLocationList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedLocationList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedPayGroupList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*PayGroup `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedPayGroupList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedPayGroupList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedPayGroupList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedPayGroupList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedPayrollRunList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*PayrollRun `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedPayrollRunList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedPayrollRunList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedPayrollRunList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedPayrollRunList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedSyncStatusList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*SyncStatus `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedSyncStatusList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedSyncStatusList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedSyncStatusList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedSyncStatusList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedTeamList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Team `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedTeamList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedTeamList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedTeamList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedTeamList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedTimeOffBalanceList struct {
	Next     *string           `json:"next,omitempty"`
	Previous *string           `json:"previous,omitempty"`
	Results  []*TimeOffBalance `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedTimeOffBalanceList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedTimeOffBalanceList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedTimeOffBalanceList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedTimeOffBalanceList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedTimeOffList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*TimeOff `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedTimeOffList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedTimeOffList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedTimeOffList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedTimeOffList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedTimesheetEntryList struct {
	Next     *string           `json:"next,omitempty"`
	Previous *string           `json:"previous,omitempty"`
	Results  []*TimesheetEntry `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedTimesheetEntryList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedTimesheetEntryList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedTimesheetEntryList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedTimesheetEntryList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PayCurrencyEnum string

const (
	PayCurrencyEnumXua PayCurrencyEnum = "XUA"
	PayCurrencyEnumAfn PayCurrencyEnum = "AFN"
	PayCurrencyEnumAfa PayCurrencyEnum = "AFA"
	PayCurrencyEnumAll PayCurrencyEnum = "ALL"
	PayCurrencyEnumAlk PayCurrencyEnum = "ALK"
	PayCurrencyEnumDzd PayCurrencyEnum = "DZD"
	PayCurrencyEnumAdp PayCurrencyEnum = "ADP"
	PayCurrencyEnumAoa PayCurrencyEnum = "AOA"
	PayCurrencyEnumAok PayCurrencyEnum = "AOK"
	PayCurrencyEnumAon PayCurrencyEnum = "AON"
	PayCurrencyEnumAor PayCurrencyEnum = "AOR"
	PayCurrencyEnumAra PayCurrencyEnum = "ARA"
	PayCurrencyEnumArs PayCurrencyEnum = "ARS"
	PayCurrencyEnumArm PayCurrencyEnum = "ARM"
	PayCurrencyEnumArp PayCurrencyEnum = "ARP"
	PayCurrencyEnumArl PayCurrencyEnum = "ARL"
	PayCurrencyEnumAmd PayCurrencyEnum = "AMD"
	PayCurrencyEnumAwg PayCurrencyEnum = "AWG"
	PayCurrencyEnumAud PayCurrencyEnum = "AUD"
	PayCurrencyEnumAts PayCurrencyEnum = "ATS"
	PayCurrencyEnumAzn PayCurrencyEnum = "AZN"
	PayCurrencyEnumAzm PayCurrencyEnum = "AZM"
	PayCurrencyEnumBsd PayCurrencyEnum = "BSD"
	PayCurrencyEnumBhd PayCurrencyEnum = "BHD"
	PayCurrencyEnumBdt PayCurrencyEnum = "BDT"
	PayCurrencyEnumBbd PayCurrencyEnum = "BBD"
	PayCurrencyEnumByn PayCurrencyEnum = "BYN"
	PayCurrencyEnumByb PayCurrencyEnum = "BYB"
	PayCurrencyEnumByr PayCurrencyEnum = "BYR"
	PayCurrencyEnumBef PayCurrencyEnum = "BEF"
	PayCurrencyEnumBec PayCurrencyEnum = "BEC"
	PayCurrencyEnumBel PayCurrencyEnum = "BEL"
	PayCurrencyEnumBzd PayCurrencyEnum = "BZD"
	PayCurrencyEnumBmd PayCurrencyEnum = "BMD"
	PayCurrencyEnumBtn PayCurrencyEnum = "BTN"
	PayCurrencyEnumBob PayCurrencyEnum = "BOB"
	PayCurrencyEnumBol PayCurrencyEnum = "BOL"
	PayCurrencyEnumBov PayCurrencyEnum = "BOV"
	PayCurrencyEnumBop PayCurrencyEnum = "BOP"
	PayCurrencyEnumBam PayCurrencyEnum = "BAM"
	PayCurrencyEnumBad PayCurrencyEnum = "BAD"
	PayCurrencyEnumBan PayCurrencyEnum = "BAN"
	PayCurrencyEnumBwp PayCurrencyEnum = "BWP"
	PayCurrencyEnumBrc PayCurrencyEnum = "BRC"
	PayCurrencyEnumBrz PayCurrencyEnum = "BRZ"
	PayCurrencyEnumBre PayCurrencyEnum = "BRE"
	PayCurrencyEnumBrr PayCurrencyEnum = "BRR"
	PayCurrencyEnumBrn PayCurrencyEnum = "BRN"
	PayCurrencyEnumBrb PayCurrencyEnum = "BRB"
	PayCurrencyEnumBrl PayCurrencyEnum = "BRL"
	PayCurrencyEnumGbp PayCurrencyEnum = "GBP"
	PayCurrencyEnumBnd PayCurrencyEnum = "BND"
	PayCurrencyEnumBgl PayCurrencyEnum = "BGL"
	PayCurrencyEnumBgn PayCurrencyEnum = "BGN"
	PayCurrencyEnumBgo PayCurrencyEnum = "BGO"
	PayCurrencyEnumBgm PayCurrencyEnum = "BGM"
	PayCurrencyEnumBuk PayCurrencyEnum = "BUK"
	PayCurrencyEnumBif PayCurrencyEnum = "BIF"
	PayCurrencyEnumXpf PayCurrencyEnum = "XPF"
	PayCurrencyEnumKhr PayCurrencyEnum = "KHR"
	PayCurrencyEnumCad PayCurrencyEnum = "CAD"
	PayCurrencyEnumCve PayCurrencyEnum = "CVE"
	PayCurrencyEnumKyd PayCurrencyEnum = "KYD"
	PayCurrencyEnumXaf PayCurrencyEnum = "XAF"
	PayCurrencyEnumCle PayCurrencyEnum = "CLE"
	PayCurrencyEnumClp PayCurrencyEnum = "CLP"
	PayCurrencyEnumClf PayCurrencyEnum = "CLF"
	PayCurrencyEnumCnx PayCurrencyEnum = "CNX"
	PayCurrencyEnumCny PayCurrencyEnum = "CNY"
	PayCurrencyEnumCnh PayCurrencyEnum = "CNH"
	PayCurrencyEnumCop PayCurrencyEnum = "COP"
	PayCurrencyEnumCou PayCurrencyEnum = "COU"
	PayCurrencyEnumKmf PayCurrencyEnum = "KMF"
	PayCurrencyEnumCdf PayCurrencyEnum = "CDF"
	PayCurrencyEnumCrc PayCurrencyEnum = "CRC"
	PayCurrencyEnumHrd PayCurrencyEnum = "HRD"
	PayCurrencyEnumHrk PayCurrencyEnum = "HRK"
	PayCurrencyEnumCuc PayCurrencyEnum = "CUC"
	PayCurrencyEnumCup PayCurrencyEnum = "CUP"
	PayCurrencyEnumCyp PayCurrencyEnum = "CYP"
	PayCurrencyEnumCzk PayCurrencyEnum = "CZK"
	PayCurrencyEnumCsk PayCurrencyEnum = "CSK"
	PayCurrencyEnumDkk PayCurrencyEnum = "DKK"
	PayCurrencyEnumDjf PayCurrencyEnum = "DJF"
	PayCurrencyEnumDop PayCurrencyEnum = "DOP"
	PayCurrencyEnumNlg PayCurrencyEnum = "NLG"
	PayCurrencyEnumXcd PayCurrencyEnum = "XCD"
	PayCurrencyEnumDdm PayCurrencyEnum = "DDM"
	PayCurrencyEnumEcs PayCurrencyEnum = "ECS"
	PayCurrencyEnumEcv PayCurrencyEnum = "ECV"
	PayCurrencyEnumEgp PayCurrencyEnum = "EGP"
	PayCurrencyEnumGqe PayCurrencyEnum = "GQE"
	PayCurrencyEnumErn PayCurrencyEnum = "ERN"
	PayCurrencyEnumEek PayCurrencyEnum = "EEK"
	PayCurrencyEnumEtb PayCurrencyEnum = "ETB"
	PayCurrencyEnumEur PayCurrencyEnum = "EUR"
	PayCurrencyEnumXba PayCurrencyEnum = "XBA"
	PayCurrencyEnumXeu PayCurrencyEnum = "XEU"
	PayCurrencyEnumXbb PayCurrencyEnum = "XBB"
	PayCurrencyEnumXbc PayCurrencyEnum = "XBC"
	PayCurrencyEnumXbd PayCurrencyEnum = "XBD"
	PayCurrencyEnumFkp PayCurrencyEnum = "FKP"
	PayCurrencyEnumFjd PayCurrencyEnum = "FJD"
	PayCurrencyEnumFim PayCurrencyEnum = "FIM"
	PayCurrencyEnumFrf PayCurrencyEnum = "FRF"
	PayCurrencyEnumXfo PayCurrencyEnum = "XFO"
	PayCurrencyEnumXfu PayCurrencyEnum = "XFU"
	PayCurrencyEnumGmd PayCurrencyEnum = "GMD"
	PayCurrencyEnumGek PayCurrencyEnum = "GEK"
	PayCurrencyEnumGel PayCurrencyEnum = "GEL"
	PayCurrencyEnumDem PayCurrencyEnum = "DEM"
	PayCurrencyEnumGhs PayCurrencyEnum = "GHS"
	PayCurrencyEnumGhc PayCurrencyEnum = "GHC"
	PayCurrencyEnumGip PayCurrencyEnum = "GIP"
	PayCurrencyEnumXau PayCurrencyEnum = "XAU"
	PayCurrencyEnumGrd PayCurrencyEnum = "GRD"
	PayCurrencyEnumGtq PayCurrencyEnum = "GTQ"
	PayCurrencyEnumGwp PayCurrencyEnum = "GWP"
	PayCurrencyEnumGnf PayCurrencyEnum = "GNF"
	PayCurrencyEnumGns PayCurrencyEnum = "GNS"
	PayCurrencyEnumGyd PayCurrencyEnum = "GYD"
	PayCurrencyEnumHtg PayCurrencyEnum = "HTG"
	PayCurrencyEnumHnl PayCurrencyEnum = "HNL"
	PayCurrencyEnumHkd PayCurrencyEnum = "HKD"
	PayCurrencyEnumHuf PayCurrencyEnum = "HUF"
	PayCurrencyEnumImp PayCurrencyEnum = "IMP"
	PayCurrencyEnumIsk PayCurrencyEnum = "ISK"
	PayCurrencyEnumIsj PayCurrencyEnum = "ISJ"
	PayCurrencyEnumInr PayCurrencyEnum = "INR"
	PayCurrencyEnumIdr PayCurrencyEnum = "IDR"
	PayCurrencyEnumIrr PayCurrencyEnum = "IRR"
	PayCurrencyEnumIqd PayCurrencyEnum = "IQD"
	PayCurrencyEnumIep PayCurrencyEnum = "IEP"
	PayCurrencyEnumIls PayCurrencyEnum = "ILS"
	PayCurrencyEnumIlp PayCurrencyEnum = "ILP"
	PayCurrencyEnumIlr PayCurrencyEnum = "ILR"
	PayCurrencyEnumItl PayCurrencyEnum = "ITL"
	PayCurrencyEnumJmd PayCurrencyEnum = "JMD"
	PayCurrencyEnumJpy PayCurrencyEnum = "JPY"
	PayCurrencyEnumJod PayCurrencyEnum = "JOD"
	PayCurrencyEnumKzt PayCurrencyEnum = "KZT"
	PayCurrencyEnumKes PayCurrencyEnum = "KES"
	PayCurrencyEnumKwd PayCurrencyEnum = "KWD"
	PayCurrencyEnumKgs PayCurrencyEnum = "KGS"
	PayCurrencyEnumLak PayCurrencyEnum = "LAK"
	PayCurrencyEnumLvl PayCurrencyEnum = "LVL"
	PayCurrencyEnumLvr PayCurrencyEnum = "LVR"
	PayCurrencyEnumLbp PayCurrencyEnum = "LBP"
	PayCurrencyEnumLsl PayCurrencyEnum = "LSL"
	PayCurrencyEnumLrd PayCurrencyEnum = "LRD"
	PayCurrencyEnumLyd PayCurrencyEnum = "LYD"
	PayCurrencyEnumLtl PayCurrencyEnum = "LTL"
	PayCurrencyEnumLtt PayCurrencyEnum = "LTT"
	PayCurrencyEnumLul PayCurrencyEnum = "LUL"
	PayCurrencyEnumLuc PayCurrencyEnum = "LUC"
	PayCurrencyEnumLuf PayCurrencyEnum = "LUF"
	PayCurrencyEnumMop PayCurrencyEnum = "MOP"
	PayCurrencyEnumMkd PayCurrencyEnum = "MKD"
	PayCurrencyEnumMkn PayCurrencyEnum = "MKN"
	PayCurrencyEnumMga PayCurrencyEnum = "MGA"
	PayCurrencyEnumMgf PayCurrencyEnum = "MGF"
	PayCurrencyEnumMwk PayCurrencyEnum = "MWK"
	PayCurrencyEnumMyr PayCurrencyEnum = "MYR"
	PayCurrencyEnumMvr PayCurrencyEnum = "MVR"
	PayCurrencyEnumMvp PayCurrencyEnum = "MVP"
	PayCurrencyEnumMlf PayCurrencyEnum = "MLF"
	PayCurrencyEnumMtl PayCurrencyEnum = "MTL"
	PayCurrencyEnumMtp PayCurrencyEnum = "MTP"
	PayCurrencyEnumMru PayCurrencyEnum = "MRU"
	PayCurrencyEnumMro PayCurrencyEnum = "MRO"
	PayCurrencyEnumMur PayCurrencyEnum = "MUR"
	PayCurrencyEnumMxv PayCurrencyEnum = "MXV"
	PayCurrencyEnumMxn PayCurrencyEnum = "MXN"
	PayCurrencyEnumMxp PayCurrencyEnum = "MXP"
	PayCurrencyEnumMdc PayCurrencyEnum = "MDC"
	PayCurrencyEnumMdl PayCurrencyEnum = "MDL"
	PayCurrencyEnumMcf PayCurrencyEnum = "MCF"
	PayCurrencyEnumMnt PayCurrencyEnum = "MNT"
	PayCurrencyEnumMad PayCurrencyEnum = "MAD"
	PayCurrencyEnumMaf PayCurrencyEnum = "MAF"
	PayCurrencyEnumMze PayCurrencyEnum = "MZE"
	PayCurrencyEnumMzn PayCurrencyEnum = "MZN"
	PayCurrencyEnumMzm PayCurrencyEnum = "MZM"
	PayCurrencyEnumMmk PayCurrencyEnum = "MMK"
	PayCurrencyEnumNad PayCurrencyEnum = "NAD"
	PayCurrencyEnumNpr PayCurrencyEnum = "NPR"
	PayCurrencyEnumAng PayCurrencyEnum = "ANG"
	PayCurrencyEnumTwd PayCurrencyEnum = "TWD"
	PayCurrencyEnumNzd PayCurrencyEnum = "NZD"
	PayCurrencyEnumNio PayCurrencyEnum = "NIO"
	PayCurrencyEnumNic PayCurrencyEnum = "NIC"
	PayCurrencyEnumNgn PayCurrencyEnum = "NGN"
	PayCurrencyEnumKpw PayCurrencyEnum = "KPW"
	PayCurrencyEnumNok PayCurrencyEnum = "NOK"
	PayCurrencyEnumOmr PayCurrencyEnum = "OMR"
	PayCurrencyEnumPkr PayCurrencyEnum = "PKR"
	PayCurrencyEnumXpd PayCurrencyEnum = "XPD"
	PayCurrencyEnumPab PayCurrencyEnum = "PAB"
	PayCurrencyEnumPgk PayCurrencyEnum = "PGK"
	PayCurrencyEnumPyg PayCurrencyEnum = "PYG"
	PayCurrencyEnumPei PayCurrencyEnum = "PEI"
	PayCurrencyEnumPen PayCurrencyEnum = "PEN"
	PayCurrencyEnumPes PayCurrencyEnum = "PES"
	PayCurrencyEnumPhp PayCurrencyEnum = "PHP"
	PayCurrencyEnumXpt PayCurrencyEnum = "XPT"
	PayCurrencyEnumPln PayCurrencyEnum = "PLN"
	PayCurrencyEnumPlz PayCurrencyEnum = "PLZ"
	PayCurrencyEnumPte PayCurrencyEnum = "PTE"
	PayCurrencyEnumGwe PayCurrencyEnum = "GWE"
	PayCurrencyEnumQar PayCurrencyEnum = "QAR"
	PayCurrencyEnumXre PayCurrencyEnum = "XRE"
	PayCurrencyEnumRhd PayCurrencyEnum = "RHD"
	PayCurrencyEnumRon PayCurrencyEnum = "RON"
	PayCurrencyEnumRol PayCurrencyEnum = "ROL"
	PayCurrencyEnumRub PayCurrencyEnum = "RUB"
	PayCurrencyEnumRur PayCurrencyEnum = "RUR"
	PayCurrencyEnumRwf PayCurrencyEnum = "RWF"
	PayCurrencyEnumSvc PayCurrencyEnum = "SVC"
	PayCurrencyEnumWst PayCurrencyEnum = "WST"
	PayCurrencyEnumSar PayCurrencyEnum = "SAR"
	PayCurrencyEnumRsd PayCurrencyEnum = "RSD"
	PayCurrencyEnumCsd PayCurrencyEnum = "CSD"
	PayCurrencyEnumScr PayCurrencyEnum = "SCR"
	PayCurrencyEnumSll PayCurrencyEnum = "SLL"
	PayCurrencyEnumXag PayCurrencyEnum = "XAG"
	PayCurrencyEnumSgd PayCurrencyEnum = "SGD"
	PayCurrencyEnumSkk PayCurrencyEnum = "SKK"
	PayCurrencyEnumSit PayCurrencyEnum = "SIT"
	PayCurrencyEnumSbd PayCurrencyEnum = "SBD"
	PayCurrencyEnumSos PayCurrencyEnum = "SOS"
	PayCurrencyEnumZar PayCurrencyEnum = "ZAR"
	PayCurrencyEnumZal PayCurrencyEnum = "ZAL"
	PayCurrencyEnumKrh PayCurrencyEnum = "KRH"
	PayCurrencyEnumKrw PayCurrencyEnum = "KRW"
	PayCurrencyEnumKro PayCurrencyEnum = "KRO"
	PayCurrencyEnumSsp PayCurrencyEnum = "SSP"
	PayCurrencyEnumSur PayCurrencyEnum = "SUR"
	PayCurrencyEnumEsp PayCurrencyEnum = "ESP"
	PayCurrencyEnumEsa PayCurrencyEnum = "ESA"
	PayCurrencyEnumEsb PayCurrencyEnum = "ESB"
	PayCurrencyEnumXdr PayCurrencyEnum = "XDR"
	PayCurrencyEnumLkr PayCurrencyEnum = "LKR"
	PayCurrencyEnumShp PayCurrencyEnum = "SHP"
	PayCurrencyEnumXsu PayCurrencyEnum = "XSU"
	PayCurrencyEnumSdd PayCurrencyEnum = "SDD"
	PayCurrencyEnumSdg PayCurrencyEnum = "SDG"
	PayCurrencyEnumSdp PayCurrencyEnum = "SDP"
	PayCurrencyEnumSrd PayCurrencyEnum = "SRD"
	PayCurrencyEnumSrg PayCurrencyEnum = "SRG"
	PayCurrencyEnumSzl PayCurrencyEnum = "SZL"
	PayCurrencyEnumSek PayCurrencyEnum = "SEK"
	PayCurrencyEnumChf PayCurrencyEnum = "CHF"
	PayCurrencyEnumSyp PayCurrencyEnum = "SYP"
	PayCurrencyEnumStn PayCurrencyEnum = "STN"
	PayCurrencyEnumStd PayCurrencyEnum = "STD"
	PayCurrencyEnumTvd PayCurrencyEnum = "TVD"
	PayCurrencyEnumTjr PayCurrencyEnum = "TJR"
	PayCurrencyEnumTjs PayCurrencyEnum = "TJS"
	PayCurrencyEnumTzs PayCurrencyEnum = "TZS"
	PayCurrencyEnumXts PayCurrencyEnum = "XTS"
	PayCurrencyEnumThb PayCurrencyEnum = "THB"
	PayCurrencyEnumXxx PayCurrencyEnum = "XXX"
	PayCurrencyEnumTpe PayCurrencyEnum = "TPE"
	PayCurrencyEnumTop PayCurrencyEnum = "TOP"
	PayCurrencyEnumTtd PayCurrencyEnum = "TTD"
	PayCurrencyEnumTnd PayCurrencyEnum = "TND"
	PayCurrencyEnumTry PayCurrencyEnum = "TRY"
	PayCurrencyEnumTrl PayCurrencyEnum = "TRL"
	PayCurrencyEnumTmt PayCurrencyEnum = "TMT"
	PayCurrencyEnumTmm PayCurrencyEnum = "TMM"
	PayCurrencyEnumUsd PayCurrencyEnum = "USD"
	PayCurrencyEnumUsn PayCurrencyEnum = "USN"
	PayCurrencyEnumUss PayCurrencyEnum = "USS"
	PayCurrencyEnumUgx PayCurrencyEnum = "UGX"
	PayCurrencyEnumUgs PayCurrencyEnum = "UGS"
	PayCurrencyEnumUah PayCurrencyEnum = "UAH"
	PayCurrencyEnumUak PayCurrencyEnum = "UAK"
	PayCurrencyEnumAed PayCurrencyEnum = "AED"
	PayCurrencyEnumUyw PayCurrencyEnum = "UYW"
	PayCurrencyEnumUyu PayCurrencyEnum = "UYU"
	PayCurrencyEnumUyp PayCurrencyEnum = "UYP"
	PayCurrencyEnumUyi PayCurrencyEnum = "UYI"
	PayCurrencyEnumUzs PayCurrencyEnum = "UZS"
	PayCurrencyEnumVuv PayCurrencyEnum = "VUV"
	PayCurrencyEnumVes PayCurrencyEnum = "VES"
	PayCurrencyEnumVeb PayCurrencyEnum = "VEB"
	PayCurrencyEnumVef PayCurrencyEnum = "VEF"
	PayCurrencyEnumVnd PayCurrencyEnum = "VND"
	PayCurrencyEnumVnn PayCurrencyEnum = "VNN"
	PayCurrencyEnumChe PayCurrencyEnum = "CHE"
	PayCurrencyEnumChw PayCurrencyEnum = "CHW"
	PayCurrencyEnumXof PayCurrencyEnum = "XOF"
	PayCurrencyEnumYdd PayCurrencyEnum = "YDD"
	PayCurrencyEnumYer PayCurrencyEnum = "YER"
	PayCurrencyEnumYun PayCurrencyEnum = "YUN"
	PayCurrencyEnumYud PayCurrencyEnum = "YUD"
	PayCurrencyEnumYum PayCurrencyEnum = "YUM"
	PayCurrencyEnumYur PayCurrencyEnum = "YUR"
	PayCurrencyEnumZwn PayCurrencyEnum = "ZWN"
	PayCurrencyEnumZrn PayCurrencyEnum = "ZRN"
	PayCurrencyEnumZrz PayCurrencyEnum = "ZRZ"
	PayCurrencyEnumZmw PayCurrencyEnum = "ZMW"
	PayCurrencyEnumZmk PayCurrencyEnum = "ZMK"
	PayCurrencyEnumZwd PayCurrencyEnum = "ZWD"
	PayCurrencyEnumZwr PayCurrencyEnum = "ZWR"
	PayCurrencyEnumZwl PayCurrencyEnum = "ZWL"
)

func NewPayCurrencyEnumFromString(s string) (PayCurrencyEnum, error) {
	switch s {
	case "XUA":
		return PayCurrencyEnumXua, nil
	case "AFN":
		return PayCurrencyEnumAfn, nil
	case "AFA":
		return PayCurrencyEnumAfa, nil
	case "ALL":
		return PayCurrencyEnumAll, nil
	case "ALK":
		return PayCurrencyEnumAlk, nil
	case "DZD":
		return PayCurrencyEnumDzd, nil
	case "ADP":
		return PayCurrencyEnumAdp, nil
	case "AOA":
		return PayCurrencyEnumAoa, nil
	case "AOK":
		return PayCurrencyEnumAok, nil
	case "AON":
		return PayCurrencyEnumAon, nil
	case "AOR":
		return PayCurrencyEnumAor, nil
	case "ARA":
		return PayCurrencyEnumAra, nil
	case "ARS":
		return PayCurrencyEnumArs, nil
	case "ARM":
		return PayCurrencyEnumArm, nil
	case "ARP":
		return PayCurrencyEnumArp, nil
	case "ARL":
		return PayCurrencyEnumArl, nil
	case "AMD":
		return PayCurrencyEnumAmd, nil
	case "AWG":
		return PayCurrencyEnumAwg, nil
	case "AUD":
		return PayCurrencyEnumAud, nil
	case "ATS":
		return PayCurrencyEnumAts, nil
	case "AZN":
		return PayCurrencyEnumAzn, nil
	case "AZM":
		return PayCurrencyEnumAzm, nil
	case "BSD":
		return PayCurrencyEnumBsd, nil
	case "BHD":
		return PayCurrencyEnumBhd, nil
	case "BDT":
		return PayCurrencyEnumBdt, nil
	case "BBD":
		return PayCurrencyEnumBbd, nil
	case "BYN":
		return PayCurrencyEnumByn, nil
	case "BYB":
		return PayCurrencyEnumByb, nil
	case "BYR":
		return PayCurrencyEnumByr, nil
	case "BEF":
		return PayCurrencyEnumBef, nil
	case "BEC":
		return PayCurrencyEnumBec, nil
	case "BEL":
		return PayCurrencyEnumBel, nil
	case "BZD":
		return PayCurrencyEnumBzd, nil
	case "BMD":
		return PayCurrencyEnumBmd, nil
	case "BTN":
		return PayCurrencyEnumBtn, nil
	case "BOB":
		return PayCurrencyEnumBob, nil
	case "BOL":
		return PayCurrencyEnumBol, nil
	case "BOV":
		return PayCurrencyEnumBov, nil
	case "BOP":
		return PayCurrencyEnumBop, nil
	case "BAM":
		return PayCurrencyEnumBam, nil
	case "BAD":
		return PayCurrencyEnumBad, nil
	case "BAN":
		return PayCurrencyEnumBan, nil
	case "BWP":
		return PayCurrencyEnumBwp, nil
	case "BRC":
		return PayCurrencyEnumBrc, nil
	case "BRZ":
		return PayCurrencyEnumBrz, nil
	case "BRE":
		return PayCurrencyEnumBre, nil
	case "BRR":
		return PayCurrencyEnumBrr, nil
	case "BRN":
		return PayCurrencyEnumBrn, nil
	case "BRB":
		return PayCurrencyEnumBrb, nil
	case "BRL":
		return PayCurrencyEnumBrl, nil
	case "GBP":
		return PayCurrencyEnumGbp, nil
	case "BND":
		return PayCurrencyEnumBnd, nil
	case "BGL":
		return PayCurrencyEnumBgl, nil
	case "BGN":
		return PayCurrencyEnumBgn, nil
	case "BGO":
		return PayCurrencyEnumBgo, nil
	case "BGM":
		return PayCurrencyEnumBgm, nil
	case "BUK":
		return PayCurrencyEnumBuk, nil
	case "BIF":
		return PayCurrencyEnumBif, nil
	case "XPF":
		return PayCurrencyEnumXpf, nil
	case "KHR":
		return PayCurrencyEnumKhr, nil
	case "CAD":
		return PayCurrencyEnumCad, nil
	case "CVE":
		return PayCurrencyEnumCve, nil
	case "KYD":
		return PayCurrencyEnumKyd, nil
	case "XAF":
		return PayCurrencyEnumXaf, nil
	case "CLE":
		return PayCurrencyEnumCle, nil
	case "CLP":
		return PayCurrencyEnumClp, nil
	case "CLF":
		return PayCurrencyEnumClf, nil
	case "CNX":
		return PayCurrencyEnumCnx, nil
	case "CNY":
		return PayCurrencyEnumCny, nil
	case "CNH":
		return PayCurrencyEnumCnh, nil
	case "COP":
		return PayCurrencyEnumCop, nil
	case "COU":
		return PayCurrencyEnumCou, nil
	case "KMF":
		return PayCurrencyEnumKmf, nil
	case "CDF":
		return PayCurrencyEnumCdf, nil
	case "CRC":
		return PayCurrencyEnumCrc, nil
	case "HRD":
		return PayCurrencyEnumHrd, nil
	case "HRK":
		return PayCurrencyEnumHrk, nil
	case "CUC":
		return PayCurrencyEnumCuc, nil
	case "CUP":
		return PayCurrencyEnumCup, nil
	case "CYP":
		return PayCurrencyEnumCyp, nil
	case "CZK":
		return PayCurrencyEnumCzk, nil
	case "CSK":
		return PayCurrencyEnumCsk, nil
	case "DKK":
		return PayCurrencyEnumDkk, nil
	case "DJF":
		return PayCurrencyEnumDjf, nil
	case "DOP":
		return PayCurrencyEnumDop, nil
	case "NLG":
		return PayCurrencyEnumNlg, nil
	case "XCD":
		return PayCurrencyEnumXcd, nil
	case "DDM":
		return PayCurrencyEnumDdm, nil
	case "ECS":
		return PayCurrencyEnumEcs, nil
	case "ECV":
		return PayCurrencyEnumEcv, nil
	case "EGP":
		return PayCurrencyEnumEgp, nil
	case "GQE":
		return PayCurrencyEnumGqe, nil
	case "ERN":
		return PayCurrencyEnumErn, nil
	case "EEK":
		return PayCurrencyEnumEek, nil
	case "ETB":
		return PayCurrencyEnumEtb, nil
	case "EUR":
		return PayCurrencyEnumEur, nil
	case "XBA":
		return PayCurrencyEnumXba, nil
	case "XEU":
		return PayCurrencyEnumXeu, nil
	case "XBB":
		return PayCurrencyEnumXbb, nil
	case "XBC":
		return PayCurrencyEnumXbc, nil
	case "XBD":
		return PayCurrencyEnumXbd, nil
	case "FKP":
		return PayCurrencyEnumFkp, nil
	case "FJD":
		return PayCurrencyEnumFjd, nil
	case "FIM":
		return PayCurrencyEnumFim, nil
	case "FRF":
		return PayCurrencyEnumFrf, nil
	case "XFO":
		return PayCurrencyEnumXfo, nil
	case "XFU":
		return PayCurrencyEnumXfu, nil
	case "GMD":
		return PayCurrencyEnumGmd, nil
	case "GEK":
		return PayCurrencyEnumGek, nil
	case "GEL":
		return PayCurrencyEnumGel, nil
	case "DEM":
		return PayCurrencyEnumDem, nil
	case "GHS":
		return PayCurrencyEnumGhs, nil
	case "GHC":
		return PayCurrencyEnumGhc, nil
	case "GIP":
		return PayCurrencyEnumGip, nil
	case "XAU":
		return PayCurrencyEnumXau, nil
	case "GRD":
		return PayCurrencyEnumGrd, nil
	case "GTQ":
		return PayCurrencyEnumGtq, nil
	case "GWP":
		return PayCurrencyEnumGwp, nil
	case "GNF":
		return PayCurrencyEnumGnf, nil
	case "GNS":
		return PayCurrencyEnumGns, nil
	case "GYD":
		return PayCurrencyEnumGyd, nil
	case "HTG":
		return PayCurrencyEnumHtg, nil
	case "HNL":
		return PayCurrencyEnumHnl, nil
	case "HKD":
		return PayCurrencyEnumHkd, nil
	case "HUF":
		return PayCurrencyEnumHuf, nil
	case "IMP":
		return PayCurrencyEnumImp, nil
	case "ISK":
		return PayCurrencyEnumIsk, nil
	case "ISJ":
		return PayCurrencyEnumIsj, nil
	case "INR":
		return PayCurrencyEnumInr, nil
	case "IDR":
		return PayCurrencyEnumIdr, nil
	case "IRR":
		return PayCurrencyEnumIrr, nil
	case "IQD":
		return PayCurrencyEnumIqd, nil
	case "IEP":
		return PayCurrencyEnumIep, nil
	case "ILS":
		return PayCurrencyEnumIls, nil
	case "ILP":
		return PayCurrencyEnumIlp, nil
	case "ILR":
		return PayCurrencyEnumIlr, nil
	case "ITL":
		return PayCurrencyEnumItl, nil
	case "JMD":
		return PayCurrencyEnumJmd, nil
	case "JPY":
		return PayCurrencyEnumJpy, nil
	case "JOD":
		return PayCurrencyEnumJod, nil
	case "KZT":
		return PayCurrencyEnumKzt, nil
	case "KES":
		return PayCurrencyEnumKes, nil
	case "KWD":
		return PayCurrencyEnumKwd, nil
	case "KGS":
		return PayCurrencyEnumKgs, nil
	case "LAK":
		return PayCurrencyEnumLak, nil
	case "LVL":
		return PayCurrencyEnumLvl, nil
	case "LVR":
		return PayCurrencyEnumLvr, nil
	case "LBP":
		return PayCurrencyEnumLbp, nil
	case "LSL":
		return PayCurrencyEnumLsl, nil
	case "LRD":
		return PayCurrencyEnumLrd, nil
	case "LYD":
		return PayCurrencyEnumLyd, nil
	case "LTL":
		return PayCurrencyEnumLtl, nil
	case "LTT":
		return PayCurrencyEnumLtt, nil
	case "LUL":
		return PayCurrencyEnumLul, nil
	case "LUC":
		return PayCurrencyEnumLuc, nil
	case "LUF":
		return PayCurrencyEnumLuf, nil
	case "MOP":
		return PayCurrencyEnumMop, nil
	case "MKD":
		return PayCurrencyEnumMkd, nil
	case "MKN":
		return PayCurrencyEnumMkn, nil
	case "MGA":
		return PayCurrencyEnumMga, nil
	case "MGF":
		return PayCurrencyEnumMgf, nil
	case "MWK":
		return PayCurrencyEnumMwk, nil
	case "MYR":
		return PayCurrencyEnumMyr, nil
	case "MVR":
		return PayCurrencyEnumMvr, nil
	case "MVP":
		return PayCurrencyEnumMvp, nil
	case "MLF":
		return PayCurrencyEnumMlf, nil
	case "MTL":
		return PayCurrencyEnumMtl, nil
	case "MTP":
		return PayCurrencyEnumMtp, nil
	case "MRU":
		return PayCurrencyEnumMru, nil
	case "MRO":
		return PayCurrencyEnumMro, nil
	case "MUR":
		return PayCurrencyEnumMur, nil
	case "MXV":
		return PayCurrencyEnumMxv, nil
	case "MXN":
		return PayCurrencyEnumMxn, nil
	case "MXP":
		return PayCurrencyEnumMxp, nil
	case "MDC":
		return PayCurrencyEnumMdc, nil
	case "MDL":
		return PayCurrencyEnumMdl, nil
	case "MCF":
		return PayCurrencyEnumMcf, nil
	case "MNT":
		return PayCurrencyEnumMnt, nil
	case "MAD":
		return PayCurrencyEnumMad, nil
	case "MAF":
		return PayCurrencyEnumMaf, nil
	case "MZE":
		return PayCurrencyEnumMze, nil
	case "MZN":
		return PayCurrencyEnumMzn, nil
	case "MZM":
		return PayCurrencyEnumMzm, nil
	case "MMK":
		return PayCurrencyEnumMmk, nil
	case "NAD":
		return PayCurrencyEnumNad, nil
	case "NPR":
		return PayCurrencyEnumNpr, nil
	case "ANG":
		return PayCurrencyEnumAng, nil
	case "TWD":
		return PayCurrencyEnumTwd, nil
	case "NZD":
		return PayCurrencyEnumNzd, nil
	case "NIO":
		return PayCurrencyEnumNio, nil
	case "NIC":
		return PayCurrencyEnumNic, nil
	case "NGN":
		return PayCurrencyEnumNgn, nil
	case "KPW":
		return PayCurrencyEnumKpw, nil
	case "NOK":
		return PayCurrencyEnumNok, nil
	case "OMR":
		return PayCurrencyEnumOmr, nil
	case "PKR":
		return PayCurrencyEnumPkr, nil
	case "XPD":
		return PayCurrencyEnumXpd, nil
	case "PAB":
		return PayCurrencyEnumPab, nil
	case "PGK":
		return PayCurrencyEnumPgk, nil
	case "PYG":
		return PayCurrencyEnumPyg, nil
	case "PEI":
		return PayCurrencyEnumPei, nil
	case "PEN":
		return PayCurrencyEnumPen, nil
	case "PES":
		return PayCurrencyEnumPes, nil
	case "PHP":
		return PayCurrencyEnumPhp, nil
	case "XPT":
		return PayCurrencyEnumXpt, nil
	case "PLN":
		return PayCurrencyEnumPln, nil
	case "PLZ":
		return PayCurrencyEnumPlz, nil
	case "PTE":
		return PayCurrencyEnumPte, nil
	case "GWE":
		return PayCurrencyEnumGwe, nil
	case "QAR":
		return PayCurrencyEnumQar, nil
	case "XRE":
		return PayCurrencyEnumXre, nil
	case "RHD":
		return PayCurrencyEnumRhd, nil
	case "RON":
		return PayCurrencyEnumRon, nil
	case "ROL":
		return PayCurrencyEnumRol, nil
	case "RUB":
		return PayCurrencyEnumRub, nil
	case "RUR":
		return PayCurrencyEnumRur, nil
	case "RWF":
		return PayCurrencyEnumRwf, nil
	case "SVC":
		return PayCurrencyEnumSvc, nil
	case "WST":
		return PayCurrencyEnumWst, nil
	case "SAR":
		return PayCurrencyEnumSar, nil
	case "RSD":
		return PayCurrencyEnumRsd, nil
	case "CSD":
		return PayCurrencyEnumCsd, nil
	case "SCR":
		return PayCurrencyEnumScr, nil
	case "SLL":
		return PayCurrencyEnumSll, nil
	case "XAG":
		return PayCurrencyEnumXag, nil
	case "SGD":
		return PayCurrencyEnumSgd, nil
	case "SKK":
		return PayCurrencyEnumSkk, nil
	case "SIT":
		return PayCurrencyEnumSit, nil
	case "SBD":
		return PayCurrencyEnumSbd, nil
	case "SOS":
		return PayCurrencyEnumSos, nil
	case "ZAR":
		return PayCurrencyEnumZar, nil
	case "ZAL":
		return PayCurrencyEnumZal, nil
	case "KRH":
		return PayCurrencyEnumKrh, nil
	case "KRW":
		return PayCurrencyEnumKrw, nil
	case "KRO":
		return PayCurrencyEnumKro, nil
	case "SSP":
		return PayCurrencyEnumSsp, nil
	case "SUR":
		return PayCurrencyEnumSur, nil
	case "ESP":
		return PayCurrencyEnumEsp, nil
	case "ESA":
		return PayCurrencyEnumEsa, nil
	case "ESB":
		return PayCurrencyEnumEsb, nil
	case "XDR":
		return PayCurrencyEnumXdr, nil
	case "LKR":
		return PayCurrencyEnumLkr, nil
	case "SHP":
		return PayCurrencyEnumShp, nil
	case "XSU":
		return PayCurrencyEnumXsu, nil
	case "SDD":
		return PayCurrencyEnumSdd, nil
	case "SDG":
		return PayCurrencyEnumSdg, nil
	case "SDP":
		return PayCurrencyEnumSdp, nil
	case "SRD":
		return PayCurrencyEnumSrd, nil
	case "SRG":
		return PayCurrencyEnumSrg, nil
	case "SZL":
		return PayCurrencyEnumSzl, nil
	case "SEK":
		return PayCurrencyEnumSek, nil
	case "CHF":
		return PayCurrencyEnumChf, nil
	case "SYP":
		return PayCurrencyEnumSyp, nil
	case "STN":
		return PayCurrencyEnumStn, nil
	case "STD":
		return PayCurrencyEnumStd, nil
	case "TVD":
		return PayCurrencyEnumTvd, nil
	case "TJR":
		return PayCurrencyEnumTjr, nil
	case "TJS":
		return PayCurrencyEnumTjs, nil
	case "TZS":
		return PayCurrencyEnumTzs, nil
	case "XTS":
		return PayCurrencyEnumXts, nil
	case "THB":
		return PayCurrencyEnumThb, nil
	case "XXX":
		return PayCurrencyEnumXxx, nil
	case "TPE":
		return PayCurrencyEnumTpe, nil
	case "TOP":
		return PayCurrencyEnumTop, nil
	case "TTD":
		return PayCurrencyEnumTtd, nil
	case "TND":
		return PayCurrencyEnumTnd, nil
	case "TRY":
		return PayCurrencyEnumTry, nil
	case "TRL":
		return PayCurrencyEnumTrl, nil
	case "TMT":
		return PayCurrencyEnumTmt, nil
	case "TMM":
		return PayCurrencyEnumTmm, nil
	case "USD":
		return PayCurrencyEnumUsd, nil
	case "USN":
		return PayCurrencyEnumUsn, nil
	case "USS":
		return PayCurrencyEnumUss, nil
	case "UGX":
		return PayCurrencyEnumUgx, nil
	case "UGS":
		return PayCurrencyEnumUgs, nil
	case "UAH":
		return PayCurrencyEnumUah, nil
	case "UAK":
		return PayCurrencyEnumUak, nil
	case "AED":
		return PayCurrencyEnumAed, nil
	case "UYW":
		return PayCurrencyEnumUyw, nil
	case "UYU":
		return PayCurrencyEnumUyu, nil
	case "UYP":
		return PayCurrencyEnumUyp, nil
	case "UYI":
		return PayCurrencyEnumUyi, nil
	case "UZS":
		return PayCurrencyEnumUzs, nil
	case "VUV":
		return PayCurrencyEnumVuv, nil
	case "VES":
		return PayCurrencyEnumVes, nil
	case "VEB":
		return PayCurrencyEnumVeb, nil
	case "VEF":
		return PayCurrencyEnumVef, nil
	case "VND":
		return PayCurrencyEnumVnd, nil
	case "VNN":
		return PayCurrencyEnumVnn, nil
	case "CHE":
		return PayCurrencyEnumChe, nil
	case "CHW":
		return PayCurrencyEnumChw, nil
	case "XOF":
		return PayCurrencyEnumXof, nil
	case "YDD":
		return PayCurrencyEnumYdd, nil
	case "YER":
		return PayCurrencyEnumYer, nil
	case "YUN":
		return PayCurrencyEnumYun, nil
	case "YUD":
		return PayCurrencyEnumYud, nil
	case "YUM":
		return PayCurrencyEnumYum, nil
	case "YUR":
		return PayCurrencyEnumYur, nil
	case "ZWN":
		return PayCurrencyEnumZwn, nil
	case "ZRN":
		return PayCurrencyEnumZrn, nil
	case "ZRZ":
		return PayCurrencyEnumZrz, nil
	case "ZMW":
		return PayCurrencyEnumZmw, nil
	case "ZMK":
		return PayCurrencyEnumZmk, nil
	case "ZWD":
		return PayCurrencyEnumZwd, nil
	case "ZWR":
		return PayCurrencyEnumZwr, nil
	case "ZWL":
		return PayCurrencyEnumZwl, nil
	}
	var t PayCurrencyEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayCurrencyEnum) Ptr() *PayCurrencyEnum {
	return &p
}

// - `WEEKLY` - WEEKLY
// - `BIWEEKLY` - BIWEEKLY
// - `MONTHLY` - MONTHLY
// - `QUARTERLY` - QUARTERLY
// - `SEMIANNUALLY` - SEMIANNUALLY
// - `ANNUALLY` - ANNUALLY
// - `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
// - `PRO_RATA` - PRO_RATA
// - `SEMIMONTHLY` - SEMIMONTHLY
type PayFrequencyEnum string

const (
	PayFrequencyEnumWeekly          PayFrequencyEnum = "WEEKLY"
	PayFrequencyEnumBiweekly        PayFrequencyEnum = "BIWEEKLY"
	PayFrequencyEnumMonthly         PayFrequencyEnum = "MONTHLY"
	PayFrequencyEnumQuarterly       PayFrequencyEnum = "QUARTERLY"
	PayFrequencyEnumSemiannually    PayFrequencyEnum = "SEMIANNUALLY"
	PayFrequencyEnumAnnually        PayFrequencyEnum = "ANNUALLY"
	PayFrequencyEnumThirteenMonthly PayFrequencyEnum = "THIRTEEN-MONTHLY"
	PayFrequencyEnumProRata         PayFrequencyEnum = "PRO_RATA"
	PayFrequencyEnumSemimonthly     PayFrequencyEnum = "SEMIMONTHLY"
)

func NewPayFrequencyEnumFromString(s string) (PayFrequencyEnum, error) {
	switch s {
	case "WEEKLY":
		return PayFrequencyEnumWeekly, nil
	case "BIWEEKLY":
		return PayFrequencyEnumBiweekly, nil
	case "MONTHLY":
		return PayFrequencyEnumMonthly, nil
	case "QUARTERLY":
		return PayFrequencyEnumQuarterly, nil
	case "SEMIANNUALLY":
		return PayFrequencyEnumSemiannually, nil
	case "ANNUALLY":
		return PayFrequencyEnumAnnually, nil
	case "THIRTEEN-MONTHLY":
		return PayFrequencyEnumThirteenMonthly, nil
	case "PRO_RATA":
		return PayFrequencyEnumProRata, nil
	case "SEMIMONTHLY":
		return PayFrequencyEnumSemimonthly, nil
	}
	var t PayFrequencyEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayFrequencyEnum) Ptr() *PayFrequencyEnum {
	return &p
}

// # The PayGroup Object
//
// ### Description
//
// The `PayGroup` object is used to represent a subset of employees that are put together for payroll processing purposes.
//
// ### Usage Example
//
// Fetch from the `LIST PayGroup` endpoint and filter by `ID` to show all pay group information.
type PayGroup struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The pay group name.
	PayGroupName *string `json:"pay_group_name,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PayGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler PayGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayGroup(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayGroup) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// - `HOUR` - HOUR
// - `DAY` - DAY
// - `WEEK` - WEEK
// - `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
// - `SEMIMONTHLY` - SEMIMONTHLY
// - `MONTH` - MONTH
// - `QUARTER` - QUARTER
// - `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
// - `YEAR` - YEAR
type PayPeriodEnum string

const (
	PayPeriodEnumHour           PayPeriodEnum = "HOUR"
	PayPeriodEnumDay            PayPeriodEnum = "DAY"
	PayPeriodEnumWeek           PayPeriodEnum = "WEEK"
	PayPeriodEnumEveryTwoWeeks  PayPeriodEnum = "EVERY_TWO_WEEKS"
	PayPeriodEnumSemimonthly    PayPeriodEnum = "SEMIMONTHLY"
	PayPeriodEnumMonth          PayPeriodEnum = "MONTH"
	PayPeriodEnumQuarter        PayPeriodEnum = "QUARTER"
	PayPeriodEnumEverySixMonths PayPeriodEnum = "EVERY_SIX_MONTHS"
	PayPeriodEnumYear           PayPeriodEnum = "YEAR"
)

func NewPayPeriodEnumFromString(s string) (PayPeriodEnum, error) {
	switch s {
	case "HOUR":
		return PayPeriodEnumHour, nil
	case "DAY":
		return PayPeriodEnumDay, nil
	case "WEEK":
		return PayPeriodEnumWeek, nil
	case "EVERY_TWO_WEEKS":
		return PayPeriodEnumEveryTwoWeeks, nil
	case "SEMIMONTHLY":
		return PayPeriodEnumSemimonthly, nil
	case "MONTH":
		return PayPeriodEnumMonth, nil
	case "QUARTER":
		return PayPeriodEnumQuarter, nil
	case "EVERY_SIX_MONTHS":
		return PayPeriodEnumEverySixMonths, nil
	case "YEAR":
		return PayPeriodEnumYear, nil
	}
	var t PayPeriodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayPeriodEnum) Ptr() *PayPeriodEnum {
	return &p
}

// # The PayrollRun Object
//
// ### Description
//
// The `PayrollRun` object is used to represent a group of pay statements for a specific pay schedule.
//
// ### Usage Example
//
// Fetch from the `LIST PayrollRuns` endpoint and filter by `ID` to show all payroll runs.
type PayrollRun struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The state of the payroll run
	//
	// - `PAID` - PAID
	// - `DRAFT` - DRAFT
	// - `APPROVED` - APPROVED
	// - `FAILED` - FAILED
	// - `CLOSED` - CLOSED
	RunState *PayrollRunRunState `json:"run_state,omitempty"`
	// The type of the payroll run
	//
	// - `REGULAR` - REGULAR
	// - `OFF_CYCLE` - OFF_CYCLE
	// - `CORRECTION` - CORRECTION
	// - `TERMINATION` - TERMINATION
	// - `SIGN_ON_BONUS` - SIGN_ON_BONUS
	RunType *PayrollRunRunType `json:"run_type,omitempty"`
	// The day and time the payroll run started.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The day and time the payroll run ended.
	EndDate *time.Time `json:"end_date,omitempty"`
	// The day and time the payroll run was checked.
	CheckDate *time.Time `json:"check_date,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PayrollRun) UnmarshalJSON(data []byte) error {
	type unmarshaler PayrollRun
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayrollRun(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayrollRun) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The state of the payroll run
//
// - `PAID` - PAID
// - `DRAFT` - DRAFT
// - `APPROVED` - APPROVED
// - `FAILED` - FAILED
// - `CLOSED` - CLOSED
type PayrollRunRunState struct {
	typeName     string
	RunStateEnum RunStateEnum
	String       string
}

func NewPayrollRunRunStateFromRunStateEnum(value RunStateEnum) *PayrollRunRunState {
	return &PayrollRunRunState{typeName: "runStateEnum", RunStateEnum: value}
}

func NewPayrollRunRunStateFromString(value string) *PayrollRunRunState {
	return &PayrollRunRunState{typeName: "string", String: value}
}

func (p *PayrollRunRunState) UnmarshalJSON(data []byte) error {
	var valueRunStateEnum RunStateEnum
	if err := json.Unmarshal(data, &valueRunStateEnum); err == nil {
		p.typeName = "runStateEnum"
		p.RunStateEnum = valueRunStateEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PayrollRunRunState) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "runStateEnum":
		return json.Marshal(p.RunStateEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PayrollRunRunStateVisitor interface {
	VisitRunStateEnum(RunStateEnum) error
	VisitString(string) error
}

func (p *PayrollRunRunState) Accept(visitor PayrollRunRunStateVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "runStateEnum":
		return visitor.VisitRunStateEnum(p.RunStateEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// The type of the payroll run
//
// - `REGULAR` - REGULAR
// - `OFF_CYCLE` - OFF_CYCLE
// - `CORRECTION` - CORRECTION
// - `TERMINATION` - TERMINATION
// - `SIGN_ON_BONUS` - SIGN_ON_BONUS
type PayrollRunRunType struct {
	typeName    string
	RunTypeEnum RunTypeEnum
	String      string
}

func NewPayrollRunRunTypeFromRunTypeEnum(value RunTypeEnum) *PayrollRunRunType {
	return &PayrollRunRunType{typeName: "runTypeEnum", RunTypeEnum: value}
}

func NewPayrollRunRunTypeFromString(value string) *PayrollRunRunType {
	return &PayrollRunRunType{typeName: "string", String: value}
}

func (p *PayrollRunRunType) UnmarshalJSON(data []byte) error {
	var valueRunTypeEnum RunTypeEnum
	if err := json.Unmarshal(data, &valueRunTypeEnum); err == nil {
		p.typeName = "runTypeEnum"
		p.RunTypeEnum = valueRunTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PayrollRunRunType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "runTypeEnum":
		return json.Marshal(p.RunTypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PayrollRunRunTypeVisitor interface {
	VisitRunTypeEnum(RunTypeEnum) error
	VisitString(string) error
}

func (p *PayrollRunRunType) Accept(visitor PayrollRunRunTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "runTypeEnum":
		return visitor.VisitRunTypeEnum(p.RunTypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type PolicyTypeEnum string

const (
	PolicyTypeEnumVacation    PolicyTypeEnum = "VACATION"
	PolicyTypeEnumSick        PolicyTypeEnum = "SICK"
	PolicyTypeEnumPersonal    PolicyTypeEnum = "PERSONAL"
	PolicyTypeEnumJuryDuty    PolicyTypeEnum = "JURY_DUTY"
	PolicyTypeEnumVolunteer   PolicyTypeEnum = "VOLUNTEER"
	PolicyTypeEnumBereavement PolicyTypeEnum = "BEREAVEMENT"
)

func NewPolicyTypeEnumFromString(s string) (PolicyTypeEnum, error) {
	switch s {
	case "VACATION":
		return PolicyTypeEnumVacation, nil
	case "SICK":
		return PolicyTypeEnumSick, nil
	case "PERSONAL":
		return PolicyTypeEnumPersonal, nil
	case "JURY_DUTY":
		return PolicyTypeEnumJuryDuty, nil
	case "VOLUNTEER":
		return PolicyTypeEnumVolunteer, nil
	case "BEREAVEMENT":
		return PolicyTypeEnumBereavement, nil
	}
	var t PolicyTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PolicyTypeEnum) Ptr() *PolicyTypeEnum {
	return &p
}

// - `GENERAL_CUSTOMER_REQUEST` - GENERAL_CUSTOMER_REQUEST
// - `GDPR` - GDPR
// - `OTHER` - OTHER
type ReasonEnum string

const (
	ReasonEnumGeneralCustomerRequest ReasonEnum = "GENERAL_CUSTOMER_REQUEST"
	ReasonEnumGdpr                   ReasonEnum = "GDPR"
	ReasonEnumOther                  ReasonEnum = "OTHER"
)

func NewReasonEnumFromString(s string) (ReasonEnum, error) {
	switch s {
	case "GENERAL_CUSTOMER_REQUEST":
		return ReasonEnumGeneralCustomerRequest, nil
	case "GDPR":
		return ReasonEnumGdpr, nil
	case "OTHER":
		return ReasonEnumOther, nil
	}
	var t ReasonEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReasonEnum) Ptr() *ReasonEnum {
	return &r
}

// - `CHILD` - CHILD
// - `SPOUSE` - SPOUSE
// - `DOMESTIC_PARTNER` - DOMESTIC_PARTNER
type RelationshipEnum string

const (
	RelationshipEnumChild           RelationshipEnum = "CHILD"
	RelationshipEnumSpouse          RelationshipEnum = "SPOUSE"
	RelationshipEnumDomesticPartner RelationshipEnum = "DOMESTIC_PARTNER"
)

func NewRelationshipEnumFromString(s string) (RelationshipEnum, error) {
	switch s {
	case "CHILD":
		return RelationshipEnumChild, nil
	case "SPOUSE":
		return RelationshipEnumSpouse, nil
	case "DOMESTIC_PARTNER":
		return RelationshipEnumDomesticPartner, nil
	}
	var t RelationshipEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RelationshipEnum) Ptr() *RelationshipEnum {
	return &r
}

// # The RemoteData Object
//
// ### Description
//
// The `RemoteData` object is used to represent the full data pulled from the third-party API for an object.
//
// ### Usage Example
//
// TODO
type RemoteData struct {
	// The third-party API path that is being called.
	Path string      `json:"path"`
	Data interface{} `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteData) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteData(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteEndpointInfo struct {
	Method             string        `json:"method"`
	UrlPath            string        `json:"url_path"`
	FieldTraversalPath []interface{} `json:"field_traversal_path,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteEndpointInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteEndpointInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteEndpointInfo(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteEndpointInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldApi struct {
	Schema             map[string]interface{}  `json:"schema,omitempty"`
	RemoteKeyName      string                  `json:"remote_key_name"`
	RemoteEndpointInfo *RemoteEndpointInfo     `json:"remote_endpoint_info,omitempty"`
	ExampleValues      []interface{}           `json:"example_values,omitempty"`
	AdvancedMetadata   *AdvancedMetadata       `json:"advanced_metadata,omitempty"`
	Coverage           *RemoteFieldApiCoverage `json:"coverage,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteFieldApi) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldApi(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldApi) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldApiCoverage struct {
	typeName string
	Integer  int
	Double   float64
}

func NewRemoteFieldApiCoverageFromInteger(value int) *RemoteFieldApiCoverage {
	return &RemoteFieldApiCoverage{typeName: "integer", Integer: value}
}

func NewRemoteFieldApiCoverageFromDouble(value float64) *RemoteFieldApiCoverage {
	return &RemoteFieldApiCoverage{typeName: "double", Double: value}
}

func (r *RemoteFieldApiCoverage) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		r.typeName = "double"
		r.Double = valueDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldApiCoverage) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "double":
		return json.Marshal(r.Double)
	}
}

type RemoteFieldApiCoverageVisitor interface {
	VisitInteger(int) error
	VisitDouble(float64) error
}

func (r *RemoteFieldApiCoverage) Accept(visitor RemoteFieldApiCoverageVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "double":
		return visitor.VisitDouble(r.Double)
	}
}

type RemoteFieldApiResponse struct {
	Benefit            []*RemoteFieldApi `json:"Benefit,omitempty"`
	EmployerBenefit    []*RemoteFieldApi `json:"EmployerBenefit,omitempty"`
	Company            []*RemoteFieldApi `json:"Company,omitempty"`
	EmployeePayrollRun []*RemoteFieldApi `json:"EmployeePayrollRun,omitempty"`
	Employee           []*RemoteFieldApi `json:"Employee,omitempty"`
	Employment         []*RemoteFieldApi `json:"Employment,omitempty"`
	Location           []*RemoteFieldApi `json:"Location,omitempty"`
	PayrollRun         []*RemoteFieldApi `json:"PayrollRun,omitempty"`
	Team               []*RemoteFieldApi `json:"Team,omitempty"`
	TimeOff            []*RemoteFieldApi `json:"TimeOff,omitempty"`
	TimeOffBalance     []*RemoteFieldApi `json:"TimeOffBalance,omitempty"`
	BankInfo           []*RemoteFieldApi `json:"BankInfo,omitempty"`
	PayGroup           []*RemoteFieldApi `json:"PayGroup,omitempty"`
	Group              []*RemoteFieldApi `json:"Group,omitempty"`
	Dependent          []*RemoteFieldApi `json:"Dependent,omitempty"`
	TimesheetEntry     []*RemoteFieldApi `json:"TimesheetEntry,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteFieldApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldApiResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldApiResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteKey Object
//
// ### Description
//
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
//
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name"`
	Key  string `json:"key"`

	_rawJSON json.RawMessage
}

func (r *RemoteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteKey(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteKey) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteResponse Object
//
// ### Description
//
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
//
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                      `json:"method"`
	Path            string                      `json:"path"`
	Status          int                         `json:"status"`
	Response        interface{}                 `json:"response,omitempty"`
	ResponseHeaders map[string]interface{}      `json:"response_headers,omitempty"`
	ResponseType    *RemoteResponseResponseType `json:"response_type,omitempty"`
	Headers         map[string]interface{}      `json:"headers,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteResponseResponseType struct {
	typeName         string
	ResponseTypeEnum ResponseTypeEnum
	String           string
}

func NewRemoteResponseResponseTypeFromResponseTypeEnum(value ResponseTypeEnum) *RemoteResponseResponseType {
	return &RemoteResponseResponseType{typeName: "responseTypeEnum", ResponseTypeEnum: value}
}

func NewRemoteResponseResponseTypeFromString(value string) *RemoteResponseResponseType {
	return &RemoteResponseResponseType{typeName: "string", String: value}
}

func (r *RemoteResponseResponseType) UnmarshalJSON(data []byte) error {
	var valueResponseTypeEnum ResponseTypeEnum
	if err := json.Unmarshal(data, &valueResponseTypeEnum); err == nil {
		r.typeName = "responseTypeEnum"
		r.ResponseTypeEnum = valueResponseTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteResponseResponseType) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "responseTypeEnum":
		return json.Marshal(r.ResponseTypeEnum)
	case "string":
		return json.Marshal(r.String)
	}
}

type RemoteResponseResponseTypeVisitor interface {
	VisitResponseTypeEnum(ResponseTypeEnum) error
	VisitString(string) error
}

func (r *RemoteResponseResponseType) Accept(visitor RemoteResponseResponseTypeVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "responseTypeEnum":
		return visitor.VisitResponseTypeEnum(r.ResponseTypeEnum)
	case "string":
		return visitor.VisitString(r.String)
	}
}

// - `JSON` - JSON
// - `XML` - XML
// - `MULTIPART` - MULTIPART
type RequestFormatEnum string

const (
	RequestFormatEnumJson      RequestFormatEnum = "JSON"
	RequestFormatEnumXml       RequestFormatEnum = "XML"
	RequestFormatEnumMultipart RequestFormatEnum = "MULTIPART"
)

func NewRequestFormatEnumFromString(s string) (RequestFormatEnum, error) {
	switch s {
	case "JSON":
		return RequestFormatEnumJson, nil
	case "XML":
		return RequestFormatEnumXml, nil
	case "MULTIPART":
		return RequestFormatEnumMultipart, nil
	}
	var t RequestFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestFormatEnum) Ptr() *RequestFormatEnum {
	return &r
}

// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type RequestTypeEnum string

const (
	RequestTypeEnumVacation    RequestTypeEnum = "VACATION"
	RequestTypeEnumSick        RequestTypeEnum = "SICK"
	RequestTypeEnumPersonal    RequestTypeEnum = "PERSONAL"
	RequestTypeEnumJuryDuty    RequestTypeEnum = "JURY_DUTY"
	RequestTypeEnumVolunteer   RequestTypeEnum = "VOLUNTEER"
	RequestTypeEnumBereavement RequestTypeEnum = "BEREAVEMENT"
)

func NewRequestTypeEnumFromString(s string) (RequestTypeEnum, error) {
	switch s {
	case "VACATION":
		return RequestTypeEnumVacation, nil
	case "SICK":
		return RequestTypeEnumSick, nil
	case "PERSONAL":
		return RequestTypeEnumPersonal, nil
	case "JURY_DUTY":
		return RequestTypeEnumJuryDuty, nil
	case "VOLUNTEER":
		return RequestTypeEnumVolunteer, nil
	case "BEREAVEMENT":
		return RequestTypeEnumBereavement, nil
	}
	var t RequestTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestTypeEnum) Ptr() *RequestTypeEnum {
	return &r
}

// - `JSON` - JSON
// - `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum string

const (
	ResponseTypeEnumJson       ResponseTypeEnum = "JSON"
	ResponseTypeEnumBase64Gzip ResponseTypeEnum = "BASE64_GZIP"
)

func NewResponseTypeEnumFromString(s string) (ResponseTypeEnum, error) {
	switch s {
	case "JSON":
		return ResponseTypeEnumJson, nil
	case "BASE64_GZIP":
		return ResponseTypeEnumBase64Gzip, nil
	}
	var t ResponseTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTypeEnum) Ptr() *ResponseTypeEnum {
	return &r
}

// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type RoleEnum string

const (
	RoleEnumAdmin     RoleEnum = "ADMIN"
	RoleEnumDeveloper RoleEnum = "DEVELOPER"
	RoleEnumMember    RoleEnum = "MEMBER"
	RoleEnumApi       RoleEnum = "API"
	RoleEnumSystem    RoleEnum = "SYSTEM"
	RoleEnumMergeTeam RoleEnum = "MERGE_TEAM"
)

func NewRoleEnumFromString(s string) (RoleEnum, error) {
	switch s {
	case "ADMIN":
		return RoleEnumAdmin, nil
	case "DEVELOPER":
		return RoleEnumDeveloper, nil
	case "MEMBER":
		return RoleEnumMember, nil
	case "API":
		return RoleEnumApi, nil
	case "SYSTEM":
		return RoleEnumSystem, nil
	case "MERGE_TEAM":
		return RoleEnumMergeTeam, nil
	}
	var t RoleEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoleEnum) Ptr() *RoleEnum {
	return &r
}

// - `PAID` - PAID
// - `DRAFT` - DRAFT
// - `APPROVED` - APPROVED
// - `FAILED` - FAILED
// - `CLOSED` - CLOSED
type RunStateEnum string

const (
	RunStateEnumPaid     RunStateEnum = "PAID"
	RunStateEnumDraft    RunStateEnum = "DRAFT"
	RunStateEnumApproved RunStateEnum = "APPROVED"
	RunStateEnumFailed   RunStateEnum = "FAILED"
	RunStateEnumClosed   RunStateEnum = "CLOSED"
)

func NewRunStateEnumFromString(s string) (RunStateEnum, error) {
	switch s {
	case "PAID":
		return RunStateEnumPaid, nil
	case "DRAFT":
		return RunStateEnumDraft, nil
	case "APPROVED":
		return RunStateEnumApproved, nil
	case "FAILED":
		return RunStateEnumFailed, nil
	case "CLOSED":
		return RunStateEnumClosed, nil
	}
	var t RunStateEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RunStateEnum) Ptr() *RunStateEnum {
	return &r
}

// - `REGULAR` - REGULAR
// - `OFF_CYCLE` - OFF_CYCLE
// - `CORRECTION` - CORRECTION
// - `TERMINATION` - TERMINATION
// - `SIGN_ON_BONUS` - SIGN_ON_BONUS
type RunTypeEnum string

const (
	RunTypeEnumRegular     RunTypeEnum = "REGULAR"
	RunTypeEnumOffCycle    RunTypeEnum = "OFF_CYCLE"
	RunTypeEnumCorrection  RunTypeEnum = "CORRECTION"
	RunTypeEnumTermination RunTypeEnum = "TERMINATION"
	RunTypeEnumSignOnBonus RunTypeEnum = "SIGN_ON_BONUS"
)

func NewRunTypeEnumFromString(s string) (RunTypeEnum, error) {
	switch s {
	case "REGULAR":
		return RunTypeEnumRegular, nil
	case "OFF_CYCLE":
		return RunTypeEnumOffCycle, nil
	case "CORRECTION":
		return RunTypeEnumCorrection, nil
	case "TERMINATION":
		return RunTypeEnumTermination, nil
	case "SIGN_ON_BONUS":
		return RunTypeEnumSignOnBonus, nil
	}
	var t RunTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RunTypeEnum) Ptr() *RunTypeEnum {
	return &r
}

// - `IN_NEXT_SYNC` - IN_NEXT_SYNC
// - `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum string

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = "IN_NEXT_SYNC"
	SelectiveSyncConfigurationsUsageEnumInLastSync SelectiveSyncConfigurationsUsageEnum = "IN_LAST_SYNC"
)

func NewSelectiveSyncConfigurationsUsageEnumFromString(s string) (SelectiveSyncConfigurationsUsageEnum, error) {
	switch s {
	case "IN_NEXT_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInNextSync, nil
	case "IN_LAST_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInLastSync, nil
	}
	var t SelectiveSyncConfigurationsUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SelectiveSyncConfigurationsUsageEnum) Ptr() *SelectiveSyncConfigurationsUsageEnum {
	return &s
}

// # The SyncStatus Object
//
// ### Description
//
// # The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
//
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name"`
	ModelId                          string                                `json:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty"`
	Status                           SyncStatusStatusEnum                  `json:"status,omitempty"`
	IsInitialSync                    bool                                  `json:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SyncStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncStatus(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatus) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// - `SYNCING` - SYNCING
// - `DONE` - DONE
// - `FAILED` - FAILED
// - `DISABLED` - DISABLED
// - `PAUSED` - PAUSED
// - `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type SyncStatusStatusEnum string

const (
	SyncStatusStatusEnumSyncing         SyncStatusStatusEnum = "SYNCING"
	SyncStatusStatusEnumDone            SyncStatusStatusEnum = "DONE"
	SyncStatusStatusEnumFailed          SyncStatusStatusEnum = "FAILED"
	SyncStatusStatusEnumDisabled        SyncStatusStatusEnum = "DISABLED"
	SyncStatusStatusEnumPaused          SyncStatusStatusEnum = "PAUSED"
	SyncStatusStatusEnumPartiallySynced SyncStatusStatusEnum = "PARTIALLY_SYNCED"
)

func NewSyncStatusStatusEnumFromString(s string) (SyncStatusStatusEnum, error) {
	switch s {
	case "SYNCING":
		return SyncStatusStatusEnumSyncing, nil
	case "DONE":
		return SyncStatusStatusEnumDone, nil
	case "FAILED":
		return SyncStatusStatusEnumFailed, nil
	case "DISABLED":
		return SyncStatusStatusEnumDisabled, nil
	case "PAUSED":
		return SyncStatusStatusEnumPaused, nil
	case "PARTIALLY_SYNCED":
		return SyncStatusStatusEnumPartiallySynced, nil
	}
	var t SyncStatusStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SyncStatusStatusEnum) Ptr() *SyncStatusStatusEnum {
	return &s
}

// # The Tax Object
//
// ### Description
//
// The `Tax` object is used to represent an array of the tax deductions for a given employee's payroll run.
//
// ### Usage Example
//
// Fetch from the `LIST Taxes` endpoint and filter by `ID` to show all taxes.
type Tax struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt         *time.Time `json:"modified_at,omitempty"`
	EmployeePayrollRun *string    `json:"employee_payroll_run,omitempty"`
	// The tax's name.
	Name *string `json:"name,omitempty"`
	// The tax amount.
	Amount *float64 `json:"amount,omitempty"`
	// Whether or not the employer is responsible for paying the tax.
	EmployerTax *bool `json:"employer_tax,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Tax) UnmarshalJSON(data []byte) error {
	type unmarshaler Tax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tax(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tax) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// # The Team Object
//
// ### Description
//
// The `Team` object is used to represent a subdivision of the company, usually a department. Each employee will be grouped into one specific Team.
//
// ### Usage Example
//
// If you're building a way to filter by `Team`, you'd hit the `GET Teams` endpoint to fetch the `Teams`, and then use the `ID` of the team your user selects to filter the `GET Employees` endpoint.
type Team struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The team's name.
	Name *string `json:"name,omitempty"`
	// The team's parent team.
	ParentTeam *TeamParentTeam `json:"parent_team,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Team) UnmarshalJSON(data []byte) error {
	type unmarshaler Team
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Team(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Team) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The team's parent team.
type TeamParentTeam struct {
	typeName string
	String   string
	Team     *Team
}

func NewTeamParentTeamFromString(value string) *TeamParentTeam {
	return &TeamParentTeam{typeName: "string", String: value}
}

func NewTeamParentTeamFromTeam(value *Team) *TeamParentTeam {
	return &TeamParentTeam{typeName: "team", Team: value}
}

func (t *TeamParentTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		t.typeName = "team"
		t.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TeamParentTeam) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "team":
		return json.Marshal(t.Team)
	}
}

type TeamParentTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (t *TeamParentTeam) Accept(visitor TeamParentTeamVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "team":
		return visitor.VisitTeam(t.Team)
	}
}

// # The TimeOff Object
//
// ### Description
//
// The `TimeOff` object is used to represent all employees' Time Off entries.
//
// ### Usage Example
//
// Fetch from the `LIST TimeOffs` endpoint and filter by `ID` to show all time off requests.
type TimeOff struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee requesting time off.
	Employee *TimeOffEmployee `json:"employee,omitempty"`
	// The Merge ID of the employee with the ability to approve the time off request.
	Approver *TimeOffApprover `json:"approver,omitempty"`
	// The status of this time off request.
	//
	// - `REQUESTED` - REQUESTED
	// - `APPROVED` - APPROVED
	// - `DECLINED` - DECLINED
	// - `CANCELLED` - CANCELLED
	// - `DELETED` - DELETED
	Status *TimeOffStatus `json:"status,omitempty"`
	// The employee note for this time off request.
	EmployeeNote *string `json:"employee_note,omitempty"`
	// The measurement that the third-party integration uses to count time requested.
	//
	// - `HOURS` - HOURS
	// - `DAYS` - DAYS
	Units *TimeOffUnits `json:"units,omitempty"`
	// The time off quantity measured by the prescribed “units”.
	Amount *float64 `json:"amount,omitempty"`
	// The type of time off request.
	//
	// - `VACATION` - VACATION
	// - `SICK` - SICK
	// - `PERSONAL` - PERSONAL
	// - `JURY_DUTY` - JURY_DUTY
	// - `VOLUNTEER` - VOLUNTEER
	// - `BEREAVEMENT` - BEREAVEMENT
	RequestType *TimeOffRequestType `json:"request_type,omitempty"`
	// The day and time of the start of the time requested off.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The day and time of the end of the time requested off.
	EndTime *time.Time `json:"end_time,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TimeOff) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeOff
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeOff(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeOff) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The Merge ID of the employee with the ability to approve the time off request.
type TimeOffApprover struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffApproverFromString(value string) *TimeOffApprover {
	return &TimeOffApprover{typeName: "string", String: value}
}

func NewTimeOffApproverFromEmployee(value *Employee) *TimeOffApprover {
	return &TimeOffApprover{typeName: "employee", Employee: value}
}

func (t *TimeOffApprover) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffApprover) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffApproverVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffApprover) Accept(visitor TimeOffApproverVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// # The TimeOffBalance Object
//
// ### Description
//
// The `TimeOffBalance` object is used to represent current balances for an employee's Time Off plan.
//
// ### Usage Example
//
// Fetch from the `LIST TimeOffBalances` endpoint and filter by `ID` to show all time off balances.
type TimeOffBalance struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee the balance belongs to.
	Employee *TimeOffBalanceEmployee `json:"employee,omitempty"`
	// The current remaining PTO balance, measured in hours. For integrations that return this value in days, Merge multiplies by 8 to calculate hours.
	Balance *float64 `json:"balance,omitempty"`
	// The amount of PTO used in terms of hours. For integrations that return this value in days, Merge multiplies by 8 to calculate hours.
	Used *float64 `json:"used,omitempty"`
	// The policy type of this time off balance.
	//
	// - `VACATION` - VACATION
	// - `SICK` - SICK
	// - `PERSONAL` - PERSONAL
	// - `JURY_DUTY` - JURY_DUTY
	// - `VOLUNTEER` - VOLUNTEER
	// - `BEREAVEMENT` - BEREAVEMENT
	PolicyType *TimeOffBalancePolicyType `json:"policy_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TimeOffBalance) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeOffBalance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeOffBalance(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeOffBalance) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The employee the balance belongs to.
type TimeOffBalanceEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffBalanceEmployeeFromString(value string) *TimeOffBalanceEmployee {
	return &TimeOffBalanceEmployee{typeName: "string", String: value}
}

func NewTimeOffBalanceEmployeeFromEmployee(value *Employee) *TimeOffBalanceEmployee {
	return &TimeOffBalanceEmployee{typeName: "employee", Employee: value}
}

func (t *TimeOffBalanceEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffBalanceEmployee) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffBalanceEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffBalanceEmployee) Accept(visitor TimeOffBalanceEmployeeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// The policy type of this time off balance.
//
// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type TimeOffBalancePolicyType struct {
	typeName       string
	PolicyTypeEnum PolicyTypeEnum
	String         string
}

func NewTimeOffBalancePolicyTypeFromPolicyTypeEnum(value PolicyTypeEnum) *TimeOffBalancePolicyType {
	return &TimeOffBalancePolicyType{typeName: "policyTypeEnum", PolicyTypeEnum: value}
}

func NewTimeOffBalancePolicyTypeFromString(value string) *TimeOffBalancePolicyType {
	return &TimeOffBalancePolicyType{typeName: "string", String: value}
}

func (t *TimeOffBalancePolicyType) UnmarshalJSON(data []byte) error {
	var valuePolicyTypeEnum PolicyTypeEnum
	if err := json.Unmarshal(data, &valuePolicyTypeEnum); err == nil {
		t.typeName = "policyTypeEnum"
		t.PolicyTypeEnum = valuePolicyTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffBalancePolicyType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "policyTypeEnum":
		return json.Marshal(t.PolicyTypeEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffBalancePolicyTypeVisitor interface {
	VisitPolicyTypeEnum(PolicyTypeEnum) error
	VisitString(string) error
}

func (t *TimeOffBalancePolicyType) Accept(visitor TimeOffBalancePolicyTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "policyTypeEnum":
		return visitor.VisitPolicyTypeEnum(t.PolicyTypeEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The employee requesting time off.
type TimeOffEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffEmployeeFromString(value string) *TimeOffEmployee {
	return &TimeOffEmployee{typeName: "string", String: value}
}

func NewTimeOffEmployeeFromEmployee(value *Employee) *TimeOffEmployee {
	return &TimeOffEmployee{typeName: "employee", Employee: value}
}

func (t *TimeOffEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffEmployee) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffEmployee) Accept(visitor TimeOffEmployeeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// # The TimeOff Object
//
// ### Description
//
// The `TimeOff` object is used to represent all employees' Time Off entries.
//
// ### Usage Example
//
// Fetch from the `LIST TimeOffs` endpoint and filter by `ID` to show all time off requests.
type TimeOffRequest struct {
	// The employee requesting time off.
	Employee *TimeOffRequestEmployee `json:"employee,omitempty"`
	// The Merge ID of the employee with the ability to approve the time off request.
	Approver *TimeOffRequestApprover `json:"approver,omitempty"`
	// The status of this time off request.
	//
	// - `REQUESTED` - REQUESTED
	// - `APPROVED` - APPROVED
	// - `DECLINED` - DECLINED
	// - `CANCELLED` - CANCELLED
	// - `DELETED` - DELETED
	Status *TimeOffRequestStatus `json:"status,omitempty"`
	// The employee note for this time off request.
	EmployeeNote *string `json:"employee_note,omitempty"`
	// The measurement that the third-party integration uses to count time requested.
	//
	// - `HOURS` - HOURS
	// - `DAYS` - DAYS
	Units *TimeOffRequestUnits `json:"units,omitempty"`
	// The time off quantity measured by the prescribed “units”.
	Amount *float64 `json:"amount,omitempty"`
	// The type of time off request.
	//
	// - `VACATION` - VACATION
	// - `SICK` - SICK
	// - `PERSONAL` - PERSONAL
	// - `JURY_DUTY` - JURY_DUTY
	// - `VOLUNTEER` - VOLUNTEER
	// - `BEREAVEMENT` - BEREAVEMENT
	RequestType *TimeOffRequestRequestType `json:"request_type,omitempty"`
	// The day and time of the start of the time requested off.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The day and time of the end of the time requested off.
	EndTime             *time.Time             `json:"end_time,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TimeOffRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeOffRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeOffRequest(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeOffRequest) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The Merge ID of the employee with the ability to approve the time off request.
type TimeOffRequestApprover struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffRequestApproverFromString(value string) *TimeOffRequestApprover {
	return &TimeOffRequestApprover{typeName: "string", String: value}
}

func NewTimeOffRequestApproverFromEmployee(value *Employee) *TimeOffRequestApprover {
	return &TimeOffRequestApprover{typeName: "employee", Employee: value}
}

func (t *TimeOffRequestApprover) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestApprover) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffRequestApproverVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffRequestApprover) Accept(visitor TimeOffRequestApproverVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// The employee requesting time off.
type TimeOffRequestEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimeOffRequestEmployeeFromString(value string) *TimeOffRequestEmployee {
	return &TimeOffRequestEmployee{typeName: "string", String: value}
}

func NewTimeOffRequestEmployeeFromEmployee(value *Employee) *TimeOffRequestEmployee {
	return &TimeOffRequestEmployee{typeName: "employee", Employee: value}
}

func (t *TimeOffRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestEmployee) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimeOffRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimeOffRequestEmployee) Accept(visitor TimeOffRequestEmployeeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// The type of time off request.
//
// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type TimeOffRequestRequestType struct {
	typeName        string
	RequestTypeEnum RequestTypeEnum
	String          string
}

func NewTimeOffRequestRequestTypeFromRequestTypeEnum(value RequestTypeEnum) *TimeOffRequestRequestType {
	return &TimeOffRequestRequestType{typeName: "requestTypeEnum", RequestTypeEnum: value}
}

func NewTimeOffRequestRequestTypeFromString(value string) *TimeOffRequestRequestType {
	return &TimeOffRequestRequestType{typeName: "string", String: value}
}

func (t *TimeOffRequestRequestType) UnmarshalJSON(data []byte) error {
	var valueRequestTypeEnum RequestTypeEnum
	if err := json.Unmarshal(data, &valueRequestTypeEnum); err == nil {
		t.typeName = "requestTypeEnum"
		t.RequestTypeEnum = valueRequestTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestRequestType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "requestTypeEnum":
		return json.Marshal(t.RequestTypeEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffRequestRequestTypeVisitor interface {
	VisitRequestTypeEnum(RequestTypeEnum) error
	VisitString(string) error
}

func (t *TimeOffRequestRequestType) Accept(visitor TimeOffRequestRequestTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "requestTypeEnum":
		return visitor.VisitRequestTypeEnum(t.RequestTypeEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The status of this time off request.
//
// - `REQUESTED` - REQUESTED
// - `APPROVED` - APPROVED
// - `DECLINED` - DECLINED
// - `CANCELLED` - CANCELLED
// - `DELETED` - DELETED
type TimeOffRequestStatus struct {
	typeName          string
	TimeOffStatusEnum TimeOffStatusEnum
	String            string
}

func NewTimeOffRequestStatusFromTimeOffStatusEnum(value TimeOffStatusEnum) *TimeOffRequestStatus {
	return &TimeOffRequestStatus{typeName: "timeOffStatusEnum", TimeOffStatusEnum: value}
}

func NewTimeOffRequestStatusFromString(value string) *TimeOffRequestStatus {
	return &TimeOffRequestStatus{typeName: "string", String: value}
}

func (t *TimeOffRequestStatus) UnmarshalJSON(data []byte) error {
	var valueTimeOffStatusEnum TimeOffStatusEnum
	if err := json.Unmarshal(data, &valueTimeOffStatusEnum); err == nil {
		t.typeName = "timeOffStatusEnum"
		t.TimeOffStatusEnum = valueTimeOffStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestStatus) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "timeOffStatusEnum":
		return json.Marshal(t.TimeOffStatusEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffRequestStatusVisitor interface {
	VisitTimeOffStatusEnum(TimeOffStatusEnum) error
	VisitString(string) error
}

func (t *TimeOffRequestStatus) Accept(visitor TimeOffRequestStatusVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "timeOffStatusEnum":
		return visitor.VisitTimeOffStatusEnum(t.TimeOffStatusEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The type of time off request.
//
// - `VACATION` - VACATION
// - `SICK` - SICK
// - `PERSONAL` - PERSONAL
// - `JURY_DUTY` - JURY_DUTY
// - `VOLUNTEER` - VOLUNTEER
// - `BEREAVEMENT` - BEREAVEMENT
type TimeOffRequestType struct {
	typeName        string
	RequestTypeEnum RequestTypeEnum
	String          string
}

func NewTimeOffRequestTypeFromRequestTypeEnum(value RequestTypeEnum) *TimeOffRequestType {
	return &TimeOffRequestType{typeName: "requestTypeEnum", RequestTypeEnum: value}
}

func NewTimeOffRequestTypeFromString(value string) *TimeOffRequestType {
	return &TimeOffRequestType{typeName: "string", String: value}
}

func (t *TimeOffRequestType) UnmarshalJSON(data []byte) error {
	var valueRequestTypeEnum RequestTypeEnum
	if err := json.Unmarshal(data, &valueRequestTypeEnum); err == nil {
		t.typeName = "requestTypeEnum"
		t.RequestTypeEnum = valueRequestTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "requestTypeEnum":
		return json.Marshal(t.RequestTypeEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffRequestTypeVisitor interface {
	VisitRequestTypeEnum(RequestTypeEnum) error
	VisitString(string) error
}

func (t *TimeOffRequestType) Accept(visitor TimeOffRequestTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "requestTypeEnum":
		return visitor.VisitRequestTypeEnum(t.RequestTypeEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The measurement that the third-party integration uses to count time requested.
//
// - `HOURS` - HOURS
// - `DAYS` - DAYS
type TimeOffRequestUnits struct {
	typeName  string
	UnitsEnum UnitsEnum
	String    string
}

func NewTimeOffRequestUnitsFromUnitsEnum(value UnitsEnum) *TimeOffRequestUnits {
	return &TimeOffRequestUnits{typeName: "unitsEnum", UnitsEnum: value}
}

func NewTimeOffRequestUnitsFromString(value string) *TimeOffRequestUnits {
	return &TimeOffRequestUnits{typeName: "string", String: value}
}

func (t *TimeOffRequestUnits) UnmarshalJSON(data []byte) error {
	var valueUnitsEnum UnitsEnum
	if err := json.Unmarshal(data, &valueUnitsEnum); err == nil {
		t.typeName = "unitsEnum"
		t.UnitsEnum = valueUnitsEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffRequestUnits) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "unitsEnum":
		return json.Marshal(t.UnitsEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffRequestUnitsVisitor interface {
	VisitUnitsEnum(UnitsEnum) error
	VisitString(string) error
}

func (t *TimeOffRequestUnits) Accept(visitor TimeOffRequestUnitsVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "unitsEnum":
		return visitor.VisitUnitsEnum(t.UnitsEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TimeOffResponse struct {
	Model    *TimeOff                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TimeOffResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeOffResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeOffResponse(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeOffResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The status of this time off request.
//
// - `REQUESTED` - REQUESTED
// - `APPROVED` - APPROVED
// - `DECLINED` - DECLINED
// - `CANCELLED` - CANCELLED
// - `DELETED` - DELETED
type TimeOffStatus struct {
	typeName          string
	TimeOffStatusEnum TimeOffStatusEnum
	String            string
}

func NewTimeOffStatusFromTimeOffStatusEnum(value TimeOffStatusEnum) *TimeOffStatus {
	return &TimeOffStatus{typeName: "timeOffStatusEnum", TimeOffStatusEnum: value}
}

func NewTimeOffStatusFromString(value string) *TimeOffStatus {
	return &TimeOffStatus{typeName: "string", String: value}
}

func (t *TimeOffStatus) UnmarshalJSON(data []byte) error {
	var valueTimeOffStatusEnum TimeOffStatusEnum
	if err := json.Unmarshal(data, &valueTimeOffStatusEnum); err == nil {
		t.typeName = "timeOffStatusEnum"
		t.TimeOffStatusEnum = valueTimeOffStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffStatus) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "timeOffStatusEnum":
		return json.Marshal(t.TimeOffStatusEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffStatusVisitor interface {
	VisitTimeOffStatusEnum(TimeOffStatusEnum) error
	VisitString(string) error
}

func (t *TimeOffStatus) Accept(visitor TimeOffStatusVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "timeOffStatusEnum":
		return visitor.VisitTimeOffStatusEnum(t.TimeOffStatusEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// - `REQUESTED` - REQUESTED
// - `APPROVED` - APPROVED
// - `DECLINED` - DECLINED
// - `CANCELLED` - CANCELLED
// - `DELETED` - DELETED
type TimeOffStatusEnum string

const (
	TimeOffStatusEnumRequested TimeOffStatusEnum = "REQUESTED"
	TimeOffStatusEnumApproved  TimeOffStatusEnum = "APPROVED"
	TimeOffStatusEnumDeclined  TimeOffStatusEnum = "DECLINED"
	TimeOffStatusEnumCancelled TimeOffStatusEnum = "CANCELLED"
	TimeOffStatusEnumDeleted   TimeOffStatusEnum = "DELETED"
)

func NewTimeOffStatusEnumFromString(s string) (TimeOffStatusEnum, error) {
	switch s {
	case "REQUESTED":
		return TimeOffStatusEnumRequested, nil
	case "APPROVED":
		return TimeOffStatusEnumApproved, nil
	case "DECLINED":
		return TimeOffStatusEnumDeclined, nil
	case "CANCELLED":
		return TimeOffStatusEnumCancelled, nil
	case "DELETED":
		return TimeOffStatusEnumDeleted, nil
	}
	var t TimeOffStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeOffStatusEnum) Ptr() *TimeOffStatusEnum {
	return &t
}

// The measurement that the third-party integration uses to count time requested.
//
// - `HOURS` - HOURS
// - `DAYS` - DAYS
type TimeOffUnits struct {
	typeName  string
	UnitsEnum UnitsEnum
	String    string
}

func NewTimeOffUnitsFromUnitsEnum(value UnitsEnum) *TimeOffUnits {
	return &TimeOffUnits{typeName: "unitsEnum", UnitsEnum: value}
}

func NewTimeOffUnitsFromString(value string) *TimeOffUnits {
	return &TimeOffUnits{typeName: "string", String: value}
}

func (t *TimeOffUnits) UnmarshalJSON(data []byte) error {
	var valueUnitsEnum UnitsEnum
	if err := json.Unmarshal(data, &valueUnitsEnum); err == nil {
		t.typeName = "unitsEnum"
		t.UnitsEnum = valueUnitsEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimeOffUnits) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "unitsEnum":
		return json.Marshal(t.UnitsEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TimeOffUnitsVisitor interface {
	VisitUnitsEnum(UnitsEnum) error
	VisitString(string) error
}

func (t *TimeOffUnits) Accept(visitor TimeOffUnitsVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "unitsEnum":
		return visitor.VisitUnitsEnum(t.UnitsEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// # The Timesheet Entry Object
//
// ### Description
//
// The `Timesheet Entry` object is used to track coverage for hours worked by an 'Employee'.
//
// ### Usage Example
//
// GET and POST Timesheet Entries
type TimesheetEntry struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee the timesheet entry is for.
	Employee *TimesheetEntryEmployee `json:"employee,omitempty"`
	// The number of hours logged by the employee.
	HoursWorked *float64 `json:"hours_worked,omitempty"`
	// The time at which the employee started work.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The time at which the employee ended work.
	EndTime *time.Time `json:"end_time,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TimesheetEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler TimesheetEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimesheetEntry(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimesheetEntry) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The employee the timesheet entry is for.
type TimesheetEntryEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimesheetEntryEmployeeFromString(value string) *TimesheetEntryEmployee {
	return &TimesheetEntryEmployee{typeName: "string", String: value}
}

func NewTimesheetEntryEmployeeFromEmployee(value *Employee) *TimesheetEntryEmployee {
	return &TimesheetEntryEmployee{typeName: "employee", Employee: value}
}

func (t *TimesheetEntryEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimesheetEntryEmployee) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimesheetEntryEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimesheetEntryEmployee) Accept(visitor TimesheetEntryEmployeeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

// # The Timesheet Entry Object
//
// ### Description
//
// The `Timesheet Entry` object is used to track coverage for hours worked by an 'Employee'.
//
// ### Usage Example
//
// GET and POST Timesheet Entries
type TimesheetEntryRequest struct {
	// The employee the timesheet entry is for.
	Employee *TimesheetEntryRequestEmployee `json:"employee,omitempty"`
	// The number of hours logged by the employee.
	HoursWorked *float64 `json:"hours_worked,omitempty"`
	// The time at which the employee started work.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The time at which the employee ended work.
	EndTime             *time.Time             `json:"end_time,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TimesheetEntryRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler TimesheetEntryRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimesheetEntryRequest(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimesheetEntryRequest) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The employee the timesheet entry is for.
type TimesheetEntryRequestEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewTimesheetEntryRequestEmployeeFromString(value string) *TimesheetEntryRequestEmployee {
	return &TimesheetEntryRequestEmployee{typeName: "string", String: value}
}

func NewTimesheetEntryRequestEmployeeFromEmployee(value *Employee) *TimesheetEntryRequestEmployee {
	return &TimesheetEntryRequestEmployee{typeName: "employee", Employee: value}
}

func (t *TimesheetEntryRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		t.typeName = "employee"
		t.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TimesheetEntryRequestEmployee) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "employee":
		return json.Marshal(t.Employee)
	}
}

type TimesheetEntryRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (t *TimesheetEntryRequestEmployee) Accept(visitor TimesheetEntryRequestEmployeeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "employee":
		return visitor.VisitEmployee(t.Employee)
	}
}

type TimesheetEntryResponse struct {
	Model    *TimesheetEntry             `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TimesheetEntryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TimesheetEntryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimesheetEntryResponse(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimesheetEntryResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// - `HOURS` - HOURS
// - `DAYS` - DAYS
type UnitsEnum string

const (
	UnitsEnumHours UnitsEnum = "HOURS"
	UnitsEnumDays  UnitsEnum = "DAYS"
)

func NewUnitsEnumFromString(s string) (UnitsEnum, error) {
	switch s {
	case "HOURS":
		return UnitsEnumHours, nil
	case "DAYS":
		return UnitsEnumDays, nil
	}
	var t UnitsEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UnitsEnum) Ptr() *UnitsEnum {
	return &u
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer"`

	_rawJSON json.RawMessage
}

func (v *ValidationProblemSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationProblemSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationProblemSource(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationProblemSource) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`

	_rawJSON json.RawMessage
}

func (w *WarningValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler WarningValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WarningValidationProblem(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WarningValidationProblem) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookReceiver struct {
	Event    string  `json:"event"`
	IsActive bool    `json:"is_active"`
	Key      *string `json:"key,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WebhookReceiver) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookReceiver
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookReceiver(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookReceiver) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
