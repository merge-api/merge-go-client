// Code generated by Fern. DO NOT EDIT.

package hris

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type AccountIntegration struct {
	// Company name.
	Name string `json:"name" url:"name"`
	// Optional. This shortened name appears in places with limited space, usually in conjunction with the platform's logo (e.g., Merge Link menu).<br><br>Example: <i>Workforce Now (in lieu of ADP Workforce Now), SuccessFactors (in lieu of SAP SuccessFactors)</i>
	AbbreviatedName *string `json:"abbreviated_name,omitempty" url:"abbreviated_name,omitempty"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty" url:"categories,omitempty"`
	// Company logo in rectangular shape.
	Image *string `json:"image,omitempty" url:"image,omitempty"`
	// Company logo in square shape.
	SquareImage *string `json:"square_image,omitempty" url:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	Slug  *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]interface{} `json:"api_endpoints_to_documentation_urls,omitempty" url:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty" url:"webhook_setup_guide_url,omitempty"`
	// Category or categories this integration is in beta status for.
	CategoryBetaStatus map[string]interface{} `json:"category_beta_status,omitempty" url:"category_beta_status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountIntegration) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AccountIntegration) GetAbbreviatedName() *string {
	if a == nil {
		return nil
	}
	return a.AbbreviatedName
}

func (a *AccountIntegration) GetCategories() []CategoriesEnum {
	if a == nil {
		return nil
	}
	return a.Categories
}

func (a *AccountIntegration) GetImage() *string {
	if a == nil {
		return nil
	}
	return a.Image
}

func (a *AccountIntegration) GetSquareImage() *string {
	if a == nil {
		return nil
	}
	return a.SquareImage
}

func (a *AccountIntegration) GetColor() *string {
	if a == nil {
		return nil
	}
	return a.Color
}

func (a *AccountIntegration) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *AccountIntegration) GetApiEndpointsToDocumentationUrls() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.ApiEndpointsToDocumentationUrls
}

func (a *AccountIntegration) GetWebhookSetupGuideUrl() *string {
	if a == nil {
		return nil
	}
	return a.WebhookSetupGuideUrl
}

func (a *AccountIntegration) GetCategoryBetaStatus() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.CategoryBetaStatus
}

func (a *AccountIntegration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountIntegration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountIntegration) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoriesEnum string

const (
	CategoriesEnumHris        CategoriesEnum = "hris"
	CategoriesEnumAts         CategoriesEnum = "ats"
	CategoriesEnumAccounting  CategoriesEnum = "accounting"
	CategoriesEnumTicketing   CategoriesEnum = "ticketing"
	CategoriesEnumCrm         CategoriesEnum = "crm"
	CategoriesEnumMktg        CategoriesEnum = "mktg"
	CategoriesEnumFilestorage CategoriesEnum = "filestorage"
)

func NewCategoriesEnumFromString(s string) (CategoriesEnum, error) {
	switch s {
	case "hris":
		return CategoriesEnumHris, nil
	case "ats":
		return CategoriesEnumAts, nil
	case "accounting":
		return CategoriesEnumAccounting, nil
	case "ticketing":
		return CategoriesEnumTicketing, nil
	case "crm":
		return CategoriesEnumCrm, nil
	case "mktg":
		return CategoriesEnumMktg, nil
	case "filestorage":
		return CategoriesEnumFilestorage, nil
	}
	var t CategoriesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoriesEnum) Ptr() *CategoriesEnum {
	return &c
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoryEnum string

const (
	CategoryEnumHris        CategoryEnum = "hris"
	CategoryEnumAts         CategoryEnum = "ats"
	CategoryEnumAccounting  CategoryEnum = "accounting"
	CategoryEnumTicketing   CategoryEnum = "ticketing"
	CategoryEnumCrm         CategoryEnum = "crm"
	CategoryEnumMktg        CategoryEnum = "mktg"
	CategoryEnumFilestorage CategoryEnum = "filestorage"
)

func NewCategoryEnumFromString(s string) (CategoryEnum, error) {
	switch s {
	case "hris":
		return CategoryEnumHris, nil
	case "ats":
		return CategoryEnumAts, nil
	case "accounting":
		return CategoryEnumAccounting, nil
	case "ticketing":
		return CategoryEnumTicketing, nil
	case "crm":
		return CategoryEnumCrm, nil
	case "mktg":
		return CategoryEnumMktg, nil
	case "filestorage":
		return CategoryEnumFilestorage, nil
	}
	var t CategoryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryEnum) Ptr() *CategoryEnum {
	return &c
}

// # The Company Object
// ### Description
// The `Company` object is used to represent a company within the HRIS / Payroll system.
//
// ### Usage Example
// Fetch from the `LIST Companies` endpoint and filter by `ID` to show all companies.
type Company struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The company's legal name.
	LegalName *string `json:"legal_name,omitempty" url:"legal_name,omitempty"`
	// The company's display name.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The company's Employer Identification Numbers.
	Eins []*string `json:"eins,omitempty" url:"eins,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Company) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *Company) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *Company) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *Company) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *Company) GetLegalName() *string {
	if c == nil {
		return nil
	}
	return c.LegalName
}

func (c *Company) GetDisplayName() *string {
	if c == nil {
		return nil
	}
	return c.DisplayName
}

func (c *Company) GetEins() []*string {
	if c == nil {
		return nil
	}
	return c.Eins
}

func (c *Company) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *Company) GetFieldMappings() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FieldMappings
}

func (c *Company) GetRemoteData() []*RemoteData {
	if c == nil {
		return nil
	}
	return c.RemoteData
}

func (c *Company) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Company) UnmarshalJSON(data []byte) error {
	type embed Company
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Company(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Company) MarshalJSON() ([]byte, error) {
	type embed Company
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*c),
		CreatedAt:  internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(c.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Company) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// * `AF` - Afghanistan
// * `AX` - Åland Islands
// * `AL` - Albania
// * `DZ` - Algeria
// * `AS` - American Samoa
// * `AD` - Andorra
// * `AO` - Angola
// * `AI` - Anguilla
// * `AQ` - Antarctica
// * `AG` - Antigua and Barbuda
// * `AR` - Argentina
// * `AM` - Armenia
// * `AW` - Aruba
// * `AU` - Australia
// * `AT` - Austria
// * `AZ` - Azerbaijan
// * `BS` - Bahamas
// * `BH` - Bahrain
// * `BD` - Bangladesh
// * `BB` - Barbados
// * `BY` - Belarus
// * `BE` - Belgium
// * `BZ` - Belize
// * `BJ` - Benin
// * `BM` - Bermuda
// * `BT` - Bhutan
// * `BO` - Bolivia
// * `BQ` - Bonaire, Sint Eustatius and Saba
// * `BA` - Bosnia and Herzegovina
// * `BW` - Botswana
// * `BV` - Bouvet Island
// * `BR` - Brazil
// * `IO` - British Indian Ocean Territory
// * `BN` - Brunei
// * `BG` - Bulgaria
// * `BF` - Burkina Faso
// * `BI` - Burundi
// * `CV` - Cabo Verde
// * `KH` - Cambodia
// * `CM` - Cameroon
// * `CA` - Canada
// * `KY` - Cayman Islands
// * `CF` - Central African Republic
// * `TD` - Chad
// * `CL` - Chile
// * `CN` - China
// * `CX` - Christmas Island
// * `CC` - Cocos (Keeling) Islands
// * `CO` - Colombia
// * `KM` - Comoros
// * `CG` - Congo
// * `CD` - Congo (the Democratic Republic of the)
// * `CK` - Cook Islands
// * `CR` - Costa Rica
// * `CI` - Côte d'Ivoire
// * `HR` - Croatia
// * `CU` - Cuba
// * `CW` - Curaçao
// * `CY` - Cyprus
// * `CZ` - Czechia
// * `DK` - Denmark
// * `DJ` - Djibouti
// * `DM` - Dominica
// * `DO` - Dominican Republic
// * `EC` - Ecuador
// * `EG` - Egypt
// * `SV` - El Salvador
// * `GQ` - Equatorial Guinea
// * `ER` - Eritrea
// * `EE` - Estonia
// * `SZ` - Eswatini
// * `ET` - Ethiopia
// * `FK` - Falkland Islands (Malvinas)
// * `FO` - Faroe Islands
// * `FJ` - Fiji
// * `FI` - Finland
// * `FR` - France
// * `GF` - French Guiana
// * `PF` - French Polynesia
// * `TF` - French Southern Territories
// * `GA` - Gabon
// * `GM` - Gambia
// * `GE` - Georgia
// * `DE` - Germany
// * `GH` - Ghana
// * `GI` - Gibraltar
// * `GR` - Greece
// * `GL` - Greenland
// * `GD` - Grenada
// * `GP` - Guadeloupe
// * `GU` - Guam
// * `GT` - Guatemala
// * `GG` - Guernsey
// * `GN` - Guinea
// * `GW` - Guinea-Bissau
// * `GY` - Guyana
// * `HT` - Haiti
// * `HM` - Heard Island and McDonald Islands
// * `VA` - Holy See
// * `HN` - Honduras
// * `HK` - Hong Kong
// * `HU` - Hungary
// * `IS` - Iceland
// * `IN` - India
// * `ID` - Indonesia
// * `IR` - Iran
// * `IQ` - Iraq
// * `IE` - Ireland
// * `IM` - Isle of Man
// * `IL` - Israel
// * `IT` - Italy
// * `JM` - Jamaica
// * `JP` - Japan
// * `JE` - Jersey
// * `JO` - Jordan
// * `KZ` - Kazakhstan
// * `KE` - Kenya
// * `KI` - Kiribati
// * `KW` - Kuwait
// * `KG` - Kyrgyzstan
// * `LA` - Laos
// * `LV` - Latvia
// * `LB` - Lebanon
// * `LS` - Lesotho
// * `LR` - Liberia
// * `LY` - Libya
// * `LI` - Liechtenstein
// * `LT` - Lithuania
// * `LU` - Luxembourg
// * `MO` - Macao
// * `MG` - Madagascar
// * `MW` - Malawi
// * `MY` - Malaysia
// * `MV` - Maldives
// * `ML` - Mali
// * `MT` - Malta
// * `MH` - Marshall Islands
// * `MQ` - Martinique
// * `MR` - Mauritania
// * `MU` - Mauritius
// * `YT` - Mayotte
// * `MX` - Mexico
// * `FM` - Micronesia (Federated States of)
// * `MD` - Moldova
// * `MC` - Monaco
// * `MN` - Mongolia
// * `ME` - Montenegro
// * `MS` - Montserrat
// * `MA` - Morocco
// * `MZ` - Mozambique
// * `MM` - Myanmar
// * `NA` - Namibia
// * `NR` - Nauru
// * `NP` - Nepal
// * `NL` - Netherlands
// * `NC` - New Caledonia
// * `NZ` - New Zealand
// * `NI` - Nicaragua
// * `NE` - Niger
// * `NG` - Nigeria
// * `NU` - Niue
// * `NF` - Norfolk Island
// * `KP` - North Korea
// * `MK` - North Macedonia
// * `MP` - Northern Mariana Islands
// * `NO` - Norway
// * `OM` - Oman
// * `PK` - Pakistan
// * `PW` - Palau
// * `PS` - Palestine, State of
// * `PA` - Panama
// * `PG` - Papua New Guinea
// * `PY` - Paraguay
// * `PE` - Peru
// * `PH` - Philippines
// * `PN` - Pitcairn
// * `PL` - Poland
// * `PT` - Portugal
// * `PR` - Puerto Rico
// * `QA` - Qatar
// * `RE` - Réunion
// * `RO` - Romania
// * `RU` - Russia
// * `RW` - Rwanda
// * `BL` - Saint Barthélemy
// * `SH` - Saint Helena, Ascension and Tristan da Cunha
// * `KN` - Saint Kitts and Nevis
// * `LC` - Saint Lucia
// * `MF` - Saint Martin (French part)
// * `PM` - Saint Pierre and Miquelon
// * `VC` - Saint Vincent and the Grenadines
// * `WS` - Samoa
// * `SM` - San Marino
// * `ST` - Sao Tome and Principe
// * `SA` - Saudi Arabia
// * `SN` - Senegal
// * `RS` - Serbia
// * `SC` - Seychelles
// * `SL` - Sierra Leone
// * `SG` - Singapore
// * `SX` - Sint Maarten (Dutch part)
// * `SK` - Slovakia
// * `SI` - Slovenia
// * `SB` - Solomon Islands
// * `SO` - Somalia
// * `ZA` - South Africa
// * `GS` - South Georgia and the South Sandwich Islands
// * `KR` - South Korea
// * `SS` - South Sudan
// * `ES` - Spain
// * `LK` - Sri Lanka
// * `SD` - Sudan
// * `SR` - Suriname
// * `SJ` - Svalbard and Jan Mayen
// * `SE` - Sweden
// * `CH` - Switzerland
// * `SY` - Syria
// * `TW` - Taiwan
// * `TJ` - Tajikistan
// * `TZ` - Tanzania
// * `TH` - Thailand
// * `TL` - Timor-Leste
// * `TG` - Togo
// * `TK` - Tokelau
// * `TO` - Tonga
// * `TT` - Trinidad and Tobago
// * `TN` - Tunisia
// * `TR` - Turkey
// * `TM` - Turkmenistan
// * `TC` - Turks and Caicos Islands
// * `TV` - Tuvalu
// * `UG` - Uganda
// * `UA` - Ukraine
// * `AE` - United Arab Emirates
// * `GB` - United Kingdom
// * `UM` - United States Minor Outlying Islands
// * `US` - United States of America
// * `UY` - Uruguay
// * `UZ` - Uzbekistan
// * `VU` - Vanuatu
// * `VE` - Venezuela
// * `VN` - Vietnam
// * `VG` - Virgin Islands (British)
// * `VI` - Virgin Islands (U.S.)
// * `WF` - Wallis and Futuna
// * `EH` - Western Sahara
// * `YE` - Yemen
// * `ZM` - Zambia
// * `ZW` - Zimbabwe
type CountryEnum string

const (
	CountryEnumAf CountryEnum = "AF"
	CountryEnumAx CountryEnum = "AX"
	CountryEnumAl CountryEnum = "AL"
	CountryEnumDz CountryEnum = "DZ"
	CountryEnumAs CountryEnum = "AS"
	CountryEnumAd CountryEnum = "AD"
	CountryEnumAo CountryEnum = "AO"
	CountryEnumAi CountryEnum = "AI"
	CountryEnumAq CountryEnum = "AQ"
	CountryEnumAg CountryEnum = "AG"
	CountryEnumAr CountryEnum = "AR"
	CountryEnumAm CountryEnum = "AM"
	CountryEnumAw CountryEnum = "AW"
	CountryEnumAu CountryEnum = "AU"
	CountryEnumAt CountryEnum = "AT"
	CountryEnumAz CountryEnum = "AZ"
	CountryEnumBs CountryEnum = "BS"
	CountryEnumBh CountryEnum = "BH"
	CountryEnumBd CountryEnum = "BD"
	CountryEnumBb CountryEnum = "BB"
	CountryEnumBy CountryEnum = "BY"
	CountryEnumBe CountryEnum = "BE"
	CountryEnumBz CountryEnum = "BZ"
	CountryEnumBj CountryEnum = "BJ"
	CountryEnumBm CountryEnum = "BM"
	CountryEnumBt CountryEnum = "BT"
	CountryEnumBo CountryEnum = "BO"
	CountryEnumBq CountryEnum = "BQ"
	CountryEnumBa CountryEnum = "BA"
	CountryEnumBw CountryEnum = "BW"
	CountryEnumBv CountryEnum = "BV"
	CountryEnumBr CountryEnum = "BR"
	CountryEnumIo CountryEnum = "IO"
	CountryEnumBn CountryEnum = "BN"
	CountryEnumBg CountryEnum = "BG"
	CountryEnumBf CountryEnum = "BF"
	CountryEnumBi CountryEnum = "BI"
	CountryEnumCv CountryEnum = "CV"
	CountryEnumKh CountryEnum = "KH"
	CountryEnumCm CountryEnum = "CM"
	CountryEnumCa CountryEnum = "CA"
	CountryEnumKy CountryEnum = "KY"
	CountryEnumCf CountryEnum = "CF"
	CountryEnumTd CountryEnum = "TD"
	CountryEnumCl CountryEnum = "CL"
	CountryEnumCn CountryEnum = "CN"
	CountryEnumCx CountryEnum = "CX"
	CountryEnumCc CountryEnum = "CC"
	CountryEnumCo CountryEnum = "CO"
	CountryEnumKm CountryEnum = "KM"
	CountryEnumCg CountryEnum = "CG"
	CountryEnumCd CountryEnum = "CD"
	CountryEnumCk CountryEnum = "CK"
	CountryEnumCr CountryEnum = "CR"
	CountryEnumCi CountryEnum = "CI"
	CountryEnumHr CountryEnum = "HR"
	CountryEnumCu CountryEnum = "CU"
	CountryEnumCw CountryEnum = "CW"
	CountryEnumCy CountryEnum = "CY"
	CountryEnumCz CountryEnum = "CZ"
	CountryEnumDk CountryEnum = "DK"
	CountryEnumDj CountryEnum = "DJ"
	CountryEnumDm CountryEnum = "DM"
	CountryEnumDo CountryEnum = "DO"
	CountryEnumEc CountryEnum = "EC"
	CountryEnumEg CountryEnum = "EG"
	CountryEnumSv CountryEnum = "SV"
	CountryEnumGq CountryEnum = "GQ"
	CountryEnumEr CountryEnum = "ER"
	CountryEnumEe CountryEnum = "EE"
	CountryEnumSz CountryEnum = "SZ"
	CountryEnumEt CountryEnum = "ET"
	CountryEnumFk CountryEnum = "FK"
	CountryEnumFo CountryEnum = "FO"
	CountryEnumFj CountryEnum = "FJ"
	CountryEnumFi CountryEnum = "FI"
	CountryEnumFr CountryEnum = "FR"
	CountryEnumGf CountryEnum = "GF"
	CountryEnumPf CountryEnum = "PF"
	CountryEnumTf CountryEnum = "TF"
	CountryEnumGa CountryEnum = "GA"
	CountryEnumGm CountryEnum = "GM"
	CountryEnumGe CountryEnum = "GE"
	CountryEnumDe CountryEnum = "DE"
	CountryEnumGh CountryEnum = "GH"
	CountryEnumGi CountryEnum = "GI"
	CountryEnumGr CountryEnum = "GR"
	CountryEnumGl CountryEnum = "GL"
	CountryEnumGd CountryEnum = "GD"
	CountryEnumGp CountryEnum = "GP"
	CountryEnumGu CountryEnum = "GU"
	CountryEnumGt CountryEnum = "GT"
	CountryEnumGg CountryEnum = "GG"
	CountryEnumGn CountryEnum = "GN"
	CountryEnumGw CountryEnum = "GW"
	CountryEnumGy CountryEnum = "GY"
	CountryEnumHt CountryEnum = "HT"
	CountryEnumHm CountryEnum = "HM"
	CountryEnumVa CountryEnum = "VA"
	CountryEnumHn CountryEnum = "HN"
	CountryEnumHk CountryEnum = "HK"
	CountryEnumHu CountryEnum = "HU"
	CountryEnumIs CountryEnum = "IS"
	CountryEnumIn CountryEnum = "IN"
	CountryEnumId CountryEnum = "ID"
	CountryEnumIr CountryEnum = "IR"
	CountryEnumIq CountryEnum = "IQ"
	CountryEnumIe CountryEnum = "IE"
	CountryEnumIm CountryEnum = "IM"
	CountryEnumIl CountryEnum = "IL"
	CountryEnumIt CountryEnum = "IT"
	CountryEnumJm CountryEnum = "JM"
	CountryEnumJp CountryEnum = "JP"
	CountryEnumJe CountryEnum = "JE"
	CountryEnumJo CountryEnum = "JO"
	CountryEnumKz CountryEnum = "KZ"
	CountryEnumKe CountryEnum = "KE"
	CountryEnumKi CountryEnum = "KI"
	CountryEnumKw CountryEnum = "KW"
	CountryEnumKg CountryEnum = "KG"
	CountryEnumLa CountryEnum = "LA"
	CountryEnumLv CountryEnum = "LV"
	CountryEnumLb CountryEnum = "LB"
	CountryEnumLs CountryEnum = "LS"
	CountryEnumLr CountryEnum = "LR"
	CountryEnumLy CountryEnum = "LY"
	CountryEnumLi CountryEnum = "LI"
	CountryEnumLt CountryEnum = "LT"
	CountryEnumLu CountryEnum = "LU"
	CountryEnumMo CountryEnum = "MO"
	CountryEnumMg CountryEnum = "MG"
	CountryEnumMw CountryEnum = "MW"
	CountryEnumMy CountryEnum = "MY"
	CountryEnumMv CountryEnum = "MV"
	CountryEnumMl CountryEnum = "ML"
	CountryEnumMt CountryEnum = "MT"
	CountryEnumMh CountryEnum = "MH"
	CountryEnumMq CountryEnum = "MQ"
	CountryEnumMr CountryEnum = "MR"
	CountryEnumMu CountryEnum = "MU"
	CountryEnumYt CountryEnum = "YT"
	CountryEnumMx CountryEnum = "MX"
	CountryEnumFm CountryEnum = "FM"
	CountryEnumMd CountryEnum = "MD"
	CountryEnumMc CountryEnum = "MC"
	CountryEnumMn CountryEnum = "MN"
	CountryEnumMe CountryEnum = "ME"
	CountryEnumMs CountryEnum = "MS"
	CountryEnumMa CountryEnum = "MA"
	CountryEnumMz CountryEnum = "MZ"
	CountryEnumMm CountryEnum = "MM"
	CountryEnumNa CountryEnum = "NA"
	CountryEnumNr CountryEnum = "NR"
	CountryEnumNp CountryEnum = "NP"
	CountryEnumNl CountryEnum = "NL"
	CountryEnumNc CountryEnum = "NC"
	CountryEnumNz CountryEnum = "NZ"
	CountryEnumNi CountryEnum = "NI"
	CountryEnumNe CountryEnum = "NE"
	CountryEnumNg CountryEnum = "NG"
	CountryEnumNu CountryEnum = "NU"
	CountryEnumNf CountryEnum = "NF"
	CountryEnumKp CountryEnum = "KP"
	CountryEnumMk CountryEnum = "MK"
	CountryEnumMp CountryEnum = "MP"
	CountryEnumNo CountryEnum = "NO"
	CountryEnumOm CountryEnum = "OM"
	CountryEnumPk CountryEnum = "PK"
	CountryEnumPw CountryEnum = "PW"
	CountryEnumPs CountryEnum = "PS"
	CountryEnumPa CountryEnum = "PA"
	CountryEnumPg CountryEnum = "PG"
	CountryEnumPy CountryEnum = "PY"
	CountryEnumPe CountryEnum = "PE"
	CountryEnumPh CountryEnum = "PH"
	CountryEnumPn CountryEnum = "PN"
	CountryEnumPl CountryEnum = "PL"
	CountryEnumPt CountryEnum = "PT"
	CountryEnumPr CountryEnum = "PR"
	CountryEnumQa CountryEnum = "QA"
	CountryEnumRe CountryEnum = "RE"
	CountryEnumRo CountryEnum = "RO"
	CountryEnumRu CountryEnum = "RU"
	CountryEnumRw CountryEnum = "RW"
	CountryEnumBl CountryEnum = "BL"
	CountryEnumSh CountryEnum = "SH"
	CountryEnumKn CountryEnum = "KN"
	CountryEnumLc CountryEnum = "LC"
	CountryEnumMf CountryEnum = "MF"
	CountryEnumPm CountryEnum = "PM"
	CountryEnumVc CountryEnum = "VC"
	CountryEnumWs CountryEnum = "WS"
	CountryEnumSm CountryEnum = "SM"
	CountryEnumSt CountryEnum = "ST"
	CountryEnumSa CountryEnum = "SA"
	CountryEnumSn CountryEnum = "SN"
	CountryEnumRs CountryEnum = "RS"
	CountryEnumSc CountryEnum = "SC"
	CountryEnumSl CountryEnum = "SL"
	CountryEnumSg CountryEnum = "SG"
	CountryEnumSx CountryEnum = "SX"
	CountryEnumSk CountryEnum = "SK"
	CountryEnumSi CountryEnum = "SI"
	CountryEnumSb CountryEnum = "SB"
	CountryEnumSo CountryEnum = "SO"
	CountryEnumZa CountryEnum = "ZA"
	CountryEnumGs CountryEnum = "GS"
	CountryEnumKr CountryEnum = "KR"
	CountryEnumSs CountryEnum = "SS"
	CountryEnumEs CountryEnum = "ES"
	CountryEnumLk CountryEnum = "LK"
	CountryEnumSd CountryEnum = "SD"
	CountryEnumSr CountryEnum = "SR"
	CountryEnumSj CountryEnum = "SJ"
	CountryEnumSe CountryEnum = "SE"
	CountryEnumCh CountryEnum = "CH"
	CountryEnumSy CountryEnum = "SY"
	CountryEnumTw CountryEnum = "TW"
	CountryEnumTj CountryEnum = "TJ"
	CountryEnumTz CountryEnum = "TZ"
	CountryEnumTh CountryEnum = "TH"
	CountryEnumTl CountryEnum = "TL"
	CountryEnumTg CountryEnum = "TG"
	CountryEnumTk CountryEnum = "TK"
	CountryEnumTo CountryEnum = "TO"
	CountryEnumTt CountryEnum = "TT"
	CountryEnumTn CountryEnum = "TN"
	CountryEnumTr CountryEnum = "TR"
	CountryEnumTm CountryEnum = "TM"
	CountryEnumTc CountryEnum = "TC"
	CountryEnumTv CountryEnum = "TV"
	CountryEnumUg CountryEnum = "UG"
	CountryEnumUa CountryEnum = "UA"
	CountryEnumAe CountryEnum = "AE"
	CountryEnumGb CountryEnum = "GB"
	CountryEnumUm CountryEnum = "UM"
	CountryEnumUs CountryEnum = "US"
	CountryEnumUy CountryEnum = "UY"
	CountryEnumUz CountryEnum = "UZ"
	CountryEnumVu CountryEnum = "VU"
	CountryEnumVe CountryEnum = "VE"
	CountryEnumVn CountryEnum = "VN"
	CountryEnumVg CountryEnum = "VG"
	CountryEnumVi CountryEnum = "VI"
	CountryEnumWf CountryEnum = "WF"
	CountryEnumEh CountryEnum = "EH"
	CountryEnumYe CountryEnum = "YE"
	CountryEnumZm CountryEnum = "ZM"
	CountryEnumZw CountryEnum = "ZW"
)

func NewCountryEnumFromString(s string) (CountryEnum, error) {
	switch s {
	case "AF":
		return CountryEnumAf, nil
	case "AX":
		return CountryEnumAx, nil
	case "AL":
		return CountryEnumAl, nil
	case "DZ":
		return CountryEnumDz, nil
	case "AS":
		return CountryEnumAs, nil
	case "AD":
		return CountryEnumAd, nil
	case "AO":
		return CountryEnumAo, nil
	case "AI":
		return CountryEnumAi, nil
	case "AQ":
		return CountryEnumAq, nil
	case "AG":
		return CountryEnumAg, nil
	case "AR":
		return CountryEnumAr, nil
	case "AM":
		return CountryEnumAm, nil
	case "AW":
		return CountryEnumAw, nil
	case "AU":
		return CountryEnumAu, nil
	case "AT":
		return CountryEnumAt, nil
	case "AZ":
		return CountryEnumAz, nil
	case "BS":
		return CountryEnumBs, nil
	case "BH":
		return CountryEnumBh, nil
	case "BD":
		return CountryEnumBd, nil
	case "BB":
		return CountryEnumBb, nil
	case "BY":
		return CountryEnumBy, nil
	case "BE":
		return CountryEnumBe, nil
	case "BZ":
		return CountryEnumBz, nil
	case "BJ":
		return CountryEnumBj, nil
	case "BM":
		return CountryEnumBm, nil
	case "BT":
		return CountryEnumBt, nil
	case "BO":
		return CountryEnumBo, nil
	case "BQ":
		return CountryEnumBq, nil
	case "BA":
		return CountryEnumBa, nil
	case "BW":
		return CountryEnumBw, nil
	case "BV":
		return CountryEnumBv, nil
	case "BR":
		return CountryEnumBr, nil
	case "IO":
		return CountryEnumIo, nil
	case "BN":
		return CountryEnumBn, nil
	case "BG":
		return CountryEnumBg, nil
	case "BF":
		return CountryEnumBf, nil
	case "BI":
		return CountryEnumBi, nil
	case "CV":
		return CountryEnumCv, nil
	case "KH":
		return CountryEnumKh, nil
	case "CM":
		return CountryEnumCm, nil
	case "CA":
		return CountryEnumCa, nil
	case "KY":
		return CountryEnumKy, nil
	case "CF":
		return CountryEnumCf, nil
	case "TD":
		return CountryEnumTd, nil
	case "CL":
		return CountryEnumCl, nil
	case "CN":
		return CountryEnumCn, nil
	case "CX":
		return CountryEnumCx, nil
	case "CC":
		return CountryEnumCc, nil
	case "CO":
		return CountryEnumCo, nil
	case "KM":
		return CountryEnumKm, nil
	case "CG":
		return CountryEnumCg, nil
	case "CD":
		return CountryEnumCd, nil
	case "CK":
		return CountryEnumCk, nil
	case "CR":
		return CountryEnumCr, nil
	case "CI":
		return CountryEnumCi, nil
	case "HR":
		return CountryEnumHr, nil
	case "CU":
		return CountryEnumCu, nil
	case "CW":
		return CountryEnumCw, nil
	case "CY":
		return CountryEnumCy, nil
	case "CZ":
		return CountryEnumCz, nil
	case "DK":
		return CountryEnumDk, nil
	case "DJ":
		return CountryEnumDj, nil
	case "DM":
		return CountryEnumDm, nil
	case "DO":
		return CountryEnumDo, nil
	case "EC":
		return CountryEnumEc, nil
	case "EG":
		return CountryEnumEg, nil
	case "SV":
		return CountryEnumSv, nil
	case "GQ":
		return CountryEnumGq, nil
	case "ER":
		return CountryEnumEr, nil
	case "EE":
		return CountryEnumEe, nil
	case "SZ":
		return CountryEnumSz, nil
	case "ET":
		return CountryEnumEt, nil
	case "FK":
		return CountryEnumFk, nil
	case "FO":
		return CountryEnumFo, nil
	case "FJ":
		return CountryEnumFj, nil
	case "FI":
		return CountryEnumFi, nil
	case "FR":
		return CountryEnumFr, nil
	case "GF":
		return CountryEnumGf, nil
	case "PF":
		return CountryEnumPf, nil
	case "TF":
		return CountryEnumTf, nil
	case "GA":
		return CountryEnumGa, nil
	case "GM":
		return CountryEnumGm, nil
	case "GE":
		return CountryEnumGe, nil
	case "DE":
		return CountryEnumDe, nil
	case "GH":
		return CountryEnumGh, nil
	case "GI":
		return CountryEnumGi, nil
	case "GR":
		return CountryEnumGr, nil
	case "GL":
		return CountryEnumGl, nil
	case "GD":
		return CountryEnumGd, nil
	case "GP":
		return CountryEnumGp, nil
	case "GU":
		return CountryEnumGu, nil
	case "GT":
		return CountryEnumGt, nil
	case "GG":
		return CountryEnumGg, nil
	case "GN":
		return CountryEnumGn, nil
	case "GW":
		return CountryEnumGw, nil
	case "GY":
		return CountryEnumGy, nil
	case "HT":
		return CountryEnumHt, nil
	case "HM":
		return CountryEnumHm, nil
	case "VA":
		return CountryEnumVa, nil
	case "HN":
		return CountryEnumHn, nil
	case "HK":
		return CountryEnumHk, nil
	case "HU":
		return CountryEnumHu, nil
	case "IS":
		return CountryEnumIs, nil
	case "IN":
		return CountryEnumIn, nil
	case "ID":
		return CountryEnumId, nil
	case "IR":
		return CountryEnumIr, nil
	case "IQ":
		return CountryEnumIq, nil
	case "IE":
		return CountryEnumIe, nil
	case "IM":
		return CountryEnumIm, nil
	case "IL":
		return CountryEnumIl, nil
	case "IT":
		return CountryEnumIt, nil
	case "JM":
		return CountryEnumJm, nil
	case "JP":
		return CountryEnumJp, nil
	case "JE":
		return CountryEnumJe, nil
	case "JO":
		return CountryEnumJo, nil
	case "KZ":
		return CountryEnumKz, nil
	case "KE":
		return CountryEnumKe, nil
	case "KI":
		return CountryEnumKi, nil
	case "KW":
		return CountryEnumKw, nil
	case "KG":
		return CountryEnumKg, nil
	case "LA":
		return CountryEnumLa, nil
	case "LV":
		return CountryEnumLv, nil
	case "LB":
		return CountryEnumLb, nil
	case "LS":
		return CountryEnumLs, nil
	case "LR":
		return CountryEnumLr, nil
	case "LY":
		return CountryEnumLy, nil
	case "LI":
		return CountryEnumLi, nil
	case "LT":
		return CountryEnumLt, nil
	case "LU":
		return CountryEnumLu, nil
	case "MO":
		return CountryEnumMo, nil
	case "MG":
		return CountryEnumMg, nil
	case "MW":
		return CountryEnumMw, nil
	case "MY":
		return CountryEnumMy, nil
	case "MV":
		return CountryEnumMv, nil
	case "ML":
		return CountryEnumMl, nil
	case "MT":
		return CountryEnumMt, nil
	case "MH":
		return CountryEnumMh, nil
	case "MQ":
		return CountryEnumMq, nil
	case "MR":
		return CountryEnumMr, nil
	case "MU":
		return CountryEnumMu, nil
	case "YT":
		return CountryEnumYt, nil
	case "MX":
		return CountryEnumMx, nil
	case "FM":
		return CountryEnumFm, nil
	case "MD":
		return CountryEnumMd, nil
	case "MC":
		return CountryEnumMc, nil
	case "MN":
		return CountryEnumMn, nil
	case "ME":
		return CountryEnumMe, nil
	case "MS":
		return CountryEnumMs, nil
	case "MA":
		return CountryEnumMa, nil
	case "MZ":
		return CountryEnumMz, nil
	case "MM":
		return CountryEnumMm, nil
	case "NA":
		return CountryEnumNa, nil
	case "NR":
		return CountryEnumNr, nil
	case "NP":
		return CountryEnumNp, nil
	case "NL":
		return CountryEnumNl, nil
	case "NC":
		return CountryEnumNc, nil
	case "NZ":
		return CountryEnumNz, nil
	case "NI":
		return CountryEnumNi, nil
	case "NE":
		return CountryEnumNe, nil
	case "NG":
		return CountryEnumNg, nil
	case "NU":
		return CountryEnumNu, nil
	case "NF":
		return CountryEnumNf, nil
	case "KP":
		return CountryEnumKp, nil
	case "MK":
		return CountryEnumMk, nil
	case "MP":
		return CountryEnumMp, nil
	case "NO":
		return CountryEnumNo, nil
	case "OM":
		return CountryEnumOm, nil
	case "PK":
		return CountryEnumPk, nil
	case "PW":
		return CountryEnumPw, nil
	case "PS":
		return CountryEnumPs, nil
	case "PA":
		return CountryEnumPa, nil
	case "PG":
		return CountryEnumPg, nil
	case "PY":
		return CountryEnumPy, nil
	case "PE":
		return CountryEnumPe, nil
	case "PH":
		return CountryEnumPh, nil
	case "PN":
		return CountryEnumPn, nil
	case "PL":
		return CountryEnumPl, nil
	case "PT":
		return CountryEnumPt, nil
	case "PR":
		return CountryEnumPr, nil
	case "QA":
		return CountryEnumQa, nil
	case "RE":
		return CountryEnumRe, nil
	case "RO":
		return CountryEnumRo, nil
	case "RU":
		return CountryEnumRu, nil
	case "RW":
		return CountryEnumRw, nil
	case "BL":
		return CountryEnumBl, nil
	case "SH":
		return CountryEnumSh, nil
	case "KN":
		return CountryEnumKn, nil
	case "LC":
		return CountryEnumLc, nil
	case "MF":
		return CountryEnumMf, nil
	case "PM":
		return CountryEnumPm, nil
	case "VC":
		return CountryEnumVc, nil
	case "WS":
		return CountryEnumWs, nil
	case "SM":
		return CountryEnumSm, nil
	case "ST":
		return CountryEnumSt, nil
	case "SA":
		return CountryEnumSa, nil
	case "SN":
		return CountryEnumSn, nil
	case "RS":
		return CountryEnumRs, nil
	case "SC":
		return CountryEnumSc, nil
	case "SL":
		return CountryEnumSl, nil
	case "SG":
		return CountryEnumSg, nil
	case "SX":
		return CountryEnumSx, nil
	case "SK":
		return CountryEnumSk, nil
	case "SI":
		return CountryEnumSi, nil
	case "SB":
		return CountryEnumSb, nil
	case "SO":
		return CountryEnumSo, nil
	case "ZA":
		return CountryEnumZa, nil
	case "GS":
		return CountryEnumGs, nil
	case "KR":
		return CountryEnumKr, nil
	case "SS":
		return CountryEnumSs, nil
	case "ES":
		return CountryEnumEs, nil
	case "LK":
		return CountryEnumLk, nil
	case "SD":
		return CountryEnumSd, nil
	case "SR":
		return CountryEnumSr, nil
	case "SJ":
		return CountryEnumSj, nil
	case "SE":
		return CountryEnumSe, nil
	case "CH":
		return CountryEnumCh, nil
	case "SY":
		return CountryEnumSy, nil
	case "TW":
		return CountryEnumTw, nil
	case "TJ":
		return CountryEnumTj, nil
	case "TZ":
		return CountryEnumTz, nil
	case "TH":
		return CountryEnumTh, nil
	case "TL":
		return CountryEnumTl, nil
	case "TG":
		return CountryEnumTg, nil
	case "TK":
		return CountryEnumTk, nil
	case "TO":
		return CountryEnumTo, nil
	case "TT":
		return CountryEnumTt, nil
	case "TN":
		return CountryEnumTn, nil
	case "TR":
		return CountryEnumTr, nil
	case "TM":
		return CountryEnumTm, nil
	case "TC":
		return CountryEnumTc, nil
	case "TV":
		return CountryEnumTv, nil
	case "UG":
		return CountryEnumUg, nil
	case "UA":
		return CountryEnumUa, nil
	case "AE":
		return CountryEnumAe, nil
	case "GB":
		return CountryEnumGb, nil
	case "UM":
		return CountryEnumUm, nil
	case "US":
		return CountryEnumUs, nil
	case "UY":
		return CountryEnumUy, nil
	case "UZ":
		return CountryEnumUz, nil
	case "VU":
		return CountryEnumVu, nil
	case "VE":
		return CountryEnumVe, nil
	case "VN":
		return CountryEnumVn, nil
	case "VG":
		return CountryEnumVg, nil
	case "VI":
		return CountryEnumVi, nil
	case "WF":
		return CountryEnumWf, nil
	case "EH":
		return CountryEnumEh, nil
	case "YE":
		return CountryEnumYe, nil
	case "ZM":
		return CountryEnumZm, nil
	case "ZW":
		return CountryEnumZw, nil
	}
	var t CountryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountryEnum) Ptr() *CountryEnum {
	return &c
}

// # The DataPassthrough Object
// ### Description
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method" url:"method"`
	// The path of the request in the third party's platform.
	Path string `json:"path" url:"path"`
	// An optional override of the third party's base url for the request.
	BaseUrlOverride *string `json:"base_url_override,omitempty" url:"base_url_override,omitempty"`
	// The data with the request. You must include a `request_format` parameter matching the data's format
	Data *string `json:"data,omitempty" url:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty" url:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`
	RequestFormat *RequestFormatEnum     `json:"request_format,omitempty" url:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty" url:"normalize_response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DataPassthroughRequest) GetMethod() MethodEnum {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DataPassthroughRequest) GetPath() string {
	if d == nil {
		return ""
	}
	return d.Path
}

func (d *DataPassthroughRequest) GetBaseUrlOverride() *string {
	if d == nil {
		return nil
	}
	return d.BaseUrlOverride
}

func (d *DataPassthroughRequest) GetData() *string {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DataPassthroughRequest) GetMultipartFormData() []*MultipartFormFieldRequest {
	if d == nil {
		return nil
	}
	return d.MultipartFormData
}

func (d *DataPassthroughRequest) GetHeaders() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DataPassthroughRequest) GetRequestFormat() *RequestFormatEnum {
	if d == nil {
		return nil
	}
	return d.RequestFormat
}

func (d *DataPassthroughRequest) GetNormalizeResponse() *bool {
	if d == nil {
		return nil
	}
	return d.NormalizeResponse
}

func (d *DataPassthroughRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DataPassthroughRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DataPassthroughRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataPassthroughRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataPassthroughRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModeLog struct {
	LogId         string                `json:"log_id" url:"log_id"`
	DashboardView string                `json:"dashboard_view" url:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary" url:"log_summary"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModeLog) GetLogId() string {
	if d == nil {
		return ""
	}
	return d.LogId
}

func (d *DebugModeLog) GetDashboardView() string {
	if d == nil {
		return ""
	}
	return d.DashboardView
}

func (d *DebugModeLog) GetLogSummary() *DebugModelLogSummary {
	if d == nil {
		return nil
	}
	return d.LogSummary
}

func (d *DebugModeLog) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModeLog) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModeLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModeLog(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModeLog) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModelLogSummary struct {
	Url        string `json:"url" url:"url"`
	Method     string `json:"method" url:"method"`
	StatusCode int    `json:"status_code" url:"status_code"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModelLogSummary) GetUrl() string {
	if d == nil {
		return ""
	}
	return d.Url
}

func (d *DebugModelLogSummary) GetMethod() string {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DebugModelLogSummary) GetStatusCode() int {
	if d == nil {
		return 0
	}
	return d.StatusCode
}

func (d *DebugModelLogSummary) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModelLogSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModelLogSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModelLogSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModelLogSummary) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The Employee Object
// ### Description
// The `Employee` object is used to represent any person who has been employed by a company. By default, it returns all employees. To filter for only active employees, set the `employment_status` query parameter to `ACTIVE`.
//
// ### Usage Example
// Fetch from the `LIST Employee` endpoint and filter by `ID` to show all employees.
type Employee struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The employee's number that appears in the third-party integration's UI.
	EmployeeNumber *string `json:"employee_number,omitempty" url:"employee_number,omitempty"`
	// The ID of the employee's company.
	Company *EmployeeCompany `json:"company,omitempty" url:"company,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`
	// The employee's preferred first name.
	PreferredName *string `json:"preferred_name,omitempty" url:"preferred_name,omitempty"`
	// The employee's full name, to use for display purposes. If a preferred first name is available, the full name will include the preferred first name.
	DisplayFullName *string `json:"display_full_name,omitempty" url:"display_full_name,omitempty"`
	// The employee's username that appears in the remote UI.
	Username *string               `json:"username,omitempty" url:"username,omitempty"`
	Groups   []*EmployeeGroupsItem `json:"groups,omitempty" url:"groups,omitempty"`
	// The employee's work email.
	WorkEmail *string `json:"work_email,omitempty" url:"work_email,omitempty"`
	// The employee's personal email.
	PersonalEmail *string `json:"personal_email,omitempty" url:"personal_email,omitempty"`
	// The employee's mobile phone number.
	MobilePhoneNumber *string `json:"mobile_phone_number,omitempty" url:"mobile_phone_number,omitempty"`
	// Array of `Employment` IDs for this Employee.
	Employments []*EmployeeEmploymentsItem `json:"employments,omitempty" url:"employments,omitempty"`
	// The employee's home address.
	HomeLocation *EmployeeHomeLocation `json:"home_location,omitempty" url:"home_location,omitempty"`
	// The employee's work address.
	WorkLocation *EmployeeWorkLocation `json:"work_location,omitempty" url:"work_location,omitempty"`
	// The employee ID of the employee's manager.
	Manager *EmployeeManager `json:"manager,omitempty" url:"manager,omitempty"`
	// The employee's team.
	Team *EmployeeTeam `json:"team,omitempty" url:"team,omitempty"`
	// The employee's pay group
	PayGroup *EmployeePayGroup `json:"pay_group,omitempty" url:"pay_group,omitempty"`
	// The employee's social security number.
	Ssn *string `json:"ssn,omitempty" url:"ssn,omitempty"`
	// The employee's gender.
	//
	// * `MALE` - MALE
	// * `FEMALE` - FEMALE
	// * `NON-BINARY` - NON-BINARY
	// * `OTHER` - OTHER
	// * `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Gender *EmployeeGender `json:"gender,omitempty" url:"gender,omitempty"`
	// The employee's ethnicity.
	//
	// * `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
	// * `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
	// * `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
	// * `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
	// * `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
	// * `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
	// * `WHITE` - WHITE
	// * `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
	Ethnicity *EmployeeEthnicity `json:"ethnicity,omitempty" url:"ethnicity,omitempty"`
	// The employee's filing status as related to marital status.
	//
	// * `SINGLE` - SINGLE
	// * `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
	// * `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
	// * `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
	// * `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
	MaritalStatus *EmployeeMaritalStatus `json:"marital_status,omitempty" url:"marital_status,omitempty"`
	// The employee's date of birth.
	DateOfBirth *time.Time `json:"date_of_birth,omitempty" url:"date_of_birth,omitempty"`
	// The date that the employee was hired, usually the day that an offer letter is signed. If an employee has multiple hire dates from previous employments, this represents the most recent hire date. Note: If you're looking for the employee's start date, refer to the start_date field.
	HireDate *time.Time `json:"hire_date,omitempty" url:"hire_date,omitempty"`
	// The date that the employee started working. If an employee was rehired, the most recent start date will be returned.
	StartDate *time.Time `json:"start_date,omitempty" url:"start_date,omitempty"`
	// When the third party's employee was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// The employment status of the employee.
	//
	// * `ACTIVE` - ACTIVE
	// * `PENDING` - PENDING
	// * `INACTIVE` - INACTIVE
	EmploymentStatus *EmployeeEmploymentStatus `json:"employment_status,omitempty" url:"employment_status,omitempty"`
	// The employee's termination date.
	TerminationDate *time.Time `json:"termination_date,omitempty" url:"termination_date,omitempty"`
	// The URL of the employee's avatar image.
	Avatar *string `json:"avatar,omitempty" url:"avatar,omitempty"`
	// Custom fields configured for a given model.
	CustomFields map[string]interface{} `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Employee) GetId() *string {
	if e == nil {
		return nil
	}
	return e.Id
}

func (e *Employee) GetRemoteId() *string {
	if e == nil {
		return nil
	}
	return e.RemoteId
}

func (e *Employee) GetCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *Employee) GetModifiedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.ModifiedAt
}

func (e *Employee) GetEmployeeNumber() *string {
	if e == nil {
		return nil
	}
	return e.EmployeeNumber
}

func (e *Employee) GetCompany() *EmployeeCompany {
	if e == nil {
		return nil
	}
	return e.Company
}

func (e *Employee) GetFirstName() *string {
	if e == nil {
		return nil
	}
	return e.FirstName
}

func (e *Employee) GetLastName() *string {
	if e == nil {
		return nil
	}
	return e.LastName
}

func (e *Employee) GetPreferredName() *string {
	if e == nil {
		return nil
	}
	return e.PreferredName
}

func (e *Employee) GetDisplayFullName() *string {
	if e == nil {
		return nil
	}
	return e.DisplayFullName
}

func (e *Employee) GetUsername() *string {
	if e == nil {
		return nil
	}
	return e.Username
}

func (e *Employee) GetGroups() []*EmployeeGroupsItem {
	if e == nil {
		return nil
	}
	return e.Groups
}

func (e *Employee) GetWorkEmail() *string {
	if e == nil {
		return nil
	}
	return e.WorkEmail
}

func (e *Employee) GetPersonalEmail() *string {
	if e == nil {
		return nil
	}
	return e.PersonalEmail
}

func (e *Employee) GetMobilePhoneNumber() *string {
	if e == nil {
		return nil
	}
	return e.MobilePhoneNumber
}

func (e *Employee) GetEmployments() []*EmployeeEmploymentsItem {
	if e == nil {
		return nil
	}
	return e.Employments
}

func (e *Employee) GetHomeLocation() *EmployeeHomeLocation {
	if e == nil {
		return nil
	}
	return e.HomeLocation
}

func (e *Employee) GetWorkLocation() *EmployeeWorkLocation {
	if e == nil {
		return nil
	}
	return e.WorkLocation
}

func (e *Employee) GetManager() *EmployeeManager {
	if e == nil {
		return nil
	}
	return e.Manager
}

func (e *Employee) GetTeam() *EmployeeTeam {
	if e == nil {
		return nil
	}
	return e.Team
}

func (e *Employee) GetPayGroup() *EmployeePayGroup {
	if e == nil {
		return nil
	}
	return e.PayGroup
}

func (e *Employee) GetSsn() *string {
	if e == nil {
		return nil
	}
	return e.Ssn
}

func (e *Employee) GetGender() *EmployeeGender {
	if e == nil {
		return nil
	}
	return e.Gender
}

func (e *Employee) GetEthnicity() *EmployeeEthnicity {
	if e == nil {
		return nil
	}
	return e.Ethnicity
}

func (e *Employee) GetMaritalStatus() *EmployeeMaritalStatus {
	if e == nil {
		return nil
	}
	return e.MaritalStatus
}

func (e *Employee) GetDateOfBirth() *time.Time {
	if e == nil {
		return nil
	}
	return e.DateOfBirth
}

func (e *Employee) GetHireDate() *time.Time {
	if e == nil {
		return nil
	}
	return e.HireDate
}

func (e *Employee) GetStartDate() *time.Time {
	if e == nil {
		return nil
	}
	return e.StartDate
}

func (e *Employee) GetRemoteCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.RemoteCreatedAt
}

func (e *Employee) GetEmploymentStatus() *EmployeeEmploymentStatus {
	if e == nil {
		return nil
	}
	return e.EmploymentStatus
}

func (e *Employee) GetTerminationDate() *time.Time {
	if e == nil {
		return nil
	}
	return e.TerminationDate
}

func (e *Employee) GetAvatar() *string {
	if e == nil {
		return nil
	}
	return e.Avatar
}

func (e *Employee) GetCustomFields() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.CustomFields
}

func (e *Employee) GetRemoteWasDeleted() *bool {
	if e == nil {
		return nil
	}
	return e.RemoteWasDeleted
}

func (e *Employee) GetFieldMappings() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.FieldMappings
}

func (e *Employee) GetRemoteData() []*RemoteData {
	if e == nil {
		return nil
	}
	return e.RemoteData
}

func (e *Employee) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Employee) UnmarshalJSON(data []byte) error {
	type embed Employee
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		DateOfBirth     *internal.DateTime `json:"date_of_birth,omitempty"`
		HireDate        *internal.DateTime `json:"hire_date,omitempty"`
		StartDate       *internal.DateTime `json:"start_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		TerminationDate *internal.DateTime `json:"termination_date,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Employee(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	e.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	e.DateOfBirth = unmarshaler.DateOfBirth.TimePtr()
	e.HireDate = unmarshaler.HireDate.TimePtr()
	e.StartDate = unmarshaler.StartDate.TimePtr()
	e.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	e.TerminationDate = unmarshaler.TerminationDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Employee) MarshalJSON() ([]byte, error) {
	type embed Employee
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		DateOfBirth     *internal.DateTime `json:"date_of_birth,omitempty"`
		HireDate        *internal.DateTime `json:"hire_date,omitempty"`
		StartDate       *internal.DateTime `json:"start_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		TerminationDate *internal.DateTime `json:"termination_date,omitempty"`
	}{
		embed:           embed(*e),
		CreatedAt:       internal.NewOptionalDateTime(e.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(e.ModifiedAt),
		DateOfBirth:     internal.NewOptionalDateTime(e.DateOfBirth),
		HireDate:        internal.NewOptionalDateTime(e.HireDate),
		StartDate:       internal.NewOptionalDateTime(e.StartDate),
		RemoteCreatedAt: internal.NewOptionalDateTime(e.RemoteCreatedAt),
		TerminationDate: internal.NewOptionalDateTime(e.TerminationDate),
	}
	return json.Marshal(marshaler)
}

func (e *Employee) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The ID of the employee's company.
type EmployeeCompany struct {
	String  string
	Company *Company

	typ string
}

func (e *EmployeeCompany) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeCompany) GetCompany() *Company {
	if e == nil {
		return nil
	}
	return e.Company
}

func (e *EmployeeCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueCompany := new(Company)
	if err := json.Unmarshal(data, &valueCompany); err == nil {
		e.typ = "Company"
		e.Company = valueCompany
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeCompany) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Company" || e.Company != nil {
		return json.Marshal(e.Company)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeCompanyVisitor interface {
	VisitString(string) error
	VisitCompany(*Company) error
}

func (e *EmployeeCompany) Accept(visitor EmployeeCompanyVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Company" || e.Company != nil {
		return visitor.VisitCompany(e.Company)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employment status of the employee.
//
// * `ACTIVE` - ACTIVE
// * `PENDING` - PENDING
// * `INACTIVE` - INACTIVE
type EmployeeEmploymentStatus struct {
	EmploymentStatusEnum EmploymentStatusEnum
	String               string

	typ string
}

func (e *EmployeeEmploymentStatus) GetEmploymentStatusEnum() EmploymentStatusEnum {
	if e == nil {
		return ""
	}
	return e.EmploymentStatusEnum
}

func (e *EmployeeEmploymentStatus) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeEmploymentStatus) UnmarshalJSON(data []byte) error {
	var valueEmploymentStatusEnum EmploymentStatusEnum
	if err := json.Unmarshal(data, &valueEmploymentStatusEnum); err == nil {
		e.typ = "EmploymentStatusEnum"
		e.EmploymentStatusEnum = valueEmploymentStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEmploymentStatus) MarshalJSON() ([]byte, error) {
	if e.typ == "EmploymentStatusEnum" || e.EmploymentStatusEnum != "" {
		return json.Marshal(e.EmploymentStatusEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeEmploymentStatusVisitor interface {
	VisitEmploymentStatusEnum(EmploymentStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeEmploymentStatus) Accept(visitor EmployeeEmploymentStatusVisitor) error {
	if e.typ == "EmploymentStatusEnum" || e.EmploymentStatusEnum != "" {
		return visitor.VisitEmploymentStatusEnum(e.EmploymentStatusEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeEmploymentsItem struct {
	String     string
	Employment *Employment

	typ string
}

func (e *EmployeeEmploymentsItem) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeEmploymentsItem) GetEmployment() *Employment {
	if e == nil {
		return nil
	}
	return e.Employment
}

func (e *EmployeeEmploymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueEmployment := new(Employment)
	if err := json.Unmarshal(data, &valueEmployment); err == nil {
		e.typ = "Employment"
		e.Employment = valueEmployment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEmploymentsItem) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Employment" || e.Employment != nil {
		return json.Marshal(e.Employment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeEmploymentsItemVisitor interface {
	VisitString(string) error
	VisitEmployment(*Employment) error
}

func (e *EmployeeEmploymentsItem) Accept(visitor EmployeeEmploymentsItemVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Employment" || e.Employment != nil {
		return visitor.VisitEmployment(e.Employment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employee's ethnicity.
//
// * `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
// * `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
// * `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// * `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// * `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// * `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// * `WHITE` - WHITE
// * `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeEthnicity struct {
	EthnicityEnum EthnicityEnum
	String        string

	typ string
}

func (e *EmployeeEthnicity) GetEthnicityEnum() EthnicityEnum {
	if e == nil {
		return ""
	}
	return e.EthnicityEnum
}

func (e *EmployeeEthnicity) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeEthnicity) UnmarshalJSON(data []byte) error {
	var valueEthnicityEnum EthnicityEnum
	if err := json.Unmarshal(data, &valueEthnicityEnum); err == nil {
		e.typ = "EthnicityEnum"
		e.EthnicityEnum = valueEthnicityEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeEthnicity) MarshalJSON() ([]byte, error) {
	if e.typ == "EthnicityEnum" || e.EthnicityEnum != "" {
		return json.Marshal(e.EthnicityEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeEthnicityVisitor interface {
	VisitEthnicityEnum(EthnicityEnum) error
	VisitString(string) error
}

func (e *EmployeeEthnicity) Accept(visitor EmployeeEthnicityVisitor) error {
	if e.typ == "EthnicityEnum" || e.EthnicityEnum != "" {
		return visitor.VisitEthnicityEnum(e.EthnicityEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employee's gender.
//
// * `MALE` - MALE
// * `FEMALE` - FEMALE
// * `NON-BINARY` - NON-BINARY
// * `OTHER` - OTHER
// * `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EmployeeGender struct {
	GenderEnum GenderEnum
	String     string

	typ string
}

func (e *EmployeeGender) GetGenderEnum() GenderEnum {
	if e == nil {
		return ""
	}
	return e.GenderEnum
}

func (e *EmployeeGender) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeGender) UnmarshalJSON(data []byte) error {
	var valueGenderEnum GenderEnum
	if err := json.Unmarshal(data, &valueGenderEnum); err == nil {
		e.typ = "GenderEnum"
		e.GenderEnum = valueGenderEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeGender) MarshalJSON() ([]byte, error) {
	if e.typ == "GenderEnum" || e.GenderEnum != "" {
		return json.Marshal(e.GenderEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeGenderVisitor interface {
	VisitGenderEnum(GenderEnum) error
	VisitString(string) error
}

func (e *EmployeeGender) Accept(visitor EmployeeGenderVisitor) error {
	if e.typ == "GenderEnum" || e.GenderEnum != "" {
		return visitor.VisitGenderEnum(e.GenderEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeGroupsItem struct {
	String string
	Group  *Group

	typ string
}

func (e *EmployeeGroupsItem) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeGroupsItem) GetGroup() *Group {
	if e == nil {
		return nil
	}
	return e.Group
}

func (e *EmployeeGroupsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		e.typ = "Group"
		e.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeGroupsItem) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Group" || e.Group != nil {
		return json.Marshal(e.Group)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeGroupsItemVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (e *EmployeeGroupsItem) Accept(visitor EmployeeGroupsItemVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Group" || e.Group != nil {
		return visitor.VisitGroup(e.Group)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employee's home address.
type EmployeeHomeLocation struct {
	String   string
	Location *Location

	typ string
}

func (e *EmployeeHomeLocation) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeHomeLocation) GetLocation() *Location {
	if e == nil {
		return nil
	}
	return e.Location
}

func (e *EmployeeHomeLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typ = "Location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeHomeLocation) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Location" || e.Location != nil {
		return json.Marshal(e.Location)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeHomeLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeHomeLocation) Accept(visitor EmployeeHomeLocationVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Location" || e.Location != nil {
		return visitor.VisitLocation(e.Location)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employee ID of the employee's manager.
type EmployeeManager struct {
	String   string
	Employee *Employee

	typ string
}

func (e *EmployeeManager) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeManager) GetEmployee() *Employee {
	if e == nil {
		return nil
	}
	return e.Employee
}

func (e *EmployeeManager) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typ = "Employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeManager) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Employee" || e.Employee != nil {
		return json.Marshal(e.Employee)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeManagerVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmployeeManager) Accept(visitor EmployeeManagerVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Employee" || e.Employee != nil {
		return visitor.VisitEmployee(e.Employee)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employee's filing status as related to marital status.
//
// * `SINGLE` - SINGLE
// * `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
// * `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
// * `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
// * `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
type EmployeeMaritalStatus struct {
	MaritalStatusEnum MaritalStatusEnum
	String            string

	typ string
}

func (e *EmployeeMaritalStatus) GetMaritalStatusEnum() MaritalStatusEnum {
	if e == nil {
		return ""
	}
	return e.MaritalStatusEnum
}

func (e *EmployeeMaritalStatus) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeMaritalStatus) UnmarshalJSON(data []byte) error {
	var valueMaritalStatusEnum MaritalStatusEnum
	if err := json.Unmarshal(data, &valueMaritalStatusEnum); err == nil {
		e.typ = "MaritalStatusEnum"
		e.MaritalStatusEnum = valueMaritalStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeMaritalStatus) MarshalJSON() ([]byte, error) {
	if e.typ == "MaritalStatusEnum" || e.MaritalStatusEnum != "" {
		return json.Marshal(e.MaritalStatusEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeMaritalStatusVisitor interface {
	VisitMaritalStatusEnum(MaritalStatusEnum) error
	VisitString(string) error
}

func (e *EmployeeMaritalStatus) Accept(visitor EmployeeMaritalStatusVisitor) error {
	if e.typ == "MaritalStatusEnum" || e.MaritalStatusEnum != "" {
		return visitor.VisitMaritalStatusEnum(e.MaritalStatusEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employee's pay group
type EmployeePayGroup struct {
	String   string
	PayGroup *PayGroup

	typ string
}

func (e *EmployeePayGroup) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeePayGroup) GetPayGroup() *PayGroup {
	if e == nil {
		return nil
	}
	return e.PayGroup
}

func (e *EmployeePayGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valuePayGroup := new(PayGroup)
	if err := json.Unmarshal(data, &valuePayGroup); err == nil {
		e.typ = "PayGroup"
		e.PayGroup = valuePayGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeePayGroup) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "PayGroup" || e.PayGroup != nil {
		return json.Marshal(e.PayGroup)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeePayGroupVisitor interface {
	VisitString(string) error
	VisitPayGroup(*PayGroup) error
}

func (e *EmployeePayGroup) Accept(visitor EmployeePayGroupVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "PayGroup" || e.PayGroup != nil {
		return visitor.VisitPayGroup(e.PayGroup)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employee's team.
type EmployeeTeam struct {
	String string
	Team   *Team

	typ string
}

func (e *EmployeeTeam) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeTeam) GetTeam() *Team {
	if e == nil {
		return nil
	}
	return e.Team
}

func (e *EmployeeTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		e.typ = "Team"
		e.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeTeam) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Team" || e.Team != nil {
		return json.Marshal(e.Team)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (e *EmployeeTeam) Accept(visitor EmployeeTeamVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Team" || e.Team != nil {
		return visitor.VisitTeam(e.Team)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employee's work address.
type EmployeeWorkLocation struct {
	String   string
	Location *Location

	typ string
}

func (e *EmployeeWorkLocation) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeWorkLocation) GetLocation() *Location {
	if e == nil {
		return nil
	}
	return e.Location
}

func (e *EmployeeWorkLocation) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueLocation := new(Location)
	if err := json.Unmarshal(data, &valueLocation); err == nil {
		e.typ = "Location"
		e.Location = valueLocation
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeWorkLocation) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Location" || e.Location != nil {
		return json.Marshal(e.Location)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeWorkLocationVisitor interface {
	VisitString(string) error
	VisitLocation(*Location) error
}

func (e *EmployeeWorkLocation) Accept(visitor EmployeeWorkLocationVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Location" || e.Location != nil {
		return visitor.VisitLocation(e.Location)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// # The Employment Object
// ### Description
// The `Employment` object is used to represent a job position at a company.
//
// If an integration supports historical tracking of employments, it will be reflected in the data. If not, a new `Employment` object will be created whenever there is a change in job title or pay. The `effective_date` field should be used to order `Employment` objects, with the most recent date corresponding to the latest employment record for an employee.
//
// ### Usage Example
// Fetch from the `LIST Employments` endpoint and filter by `ID` to show all employees.
type Employment struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The employee holding this position.
	Employee *EmploymentEmployee `json:"employee,omitempty" url:"employee,omitempty"`
	// The position's title.
	JobTitle *string `json:"job_title,omitempty" url:"job_title,omitempty"`
	// The position's pay rate.
	PayRate *float64 `json:"pay_rate,omitempty" url:"pay_rate,omitempty"`
	// The time period this pay rate encompasses.
	//
	// * `HOUR` - HOUR
	// * `DAY` - DAY
	// * `WEEK` - WEEK
	// * `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
	// * `SEMIMONTHLY` - SEMIMONTHLY
	// * `MONTH` - MONTH
	// * `QUARTER` - QUARTER
	// * `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
	// * `YEAR` - YEAR
	PayPeriod *EmploymentPayPeriod `json:"pay_period,omitempty" url:"pay_period,omitempty"`
	// The position's pay frequency.
	//
	// * `WEEKLY` - WEEKLY
	// * `BIWEEKLY` - BIWEEKLY
	// * `MONTHLY` - MONTHLY
	// * `QUARTERLY` - QUARTERLY
	// * `SEMIANNUALLY` - SEMIANNUALLY
	// * `ANNUALLY` - ANNUALLY
	// * `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
	// * `PRO_RATA` - PRO_RATA
	// * `SEMIMONTHLY` - SEMIMONTHLY
	PayFrequency *EmploymentPayFrequency `json:"pay_frequency,omitempty" url:"pay_frequency,omitempty"`
	// The position's currency code.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	PayCurrency *EmploymentPayCurrency `json:"pay_currency,omitempty" url:"pay_currency,omitempty"`
	// The employment's pay group
	PayGroup *EmploymentPayGroup `json:"pay_group,omitempty" url:"pay_group,omitempty"`
	// The position's FLSA status.
	//
	// * `EXEMPT` - EXEMPT
	// * `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
	// * `NONEXEMPT` - NONEXEMPT
	// * `OWNER` - OWNER
	FlsaStatus *EmploymentFlsaStatus `json:"flsa_status,omitempty" url:"flsa_status,omitempty"`
	// The position's effective date.
	EffectiveDate *time.Time `json:"effective_date,omitempty" url:"effective_date,omitempty"`
	// The position's type of employment.
	//
	// * `FULL_TIME` - FULL_TIME
	// * `PART_TIME` - PART_TIME
	// * `INTERN` - INTERN
	// * `CONTRACTOR` - CONTRACTOR
	// * `FREELANCE` - FREELANCE
	EmploymentType *EmploymentEmploymentType `json:"employment_type,omitempty" url:"employment_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Employment) GetId() *string {
	if e == nil {
		return nil
	}
	return e.Id
}

func (e *Employment) GetRemoteId() *string {
	if e == nil {
		return nil
	}
	return e.RemoteId
}

func (e *Employment) GetCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *Employment) GetModifiedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.ModifiedAt
}

func (e *Employment) GetEmployee() *EmploymentEmployee {
	if e == nil {
		return nil
	}
	return e.Employee
}

func (e *Employment) GetJobTitle() *string {
	if e == nil {
		return nil
	}
	return e.JobTitle
}

func (e *Employment) GetPayRate() *float64 {
	if e == nil {
		return nil
	}
	return e.PayRate
}

func (e *Employment) GetPayPeriod() *EmploymentPayPeriod {
	if e == nil {
		return nil
	}
	return e.PayPeriod
}

func (e *Employment) GetPayFrequency() *EmploymentPayFrequency {
	if e == nil {
		return nil
	}
	return e.PayFrequency
}

func (e *Employment) GetPayCurrency() *EmploymentPayCurrency {
	if e == nil {
		return nil
	}
	return e.PayCurrency
}

func (e *Employment) GetPayGroup() *EmploymentPayGroup {
	if e == nil {
		return nil
	}
	return e.PayGroup
}

func (e *Employment) GetFlsaStatus() *EmploymentFlsaStatus {
	if e == nil {
		return nil
	}
	return e.FlsaStatus
}

func (e *Employment) GetEffectiveDate() *time.Time {
	if e == nil {
		return nil
	}
	return e.EffectiveDate
}

func (e *Employment) GetEmploymentType() *EmploymentEmploymentType {
	if e == nil {
		return nil
	}
	return e.EmploymentType
}

func (e *Employment) GetRemoteWasDeleted() *bool {
	if e == nil {
		return nil
	}
	return e.RemoteWasDeleted
}

func (e *Employment) GetFieldMappings() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.FieldMappings
}

func (e *Employment) GetRemoteData() []*RemoteData {
	if e == nil {
		return nil
	}
	return e.RemoteData
}

func (e *Employment) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Employment) UnmarshalJSON(data []byte) error {
	type embed Employment
	var unmarshaler = struct {
		embed
		CreatedAt     *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt    *internal.DateTime `json:"modified_at,omitempty"`
		EffectiveDate *internal.DateTime `json:"effective_date,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Employment(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	e.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	e.EffectiveDate = unmarshaler.EffectiveDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Employment) MarshalJSON() ([]byte, error) {
	type embed Employment
	var marshaler = struct {
		embed
		CreatedAt     *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt    *internal.DateTime `json:"modified_at,omitempty"`
		EffectiveDate *internal.DateTime `json:"effective_date,omitempty"`
	}{
		embed:         embed(*e),
		CreatedAt:     internal.NewOptionalDateTime(e.CreatedAt),
		ModifiedAt:    internal.NewOptionalDateTime(e.ModifiedAt),
		EffectiveDate: internal.NewOptionalDateTime(e.EffectiveDate),
	}
	return json.Marshal(marshaler)
}

func (e *Employment) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The employee holding this position.
type EmploymentEmployee struct {
	String   string
	Employee *Employee

	typ string
}

func (e *EmploymentEmployee) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmploymentEmployee) GetEmployee() *Employee {
	if e == nil {
		return nil
	}
	return e.Employee
}

func (e *EmploymentEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typ = "Employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentEmployee) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Employee" || e.Employee != nil {
		return json.Marshal(e.Employee)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmploymentEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *EmploymentEmployee) Accept(visitor EmploymentEmployeeVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Employee" || e.Employee != nil {
		return visitor.VisitEmployee(e.Employee)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The position's type of employment.
//
// * `FULL_TIME` - FULL_TIME
// * `PART_TIME` - PART_TIME
// * `INTERN` - INTERN
// * `CONTRACTOR` - CONTRACTOR
// * `FREELANCE` - FREELANCE
type EmploymentEmploymentType struct {
	EmploymentTypeEnum EmploymentTypeEnum
	String             string

	typ string
}

func (e *EmploymentEmploymentType) GetEmploymentTypeEnum() EmploymentTypeEnum {
	if e == nil {
		return ""
	}
	return e.EmploymentTypeEnum
}

func (e *EmploymentEmploymentType) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmploymentEmploymentType) UnmarshalJSON(data []byte) error {
	var valueEmploymentTypeEnum EmploymentTypeEnum
	if err := json.Unmarshal(data, &valueEmploymentTypeEnum); err == nil {
		e.typ = "EmploymentTypeEnum"
		e.EmploymentTypeEnum = valueEmploymentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentEmploymentType) MarshalJSON() ([]byte, error) {
	if e.typ == "EmploymentTypeEnum" || e.EmploymentTypeEnum != "" {
		return json.Marshal(e.EmploymentTypeEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmploymentEmploymentTypeVisitor interface {
	VisitEmploymentTypeEnum(EmploymentTypeEnum) error
	VisitString(string) error
}

func (e *EmploymentEmploymentType) Accept(visitor EmploymentEmploymentTypeVisitor) error {
	if e.typ == "EmploymentTypeEnum" || e.EmploymentTypeEnum != "" {
		return visitor.VisitEmploymentTypeEnum(e.EmploymentTypeEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The position's FLSA status.
//
// * `EXEMPT` - EXEMPT
// * `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
// * `NONEXEMPT` - NONEXEMPT
// * `OWNER` - OWNER
type EmploymentFlsaStatus struct {
	FlsaStatusEnum FlsaStatusEnum
	String         string

	typ string
}

func (e *EmploymentFlsaStatus) GetFlsaStatusEnum() FlsaStatusEnum {
	if e == nil {
		return ""
	}
	return e.FlsaStatusEnum
}

func (e *EmploymentFlsaStatus) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmploymentFlsaStatus) UnmarshalJSON(data []byte) error {
	var valueFlsaStatusEnum FlsaStatusEnum
	if err := json.Unmarshal(data, &valueFlsaStatusEnum); err == nil {
		e.typ = "FlsaStatusEnum"
		e.FlsaStatusEnum = valueFlsaStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentFlsaStatus) MarshalJSON() ([]byte, error) {
	if e.typ == "FlsaStatusEnum" || e.FlsaStatusEnum != "" {
		return json.Marshal(e.FlsaStatusEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmploymentFlsaStatusVisitor interface {
	VisitFlsaStatusEnum(FlsaStatusEnum) error
	VisitString(string) error
}

func (e *EmploymentFlsaStatus) Accept(visitor EmploymentFlsaStatusVisitor) error {
	if e.typ == "FlsaStatusEnum" || e.FlsaStatusEnum != "" {
		return visitor.VisitFlsaStatusEnum(e.FlsaStatusEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The position's currency code.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type EmploymentPayCurrency struct {
	PayCurrencyEnum PayCurrencyEnum
	String          string

	typ string
}

func (e *EmploymentPayCurrency) GetPayCurrencyEnum() PayCurrencyEnum {
	if e == nil {
		return ""
	}
	return e.PayCurrencyEnum
}

func (e *EmploymentPayCurrency) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmploymentPayCurrency) UnmarshalJSON(data []byte) error {
	var valuePayCurrencyEnum PayCurrencyEnum
	if err := json.Unmarshal(data, &valuePayCurrencyEnum); err == nil {
		e.typ = "PayCurrencyEnum"
		e.PayCurrencyEnum = valuePayCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayCurrency) MarshalJSON() ([]byte, error) {
	if e.typ == "PayCurrencyEnum" || e.PayCurrencyEnum != "" {
		return json.Marshal(e.PayCurrencyEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmploymentPayCurrencyVisitor interface {
	VisitPayCurrencyEnum(PayCurrencyEnum) error
	VisitString(string) error
}

func (e *EmploymentPayCurrency) Accept(visitor EmploymentPayCurrencyVisitor) error {
	if e.typ == "PayCurrencyEnum" || e.PayCurrencyEnum != "" {
		return visitor.VisitPayCurrencyEnum(e.PayCurrencyEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The position's pay frequency.
//
// * `WEEKLY` - WEEKLY
// * `BIWEEKLY` - BIWEEKLY
// * `MONTHLY` - MONTHLY
// * `QUARTERLY` - QUARTERLY
// * `SEMIANNUALLY` - SEMIANNUALLY
// * `ANNUALLY` - ANNUALLY
// * `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
// * `PRO_RATA` - PRO_RATA
// * `SEMIMONTHLY` - SEMIMONTHLY
type EmploymentPayFrequency struct {
	PayFrequencyEnum PayFrequencyEnum
	String           string

	typ string
}

func (e *EmploymentPayFrequency) GetPayFrequencyEnum() PayFrequencyEnum {
	if e == nil {
		return ""
	}
	return e.PayFrequencyEnum
}

func (e *EmploymentPayFrequency) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmploymentPayFrequency) UnmarshalJSON(data []byte) error {
	var valuePayFrequencyEnum PayFrequencyEnum
	if err := json.Unmarshal(data, &valuePayFrequencyEnum); err == nil {
		e.typ = "PayFrequencyEnum"
		e.PayFrequencyEnum = valuePayFrequencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayFrequency) MarshalJSON() ([]byte, error) {
	if e.typ == "PayFrequencyEnum" || e.PayFrequencyEnum != "" {
		return json.Marshal(e.PayFrequencyEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmploymentPayFrequencyVisitor interface {
	VisitPayFrequencyEnum(PayFrequencyEnum) error
	VisitString(string) error
}

func (e *EmploymentPayFrequency) Accept(visitor EmploymentPayFrequencyVisitor) error {
	if e.typ == "PayFrequencyEnum" || e.PayFrequencyEnum != "" {
		return visitor.VisitPayFrequencyEnum(e.PayFrequencyEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The employment's pay group
type EmploymentPayGroup struct {
	String   string
	PayGroup *PayGroup

	typ string
}

func (e *EmploymentPayGroup) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmploymentPayGroup) GetPayGroup() *PayGroup {
	if e == nil {
		return nil
	}
	return e.PayGroup
}

func (e *EmploymentPayGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valuePayGroup := new(PayGroup)
	if err := json.Unmarshal(data, &valuePayGroup); err == nil {
		e.typ = "PayGroup"
		e.PayGroup = valuePayGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayGroup) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "PayGroup" || e.PayGroup != nil {
		return json.Marshal(e.PayGroup)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmploymentPayGroupVisitor interface {
	VisitString(string) error
	VisitPayGroup(*PayGroup) error
}

func (e *EmploymentPayGroup) Accept(visitor EmploymentPayGroupVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "PayGroup" || e.PayGroup != nil {
		return visitor.VisitPayGroup(e.PayGroup)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The time period this pay rate encompasses.
//
// * `HOUR` - HOUR
// * `DAY` - DAY
// * `WEEK` - WEEK
// * `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
// * `SEMIMONTHLY` - SEMIMONTHLY
// * `MONTH` - MONTH
// * `QUARTER` - QUARTER
// * `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
// * `YEAR` - YEAR
type EmploymentPayPeriod struct {
	PayPeriodEnum PayPeriodEnum
	String        string

	typ string
}

func (e *EmploymentPayPeriod) GetPayPeriodEnum() PayPeriodEnum {
	if e == nil {
		return ""
	}
	return e.PayPeriodEnum
}

func (e *EmploymentPayPeriod) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmploymentPayPeriod) UnmarshalJSON(data []byte) error {
	var valuePayPeriodEnum PayPeriodEnum
	if err := json.Unmarshal(data, &valuePayPeriodEnum); err == nil {
		e.typ = "PayPeriodEnum"
		e.PayPeriodEnum = valuePayPeriodEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmploymentPayPeriod) MarshalJSON() ([]byte, error) {
	if e.typ == "PayPeriodEnum" || e.PayPeriodEnum != "" {
		return json.Marshal(e.PayPeriodEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmploymentPayPeriodVisitor interface {
	VisitPayPeriodEnum(PayPeriodEnum) error
	VisitString(string) error
}

func (e *EmploymentPayPeriod) Accept(visitor EmploymentPayPeriodVisitor) error {
	if e.typ == "PayPeriodEnum" || e.PayPeriodEnum != "" {
		return visitor.VisitPayPeriodEnum(e.PayPeriodEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// * `ACTIVE` - ACTIVE
// * `PENDING` - PENDING
// * `INACTIVE` - INACTIVE
type EmploymentStatusEnum string

const (
	EmploymentStatusEnumActive   EmploymentStatusEnum = "ACTIVE"
	EmploymentStatusEnumPending  EmploymentStatusEnum = "PENDING"
	EmploymentStatusEnumInactive EmploymentStatusEnum = "INACTIVE"
)

func NewEmploymentStatusEnumFromString(s string) (EmploymentStatusEnum, error) {
	switch s {
	case "ACTIVE":
		return EmploymentStatusEnumActive, nil
	case "PENDING":
		return EmploymentStatusEnumPending, nil
	case "INACTIVE":
		return EmploymentStatusEnumInactive, nil
	}
	var t EmploymentStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmploymentStatusEnum) Ptr() *EmploymentStatusEnum {
	return &e
}

// * `FULL_TIME` - FULL_TIME
// * `PART_TIME` - PART_TIME
// * `INTERN` - INTERN
// * `CONTRACTOR` - CONTRACTOR
// * `FREELANCE` - FREELANCE
type EmploymentTypeEnum string

const (
	EmploymentTypeEnumFullTime   EmploymentTypeEnum = "FULL_TIME"
	EmploymentTypeEnumPartTime   EmploymentTypeEnum = "PART_TIME"
	EmploymentTypeEnumIntern     EmploymentTypeEnum = "INTERN"
	EmploymentTypeEnumContractor EmploymentTypeEnum = "CONTRACTOR"
	EmploymentTypeEnumFreelance  EmploymentTypeEnum = "FREELANCE"
)

func NewEmploymentTypeEnumFromString(s string) (EmploymentTypeEnum, error) {
	switch s {
	case "FULL_TIME":
		return EmploymentTypeEnumFullTime, nil
	case "PART_TIME":
		return EmploymentTypeEnumPartTime, nil
	case "INTERN":
		return EmploymentTypeEnumIntern, nil
	case "CONTRACTOR":
		return EmploymentTypeEnumContractor, nil
	case "FREELANCE":
		return EmploymentTypeEnumFreelance, nil
	}
	var t EmploymentTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmploymentTypeEnum) Ptr() *EmploymentTypeEnum {
	return &e
}

// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum string

const (
	EncodingEnumRaw        EncodingEnum = "RAW"
	EncodingEnumBase64     EncodingEnum = "BASE64"
	EncodingEnumGzipBase64 EncodingEnum = "GZIP_BASE64"
)

func NewEncodingEnumFromString(s string) (EncodingEnum, error) {
	switch s {
	case "RAW":
		return EncodingEnumRaw, nil
	case "BASE64":
		return EncodingEnumBase64, nil
	case "GZIP_BASE64":
		return EncodingEnumGzipBase64, nil
	}
	var t EncodingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncodingEnum) Ptr() *EncodingEnum {
	return &e
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorValidationProblem) GetSource() *ValidationProblemSource {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *ErrorValidationProblem) GetTitle() string {
	if e == nil {
		return ""
	}
	return e.Title
}

func (e *ErrorValidationProblem) GetDetail() string {
	if e == nil {
		return ""
	}
	return e.Detail
}

func (e *ErrorValidationProblem) GetProblemType() string {
	if e == nil {
		return ""
	}
	return e.ProblemType
}

func (e *ErrorValidationProblem) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorValidationProblem) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// * `AMERICAN_INDIAN_OR_ALASKA_NATIVE` - AMERICAN_INDIAN_OR_ALASKA_NATIVE
// * `ASIAN_OR_INDIAN_SUBCONTINENT` - ASIAN_OR_INDIAN_SUBCONTINENT
// * `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// * `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// * `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// * `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// * `WHITE` - WHITE
// * `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type EthnicityEnum string

const (
	EthnicityEnumAmericanIndianOrAlaskaNative         EthnicityEnum = "AMERICAN_INDIAN_OR_ALASKA_NATIVE"
	EthnicityEnumAsianOrIndianSubcontinent            EthnicityEnum = "ASIAN_OR_INDIAN_SUBCONTINENT"
	EthnicityEnumBlackOrAfricanAmerican               EthnicityEnum = "BLACK_OR_AFRICAN_AMERICAN"
	EthnicityEnumHispanicOrLatino                     EthnicityEnum = "HISPANIC_OR_LATINO"
	EthnicityEnumNativeHawaiianOrOtherPacificIslander EthnicityEnum = "NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER"
	EthnicityEnumTwoOrMoreRaces                       EthnicityEnum = "TWO_OR_MORE_RACES"
	EthnicityEnumWhite                                EthnicityEnum = "WHITE"
	EthnicityEnumPreferNotToDisclose                  EthnicityEnum = "PREFER_NOT_TO_DISCLOSE"
)

func NewEthnicityEnumFromString(s string) (EthnicityEnum, error) {
	switch s {
	case "AMERICAN_INDIAN_OR_ALASKA_NATIVE":
		return EthnicityEnumAmericanIndianOrAlaskaNative, nil
	case "ASIAN_OR_INDIAN_SUBCONTINENT":
		return EthnicityEnumAsianOrIndianSubcontinent, nil
	case "BLACK_OR_AFRICAN_AMERICAN":
		return EthnicityEnumBlackOrAfricanAmerican, nil
	case "HISPANIC_OR_LATINO":
		return EthnicityEnumHispanicOrLatino, nil
	case "NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER":
		return EthnicityEnumNativeHawaiianOrOtherPacificIslander, nil
	case "TWO_OR_MORE_RACES":
		return EthnicityEnumTwoOrMoreRaces, nil
	case "WHITE":
		return EthnicityEnumWhite, nil
	case "PREFER_NOT_TO_DISCLOSE":
		return EthnicityEnumPreferNotToDisclose, nil
	}
	var t EthnicityEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EthnicityEnum) Ptr() *EthnicityEnum {
	return &e
}

type FieldPermissionDeserializerRequest struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty" url:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty" url:"disabled_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FieldPermissionDeserializerRequest) GetEnabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.EnabledFields
}

func (f *FieldPermissionDeserializerRequest) GetDisabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.DisabledFields
}

func (f *FieldPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializerRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// * `EXEMPT` - EXEMPT
// * `SALARIED_NONEXEMPT` - SALARIED_NONEXEMPT
// * `NONEXEMPT` - NONEXEMPT
// * `OWNER` - OWNER
type FlsaStatusEnum string

const (
	FlsaStatusEnumExempt            FlsaStatusEnum = "EXEMPT"
	FlsaStatusEnumSalariedNonexempt FlsaStatusEnum = "SALARIED_NONEXEMPT"
	FlsaStatusEnumNonexempt         FlsaStatusEnum = "NONEXEMPT"
	FlsaStatusEnumOwner             FlsaStatusEnum = "OWNER"
)

func NewFlsaStatusEnumFromString(s string) (FlsaStatusEnum, error) {
	switch s {
	case "EXEMPT":
		return FlsaStatusEnumExempt, nil
	case "SALARIED_NONEXEMPT":
		return FlsaStatusEnumSalariedNonexempt, nil
	case "NONEXEMPT":
		return FlsaStatusEnumNonexempt, nil
	case "OWNER":
		return FlsaStatusEnumOwner, nil
	}
	var t FlsaStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FlsaStatusEnum) Ptr() *FlsaStatusEnum {
	return &f
}

// * `MALE` - MALE
// * `FEMALE` - FEMALE
// * `NON-BINARY` - NON-BINARY
// * `OTHER` - OTHER
// * `PREFER_NOT_TO_DISCLOSE` - PREFER_NOT_TO_DISCLOSE
type GenderEnum string

const (
	GenderEnumMale                GenderEnum = "MALE"
	GenderEnumFemale              GenderEnum = "FEMALE"
	GenderEnumNonBinary           GenderEnum = "NON-BINARY"
	GenderEnumOther               GenderEnum = "OTHER"
	GenderEnumPreferNotToDisclose GenderEnum = "PREFER_NOT_TO_DISCLOSE"
)

func NewGenderEnumFromString(s string) (GenderEnum, error) {
	switch s {
	case "MALE":
		return GenderEnumMale, nil
	case "FEMALE":
		return GenderEnumFemale, nil
	case "NON-BINARY":
		return GenderEnumNonBinary, nil
	case "OTHER":
		return GenderEnumOther, nil
	case "PREFER_NOT_TO_DISCLOSE":
		return GenderEnumPreferNotToDisclose, nil
	}
	var t GenderEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenderEnum) Ptr() *GenderEnum {
	return &g
}

// # The Group Object
// ### Description
// The `Group` object is used to represent any subset of employees across, for example, `DEPARTMENT` or `TEAM`. Employees can be in multiple Groups.
//
// ### Usage Example
// Fetch from the `LIST Employee` endpoint and expand groups to view an employee's groups.
type Group struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The parent group for this group.
	ParentGroup *string `json:"parent_group,omitempty" url:"parent_group,omitempty"`
	// The group name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The Group type returned directly from the third-party.
	//
	// * `TEAM` - TEAM
	// * `DEPARTMENT` - DEPARTMENT
	// * `COST_CENTER` - COST_CENTER
	// * `BUSINESS_UNIT` - BUSINESS_UNIT
	// * `GROUP` - GROUP
	Type *GroupType `json:"type,omitempty" url:"type,omitempty"`
	// Indicates whether the Group refers to a team in the third party platform. Note that this is an opinionated view based on how Merge observes most organizations representing teams in each third party platform. If your customer uses a platform different from most, there is a chance this will not be correct.
	IsCommonlyUsedAsTeam *bool `json:"is_commonly_used_as_team,omitempty" url:"is_commonly_used_as_team,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *Group) GetId() *string {
	if g == nil {
		return nil
	}
	return g.Id
}

func (g *Group) GetRemoteId() *string {
	if g == nil {
		return nil
	}
	return g.RemoteId
}

func (g *Group) GetCreatedAt() *time.Time {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *Group) GetModifiedAt() *time.Time {
	if g == nil {
		return nil
	}
	return g.ModifiedAt
}

func (g *Group) GetParentGroup() *string {
	if g == nil {
		return nil
	}
	return g.ParentGroup
}

func (g *Group) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *Group) GetType() *GroupType {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *Group) GetIsCommonlyUsedAsTeam() *bool {
	if g == nil {
		return nil
	}
	return g.IsCommonlyUsedAsTeam
}

func (g *Group) GetRemoteWasDeleted() *bool {
	if g == nil {
		return nil
	}
	return g.RemoteWasDeleted
}

func (g *Group) GetFieldMappings() map[string]interface{} {
	if g == nil {
		return nil
	}
	return g.FieldMappings
}

func (g *Group) GetRemoteData() []*RemoteData {
	if g == nil {
		return nil
	}
	return g.RemoteData
}

func (g *Group) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Group) UnmarshalJSON(data []byte) error {
	type embed Group
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = Group(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	g.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *Group) MarshalJSON() ([]byte, error) {
	type embed Group
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*g),
		CreatedAt:  internal.NewOptionalDateTime(g.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(g.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (g *Group) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The Group type returned directly from the third-party.
//
// * `TEAM` - TEAM
// * `DEPARTMENT` - DEPARTMENT
// * `COST_CENTER` - COST_CENTER
// * `BUSINESS_UNIT` - BUSINESS_UNIT
// * `GROUP` - GROUP
type GroupType struct {
	GroupTypeEnum GroupTypeEnum
	String        string

	typ string
}

func (g *GroupType) GetGroupTypeEnum() GroupTypeEnum {
	if g == nil {
		return ""
	}
	return g.GroupTypeEnum
}

func (g *GroupType) GetString() string {
	if g == nil {
		return ""
	}
	return g.String
}

func (g *GroupType) UnmarshalJSON(data []byte) error {
	var valueGroupTypeEnum GroupTypeEnum
	if err := json.Unmarshal(data, &valueGroupTypeEnum); err == nil {
		g.typ = "GroupTypeEnum"
		g.GroupTypeEnum = valueGroupTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typ = "String"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroupType) MarshalJSON() ([]byte, error) {
	if g.typ == "GroupTypeEnum" || g.GroupTypeEnum != "" {
		return json.Marshal(g.GroupTypeEnum)
	}
	if g.typ == "String" || g.String != "" {
		return json.Marshal(g.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroupTypeVisitor interface {
	VisitGroupTypeEnum(GroupTypeEnum) error
	VisitString(string) error
}

func (g *GroupType) Accept(visitor GroupTypeVisitor) error {
	if g.typ == "GroupTypeEnum" || g.GroupTypeEnum != "" {
		return visitor.VisitGroupTypeEnum(g.GroupTypeEnum)
	}
	if g.typ == "String" || g.String != "" {
		return visitor.VisitString(g.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

// * `TEAM` - TEAM
// * `DEPARTMENT` - DEPARTMENT
// * `COST_CENTER` - COST_CENTER
// * `BUSINESS_UNIT` - BUSINESS_UNIT
// * `GROUP` - GROUP
type GroupTypeEnum string

const (
	GroupTypeEnumTeam         GroupTypeEnum = "TEAM"
	GroupTypeEnumDepartment   GroupTypeEnum = "DEPARTMENT"
	GroupTypeEnumCostCenter   GroupTypeEnum = "COST_CENTER"
	GroupTypeEnumBusinessUnit GroupTypeEnum = "BUSINESS_UNIT"
	GroupTypeEnumGroup        GroupTypeEnum = "GROUP"
)

func NewGroupTypeEnumFromString(s string) (GroupTypeEnum, error) {
	switch s {
	case "TEAM":
		return GroupTypeEnumTeam, nil
	case "DEPARTMENT":
		return GroupTypeEnumDepartment, nil
	case "COST_CENTER":
		return GroupTypeEnumCostCenter, nil
	case "BUSINESS_UNIT":
		return GroupTypeEnumBusinessUnit, nil
	case "GROUP":
		return GroupTypeEnumGroup, nil
	}
	var t GroupTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GroupTypeEnum) Ptr() *GroupTypeEnum {
	return &g
}

type IndividualCommonModelScopeDeserializerRequest struct {
	ModelName        string                                         `json:"model_name" url:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializerRequest `json:"model_permissions,omitempty" url:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializerRequest            `json:"field_permissions,omitempty" url:"field_permissions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelName() string {
	if i == nil {
		return ""
	}
	return i.ModelName
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelPermissions() map[string]*ModelPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.ModelPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetFieldPermissions() *FieldPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.FieldPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualCommonModelScopeDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializerRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type LastSyncResultEnum string

const (
	LastSyncResultEnumSyncing         LastSyncResultEnum = "SYNCING"
	LastSyncResultEnumDone            LastSyncResultEnum = "DONE"
	LastSyncResultEnumFailed          LastSyncResultEnum = "FAILED"
	LastSyncResultEnumDisabled        LastSyncResultEnum = "DISABLED"
	LastSyncResultEnumPaused          LastSyncResultEnum = "PAUSED"
	LastSyncResultEnumPartiallySynced LastSyncResultEnum = "PARTIALLY_SYNCED"
)

func NewLastSyncResultEnumFromString(s string) (LastSyncResultEnum, error) {
	switch s {
	case "SYNCING":
		return LastSyncResultEnumSyncing, nil
	case "DONE":
		return LastSyncResultEnumDone, nil
	case "FAILED":
		return LastSyncResultEnumFailed, nil
	case "DISABLED":
		return LastSyncResultEnumDisabled, nil
	case "PAUSED":
		return LastSyncResultEnumPaused, nil
	case "PARTIALLY_SYNCED":
		return LastSyncResultEnumPartiallySynced, nil
	}
	var t LastSyncResultEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LastSyncResultEnum) Ptr() *LastSyncResultEnum {
	return &l
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status" url:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request" url:"can_make_request"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LinkedAccountStatus) GetLinkedAccountStatus() string {
	if l == nil {
		return ""
	}
	return l.LinkedAccountStatus
}

func (l *LinkedAccountStatus) GetCanMakeRequest() bool {
	if l == nil {
		return false
	}
	return l.CanMakeRequest
}

func (l *LinkedAccountStatus) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkedAccountStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedAccountStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedAccountStatus(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedAccountStatus) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// # The Location Object
// ### Description
// The `Location` object is used to represent an address that can be associated with an employee.
//
// ### Usage Example
// Fetch from the `LIST Locations` endpoint and filter by `ID` to show all office locations.
type Location struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The location's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The location's phone number.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// Line 1 of the location's street address.
	Street1 *string `json:"street_1,omitempty" url:"street_1,omitempty"`
	// Line 2 of the location's street address.
	Street2 *string `json:"street_2,omitempty" url:"street_2,omitempty"`
	// The location's city.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// The location's state. Represents a region if outside of the US.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// The location's zip code or postal code.
	ZipCode *string `json:"zip_code,omitempty" url:"zip_code,omitempty"`
	// The location's country.
	//
	// * `AF` - Afghanistan
	// * `AX` - Åland Islands
	// * `AL` - Albania
	// * `DZ` - Algeria
	// * `AS` - American Samoa
	// * `AD` - Andorra
	// * `AO` - Angola
	// * `AI` - Anguilla
	// * `AQ` - Antarctica
	// * `AG` - Antigua and Barbuda
	// * `AR` - Argentina
	// * `AM` - Armenia
	// * `AW` - Aruba
	// * `AU` - Australia
	// * `AT` - Austria
	// * `AZ` - Azerbaijan
	// * `BS` - Bahamas
	// * `BH` - Bahrain
	// * `BD` - Bangladesh
	// * `BB` - Barbados
	// * `BY` - Belarus
	// * `BE` - Belgium
	// * `BZ` - Belize
	// * `BJ` - Benin
	// * `BM` - Bermuda
	// * `BT` - Bhutan
	// * `BO` - Bolivia
	// * `BQ` - Bonaire, Sint Eustatius and Saba
	// * `BA` - Bosnia and Herzegovina
	// * `BW` - Botswana
	// * `BV` - Bouvet Island
	// * `BR` - Brazil
	// * `IO` - British Indian Ocean Territory
	// * `BN` - Brunei
	// * `BG` - Bulgaria
	// * `BF` - Burkina Faso
	// * `BI` - Burundi
	// * `CV` - Cabo Verde
	// * `KH` - Cambodia
	// * `CM` - Cameroon
	// * `CA` - Canada
	// * `KY` - Cayman Islands
	// * `CF` - Central African Republic
	// * `TD` - Chad
	// * `CL` - Chile
	// * `CN` - China
	// * `CX` - Christmas Island
	// * `CC` - Cocos (Keeling) Islands
	// * `CO` - Colombia
	// * `KM` - Comoros
	// * `CG` - Congo
	// * `CD` - Congo (the Democratic Republic of the)
	// * `CK` - Cook Islands
	// * `CR` - Costa Rica
	// * `CI` - Côte d'Ivoire
	// * `HR` - Croatia
	// * `CU` - Cuba
	// * `CW` - Curaçao
	// * `CY` - Cyprus
	// * `CZ` - Czechia
	// * `DK` - Denmark
	// * `DJ` - Djibouti
	// * `DM` - Dominica
	// * `DO` - Dominican Republic
	// * `EC` - Ecuador
	// * `EG` - Egypt
	// * `SV` - El Salvador
	// * `GQ` - Equatorial Guinea
	// * `ER` - Eritrea
	// * `EE` - Estonia
	// * `SZ` - Eswatini
	// * `ET` - Ethiopia
	// * `FK` - Falkland Islands (Malvinas)
	// * `FO` - Faroe Islands
	// * `FJ` - Fiji
	// * `FI` - Finland
	// * `FR` - France
	// * `GF` - French Guiana
	// * `PF` - French Polynesia
	// * `TF` - French Southern Territories
	// * `GA` - Gabon
	// * `GM` - Gambia
	// * `GE` - Georgia
	// * `DE` - Germany
	// * `GH` - Ghana
	// * `GI` - Gibraltar
	// * `GR` - Greece
	// * `GL` - Greenland
	// * `GD` - Grenada
	// * `GP` - Guadeloupe
	// * `GU` - Guam
	// * `GT` - Guatemala
	// * `GG` - Guernsey
	// * `GN` - Guinea
	// * `GW` - Guinea-Bissau
	// * `GY` - Guyana
	// * `HT` - Haiti
	// * `HM` - Heard Island and McDonald Islands
	// * `VA` - Holy See
	// * `HN` - Honduras
	// * `HK` - Hong Kong
	// * `HU` - Hungary
	// * `IS` - Iceland
	// * `IN` - India
	// * `ID` - Indonesia
	// * `IR` - Iran
	// * `IQ` - Iraq
	// * `IE` - Ireland
	// * `IM` - Isle of Man
	// * `IL` - Israel
	// * `IT` - Italy
	// * `JM` - Jamaica
	// * `JP` - Japan
	// * `JE` - Jersey
	// * `JO` - Jordan
	// * `KZ` - Kazakhstan
	// * `KE` - Kenya
	// * `KI` - Kiribati
	// * `KW` - Kuwait
	// * `KG` - Kyrgyzstan
	// * `LA` - Laos
	// * `LV` - Latvia
	// * `LB` - Lebanon
	// * `LS` - Lesotho
	// * `LR` - Liberia
	// * `LY` - Libya
	// * `LI` - Liechtenstein
	// * `LT` - Lithuania
	// * `LU` - Luxembourg
	// * `MO` - Macao
	// * `MG` - Madagascar
	// * `MW` - Malawi
	// * `MY` - Malaysia
	// * `MV` - Maldives
	// * `ML` - Mali
	// * `MT` - Malta
	// * `MH` - Marshall Islands
	// * `MQ` - Martinique
	// * `MR` - Mauritania
	// * `MU` - Mauritius
	// * `YT` - Mayotte
	// * `MX` - Mexico
	// * `FM` - Micronesia (Federated States of)
	// * `MD` - Moldova
	// * `MC` - Monaco
	// * `MN` - Mongolia
	// * `ME` - Montenegro
	// * `MS` - Montserrat
	// * `MA` - Morocco
	// * `MZ` - Mozambique
	// * `MM` - Myanmar
	// * `NA` - Namibia
	// * `NR` - Nauru
	// * `NP` - Nepal
	// * `NL` - Netherlands
	// * `NC` - New Caledonia
	// * `NZ` - New Zealand
	// * `NI` - Nicaragua
	// * `NE` - Niger
	// * `NG` - Nigeria
	// * `NU` - Niue
	// * `NF` - Norfolk Island
	// * `KP` - North Korea
	// * `MK` - North Macedonia
	// * `MP` - Northern Mariana Islands
	// * `NO` - Norway
	// * `OM` - Oman
	// * `PK` - Pakistan
	// * `PW` - Palau
	// * `PS` - Palestine, State of
	// * `PA` - Panama
	// * `PG` - Papua New Guinea
	// * `PY` - Paraguay
	// * `PE` - Peru
	// * `PH` - Philippines
	// * `PN` - Pitcairn
	// * `PL` - Poland
	// * `PT` - Portugal
	// * `PR` - Puerto Rico
	// * `QA` - Qatar
	// * `RE` - Réunion
	// * `RO` - Romania
	// * `RU` - Russia
	// * `RW` - Rwanda
	// * `BL` - Saint Barthélemy
	// * `SH` - Saint Helena, Ascension and Tristan da Cunha
	// * `KN` - Saint Kitts and Nevis
	// * `LC` - Saint Lucia
	// * `MF` - Saint Martin (French part)
	// * `PM` - Saint Pierre and Miquelon
	// * `VC` - Saint Vincent and the Grenadines
	// * `WS` - Samoa
	// * `SM` - San Marino
	// * `ST` - Sao Tome and Principe
	// * `SA` - Saudi Arabia
	// * `SN` - Senegal
	// * `RS` - Serbia
	// * `SC` - Seychelles
	// * `SL` - Sierra Leone
	// * `SG` - Singapore
	// * `SX` - Sint Maarten (Dutch part)
	// * `SK` - Slovakia
	// * `SI` - Slovenia
	// * `SB` - Solomon Islands
	// * `SO` - Somalia
	// * `ZA` - South Africa
	// * `GS` - South Georgia and the South Sandwich Islands
	// * `KR` - South Korea
	// * `SS` - South Sudan
	// * `ES` - Spain
	// * `LK` - Sri Lanka
	// * `SD` - Sudan
	// * `SR` - Suriname
	// * `SJ` - Svalbard and Jan Mayen
	// * `SE` - Sweden
	// * `CH` - Switzerland
	// * `SY` - Syria
	// * `TW` - Taiwan
	// * `TJ` - Tajikistan
	// * `TZ` - Tanzania
	// * `TH` - Thailand
	// * `TL` - Timor-Leste
	// * `TG` - Togo
	// * `TK` - Tokelau
	// * `TO` - Tonga
	// * `TT` - Trinidad and Tobago
	// * `TN` - Tunisia
	// * `TR` - Turkey
	// * `TM` - Turkmenistan
	// * `TC` - Turks and Caicos Islands
	// * `TV` - Tuvalu
	// * `UG` - Uganda
	// * `UA` - Ukraine
	// * `AE` - United Arab Emirates
	// * `GB` - United Kingdom
	// * `UM` - United States Minor Outlying Islands
	// * `US` - United States of America
	// * `UY` - Uruguay
	// * `UZ` - Uzbekistan
	// * `VU` - Vanuatu
	// * `VE` - Venezuela
	// * `VN` - Vietnam
	// * `VG` - Virgin Islands (British)
	// * `VI` - Virgin Islands (U.S.)
	// * `WF` - Wallis and Futuna
	// * `EH` - Western Sahara
	// * `YE` - Yemen
	// * `ZM` - Zambia
	// * `ZW` - Zimbabwe
	Country *LocationCountry `json:"country,omitempty" url:"country,omitempty"`
	// The location's type. Can be either WORK or HOME
	//
	// * `HOME` - HOME
	// * `WORK` - WORK
	LocationType *LocationLocationType `json:"location_type,omitempty" url:"location_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *Location) GetId() *string {
	if l == nil {
		return nil
	}
	return l.Id
}

func (l *Location) GetRemoteId() *string {
	if l == nil {
		return nil
	}
	return l.RemoteId
}

func (l *Location) GetCreatedAt() *time.Time {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *Location) GetModifiedAt() *time.Time {
	if l == nil {
		return nil
	}
	return l.ModifiedAt
}

func (l *Location) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *Location) GetPhoneNumber() *string {
	if l == nil {
		return nil
	}
	return l.PhoneNumber
}

func (l *Location) GetStreet1() *string {
	if l == nil {
		return nil
	}
	return l.Street1
}

func (l *Location) GetStreet2() *string {
	if l == nil {
		return nil
	}
	return l.Street2
}

func (l *Location) GetCity() *string {
	if l == nil {
		return nil
	}
	return l.City
}

func (l *Location) GetState() *string {
	if l == nil {
		return nil
	}
	return l.State
}

func (l *Location) GetZipCode() *string {
	if l == nil {
		return nil
	}
	return l.ZipCode
}

func (l *Location) GetCountry() *LocationCountry {
	if l == nil {
		return nil
	}
	return l.Country
}

func (l *Location) GetLocationType() *LocationLocationType {
	if l == nil {
		return nil
	}
	return l.LocationType
}

func (l *Location) GetRemoteWasDeleted() *bool {
	if l == nil {
		return nil
	}
	return l.RemoteWasDeleted
}

func (l *Location) GetFieldMappings() map[string]interface{} {
	if l == nil {
		return nil
	}
	return l.FieldMappings
}

func (l *Location) GetRemoteData() []*RemoteData {
	if l == nil {
		return nil
	}
	return l.RemoteData
}

func (l *Location) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Location) UnmarshalJSON(data []byte) error {
	type embed Location
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = Location(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	l.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *Location) MarshalJSON() ([]byte, error) {
	type embed Location
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*l),
		CreatedAt:  internal.NewOptionalDateTime(l.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(l.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (l *Location) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The location's country.
//
// * `AF` - Afghanistan
// * `AX` - Åland Islands
// * `AL` - Albania
// * `DZ` - Algeria
// * `AS` - American Samoa
// * `AD` - Andorra
// * `AO` - Angola
// * `AI` - Anguilla
// * `AQ` - Antarctica
// * `AG` - Antigua and Barbuda
// * `AR` - Argentina
// * `AM` - Armenia
// * `AW` - Aruba
// * `AU` - Australia
// * `AT` - Austria
// * `AZ` - Azerbaijan
// * `BS` - Bahamas
// * `BH` - Bahrain
// * `BD` - Bangladesh
// * `BB` - Barbados
// * `BY` - Belarus
// * `BE` - Belgium
// * `BZ` - Belize
// * `BJ` - Benin
// * `BM` - Bermuda
// * `BT` - Bhutan
// * `BO` - Bolivia
// * `BQ` - Bonaire, Sint Eustatius and Saba
// * `BA` - Bosnia and Herzegovina
// * `BW` - Botswana
// * `BV` - Bouvet Island
// * `BR` - Brazil
// * `IO` - British Indian Ocean Territory
// * `BN` - Brunei
// * `BG` - Bulgaria
// * `BF` - Burkina Faso
// * `BI` - Burundi
// * `CV` - Cabo Verde
// * `KH` - Cambodia
// * `CM` - Cameroon
// * `CA` - Canada
// * `KY` - Cayman Islands
// * `CF` - Central African Republic
// * `TD` - Chad
// * `CL` - Chile
// * `CN` - China
// * `CX` - Christmas Island
// * `CC` - Cocos (Keeling) Islands
// * `CO` - Colombia
// * `KM` - Comoros
// * `CG` - Congo
// * `CD` - Congo (the Democratic Republic of the)
// * `CK` - Cook Islands
// * `CR` - Costa Rica
// * `CI` - Côte d'Ivoire
// * `HR` - Croatia
// * `CU` - Cuba
// * `CW` - Curaçao
// * `CY` - Cyprus
// * `CZ` - Czechia
// * `DK` - Denmark
// * `DJ` - Djibouti
// * `DM` - Dominica
// * `DO` - Dominican Republic
// * `EC` - Ecuador
// * `EG` - Egypt
// * `SV` - El Salvador
// * `GQ` - Equatorial Guinea
// * `ER` - Eritrea
// * `EE` - Estonia
// * `SZ` - Eswatini
// * `ET` - Ethiopia
// * `FK` - Falkland Islands (Malvinas)
// * `FO` - Faroe Islands
// * `FJ` - Fiji
// * `FI` - Finland
// * `FR` - France
// * `GF` - French Guiana
// * `PF` - French Polynesia
// * `TF` - French Southern Territories
// * `GA` - Gabon
// * `GM` - Gambia
// * `GE` - Georgia
// * `DE` - Germany
// * `GH` - Ghana
// * `GI` - Gibraltar
// * `GR` - Greece
// * `GL` - Greenland
// * `GD` - Grenada
// * `GP` - Guadeloupe
// * `GU` - Guam
// * `GT` - Guatemala
// * `GG` - Guernsey
// * `GN` - Guinea
// * `GW` - Guinea-Bissau
// * `GY` - Guyana
// * `HT` - Haiti
// * `HM` - Heard Island and McDonald Islands
// * `VA` - Holy See
// * `HN` - Honduras
// * `HK` - Hong Kong
// * `HU` - Hungary
// * `IS` - Iceland
// * `IN` - India
// * `ID` - Indonesia
// * `IR` - Iran
// * `IQ` - Iraq
// * `IE` - Ireland
// * `IM` - Isle of Man
// * `IL` - Israel
// * `IT` - Italy
// * `JM` - Jamaica
// * `JP` - Japan
// * `JE` - Jersey
// * `JO` - Jordan
// * `KZ` - Kazakhstan
// * `KE` - Kenya
// * `KI` - Kiribati
// * `KW` - Kuwait
// * `KG` - Kyrgyzstan
// * `LA` - Laos
// * `LV` - Latvia
// * `LB` - Lebanon
// * `LS` - Lesotho
// * `LR` - Liberia
// * `LY` - Libya
// * `LI` - Liechtenstein
// * `LT` - Lithuania
// * `LU` - Luxembourg
// * `MO` - Macao
// * `MG` - Madagascar
// * `MW` - Malawi
// * `MY` - Malaysia
// * `MV` - Maldives
// * `ML` - Mali
// * `MT` - Malta
// * `MH` - Marshall Islands
// * `MQ` - Martinique
// * `MR` - Mauritania
// * `MU` - Mauritius
// * `YT` - Mayotte
// * `MX` - Mexico
// * `FM` - Micronesia (Federated States of)
// * `MD` - Moldova
// * `MC` - Monaco
// * `MN` - Mongolia
// * `ME` - Montenegro
// * `MS` - Montserrat
// * `MA` - Morocco
// * `MZ` - Mozambique
// * `MM` - Myanmar
// * `NA` - Namibia
// * `NR` - Nauru
// * `NP` - Nepal
// * `NL` - Netherlands
// * `NC` - New Caledonia
// * `NZ` - New Zealand
// * `NI` - Nicaragua
// * `NE` - Niger
// * `NG` - Nigeria
// * `NU` - Niue
// * `NF` - Norfolk Island
// * `KP` - North Korea
// * `MK` - North Macedonia
// * `MP` - Northern Mariana Islands
// * `NO` - Norway
// * `OM` - Oman
// * `PK` - Pakistan
// * `PW` - Palau
// * `PS` - Palestine, State of
// * `PA` - Panama
// * `PG` - Papua New Guinea
// * `PY` - Paraguay
// * `PE` - Peru
// * `PH` - Philippines
// * `PN` - Pitcairn
// * `PL` - Poland
// * `PT` - Portugal
// * `PR` - Puerto Rico
// * `QA` - Qatar
// * `RE` - Réunion
// * `RO` - Romania
// * `RU` - Russia
// * `RW` - Rwanda
// * `BL` - Saint Barthélemy
// * `SH` - Saint Helena, Ascension and Tristan da Cunha
// * `KN` - Saint Kitts and Nevis
// * `LC` - Saint Lucia
// * `MF` - Saint Martin (French part)
// * `PM` - Saint Pierre and Miquelon
// * `VC` - Saint Vincent and the Grenadines
// * `WS` - Samoa
// * `SM` - San Marino
// * `ST` - Sao Tome and Principe
// * `SA` - Saudi Arabia
// * `SN` - Senegal
// * `RS` - Serbia
// * `SC` - Seychelles
// * `SL` - Sierra Leone
// * `SG` - Singapore
// * `SX` - Sint Maarten (Dutch part)
// * `SK` - Slovakia
// * `SI` - Slovenia
// * `SB` - Solomon Islands
// * `SO` - Somalia
// * `ZA` - South Africa
// * `GS` - South Georgia and the South Sandwich Islands
// * `KR` - South Korea
// * `SS` - South Sudan
// * `ES` - Spain
// * `LK` - Sri Lanka
// * `SD` - Sudan
// * `SR` - Suriname
// * `SJ` - Svalbard and Jan Mayen
// * `SE` - Sweden
// * `CH` - Switzerland
// * `SY` - Syria
// * `TW` - Taiwan
// * `TJ` - Tajikistan
// * `TZ` - Tanzania
// * `TH` - Thailand
// * `TL` - Timor-Leste
// * `TG` - Togo
// * `TK` - Tokelau
// * `TO` - Tonga
// * `TT` - Trinidad and Tobago
// * `TN` - Tunisia
// * `TR` - Turkey
// * `TM` - Turkmenistan
// * `TC` - Turks and Caicos Islands
// * `TV` - Tuvalu
// * `UG` - Uganda
// * `UA` - Ukraine
// * `AE` - United Arab Emirates
// * `GB` - United Kingdom
// * `UM` - United States Minor Outlying Islands
// * `US` - United States of America
// * `UY` - Uruguay
// * `UZ` - Uzbekistan
// * `VU` - Vanuatu
// * `VE` - Venezuela
// * `VN` - Vietnam
// * `VG` - Virgin Islands (British)
// * `VI` - Virgin Islands (U.S.)
// * `WF` - Wallis and Futuna
// * `EH` - Western Sahara
// * `YE` - Yemen
// * `ZM` - Zambia
// * `ZW` - Zimbabwe
type LocationCountry struct {
	CountryEnum CountryEnum
	String      string

	typ string
}

func (l *LocationCountry) GetCountryEnum() CountryEnum {
	if l == nil {
		return ""
	}
	return l.CountryEnum
}

func (l *LocationCountry) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LocationCountry) UnmarshalJSON(data []byte) error {
	var valueCountryEnum CountryEnum
	if err := json.Unmarshal(data, &valueCountryEnum); err == nil {
		l.typ = "CountryEnum"
		l.CountryEnum = valueCountryEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LocationCountry) MarshalJSON() ([]byte, error) {
	if l.typ == "CountryEnum" || l.CountryEnum != "" {
		return json.Marshal(l.CountryEnum)
	}
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LocationCountryVisitor interface {
	VisitCountryEnum(CountryEnum) error
	VisitString(string) error
}

func (l *LocationCountry) Accept(visitor LocationCountryVisitor) error {
	if l.typ == "CountryEnum" || l.CountryEnum != "" {
		return visitor.VisitCountryEnum(l.CountryEnum)
	}
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// The location's type. Can be either WORK or HOME
//
// * `HOME` - HOME
// * `WORK` - WORK
type LocationLocationType struct {
	LocationTypeEnum LocationTypeEnum
	String           string

	typ string
}

func (l *LocationLocationType) GetLocationTypeEnum() LocationTypeEnum {
	if l == nil {
		return ""
	}
	return l.LocationTypeEnum
}

func (l *LocationLocationType) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LocationLocationType) UnmarshalJSON(data []byte) error {
	var valueLocationTypeEnum LocationTypeEnum
	if err := json.Unmarshal(data, &valueLocationTypeEnum); err == nil {
		l.typ = "LocationTypeEnum"
		l.LocationTypeEnum = valueLocationTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LocationLocationType) MarshalJSON() ([]byte, error) {
	if l.typ == "LocationTypeEnum" || l.LocationTypeEnum != "" {
		return json.Marshal(l.LocationTypeEnum)
	}
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LocationLocationTypeVisitor interface {
	VisitLocationTypeEnum(LocationTypeEnum) error
	VisitString(string) error
}

func (l *LocationLocationType) Accept(visitor LocationLocationTypeVisitor) error {
	if l.typ == "LocationTypeEnum" || l.LocationTypeEnum != "" {
		return visitor.VisitLocationTypeEnum(l.LocationTypeEnum)
	}
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// * `HOME` - HOME
// * `WORK` - WORK
type LocationTypeEnum string

const (
	LocationTypeEnumHome LocationTypeEnum = "HOME"
	LocationTypeEnumWork LocationTypeEnum = "WORK"
)

func NewLocationTypeEnumFromString(s string) (LocationTypeEnum, error) {
	switch s {
	case "HOME":
		return LocationTypeEnumHome, nil
	case "WORK":
		return LocationTypeEnumWork, nil
	}
	var t LocationTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationTypeEnum) Ptr() *LocationTypeEnum {
	return &l
}

// * `SINGLE` - SINGLE
// * `MARRIED_FILING_JOINTLY` - MARRIED_FILING_JOINTLY
// * `MARRIED_FILING_SEPARATELY` - MARRIED_FILING_SEPARATELY
// * `HEAD_OF_HOUSEHOLD` - HEAD_OF_HOUSEHOLD
// * `QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD` - QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD
type MaritalStatusEnum string

const (
	MaritalStatusEnumSingle                                     MaritalStatusEnum = "SINGLE"
	MaritalStatusEnumMarriedFilingJointly                       MaritalStatusEnum = "MARRIED_FILING_JOINTLY"
	MaritalStatusEnumMarriedFilingSeparately                    MaritalStatusEnum = "MARRIED_FILING_SEPARATELY"
	MaritalStatusEnumHeadOfHousehold                            MaritalStatusEnum = "HEAD_OF_HOUSEHOLD"
	MaritalStatusEnumQualifyingWidowOrWidowerWithDependentChild MaritalStatusEnum = "QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD"
)

func NewMaritalStatusEnumFromString(s string) (MaritalStatusEnum, error) {
	switch s {
	case "SINGLE":
		return MaritalStatusEnumSingle, nil
	case "MARRIED_FILING_JOINTLY":
		return MaritalStatusEnumMarriedFilingJointly, nil
	case "MARRIED_FILING_SEPARATELY":
		return MaritalStatusEnumMarriedFilingSeparately, nil
	case "HEAD_OF_HOUSEHOLD":
		return MaritalStatusEnumHeadOfHousehold, nil
	case "QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD":
		return MaritalStatusEnumQualifyingWidowOrWidowerWithDependentChild, nil
	}
	var t MaritalStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MaritalStatusEnum) Ptr() *MaritalStatusEnum {
	return &m
}

type MetaResponse struct {
	RequestSchema                  map[string]interface{} `json:"request_schema" url:"request_schema"`
	RemoteFieldClasses             map[string]interface{} `json:"remote_field_classes,omitempty" url:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus   `json:"status,omitempty" url:"status,omitempty"`
	HasConditionalParams           bool                   `json:"has_conditional_params" url:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                   `json:"has_required_linked_account_params" url:"has_required_linked_account_params"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetaResponse) GetRequestSchema() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RequestSchema
}

func (m *MetaResponse) GetRemoteFieldClasses() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RemoteFieldClasses
}

func (m *MetaResponse) GetStatus() *LinkedAccountStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

func (m *MetaResponse) GetHasConditionalParams() bool {
	if m == nil {
		return false
	}
	return m.HasConditionalParams
}

func (m *MetaResponse) GetHasRequiredLinkedAccountParams() bool {
	if m == nil {
		return false
	}
	return m.HasRequiredLinkedAccountParams
}

func (m *MetaResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetaResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// * `GET` - GET
// * `OPTIONS` - OPTIONS
// * `HEAD` - HEAD
// * `POST` - POST
// * `PUT` - PUT
// * `PATCH` - PATCH
// * `DELETE` - DELETE
type MethodEnum string

const (
	MethodEnumGet     MethodEnum = "GET"
	MethodEnumOptions MethodEnum = "OPTIONS"
	MethodEnumHead    MethodEnum = "HEAD"
	MethodEnumPost    MethodEnum = "POST"
	MethodEnumPut     MethodEnum = "PUT"
	MethodEnumPatch   MethodEnum = "PATCH"
	MethodEnumDelete  MethodEnum = "DELETE"
)

func NewMethodEnumFromString(s string) (MethodEnum, error) {
	switch s {
	case "GET":
		return MethodEnumGet, nil
	case "OPTIONS":
		return MethodEnumOptions, nil
	case "HEAD":
		return MethodEnumHead, nil
	case "POST":
		return MethodEnumPost, nil
	case "PUT":
		return MethodEnumPut, nil
	case "PATCH":
		return MethodEnumPatch, nil
	case "DELETE":
		return MethodEnumDelete, nil
	}
	var t MethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodEnum) Ptr() *MethodEnum {
	return &m
}

// # The ModelOperation Object
// ### Description
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name" url:"model_name"`
	AvailableOperations    []string `json:"available_operations" url:"available_operations"`
	RequiredPostParameters []string `json:"required_post_parameters" url:"required_post_parameters"`
	SupportedFields        []string `json:"supported_fields" url:"supported_fields"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelOperation) GetModelName() string {
	if m == nil {
		return ""
	}
	return m.ModelName
}

func (m *ModelOperation) GetAvailableOperations() []string {
	if m == nil {
		return nil
	}
	return m.AvailableOperations
}

func (m *ModelOperation) GetRequiredPostParameters() []string {
	if m == nil {
		return nil
	}
	return m.RequiredPostParameters
}

func (m *ModelOperation) GetSupportedFields() []string {
	if m == nil {
		return nil
	}
	return m.SupportedFields
}

func (m *ModelOperation) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelOperation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelOperation) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializerRequest struct {
	IsEnabled *bool `json:"is_enabled,omitempty" url:"is_enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelPermissionDeserializerRequest) GetIsEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.IsEnabled
}

func (m *ModelPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializerRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The MultipartFormField Object
// ### Description
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name" url:"name"`
	// The data for the form field.
	Data string `json:"data" url:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// * `RAW` - RAW
	// * `BASE64` - BASE64
	// * `GZIP_BASE64` - GZIP_BASE64
	Encoding *EncodingEnum `json:"encoding,omitempty" url:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MultipartFormFieldRequest) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MultipartFormFieldRequest) GetData() string {
	if m == nil {
		return ""
	}
	return m.Data
}

func (m *MultipartFormFieldRequest) GetEncoding() *EncodingEnum {
	if m == nil {
		return nil
	}
	return m.Encoding
}

func (m *MultipartFormFieldRequest) GetFileName() *string {
	if m == nil {
		return nil
	}
	return m.FileName
}

func (m *MultipartFormFieldRequest) GetContentType() *string {
	if m == nil {
		return nil
	}
	return m.ContentType
}

func (m *MultipartFormFieldRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipartFormFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipartFormFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipartFormFieldRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipartFormFieldRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type PayCurrencyEnum string

const (
	PayCurrencyEnumXua PayCurrencyEnum = "XUA"
	PayCurrencyEnumAfn PayCurrencyEnum = "AFN"
	PayCurrencyEnumAfa PayCurrencyEnum = "AFA"
	PayCurrencyEnumAll PayCurrencyEnum = "ALL"
	PayCurrencyEnumAlk PayCurrencyEnum = "ALK"
	PayCurrencyEnumDzd PayCurrencyEnum = "DZD"
	PayCurrencyEnumAdp PayCurrencyEnum = "ADP"
	PayCurrencyEnumAoa PayCurrencyEnum = "AOA"
	PayCurrencyEnumAok PayCurrencyEnum = "AOK"
	PayCurrencyEnumAon PayCurrencyEnum = "AON"
	PayCurrencyEnumAor PayCurrencyEnum = "AOR"
	PayCurrencyEnumAra PayCurrencyEnum = "ARA"
	PayCurrencyEnumArs PayCurrencyEnum = "ARS"
	PayCurrencyEnumArm PayCurrencyEnum = "ARM"
	PayCurrencyEnumArp PayCurrencyEnum = "ARP"
	PayCurrencyEnumArl PayCurrencyEnum = "ARL"
	PayCurrencyEnumAmd PayCurrencyEnum = "AMD"
	PayCurrencyEnumAwg PayCurrencyEnum = "AWG"
	PayCurrencyEnumAud PayCurrencyEnum = "AUD"
	PayCurrencyEnumAts PayCurrencyEnum = "ATS"
	PayCurrencyEnumAzn PayCurrencyEnum = "AZN"
	PayCurrencyEnumAzm PayCurrencyEnum = "AZM"
	PayCurrencyEnumBsd PayCurrencyEnum = "BSD"
	PayCurrencyEnumBhd PayCurrencyEnum = "BHD"
	PayCurrencyEnumBdt PayCurrencyEnum = "BDT"
	PayCurrencyEnumBbd PayCurrencyEnum = "BBD"
	PayCurrencyEnumByn PayCurrencyEnum = "BYN"
	PayCurrencyEnumByb PayCurrencyEnum = "BYB"
	PayCurrencyEnumByr PayCurrencyEnum = "BYR"
	PayCurrencyEnumBef PayCurrencyEnum = "BEF"
	PayCurrencyEnumBec PayCurrencyEnum = "BEC"
	PayCurrencyEnumBel PayCurrencyEnum = "BEL"
	PayCurrencyEnumBzd PayCurrencyEnum = "BZD"
	PayCurrencyEnumBmd PayCurrencyEnum = "BMD"
	PayCurrencyEnumBtn PayCurrencyEnum = "BTN"
	PayCurrencyEnumBob PayCurrencyEnum = "BOB"
	PayCurrencyEnumBol PayCurrencyEnum = "BOL"
	PayCurrencyEnumBov PayCurrencyEnum = "BOV"
	PayCurrencyEnumBop PayCurrencyEnum = "BOP"
	PayCurrencyEnumBam PayCurrencyEnum = "BAM"
	PayCurrencyEnumBad PayCurrencyEnum = "BAD"
	PayCurrencyEnumBan PayCurrencyEnum = "BAN"
	PayCurrencyEnumBwp PayCurrencyEnum = "BWP"
	PayCurrencyEnumBrc PayCurrencyEnum = "BRC"
	PayCurrencyEnumBrz PayCurrencyEnum = "BRZ"
	PayCurrencyEnumBre PayCurrencyEnum = "BRE"
	PayCurrencyEnumBrr PayCurrencyEnum = "BRR"
	PayCurrencyEnumBrn PayCurrencyEnum = "BRN"
	PayCurrencyEnumBrb PayCurrencyEnum = "BRB"
	PayCurrencyEnumBrl PayCurrencyEnum = "BRL"
	PayCurrencyEnumGbp PayCurrencyEnum = "GBP"
	PayCurrencyEnumBnd PayCurrencyEnum = "BND"
	PayCurrencyEnumBgl PayCurrencyEnum = "BGL"
	PayCurrencyEnumBgn PayCurrencyEnum = "BGN"
	PayCurrencyEnumBgo PayCurrencyEnum = "BGO"
	PayCurrencyEnumBgm PayCurrencyEnum = "BGM"
	PayCurrencyEnumBuk PayCurrencyEnum = "BUK"
	PayCurrencyEnumBif PayCurrencyEnum = "BIF"
	PayCurrencyEnumXpf PayCurrencyEnum = "XPF"
	PayCurrencyEnumKhr PayCurrencyEnum = "KHR"
	PayCurrencyEnumCad PayCurrencyEnum = "CAD"
	PayCurrencyEnumCve PayCurrencyEnum = "CVE"
	PayCurrencyEnumKyd PayCurrencyEnum = "KYD"
	PayCurrencyEnumXaf PayCurrencyEnum = "XAF"
	PayCurrencyEnumCle PayCurrencyEnum = "CLE"
	PayCurrencyEnumClp PayCurrencyEnum = "CLP"
	PayCurrencyEnumClf PayCurrencyEnum = "CLF"
	PayCurrencyEnumCnx PayCurrencyEnum = "CNX"
	PayCurrencyEnumCny PayCurrencyEnum = "CNY"
	PayCurrencyEnumCnh PayCurrencyEnum = "CNH"
	PayCurrencyEnumCop PayCurrencyEnum = "COP"
	PayCurrencyEnumCou PayCurrencyEnum = "COU"
	PayCurrencyEnumKmf PayCurrencyEnum = "KMF"
	PayCurrencyEnumCdf PayCurrencyEnum = "CDF"
	PayCurrencyEnumCrc PayCurrencyEnum = "CRC"
	PayCurrencyEnumHrd PayCurrencyEnum = "HRD"
	PayCurrencyEnumHrk PayCurrencyEnum = "HRK"
	PayCurrencyEnumCuc PayCurrencyEnum = "CUC"
	PayCurrencyEnumCup PayCurrencyEnum = "CUP"
	PayCurrencyEnumCyp PayCurrencyEnum = "CYP"
	PayCurrencyEnumCzk PayCurrencyEnum = "CZK"
	PayCurrencyEnumCsk PayCurrencyEnum = "CSK"
	PayCurrencyEnumDkk PayCurrencyEnum = "DKK"
	PayCurrencyEnumDjf PayCurrencyEnum = "DJF"
	PayCurrencyEnumDop PayCurrencyEnum = "DOP"
	PayCurrencyEnumNlg PayCurrencyEnum = "NLG"
	PayCurrencyEnumXcd PayCurrencyEnum = "XCD"
	PayCurrencyEnumDdm PayCurrencyEnum = "DDM"
	PayCurrencyEnumEcs PayCurrencyEnum = "ECS"
	PayCurrencyEnumEcv PayCurrencyEnum = "ECV"
	PayCurrencyEnumEgp PayCurrencyEnum = "EGP"
	PayCurrencyEnumGqe PayCurrencyEnum = "GQE"
	PayCurrencyEnumErn PayCurrencyEnum = "ERN"
	PayCurrencyEnumEek PayCurrencyEnum = "EEK"
	PayCurrencyEnumEtb PayCurrencyEnum = "ETB"
	PayCurrencyEnumEur PayCurrencyEnum = "EUR"
	PayCurrencyEnumXba PayCurrencyEnum = "XBA"
	PayCurrencyEnumXeu PayCurrencyEnum = "XEU"
	PayCurrencyEnumXbb PayCurrencyEnum = "XBB"
	PayCurrencyEnumXbc PayCurrencyEnum = "XBC"
	PayCurrencyEnumXbd PayCurrencyEnum = "XBD"
	PayCurrencyEnumFkp PayCurrencyEnum = "FKP"
	PayCurrencyEnumFjd PayCurrencyEnum = "FJD"
	PayCurrencyEnumFim PayCurrencyEnum = "FIM"
	PayCurrencyEnumFrf PayCurrencyEnum = "FRF"
	PayCurrencyEnumXfo PayCurrencyEnum = "XFO"
	PayCurrencyEnumXfu PayCurrencyEnum = "XFU"
	PayCurrencyEnumGmd PayCurrencyEnum = "GMD"
	PayCurrencyEnumGek PayCurrencyEnum = "GEK"
	PayCurrencyEnumGel PayCurrencyEnum = "GEL"
	PayCurrencyEnumDem PayCurrencyEnum = "DEM"
	PayCurrencyEnumGhs PayCurrencyEnum = "GHS"
	PayCurrencyEnumGhc PayCurrencyEnum = "GHC"
	PayCurrencyEnumGip PayCurrencyEnum = "GIP"
	PayCurrencyEnumXau PayCurrencyEnum = "XAU"
	PayCurrencyEnumGrd PayCurrencyEnum = "GRD"
	PayCurrencyEnumGtq PayCurrencyEnum = "GTQ"
	PayCurrencyEnumGwp PayCurrencyEnum = "GWP"
	PayCurrencyEnumGnf PayCurrencyEnum = "GNF"
	PayCurrencyEnumGns PayCurrencyEnum = "GNS"
	PayCurrencyEnumGyd PayCurrencyEnum = "GYD"
	PayCurrencyEnumHtg PayCurrencyEnum = "HTG"
	PayCurrencyEnumHnl PayCurrencyEnum = "HNL"
	PayCurrencyEnumHkd PayCurrencyEnum = "HKD"
	PayCurrencyEnumHuf PayCurrencyEnum = "HUF"
	PayCurrencyEnumImp PayCurrencyEnum = "IMP"
	PayCurrencyEnumIsk PayCurrencyEnum = "ISK"
	PayCurrencyEnumIsj PayCurrencyEnum = "ISJ"
	PayCurrencyEnumInr PayCurrencyEnum = "INR"
	PayCurrencyEnumIdr PayCurrencyEnum = "IDR"
	PayCurrencyEnumIrr PayCurrencyEnum = "IRR"
	PayCurrencyEnumIqd PayCurrencyEnum = "IQD"
	PayCurrencyEnumIep PayCurrencyEnum = "IEP"
	PayCurrencyEnumIls PayCurrencyEnum = "ILS"
	PayCurrencyEnumIlp PayCurrencyEnum = "ILP"
	PayCurrencyEnumIlr PayCurrencyEnum = "ILR"
	PayCurrencyEnumItl PayCurrencyEnum = "ITL"
	PayCurrencyEnumJmd PayCurrencyEnum = "JMD"
	PayCurrencyEnumJpy PayCurrencyEnum = "JPY"
	PayCurrencyEnumJod PayCurrencyEnum = "JOD"
	PayCurrencyEnumKzt PayCurrencyEnum = "KZT"
	PayCurrencyEnumKes PayCurrencyEnum = "KES"
	PayCurrencyEnumKwd PayCurrencyEnum = "KWD"
	PayCurrencyEnumKgs PayCurrencyEnum = "KGS"
	PayCurrencyEnumLak PayCurrencyEnum = "LAK"
	PayCurrencyEnumLvl PayCurrencyEnum = "LVL"
	PayCurrencyEnumLvr PayCurrencyEnum = "LVR"
	PayCurrencyEnumLbp PayCurrencyEnum = "LBP"
	PayCurrencyEnumLsl PayCurrencyEnum = "LSL"
	PayCurrencyEnumLrd PayCurrencyEnum = "LRD"
	PayCurrencyEnumLyd PayCurrencyEnum = "LYD"
	PayCurrencyEnumLtl PayCurrencyEnum = "LTL"
	PayCurrencyEnumLtt PayCurrencyEnum = "LTT"
	PayCurrencyEnumLul PayCurrencyEnum = "LUL"
	PayCurrencyEnumLuc PayCurrencyEnum = "LUC"
	PayCurrencyEnumLuf PayCurrencyEnum = "LUF"
	PayCurrencyEnumMop PayCurrencyEnum = "MOP"
	PayCurrencyEnumMkd PayCurrencyEnum = "MKD"
	PayCurrencyEnumMkn PayCurrencyEnum = "MKN"
	PayCurrencyEnumMga PayCurrencyEnum = "MGA"
	PayCurrencyEnumMgf PayCurrencyEnum = "MGF"
	PayCurrencyEnumMwk PayCurrencyEnum = "MWK"
	PayCurrencyEnumMyr PayCurrencyEnum = "MYR"
	PayCurrencyEnumMvr PayCurrencyEnum = "MVR"
	PayCurrencyEnumMvp PayCurrencyEnum = "MVP"
	PayCurrencyEnumMlf PayCurrencyEnum = "MLF"
	PayCurrencyEnumMtl PayCurrencyEnum = "MTL"
	PayCurrencyEnumMtp PayCurrencyEnum = "MTP"
	PayCurrencyEnumMru PayCurrencyEnum = "MRU"
	PayCurrencyEnumMro PayCurrencyEnum = "MRO"
	PayCurrencyEnumMur PayCurrencyEnum = "MUR"
	PayCurrencyEnumMxv PayCurrencyEnum = "MXV"
	PayCurrencyEnumMxn PayCurrencyEnum = "MXN"
	PayCurrencyEnumMxp PayCurrencyEnum = "MXP"
	PayCurrencyEnumMdc PayCurrencyEnum = "MDC"
	PayCurrencyEnumMdl PayCurrencyEnum = "MDL"
	PayCurrencyEnumMcf PayCurrencyEnum = "MCF"
	PayCurrencyEnumMnt PayCurrencyEnum = "MNT"
	PayCurrencyEnumMad PayCurrencyEnum = "MAD"
	PayCurrencyEnumMaf PayCurrencyEnum = "MAF"
	PayCurrencyEnumMze PayCurrencyEnum = "MZE"
	PayCurrencyEnumMzn PayCurrencyEnum = "MZN"
	PayCurrencyEnumMzm PayCurrencyEnum = "MZM"
	PayCurrencyEnumMmk PayCurrencyEnum = "MMK"
	PayCurrencyEnumNad PayCurrencyEnum = "NAD"
	PayCurrencyEnumNpr PayCurrencyEnum = "NPR"
	PayCurrencyEnumAng PayCurrencyEnum = "ANG"
	PayCurrencyEnumTwd PayCurrencyEnum = "TWD"
	PayCurrencyEnumNzd PayCurrencyEnum = "NZD"
	PayCurrencyEnumNio PayCurrencyEnum = "NIO"
	PayCurrencyEnumNic PayCurrencyEnum = "NIC"
	PayCurrencyEnumNgn PayCurrencyEnum = "NGN"
	PayCurrencyEnumKpw PayCurrencyEnum = "KPW"
	PayCurrencyEnumNok PayCurrencyEnum = "NOK"
	PayCurrencyEnumOmr PayCurrencyEnum = "OMR"
	PayCurrencyEnumPkr PayCurrencyEnum = "PKR"
	PayCurrencyEnumXpd PayCurrencyEnum = "XPD"
	PayCurrencyEnumPab PayCurrencyEnum = "PAB"
	PayCurrencyEnumPgk PayCurrencyEnum = "PGK"
	PayCurrencyEnumPyg PayCurrencyEnum = "PYG"
	PayCurrencyEnumPei PayCurrencyEnum = "PEI"
	PayCurrencyEnumPen PayCurrencyEnum = "PEN"
	PayCurrencyEnumPes PayCurrencyEnum = "PES"
	PayCurrencyEnumPhp PayCurrencyEnum = "PHP"
	PayCurrencyEnumXpt PayCurrencyEnum = "XPT"
	PayCurrencyEnumPln PayCurrencyEnum = "PLN"
	PayCurrencyEnumPlz PayCurrencyEnum = "PLZ"
	PayCurrencyEnumPte PayCurrencyEnum = "PTE"
	PayCurrencyEnumGwe PayCurrencyEnum = "GWE"
	PayCurrencyEnumQar PayCurrencyEnum = "QAR"
	PayCurrencyEnumXre PayCurrencyEnum = "XRE"
	PayCurrencyEnumRhd PayCurrencyEnum = "RHD"
	PayCurrencyEnumRon PayCurrencyEnum = "RON"
	PayCurrencyEnumRol PayCurrencyEnum = "ROL"
	PayCurrencyEnumRub PayCurrencyEnum = "RUB"
	PayCurrencyEnumRur PayCurrencyEnum = "RUR"
	PayCurrencyEnumRwf PayCurrencyEnum = "RWF"
	PayCurrencyEnumSvc PayCurrencyEnum = "SVC"
	PayCurrencyEnumWst PayCurrencyEnum = "WST"
	PayCurrencyEnumSar PayCurrencyEnum = "SAR"
	PayCurrencyEnumRsd PayCurrencyEnum = "RSD"
	PayCurrencyEnumCsd PayCurrencyEnum = "CSD"
	PayCurrencyEnumScr PayCurrencyEnum = "SCR"
	PayCurrencyEnumSll PayCurrencyEnum = "SLL"
	PayCurrencyEnumXag PayCurrencyEnum = "XAG"
	PayCurrencyEnumSgd PayCurrencyEnum = "SGD"
	PayCurrencyEnumSkk PayCurrencyEnum = "SKK"
	PayCurrencyEnumSit PayCurrencyEnum = "SIT"
	PayCurrencyEnumSbd PayCurrencyEnum = "SBD"
	PayCurrencyEnumSos PayCurrencyEnum = "SOS"
	PayCurrencyEnumZar PayCurrencyEnum = "ZAR"
	PayCurrencyEnumZal PayCurrencyEnum = "ZAL"
	PayCurrencyEnumKrh PayCurrencyEnum = "KRH"
	PayCurrencyEnumKrw PayCurrencyEnum = "KRW"
	PayCurrencyEnumKro PayCurrencyEnum = "KRO"
	PayCurrencyEnumSsp PayCurrencyEnum = "SSP"
	PayCurrencyEnumSur PayCurrencyEnum = "SUR"
	PayCurrencyEnumEsp PayCurrencyEnum = "ESP"
	PayCurrencyEnumEsa PayCurrencyEnum = "ESA"
	PayCurrencyEnumEsb PayCurrencyEnum = "ESB"
	PayCurrencyEnumXdr PayCurrencyEnum = "XDR"
	PayCurrencyEnumLkr PayCurrencyEnum = "LKR"
	PayCurrencyEnumShp PayCurrencyEnum = "SHP"
	PayCurrencyEnumXsu PayCurrencyEnum = "XSU"
	PayCurrencyEnumSdd PayCurrencyEnum = "SDD"
	PayCurrencyEnumSdg PayCurrencyEnum = "SDG"
	PayCurrencyEnumSdp PayCurrencyEnum = "SDP"
	PayCurrencyEnumSrd PayCurrencyEnum = "SRD"
	PayCurrencyEnumSrg PayCurrencyEnum = "SRG"
	PayCurrencyEnumSzl PayCurrencyEnum = "SZL"
	PayCurrencyEnumSek PayCurrencyEnum = "SEK"
	PayCurrencyEnumChf PayCurrencyEnum = "CHF"
	PayCurrencyEnumSyp PayCurrencyEnum = "SYP"
	PayCurrencyEnumStn PayCurrencyEnum = "STN"
	PayCurrencyEnumStd PayCurrencyEnum = "STD"
	PayCurrencyEnumTvd PayCurrencyEnum = "TVD"
	PayCurrencyEnumTjr PayCurrencyEnum = "TJR"
	PayCurrencyEnumTjs PayCurrencyEnum = "TJS"
	PayCurrencyEnumTzs PayCurrencyEnum = "TZS"
	PayCurrencyEnumXts PayCurrencyEnum = "XTS"
	PayCurrencyEnumThb PayCurrencyEnum = "THB"
	PayCurrencyEnumXxx PayCurrencyEnum = "XXX"
	PayCurrencyEnumTpe PayCurrencyEnum = "TPE"
	PayCurrencyEnumTop PayCurrencyEnum = "TOP"
	PayCurrencyEnumTtd PayCurrencyEnum = "TTD"
	PayCurrencyEnumTnd PayCurrencyEnum = "TND"
	PayCurrencyEnumTry PayCurrencyEnum = "TRY"
	PayCurrencyEnumTrl PayCurrencyEnum = "TRL"
	PayCurrencyEnumTmt PayCurrencyEnum = "TMT"
	PayCurrencyEnumTmm PayCurrencyEnum = "TMM"
	PayCurrencyEnumUsd PayCurrencyEnum = "USD"
	PayCurrencyEnumUsn PayCurrencyEnum = "USN"
	PayCurrencyEnumUss PayCurrencyEnum = "USS"
	PayCurrencyEnumUgx PayCurrencyEnum = "UGX"
	PayCurrencyEnumUgs PayCurrencyEnum = "UGS"
	PayCurrencyEnumUah PayCurrencyEnum = "UAH"
	PayCurrencyEnumUak PayCurrencyEnum = "UAK"
	PayCurrencyEnumAed PayCurrencyEnum = "AED"
	PayCurrencyEnumUyw PayCurrencyEnum = "UYW"
	PayCurrencyEnumUyu PayCurrencyEnum = "UYU"
	PayCurrencyEnumUyp PayCurrencyEnum = "UYP"
	PayCurrencyEnumUyi PayCurrencyEnum = "UYI"
	PayCurrencyEnumUzs PayCurrencyEnum = "UZS"
	PayCurrencyEnumVuv PayCurrencyEnum = "VUV"
	PayCurrencyEnumVes PayCurrencyEnum = "VES"
	PayCurrencyEnumVeb PayCurrencyEnum = "VEB"
	PayCurrencyEnumVef PayCurrencyEnum = "VEF"
	PayCurrencyEnumVnd PayCurrencyEnum = "VND"
	PayCurrencyEnumVnn PayCurrencyEnum = "VNN"
	PayCurrencyEnumChe PayCurrencyEnum = "CHE"
	PayCurrencyEnumChw PayCurrencyEnum = "CHW"
	PayCurrencyEnumXof PayCurrencyEnum = "XOF"
	PayCurrencyEnumYdd PayCurrencyEnum = "YDD"
	PayCurrencyEnumYer PayCurrencyEnum = "YER"
	PayCurrencyEnumYun PayCurrencyEnum = "YUN"
	PayCurrencyEnumYud PayCurrencyEnum = "YUD"
	PayCurrencyEnumYum PayCurrencyEnum = "YUM"
	PayCurrencyEnumYur PayCurrencyEnum = "YUR"
	PayCurrencyEnumZwn PayCurrencyEnum = "ZWN"
	PayCurrencyEnumZrn PayCurrencyEnum = "ZRN"
	PayCurrencyEnumZrz PayCurrencyEnum = "ZRZ"
	PayCurrencyEnumZmw PayCurrencyEnum = "ZMW"
	PayCurrencyEnumZmk PayCurrencyEnum = "ZMK"
	PayCurrencyEnumZwd PayCurrencyEnum = "ZWD"
	PayCurrencyEnumZwr PayCurrencyEnum = "ZWR"
	PayCurrencyEnumZwl PayCurrencyEnum = "ZWL"
)

func NewPayCurrencyEnumFromString(s string) (PayCurrencyEnum, error) {
	switch s {
	case "XUA":
		return PayCurrencyEnumXua, nil
	case "AFN":
		return PayCurrencyEnumAfn, nil
	case "AFA":
		return PayCurrencyEnumAfa, nil
	case "ALL":
		return PayCurrencyEnumAll, nil
	case "ALK":
		return PayCurrencyEnumAlk, nil
	case "DZD":
		return PayCurrencyEnumDzd, nil
	case "ADP":
		return PayCurrencyEnumAdp, nil
	case "AOA":
		return PayCurrencyEnumAoa, nil
	case "AOK":
		return PayCurrencyEnumAok, nil
	case "AON":
		return PayCurrencyEnumAon, nil
	case "AOR":
		return PayCurrencyEnumAor, nil
	case "ARA":
		return PayCurrencyEnumAra, nil
	case "ARS":
		return PayCurrencyEnumArs, nil
	case "ARM":
		return PayCurrencyEnumArm, nil
	case "ARP":
		return PayCurrencyEnumArp, nil
	case "ARL":
		return PayCurrencyEnumArl, nil
	case "AMD":
		return PayCurrencyEnumAmd, nil
	case "AWG":
		return PayCurrencyEnumAwg, nil
	case "AUD":
		return PayCurrencyEnumAud, nil
	case "ATS":
		return PayCurrencyEnumAts, nil
	case "AZN":
		return PayCurrencyEnumAzn, nil
	case "AZM":
		return PayCurrencyEnumAzm, nil
	case "BSD":
		return PayCurrencyEnumBsd, nil
	case "BHD":
		return PayCurrencyEnumBhd, nil
	case "BDT":
		return PayCurrencyEnumBdt, nil
	case "BBD":
		return PayCurrencyEnumBbd, nil
	case "BYN":
		return PayCurrencyEnumByn, nil
	case "BYB":
		return PayCurrencyEnumByb, nil
	case "BYR":
		return PayCurrencyEnumByr, nil
	case "BEF":
		return PayCurrencyEnumBef, nil
	case "BEC":
		return PayCurrencyEnumBec, nil
	case "BEL":
		return PayCurrencyEnumBel, nil
	case "BZD":
		return PayCurrencyEnumBzd, nil
	case "BMD":
		return PayCurrencyEnumBmd, nil
	case "BTN":
		return PayCurrencyEnumBtn, nil
	case "BOB":
		return PayCurrencyEnumBob, nil
	case "BOL":
		return PayCurrencyEnumBol, nil
	case "BOV":
		return PayCurrencyEnumBov, nil
	case "BOP":
		return PayCurrencyEnumBop, nil
	case "BAM":
		return PayCurrencyEnumBam, nil
	case "BAD":
		return PayCurrencyEnumBad, nil
	case "BAN":
		return PayCurrencyEnumBan, nil
	case "BWP":
		return PayCurrencyEnumBwp, nil
	case "BRC":
		return PayCurrencyEnumBrc, nil
	case "BRZ":
		return PayCurrencyEnumBrz, nil
	case "BRE":
		return PayCurrencyEnumBre, nil
	case "BRR":
		return PayCurrencyEnumBrr, nil
	case "BRN":
		return PayCurrencyEnumBrn, nil
	case "BRB":
		return PayCurrencyEnumBrb, nil
	case "BRL":
		return PayCurrencyEnumBrl, nil
	case "GBP":
		return PayCurrencyEnumGbp, nil
	case "BND":
		return PayCurrencyEnumBnd, nil
	case "BGL":
		return PayCurrencyEnumBgl, nil
	case "BGN":
		return PayCurrencyEnumBgn, nil
	case "BGO":
		return PayCurrencyEnumBgo, nil
	case "BGM":
		return PayCurrencyEnumBgm, nil
	case "BUK":
		return PayCurrencyEnumBuk, nil
	case "BIF":
		return PayCurrencyEnumBif, nil
	case "XPF":
		return PayCurrencyEnumXpf, nil
	case "KHR":
		return PayCurrencyEnumKhr, nil
	case "CAD":
		return PayCurrencyEnumCad, nil
	case "CVE":
		return PayCurrencyEnumCve, nil
	case "KYD":
		return PayCurrencyEnumKyd, nil
	case "XAF":
		return PayCurrencyEnumXaf, nil
	case "CLE":
		return PayCurrencyEnumCle, nil
	case "CLP":
		return PayCurrencyEnumClp, nil
	case "CLF":
		return PayCurrencyEnumClf, nil
	case "CNX":
		return PayCurrencyEnumCnx, nil
	case "CNY":
		return PayCurrencyEnumCny, nil
	case "CNH":
		return PayCurrencyEnumCnh, nil
	case "COP":
		return PayCurrencyEnumCop, nil
	case "COU":
		return PayCurrencyEnumCou, nil
	case "KMF":
		return PayCurrencyEnumKmf, nil
	case "CDF":
		return PayCurrencyEnumCdf, nil
	case "CRC":
		return PayCurrencyEnumCrc, nil
	case "HRD":
		return PayCurrencyEnumHrd, nil
	case "HRK":
		return PayCurrencyEnumHrk, nil
	case "CUC":
		return PayCurrencyEnumCuc, nil
	case "CUP":
		return PayCurrencyEnumCup, nil
	case "CYP":
		return PayCurrencyEnumCyp, nil
	case "CZK":
		return PayCurrencyEnumCzk, nil
	case "CSK":
		return PayCurrencyEnumCsk, nil
	case "DKK":
		return PayCurrencyEnumDkk, nil
	case "DJF":
		return PayCurrencyEnumDjf, nil
	case "DOP":
		return PayCurrencyEnumDop, nil
	case "NLG":
		return PayCurrencyEnumNlg, nil
	case "XCD":
		return PayCurrencyEnumXcd, nil
	case "DDM":
		return PayCurrencyEnumDdm, nil
	case "ECS":
		return PayCurrencyEnumEcs, nil
	case "ECV":
		return PayCurrencyEnumEcv, nil
	case "EGP":
		return PayCurrencyEnumEgp, nil
	case "GQE":
		return PayCurrencyEnumGqe, nil
	case "ERN":
		return PayCurrencyEnumErn, nil
	case "EEK":
		return PayCurrencyEnumEek, nil
	case "ETB":
		return PayCurrencyEnumEtb, nil
	case "EUR":
		return PayCurrencyEnumEur, nil
	case "XBA":
		return PayCurrencyEnumXba, nil
	case "XEU":
		return PayCurrencyEnumXeu, nil
	case "XBB":
		return PayCurrencyEnumXbb, nil
	case "XBC":
		return PayCurrencyEnumXbc, nil
	case "XBD":
		return PayCurrencyEnumXbd, nil
	case "FKP":
		return PayCurrencyEnumFkp, nil
	case "FJD":
		return PayCurrencyEnumFjd, nil
	case "FIM":
		return PayCurrencyEnumFim, nil
	case "FRF":
		return PayCurrencyEnumFrf, nil
	case "XFO":
		return PayCurrencyEnumXfo, nil
	case "XFU":
		return PayCurrencyEnumXfu, nil
	case "GMD":
		return PayCurrencyEnumGmd, nil
	case "GEK":
		return PayCurrencyEnumGek, nil
	case "GEL":
		return PayCurrencyEnumGel, nil
	case "DEM":
		return PayCurrencyEnumDem, nil
	case "GHS":
		return PayCurrencyEnumGhs, nil
	case "GHC":
		return PayCurrencyEnumGhc, nil
	case "GIP":
		return PayCurrencyEnumGip, nil
	case "XAU":
		return PayCurrencyEnumXau, nil
	case "GRD":
		return PayCurrencyEnumGrd, nil
	case "GTQ":
		return PayCurrencyEnumGtq, nil
	case "GWP":
		return PayCurrencyEnumGwp, nil
	case "GNF":
		return PayCurrencyEnumGnf, nil
	case "GNS":
		return PayCurrencyEnumGns, nil
	case "GYD":
		return PayCurrencyEnumGyd, nil
	case "HTG":
		return PayCurrencyEnumHtg, nil
	case "HNL":
		return PayCurrencyEnumHnl, nil
	case "HKD":
		return PayCurrencyEnumHkd, nil
	case "HUF":
		return PayCurrencyEnumHuf, nil
	case "IMP":
		return PayCurrencyEnumImp, nil
	case "ISK":
		return PayCurrencyEnumIsk, nil
	case "ISJ":
		return PayCurrencyEnumIsj, nil
	case "INR":
		return PayCurrencyEnumInr, nil
	case "IDR":
		return PayCurrencyEnumIdr, nil
	case "IRR":
		return PayCurrencyEnumIrr, nil
	case "IQD":
		return PayCurrencyEnumIqd, nil
	case "IEP":
		return PayCurrencyEnumIep, nil
	case "ILS":
		return PayCurrencyEnumIls, nil
	case "ILP":
		return PayCurrencyEnumIlp, nil
	case "ILR":
		return PayCurrencyEnumIlr, nil
	case "ITL":
		return PayCurrencyEnumItl, nil
	case "JMD":
		return PayCurrencyEnumJmd, nil
	case "JPY":
		return PayCurrencyEnumJpy, nil
	case "JOD":
		return PayCurrencyEnumJod, nil
	case "KZT":
		return PayCurrencyEnumKzt, nil
	case "KES":
		return PayCurrencyEnumKes, nil
	case "KWD":
		return PayCurrencyEnumKwd, nil
	case "KGS":
		return PayCurrencyEnumKgs, nil
	case "LAK":
		return PayCurrencyEnumLak, nil
	case "LVL":
		return PayCurrencyEnumLvl, nil
	case "LVR":
		return PayCurrencyEnumLvr, nil
	case "LBP":
		return PayCurrencyEnumLbp, nil
	case "LSL":
		return PayCurrencyEnumLsl, nil
	case "LRD":
		return PayCurrencyEnumLrd, nil
	case "LYD":
		return PayCurrencyEnumLyd, nil
	case "LTL":
		return PayCurrencyEnumLtl, nil
	case "LTT":
		return PayCurrencyEnumLtt, nil
	case "LUL":
		return PayCurrencyEnumLul, nil
	case "LUC":
		return PayCurrencyEnumLuc, nil
	case "LUF":
		return PayCurrencyEnumLuf, nil
	case "MOP":
		return PayCurrencyEnumMop, nil
	case "MKD":
		return PayCurrencyEnumMkd, nil
	case "MKN":
		return PayCurrencyEnumMkn, nil
	case "MGA":
		return PayCurrencyEnumMga, nil
	case "MGF":
		return PayCurrencyEnumMgf, nil
	case "MWK":
		return PayCurrencyEnumMwk, nil
	case "MYR":
		return PayCurrencyEnumMyr, nil
	case "MVR":
		return PayCurrencyEnumMvr, nil
	case "MVP":
		return PayCurrencyEnumMvp, nil
	case "MLF":
		return PayCurrencyEnumMlf, nil
	case "MTL":
		return PayCurrencyEnumMtl, nil
	case "MTP":
		return PayCurrencyEnumMtp, nil
	case "MRU":
		return PayCurrencyEnumMru, nil
	case "MRO":
		return PayCurrencyEnumMro, nil
	case "MUR":
		return PayCurrencyEnumMur, nil
	case "MXV":
		return PayCurrencyEnumMxv, nil
	case "MXN":
		return PayCurrencyEnumMxn, nil
	case "MXP":
		return PayCurrencyEnumMxp, nil
	case "MDC":
		return PayCurrencyEnumMdc, nil
	case "MDL":
		return PayCurrencyEnumMdl, nil
	case "MCF":
		return PayCurrencyEnumMcf, nil
	case "MNT":
		return PayCurrencyEnumMnt, nil
	case "MAD":
		return PayCurrencyEnumMad, nil
	case "MAF":
		return PayCurrencyEnumMaf, nil
	case "MZE":
		return PayCurrencyEnumMze, nil
	case "MZN":
		return PayCurrencyEnumMzn, nil
	case "MZM":
		return PayCurrencyEnumMzm, nil
	case "MMK":
		return PayCurrencyEnumMmk, nil
	case "NAD":
		return PayCurrencyEnumNad, nil
	case "NPR":
		return PayCurrencyEnumNpr, nil
	case "ANG":
		return PayCurrencyEnumAng, nil
	case "TWD":
		return PayCurrencyEnumTwd, nil
	case "NZD":
		return PayCurrencyEnumNzd, nil
	case "NIO":
		return PayCurrencyEnumNio, nil
	case "NIC":
		return PayCurrencyEnumNic, nil
	case "NGN":
		return PayCurrencyEnumNgn, nil
	case "KPW":
		return PayCurrencyEnumKpw, nil
	case "NOK":
		return PayCurrencyEnumNok, nil
	case "OMR":
		return PayCurrencyEnumOmr, nil
	case "PKR":
		return PayCurrencyEnumPkr, nil
	case "XPD":
		return PayCurrencyEnumXpd, nil
	case "PAB":
		return PayCurrencyEnumPab, nil
	case "PGK":
		return PayCurrencyEnumPgk, nil
	case "PYG":
		return PayCurrencyEnumPyg, nil
	case "PEI":
		return PayCurrencyEnumPei, nil
	case "PEN":
		return PayCurrencyEnumPen, nil
	case "PES":
		return PayCurrencyEnumPes, nil
	case "PHP":
		return PayCurrencyEnumPhp, nil
	case "XPT":
		return PayCurrencyEnumXpt, nil
	case "PLN":
		return PayCurrencyEnumPln, nil
	case "PLZ":
		return PayCurrencyEnumPlz, nil
	case "PTE":
		return PayCurrencyEnumPte, nil
	case "GWE":
		return PayCurrencyEnumGwe, nil
	case "QAR":
		return PayCurrencyEnumQar, nil
	case "XRE":
		return PayCurrencyEnumXre, nil
	case "RHD":
		return PayCurrencyEnumRhd, nil
	case "RON":
		return PayCurrencyEnumRon, nil
	case "ROL":
		return PayCurrencyEnumRol, nil
	case "RUB":
		return PayCurrencyEnumRub, nil
	case "RUR":
		return PayCurrencyEnumRur, nil
	case "RWF":
		return PayCurrencyEnumRwf, nil
	case "SVC":
		return PayCurrencyEnumSvc, nil
	case "WST":
		return PayCurrencyEnumWst, nil
	case "SAR":
		return PayCurrencyEnumSar, nil
	case "RSD":
		return PayCurrencyEnumRsd, nil
	case "CSD":
		return PayCurrencyEnumCsd, nil
	case "SCR":
		return PayCurrencyEnumScr, nil
	case "SLL":
		return PayCurrencyEnumSll, nil
	case "XAG":
		return PayCurrencyEnumXag, nil
	case "SGD":
		return PayCurrencyEnumSgd, nil
	case "SKK":
		return PayCurrencyEnumSkk, nil
	case "SIT":
		return PayCurrencyEnumSit, nil
	case "SBD":
		return PayCurrencyEnumSbd, nil
	case "SOS":
		return PayCurrencyEnumSos, nil
	case "ZAR":
		return PayCurrencyEnumZar, nil
	case "ZAL":
		return PayCurrencyEnumZal, nil
	case "KRH":
		return PayCurrencyEnumKrh, nil
	case "KRW":
		return PayCurrencyEnumKrw, nil
	case "KRO":
		return PayCurrencyEnumKro, nil
	case "SSP":
		return PayCurrencyEnumSsp, nil
	case "SUR":
		return PayCurrencyEnumSur, nil
	case "ESP":
		return PayCurrencyEnumEsp, nil
	case "ESA":
		return PayCurrencyEnumEsa, nil
	case "ESB":
		return PayCurrencyEnumEsb, nil
	case "XDR":
		return PayCurrencyEnumXdr, nil
	case "LKR":
		return PayCurrencyEnumLkr, nil
	case "SHP":
		return PayCurrencyEnumShp, nil
	case "XSU":
		return PayCurrencyEnumXsu, nil
	case "SDD":
		return PayCurrencyEnumSdd, nil
	case "SDG":
		return PayCurrencyEnumSdg, nil
	case "SDP":
		return PayCurrencyEnumSdp, nil
	case "SRD":
		return PayCurrencyEnumSrd, nil
	case "SRG":
		return PayCurrencyEnumSrg, nil
	case "SZL":
		return PayCurrencyEnumSzl, nil
	case "SEK":
		return PayCurrencyEnumSek, nil
	case "CHF":
		return PayCurrencyEnumChf, nil
	case "SYP":
		return PayCurrencyEnumSyp, nil
	case "STN":
		return PayCurrencyEnumStn, nil
	case "STD":
		return PayCurrencyEnumStd, nil
	case "TVD":
		return PayCurrencyEnumTvd, nil
	case "TJR":
		return PayCurrencyEnumTjr, nil
	case "TJS":
		return PayCurrencyEnumTjs, nil
	case "TZS":
		return PayCurrencyEnumTzs, nil
	case "XTS":
		return PayCurrencyEnumXts, nil
	case "THB":
		return PayCurrencyEnumThb, nil
	case "XXX":
		return PayCurrencyEnumXxx, nil
	case "TPE":
		return PayCurrencyEnumTpe, nil
	case "TOP":
		return PayCurrencyEnumTop, nil
	case "TTD":
		return PayCurrencyEnumTtd, nil
	case "TND":
		return PayCurrencyEnumTnd, nil
	case "TRY":
		return PayCurrencyEnumTry, nil
	case "TRL":
		return PayCurrencyEnumTrl, nil
	case "TMT":
		return PayCurrencyEnumTmt, nil
	case "TMM":
		return PayCurrencyEnumTmm, nil
	case "USD":
		return PayCurrencyEnumUsd, nil
	case "USN":
		return PayCurrencyEnumUsn, nil
	case "USS":
		return PayCurrencyEnumUss, nil
	case "UGX":
		return PayCurrencyEnumUgx, nil
	case "UGS":
		return PayCurrencyEnumUgs, nil
	case "UAH":
		return PayCurrencyEnumUah, nil
	case "UAK":
		return PayCurrencyEnumUak, nil
	case "AED":
		return PayCurrencyEnumAed, nil
	case "UYW":
		return PayCurrencyEnumUyw, nil
	case "UYU":
		return PayCurrencyEnumUyu, nil
	case "UYP":
		return PayCurrencyEnumUyp, nil
	case "UYI":
		return PayCurrencyEnumUyi, nil
	case "UZS":
		return PayCurrencyEnumUzs, nil
	case "VUV":
		return PayCurrencyEnumVuv, nil
	case "VES":
		return PayCurrencyEnumVes, nil
	case "VEB":
		return PayCurrencyEnumVeb, nil
	case "VEF":
		return PayCurrencyEnumVef, nil
	case "VND":
		return PayCurrencyEnumVnd, nil
	case "VNN":
		return PayCurrencyEnumVnn, nil
	case "CHE":
		return PayCurrencyEnumChe, nil
	case "CHW":
		return PayCurrencyEnumChw, nil
	case "XOF":
		return PayCurrencyEnumXof, nil
	case "YDD":
		return PayCurrencyEnumYdd, nil
	case "YER":
		return PayCurrencyEnumYer, nil
	case "YUN":
		return PayCurrencyEnumYun, nil
	case "YUD":
		return PayCurrencyEnumYud, nil
	case "YUM":
		return PayCurrencyEnumYum, nil
	case "YUR":
		return PayCurrencyEnumYur, nil
	case "ZWN":
		return PayCurrencyEnumZwn, nil
	case "ZRN":
		return PayCurrencyEnumZrn, nil
	case "ZRZ":
		return PayCurrencyEnumZrz, nil
	case "ZMW":
		return PayCurrencyEnumZmw, nil
	case "ZMK":
		return PayCurrencyEnumZmk, nil
	case "ZWD":
		return PayCurrencyEnumZwd, nil
	case "ZWR":
		return PayCurrencyEnumZwr, nil
	case "ZWL":
		return PayCurrencyEnumZwl, nil
	}
	var t PayCurrencyEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayCurrencyEnum) Ptr() *PayCurrencyEnum {
	return &p
}

// * `WEEKLY` - WEEKLY
// * `BIWEEKLY` - BIWEEKLY
// * `MONTHLY` - MONTHLY
// * `QUARTERLY` - QUARTERLY
// * `SEMIANNUALLY` - SEMIANNUALLY
// * `ANNUALLY` - ANNUALLY
// * `THIRTEEN-MONTHLY` - THIRTEEN-MONTHLY
// * `PRO_RATA` - PRO_RATA
// * `SEMIMONTHLY` - SEMIMONTHLY
type PayFrequencyEnum string

const (
	PayFrequencyEnumWeekly          PayFrequencyEnum = "WEEKLY"
	PayFrequencyEnumBiweekly        PayFrequencyEnum = "BIWEEKLY"
	PayFrequencyEnumMonthly         PayFrequencyEnum = "MONTHLY"
	PayFrequencyEnumQuarterly       PayFrequencyEnum = "QUARTERLY"
	PayFrequencyEnumSemiannually    PayFrequencyEnum = "SEMIANNUALLY"
	PayFrequencyEnumAnnually        PayFrequencyEnum = "ANNUALLY"
	PayFrequencyEnumThirteenMonthly PayFrequencyEnum = "THIRTEEN-MONTHLY"
	PayFrequencyEnumProRata         PayFrequencyEnum = "PRO_RATA"
	PayFrequencyEnumSemimonthly     PayFrequencyEnum = "SEMIMONTHLY"
)

func NewPayFrequencyEnumFromString(s string) (PayFrequencyEnum, error) {
	switch s {
	case "WEEKLY":
		return PayFrequencyEnumWeekly, nil
	case "BIWEEKLY":
		return PayFrequencyEnumBiweekly, nil
	case "MONTHLY":
		return PayFrequencyEnumMonthly, nil
	case "QUARTERLY":
		return PayFrequencyEnumQuarterly, nil
	case "SEMIANNUALLY":
		return PayFrequencyEnumSemiannually, nil
	case "ANNUALLY":
		return PayFrequencyEnumAnnually, nil
	case "THIRTEEN-MONTHLY":
		return PayFrequencyEnumThirteenMonthly, nil
	case "PRO_RATA":
		return PayFrequencyEnumProRata, nil
	case "SEMIMONTHLY":
		return PayFrequencyEnumSemimonthly, nil
	}
	var t PayFrequencyEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayFrequencyEnum) Ptr() *PayFrequencyEnum {
	return &p
}

// # The PayGroup Object
// ### Description
// The `PayGroup` object is used to represent a subset of employees that are put together for payroll processing purposes.
//
// ### Usage Example
// Fetch from the `LIST PayGroup` endpoint and filter by `ID` to show all pay group information.
type PayGroup struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The pay group name.
	PayGroupName *string `json:"pay_group_name,omitempty" url:"pay_group_name,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayGroup) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PayGroup) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PayGroup) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PayGroup) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *PayGroup) GetPayGroupName() *string {
	if p == nil {
		return nil
	}
	return p.PayGroupName
}

func (p *PayGroup) GetRemoteWasDeleted() *bool {
	if p == nil {
		return nil
	}
	return p.RemoteWasDeleted
}

func (p *PayGroup) GetFieldMappings() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.FieldMappings
}

func (p *PayGroup) GetRemoteData() []*RemoteData {
	if p == nil {
		return nil
	}
	return p.RemoteData
}

func (p *PayGroup) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayGroup) UnmarshalJSON(data []byte) error {
	type embed PayGroup
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PayGroup(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayGroup) MarshalJSON() ([]byte, error) {
	type embed PayGroup
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*p),
		CreatedAt:  internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(p.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PayGroup) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// * `HOUR` - HOUR
// * `DAY` - DAY
// * `WEEK` - WEEK
// * `EVERY_TWO_WEEKS` - EVERY_TWO_WEEKS
// * `SEMIMONTHLY` - SEMIMONTHLY
// * `MONTH` - MONTH
// * `QUARTER` - QUARTER
// * `EVERY_SIX_MONTHS` - EVERY_SIX_MONTHS
// * `YEAR` - YEAR
type PayPeriodEnum string

const (
	PayPeriodEnumHour           PayPeriodEnum = "HOUR"
	PayPeriodEnumDay            PayPeriodEnum = "DAY"
	PayPeriodEnumWeek           PayPeriodEnum = "WEEK"
	PayPeriodEnumEveryTwoWeeks  PayPeriodEnum = "EVERY_TWO_WEEKS"
	PayPeriodEnumSemimonthly    PayPeriodEnum = "SEMIMONTHLY"
	PayPeriodEnumMonth          PayPeriodEnum = "MONTH"
	PayPeriodEnumQuarter        PayPeriodEnum = "QUARTER"
	PayPeriodEnumEverySixMonths PayPeriodEnum = "EVERY_SIX_MONTHS"
	PayPeriodEnumYear           PayPeriodEnum = "YEAR"
)

func NewPayPeriodEnumFromString(s string) (PayPeriodEnum, error) {
	switch s {
	case "HOUR":
		return PayPeriodEnumHour, nil
	case "DAY":
		return PayPeriodEnumDay, nil
	case "WEEK":
		return PayPeriodEnumWeek, nil
	case "EVERY_TWO_WEEKS":
		return PayPeriodEnumEveryTwoWeeks, nil
	case "SEMIMONTHLY":
		return PayPeriodEnumSemimonthly, nil
	case "MONTH":
		return PayPeriodEnumMonth, nil
	case "QUARTER":
		return PayPeriodEnumQuarter, nil
	case "EVERY_SIX_MONTHS":
		return PayPeriodEnumEverySixMonths, nil
	case "YEAR":
		return PayPeriodEnumYear, nil
	}
	var t PayPeriodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayPeriodEnum) Ptr() *PayPeriodEnum {
	return &p
}

// # The PayrollRun Object
// ### Description
// The `PayrollRun` object is used to represent a group of pay statements for a specific pay schedule.
//
// ### Usage Example
// Fetch from the `LIST PayrollRuns` endpoint and filter by `ID` to show all payroll runs.
type PayrollRun struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The state of the payroll run
	//
	// * `PAID` - PAID
	// * `DRAFT` - DRAFT
	// * `APPROVED` - APPROVED
	// * `FAILED` - FAILED
	// * `CLOSED` - CLOSED
	RunState *PayrollRunRunState `json:"run_state,omitempty" url:"run_state,omitempty"`
	// The type of the payroll run
	//
	// * `REGULAR` - REGULAR
	// * `OFF_CYCLE` - OFF_CYCLE
	// * `CORRECTION` - CORRECTION
	// * `TERMINATION` - TERMINATION
	// * `SIGN_ON_BONUS` - SIGN_ON_BONUS
	RunType *PayrollRunRunType `json:"run_type,omitempty" url:"run_type,omitempty"`
	// The day and time the payroll run started.
	StartDate *time.Time `json:"start_date,omitempty" url:"start_date,omitempty"`
	// The day and time the payroll run ended.
	EndDate *time.Time `json:"end_date,omitempty" url:"end_date,omitempty"`
	// The day and time the payroll run was checked.
	CheckDate *time.Time `json:"check_date,omitempty" url:"check_date,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayrollRun) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PayrollRun) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PayrollRun) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PayrollRun) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *PayrollRun) GetRunState() *PayrollRunRunState {
	if p == nil {
		return nil
	}
	return p.RunState
}

func (p *PayrollRun) GetRunType() *PayrollRunRunType {
	if p == nil {
		return nil
	}
	return p.RunType
}

func (p *PayrollRun) GetStartDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.StartDate
}

func (p *PayrollRun) GetEndDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.EndDate
}

func (p *PayrollRun) GetCheckDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.CheckDate
}

func (p *PayrollRun) GetRemoteWasDeleted() *bool {
	if p == nil {
		return nil
	}
	return p.RemoteWasDeleted
}

func (p *PayrollRun) GetFieldMappings() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.FieldMappings
}

func (p *PayrollRun) GetRemoteData() []*RemoteData {
	if p == nil {
		return nil
	}
	return p.RemoteData
}

func (p *PayrollRun) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayrollRun) UnmarshalJSON(data []byte) error {
	type embed PayrollRun
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
		StartDate  *internal.DateTime `json:"start_date,omitempty"`
		EndDate    *internal.DateTime `json:"end_date,omitempty"`
		CheckDate  *internal.DateTime `json:"check_date,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PayrollRun(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	p.StartDate = unmarshaler.StartDate.TimePtr()
	p.EndDate = unmarshaler.EndDate.TimePtr()
	p.CheckDate = unmarshaler.CheckDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayrollRun) MarshalJSON() ([]byte, error) {
	type embed PayrollRun
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
		StartDate  *internal.DateTime `json:"start_date,omitempty"`
		EndDate    *internal.DateTime `json:"end_date,omitempty"`
		CheckDate  *internal.DateTime `json:"check_date,omitempty"`
	}{
		embed:      embed(*p),
		CreatedAt:  internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(p.ModifiedAt),
		StartDate:  internal.NewOptionalDateTime(p.StartDate),
		EndDate:    internal.NewOptionalDateTime(p.EndDate),
		CheckDate:  internal.NewOptionalDateTime(p.CheckDate),
	}
	return json.Marshal(marshaler)
}

func (p *PayrollRun) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The state of the payroll run
//
// * `PAID` - PAID
// * `DRAFT` - DRAFT
// * `APPROVED` - APPROVED
// * `FAILED` - FAILED
// * `CLOSED` - CLOSED
type PayrollRunRunState struct {
	RunStateEnum RunStateEnum
	String       string

	typ string
}

func (p *PayrollRunRunState) GetRunStateEnum() RunStateEnum {
	if p == nil {
		return ""
	}
	return p.RunStateEnum
}

func (p *PayrollRunRunState) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PayrollRunRunState) UnmarshalJSON(data []byte) error {
	var valueRunStateEnum RunStateEnum
	if err := json.Unmarshal(data, &valueRunStateEnum); err == nil {
		p.typ = "RunStateEnum"
		p.RunStateEnum = valueRunStateEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PayrollRunRunState) MarshalJSON() ([]byte, error) {
	if p.typ == "RunStateEnum" || p.RunStateEnum != "" {
		return json.Marshal(p.RunStateEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PayrollRunRunStateVisitor interface {
	VisitRunStateEnum(RunStateEnum) error
	VisitString(string) error
}

func (p *PayrollRunRunState) Accept(visitor PayrollRunRunStateVisitor) error {
	if p.typ == "RunStateEnum" || p.RunStateEnum != "" {
		return visitor.VisitRunStateEnum(p.RunStateEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The type of the payroll run
//
// * `REGULAR` - REGULAR
// * `OFF_CYCLE` - OFF_CYCLE
// * `CORRECTION` - CORRECTION
// * `TERMINATION` - TERMINATION
// * `SIGN_ON_BONUS` - SIGN_ON_BONUS
type PayrollRunRunType struct {
	RunTypeEnum RunTypeEnum
	String      string

	typ string
}

func (p *PayrollRunRunType) GetRunTypeEnum() RunTypeEnum {
	if p == nil {
		return ""
	}
	return p.RunTypeEnum
}

func (p *PayrollRunRunType) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PayrollRunRunType) UnmarshalJSON(data []byte) error {
	var valueRunTypeEnum RunTypeEnum
	if err := json.Unmarshal(data, &valueRunTypeEnum); err == nil {
		p.typ = "RunTypeEnum"
		p.RunTypeEnum = valueRunTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PayrollRunRunType) MarshalJSON() ([]byte, error) {
	if p.typ == "RunTypeEnum" || p.RunTypeEnum != "" {
		return json.Marshal(p.RunTypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PayrollRunRunTypeVisitor interface {
	VisitRunTypeEnum(RunTypeEnum) error
	VisitString(string) error
}

func (p *PayrollRunRunType) Accept(visitor PayrollRunRunTypeVisitor) error {
	if p.typ == "RunTypeEnum" || p.RunTypeEnum != "" {
		return visitor.VisitRunTypeEnum(p.RunTypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// # The RemoteData Object
// ### Description
// The `RemoteData` object is used to represent the full data pulled from the third-party API for an object.
//
// ### Usage Example
// TODO
type RemoteData struct {
	// The third-party API path that is being called.
	Path string      `json:"path" url:"path"`
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteData) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteData) GetData() interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RemoteData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteData) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteKey Object
// ### Description
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name" url:"name"`
	Key  string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteKey) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

func (r *RemoteKey) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *RemoteKey) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteKey) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteResponse Object
// ### Description
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                      `json:"method" url:"method"`
	Path            string                      `json:"path" url:"path"`
	Status          int                         `json:"status" url:"status"`
	Response        interface{}                 `json:"response" url:"response"`
	ResponseHeaders map[string]interface{}      `json:"response_headers,omitempty" url:"response_headers,omitempty"`
	ResponseType    *RemoteResponseResponseType `json:"response_type,omitempty" url:"response_type,omitempty"`
	Headers         map[string]interface{}      `json:"headers,omitempty" url:"headers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteResponse) GetMethod() string {
	if r == nil {
		return ""
	}
	return r.Method
}

func (r *RemoteResponse) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteResponse) GetStatus() int {
	if r == nil {
		return 0
	}
	return r.Status
}

func (r *RemoteResponse) GetResponse() interface{} {
	if r == nil {
		return nil
	}
	return r.Response
}

func (r *RemoteResponse) GetResponseHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.ResponseHeaders
}

func (r *RemoteResponse) GetResponseType() *RemoteResponseResponseType {
	if r == nil {
		return nil
	}
	return r.ResponseType
}

func (r *RemoteResponse) GetHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Headers
}

func (r *RemoteResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteResponseResponseType struct {
	ResponseTypeEnum ResponseTypeEnum
	String           string

	typ string
}

func (r *RemoteResponseResponseType) GetResponseTypeEnum() ResponseTypeEnum {
	if r == nil {
		return ""
	}
	return r.ResponseTypeEnum
}

func (r *RemoteResponseResponseType) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *RemoteResponseResponseType) UnmarshalJSON(data []byte) error {
	var valueResponseTypeEnum ResponseTypeEnum
	if err := json.Unmarshal(data, &valueResponseTypeEnum); err == nil {
		r.typ = "ResponseTypeEnum"
		r.ResponseTypeEnum = valueResponseTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteResponseResponseType) MarshalJSON() ([]byte, error) {
	if r.typ == "ResponseTypeEnum" || r.ResponseTypeEnum != "" {
		return json.Marshal(r.ResponseTypeEnum)
	}
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RemoteResponseResponseTypeVisitor interface {
	VisitResponseTypeEnum(ResponseTypeEnum) error
	VisitString(string) error
}

func (r *RemoteResponseResponseType) Accept(visitor RemoteResponseResponseTypeVisitor) error {
	if r.typ == "ResponseTypeEnum" || r.ResponseTypeEnum != "" {
		return visitor.VisitResponseTypeEnum(r.ResponseTypeEnum)
	}
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

// * `JSON` - JSON
// * `XML` - XML
// * `MULTIPART` - MULTIPART
type RequestFormatEnum string

const (
	RequestFormatEnumJson      RequestFormatEnum = "JSON"
	RequestFormatEnumXml       RequestFormatEnum = "XML"
	RequestFormatEnumMultipart RequestFormatEnum = "MULTIPART"
)

func NewRequestFormatEnumFromString(s string) (RequestFormatEnum, error) {
	switch s {
	case "JSON":
		return RequestFormatEnumJson, nil
	case "XML":
		return RequestFormatEnumXml, nil
	case "MULTIPART":
		return RequestFormatEnumMultipart, nil
	}
	var t RequestFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestFormatEnum) Ptr() *RequestFormatEnum {
	return &r
}

// * `JSON` - JSON
// * `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum string

const (
	ResponseTypeEnumJson       ResponseTypeEnum = "JSON"
	ResponseTypeEnumBase64Gzip ResponseTypeEnum = "BASE64_GZIP"
)

func NewResponseTypeEnumFromString(s string) (ResponseTypeEnum, error) {
	switch s {
	case "JSON":
		return ResponseTypeEnumJson, nil
	case "BASE64_GZIP":
		return ResponseTypeEnumBase64Gzip, nil
	}
	var t ResponseTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTypeEnum) Ptr() *ResponseTypeEnum {
	return &r
}

// * `PAID` - PAID
// * `DRAFT` - DRAFT
// * `APPROVED` - APPROVED
// * `FAILED` - FAILED
// * `CLOSED` - CLOSED
type RunStateEnum string

const (
	RunStateEnumPaid     RunStateEnum = "PAID"
	RunStateEnumDraft    RunStateEnum = "DRAFT"
	RunStateEnumApproved RunStateEnum = "APPROVED"
	RunStateEnumFailed   RunStateEnum = "FAILED"
	RunStateEnumClosed   RunStateEnum = "CLOSED"
)

func NewRunStateEnumFromString(s string) (RunStateEnum, error) {
	switch s {
	case "PAID":
		return RunStateEnumPaid, nil
	case "DRAFT":
		return RunStateEnumDraft, nil
	case "APPROVED":
		return RunStateEnumApproved, nil
	case "FAILED":
		return RunStateEnumFailed, nil
	case "CLOSED":
		return RunStateEnumClosed, nil
	}
	var t RunStateEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RunStateEnum) Ptr() *RunStateEnum {
	return &r
}

// * `REGULAR` - REGULAR
// * `OFF_CYCLE` - OFF_CYCLE
// * `CORRECTION` - CORRECTION
// * `TERMINATION` - TERMINATION
// * `SIGN_ON_BONUS` - SIGN_ON_BONUS
type RunTypeEnum string

const (
	RunTypeEnumRegular     RunTypeEnum = "REGULAR"
	RunTypeEnumOffCycle    RunTypeEnum = "OFF_CYCLE"
	RunTypeEnumCorrection  RunTypeEnum = "CORRECTION"
	RunTypeEnumTermination RunTypeEnum = "TERMINATION"
	RunTypeEnumSignOnBonus RunTypeEnum = "SIGN_ON_BONUS"
)

func NewRunTypeEnumFromString(s string) (RunTypeEnum, error) {
	switch s {
	case "REGULAR":
		return RunTypeEnumRegular, nil
	case "OFF_CYCLE":
		return RunTypeEnumOffCycle, nil
	case "CORRECTION":
		return RunTypeEnumCorrection, nil
	case "TERMINATION":
		return RunTypeEnumTermination, nil
	case "SIGN_ON_BONUS":
		return RunTypeEnumSignOnBonus, nil
	}
	var t RunTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RunTypeEnum) Ptr() *RunTypeEnum {
	return &r
}

// * `IN_NEXT_SYNC` - IN_NEXT_SYNC
// * `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum string

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = "IN_NEXT_SYNC"
	SelectiveSyncConfigurationsUsageEnumInLastSync SelectiveSyncConfigurationsUsageEnum = "IN_LAST_SYNC"
)

func NewSelectiveSyncConfigurationsUsageEnumFromString(s string) (SelectiveSyncConfigurationsUsageEnum, error) {
	switch s {
	case "IN_NEXT_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInNextSync, nil
	case "IN_LAST_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInLastSync, nil
	}
	var t SelectiveSyncConfigurationsUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SelectiveSyncConfigurationsUsageEnum) Ptr() *SelectiveSyncConfigurationsUsageEnum {
	return &s
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type StatusFd5Enum string

const (
	StatusFd5EnumSyncing         StatusFd5Enum = "SYNCING"
	StatusFd5EnumDone            StatusFd5Enum = "DONE"
	StatusFd5EnumFailed          StatusFd5Enum = "FAILED"
	StatusFd5EnumDisabled        StatusFd5Enum = "DISABLED"
	StatusFd5EnumPaused          StatusFd5Enum = "PAUSED"
	StatusFd5EnumPartiallySynced StatusFd5Enum = "PARTIALLY_SYNCED"
)

func NewStatusFd5EnumFromString(s string) (StatusFd5Enum, error) {
	switch s {
	case "SYNCING":
		return StatusFd5EnumSyncing, nil
	case "DONE":
		return StatusFd5EnumDone, nil
	case "FAILED":
		return StatusFd5EnumFailed, nil
	case "DISABLED":
		return StatusFd5EnumDisabled, nil
	case "PAUSED":
		return StatusFd5EnumPaused, nil
	case "PARTIALLY_SYNCED":
		return StatusFd5EnumPartiallySynced, nil
	}
	var t StatusFd5Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusFd5Enum) Ptr() *StatusFd5Enum {
	return &s
}

// # The SyncStatus Object
// ### Description
// The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name" url:"model_name"`
	ModelId                          string                                `json:"model_id" url:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty" url:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty" url:"next_sync_start,omitempty"`
	LastSyncResult                   *SyncStatusLastSyncResult             `json:"last_sync_result,omitempty" url:"last_sync_result,omitempty"`
	LastSyncFinished                 *time.Time                            `json:"last_sync_finished,omitempty" url:"last_sync_finished,omitempty"`
	Status                           *SyncStatusStatus                     `json:"status" url:"status"`
	IsInitialSync                    bool                                  `json:"is_initial_sync" url:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty" url:"selective_sync_configurations_usage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncStatus) GetModelName() string {
	if s == nil {
		return ""
	}
	return s.ModelName
}

func (s *SyncStatus) GetModelId() string {
	if s == nil {
		return ""
	}
	return s.ModelId
}

func (s *SyncStatus) GetLastSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncStart
}

func (s *SyncStatus) GetNextSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.NextSyncStart
}

func (s *SyncStatus) GetLastSyncResult() *SyncStatusLastSyncResult {
	if s == nil {
		return nil
	}
	return s.LastSyncResult
}

func (s *SyncStatus) GetLastSyncFinished() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncFinished
}

func (s *SyncStatus) GetStatus() *SyncStatusStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SyncStatus) GetIsInitialSync() bool {
	if s == nil {
		return false
	}
	return s.IsInitialSync
}

func (s *SyncStatus) GetSelectiveSyncConfigurationsUsage() *SelectiveSyncConfigurationsUsageEnum {
	if s == nil {
		return nil
	}
	return s.SelectiveSyncConfigurationsUsage
}

func (s *SyncStatus) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncStatus) UnmarshalJSON(data []byte) error {
	type embed SyncStatus
	var unmarshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SyncStatus(unmarshaler.embed)
	s.LastSyncStart = unmarshaler.LastSyncStart.TimePtr()
	s.NextSyncStart = unmarshaler.NextSyncStart.TimePtr()
	s.LastSyncFinished = unmarshaler.LastSyncFinished.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatus) MarshalJSON() ([]byte, error) {
	type embed SyncStatus
	var marshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed:            embed(*s),
		LastSyncStart:    internal.NewOptionalDateTime(s.LastSyncStart),
		NextSyncStart:    internal.NewOptionalDateTime(s.NextSyncStart),
		LastSyncFinished: internal.NewOptionalDateTime(s.LastSyncFinished),
	}
	return json.Marshal(marshaler)
}

func (s *SyncStatus) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncStatusLastSyncResult struct {
	LastSyncResultEnum LastSyncResultEnum
	String             string

	typ string
}

func (s *SyncStatusLastSyncResult) GetLastSyncResultEnum() LastSyncResultEnum {
	if s == nil {
		return ""
	}
	return s.LastSyncResultEnum
}

func (s *SyncStatusLastSyncResult) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SyncStatusLastSyncResult) UnmarshalJSON(data []byte) error {
	var valueLastSyncResultEnum LastSyncResultEnum
	if err := json.Unmarshal(data, &valueLastSyncResultEnum); err == nil {
		s.typ = "LastSyncResultEnum"
		s.LastSyncResultEnum = valueLastSyncResultEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SyncStatusLastSyncResult) MarshalJSON() ([]byte, error) {
	if s.typ == "LastSyncResultEnum" || s.LastSyncResultEnum != "" {
		return json.Marshal(s.LastSyncResultEnum)
	}
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SyncStatusLastSyncResultVisitor interface {
	VisitLastSyncResultEnum(LastSyncResultEnum) error
	VisitString(string) error
}

func (s *SyncStatusLastSyncResult) Accept(visitor SyncStatusLastSyncResultVisitor) error {
	if s.typ == "LastSyncResultEnum" || s.LastSyncResultEnum != "" {
		return visitor.VisitLastSyncResultEnum(s.LastSyncResultEnum)
	}
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SyncStatusStatus struct {
	StatusFd5Enum StatusFd5Enum
	String        string

	typ string
}

func (s *SyncStatusStatus) GetStatusFd5Enum() StatusFd5Enum {
	if s == nil {
		return ""
	}
	return s.StatusFd5Enum
}

func (s *SyncStatusStatus) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SyncStatusStatus) UnmarshalJSON(data []byte) error {
	var valueStatusFd5Enum StatusFd5Enum
	if err := json.Unmarshal(data, &valueStatusFd5Enum); err == nil {
		s.typ = "StatusFd5Enum"
		s.StatusFd5Enum = valueStatusFd5Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SyncStatusStatus) MarshalJSON() ([]byte, error) {
	if s.typ == "StatusFd5Enum" || s.StatusFd5Enum != "" {
		return json.Marshal(s.StatusFd5Enum)
	}
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SyncStatusStatusVisitor interface {
	VisitStatusFd5Enum(StatusFd5Enum) error
	VisitString(string) error
}

func (s *SyncStatusStatus) Accept(visitor SyncStatusStatusVisitor) error {
	if s.typ == "StatusFd5Enum" || s.StatusFd5Enum != "" {
		return visitor.VisitStatusFd5Enum(s.StatusFd5Enum)
	}
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// # The Team Object
// ### Description
// The `Team` object is used to represent a subdivision of the company, usually a department. Each employee will be grouped into one specific Team.
//
// ### Usage Example
// If you're building a way to filter by `Team`, you'd hit the `GET Teams` endpoint to fetch the `Teams`, and then use the `ID` of the team your user selects to filter the `GET Employees` endpoint.
type Team struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The team's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The team's parent team.
	ParentTeam *TeamParentTeam `json:"parent_team,omitempty" url:"parent_team,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Team) GetId() *string {
	if t == nil {
		return nil
	}
	return t.Id
}

func (t *Team) GetRemoteId() *string {
	if t == nil {
		return nil
	}
	return t.RemoteId
}

func (t *Team) GetCreatedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *Team) GetModifiedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.ModifiedAt
}

func (t *Team) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *Team) GetParentTeam() *TeamParentTeam {
	if t == nil {
		return nil
	}
	return t.ParentTeam
}

func (t *Team) GetRemoteWasDeleted() *bool {
	if t == nil {
		return nil
	}
	return t.RemoteWasDeleted
}

func (t *Team) GetFieldMappings() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.FieldMappings
}

func (t *Team) GetRemoteData() []*RemoteData {
	if t == nil {
		return nil
	}
	return t.RemoteData
}

func (t *Team) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Team) UnmarshalJSON(data []byte) error {
	type embed Team
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Team(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	t.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Team) MarshalJSON() ([]byte, error) {
	type embed Team
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*t),
		CreatedAt:  internal.NewOptionalDateTime(t.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(t.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (t *Team) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The team's parent team.
type TeamParentTeam struct {
	String string
	Team   *Team

	typ string
}

func (t *TeamParentTeam) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TeamParentTeam) GetTeam() *Team {
	if t == nil {
		return nil
	}
	return t.Team
}

func (t *TeamParentTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		t.typ = "Team"
		t.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TeamParentTeam) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "Team" || t.Team != nil {
		return json.Marshal(t.Team)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TeamParentTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (t *TeamParentTeam) Accept(visitor TeamParentTeamVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "Team" || t.Team != nil {
		return visitor.VisitTeam(t.Team)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer" url:"pointer"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValidationProblemSource) GetPointer() string {
	if v == nil {
		return ""
	}
	return v.Pointer
}

func (v *ValidationProblemSource) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationProblemSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationProblemSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationProblemSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationProblemSource) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WarningValidationProblem) GetSource() *ValidationProblemSource {
	if w == nil {
		return nil
	}
	return w.Source
}

func (w *WarningValidationProblem) GetTitle() string {
	if w == nil {
		return ""
	}
	return w.Title
}

func (w *WarningValidationProblem) GetDetail() string {
	if w == nil {
		return ""
	}
	return w.Detail
}

func (w *WarningValidationProblem) GetProblemType() string {
	if w == nil {
		return ""
	}
	return w.ProblemType
}

func (w *WarningValidationProblem) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WarningValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler WarningValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WarningValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WarningValidationProblem) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
