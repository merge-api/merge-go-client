// Code generated by Fern. DO NOT EDIT.

package ats

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/internal"
	big "math/big"
	time "time"
)

var (
	issuesListRequestFieldAccountToken            = big.NewInt(1 << 0)
	issuesListRequestFieldCursor                  = big.NewInt(1 << 1)
	issuesListRequestFieldEndDate                 = big.NewInt(1 << 2)
	issuesListRequestFieldEndUserOrganizationName = big.NewInt(1 << 3)
	issuesListRequestFieldFirstIncidentTimeAfter  = big.NewInt(1 << 4)
	issuesListRequestFieldFirstIncidentTimeBefore = big.NewInt(1 << 5)
	issuesListRequestFieldIncludeMuted            = big.NewInt(1 << 6)
	issuesListRequestFieldIntegrationName         = big.NewInt(1 << 7)
	issuesListRequestFieldLastIncidentTimeAfter   = big.NewInt(1 << 8)
	issuesListRequestFieldLastIncidentTimeBefore  = big.NewInt(1 << 9)
	issuesListRequestFieldLinkedAccountId         = big.NewInt(1 << 10)
	issuesListRequestFieldPageSize                = big.NewInt(1 << 11)
	issuesListRequestFieldStartDate               = big.NewInt(1 << 12)
	issuesListRequestFieldStatus                  = big.NewInt(1 << 13)
)

type IssuesListRequest struct {
	AccountToken *string `json:"-" url:"account_token,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// If included, will only include issues whose most recent action occurred before this time
	EndDate                 *string `json:"-" url:"end_date,omitempty"`
	EndUserOrganizationName *string `json:"-" url:"end_user_organization_name,omitempty"`
	// If provided, will only return issues whose first incident time was after this datetime.
	FirstIncidentTimeAfter *time.Time `json:"-" url:"first_incident_time_after,omitempty"`
	// If provided, will only return issues whose first incident time was before this datetime.
	FirstIncidentTimeBefore *time.Time `json:"-" url:"first_incident_time_before,omitempty"`
	// If true, will include muted issues
	IncludeMuted    *string `json:"-" url:"include_muted,omitempty"`
	IntegrationName *string `json:"-" url:"integration_name,omitempty"`
	// If provided, will only return issues whose last incident time was after this datetime.
	LastIncidentTimeAfter *time.Time `json:"-" url:"last_incident_time_after,omitempty"`
	// If provided, will only return issues whose last incident time was before this datetime.
	LastIncidentTimeBefore *time.Time `json:"-" url:"last_incident_time_before,omitempty"`
	// If provided, will only include issues pertaining to the linked account passed in.
	LinkedAccountId *string `json:"-" url:"linked_account_id,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// If included, will only include issues whose most recent action occurred after this time
	StartDate *string `json:"-" url:"start_date,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// * `ONGOING` - ONGOING
	// * `RESOLVED` - RESOLVED
	Status *IssuesListRequestStatus `json:"-" url:"status,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *IssuesListRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetAccountToken sets the AccountToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetAccountToken(accountToken *string) {
	i.AccountToken = accountToken
	i.require(issuesListRequestFieldAccountToken)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetCursor(cursor *string) {
	i.Cursor = cursor
	i.require(issuesListRequestFieldCursor)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetEndDate(endDate *string) {
	i.EndDate = endDate
	i.require(issuesListRequestFieldEndDate)
}

// SetEndUserOrganizationName sets the EndUserOrganizationName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetEndUserOrganizationName(endUserOrganizationName *string) {
	i.EndUserOrganizationName = endUserOrganizationName
	i.require(issuesListRequestFieldEndUserOrganizationName)
}

// SetFirstIncidentTimeAfter sets the FirstIncidentTimeAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetFirstIncidentTimeAfter(firstIncidentTimeAfter *time.Time) {
	i.FirstIncidentTimeAfter = firstIncidentTimeAfter
	i.require(issuesListRequestFieldFirstIncidentTimeAfter)
}

// SetFirstIncidentTimeBefore sets the FirstIncidentTimeBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetFirstIncidentTimeBefore(firstIncidentTimeBefore *time.Time) {
	i.FirstIncidentTimeBefore = firstIncidentTimeBefore
	i.require(issuesListRequestFieldFirstIncidentTimeBefore)
}

// SetIncludeMuted sets the IncludeMuted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetIncludeMuted(includeMuted *string) {
	i.IncludeMuted = includeMuted
	i.require(issuesListRequestFieldIncludeMuted)
}

// SetIntegrationName sets the IntegrationName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetIntegrationName(integrationName *string) {
	i.IntegrationName = integrationName
	i.require(issuesListRequestFieldIntegrationName)
}

// SetLastIncidentTimeAfter sets the LastIncidentTimeAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetLastIncidentTimeAfter(lastIncidentTimeAfter *time.Time) {
	i.LastIncidentTimeAfter = lastIncidentTimeAfter
	i.require(issuesListRequestFieldLastIncidentTimeAfter)
}

// SetLastIncidentTimeBefore sets the LastIncidentTimeBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetLastIncidentTimeBefore(lastIncidentTimeBefore *time.Time) {
	i.LastIncidentTimeBefore = lastIncidentTimeBefore
	i.require(issuesListRequestFieldLastIncidentTimeBefore)
}

// SetLinkedAccountId sets the LinkedAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetLinkedAccountId(linkedAccountId *string) {
	i.LinkedAccountId = linkedAccountId
	i.require(issuesListRequestFieldLinkedAccountId)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetPageSize(pageSize *int) {
	i.PageSize = pageSize
	i.require(issuesListRequestFieldPageSize)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetStartDate(startDate *string) {
	i.StartDate = startDate
	i.require(issuesListRequestFieldStartDate)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IssuesListRequest) SetStatus(status *IssuesListRequestStatus) {
	i.Status = status
	i.require(issuesListRequestFieldStatus)
}

type IssuesListRequestStatus string

const (
	IssuesListRequestStatusOngoing  IssuesListRequestStatus = "ONGOING"
	IssuesListRequestStatusResolved IssuesListRequestStatus = "RESOLVED"
)

func NewIssuesListRequestStatusFromString(s string) (IssuesListRequestStatus, error) {
	switch s {
	case "ONGOING":
		return IssuesListRequestStatusOngoing, nil
	case "RESOLVED":
		return IssuesListRequestStatusResolved, nil
	}
	var t IssuesListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssuesListRequestStatus) Ptr() *IssuesListRequestStatus {
	return &i
}

var (
	issueFieldId                = big.NewInt(1 << 0)
	issueFieldStatus            = big.NewInt(1 << 1)
	issueFieldErrorDescription  = big.NewInt(1 << 2)
	issueFieldEndUser           = big.NewInt(1 << 3)
	issueFieldFirstIncidentTime = big.NewInt(1 << 4)
	issueFieldLastIncidentTime  = big.NewInt(1 << 5)
	issueFieldIsMuted           = big.NewInt(1 << 6)
	issueFieldErrorDetails      = big.NewInt(1 << 7)
)

type Issue struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// * `ONGOING` - ONGOING
	// * `RESOLVED` - RESOLVED
	Status            *IssueStatus           `json:"status,omitempty" url:"status,omitempty"`
	ErrorDescription  string                 `json:"error_description" url:"error_description"`
	EndUser           map[string]interface{} `json:"end_user,omitempty" url:"end_user,omitempty"`
	FirstIncidentTime *time.Time             `json:"first_incident_time,omitempty" url:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time             `json:"last_incident_time,omitempty" url:"last_incident_time,omitempty"`
	IsMuted           *bool                  `json:"is_muted,omitempty" url:"is_muted,omitempty"`
	ErrorDetails      []string               `json:"error_details,omitempty" url:"error_details,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Issue) GetId() *string {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *Issue) GetStatus() *IssueStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *Issue) GetErrorDescription() string {
	if i == nil {
		return ""
	}
	return i.ErrorDescription
}

func (i *Issue) GetEndUser() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.EndUser
}

func (i *Issue) GetFirstIncidentTime() *time.Time {
	if i == nil {
		return nil
	}
	return i.FirstIncidentTime
}

func (i *Issue) GetLastIncidentTime() *time.Time {
	if i == nil {
		return nil
	}
	return i.LastIncidentTime
}

func (i *Issue) GetIsMuted() *bool {
	if i == nil {
		return nil
	}
	return i.IsMuted
}

func (i *Issue) GetErrorDetails() []string {
	if i == nil {
		return nil
	}
	return i.ErrorDetails
}

func (i *Issue) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Issue) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Issue) SetId(id *string) {
	i.Id = id
	i.require(issueFieldId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Issue) SetStatus(status *IssueStatus) {
	i.Status = status
	i.require(issueFieldStatus)
}

// SetErrorDescription sets the ErrorDescription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Issue) SetErrorDescription(errorDescription string) {
	i.ErrorDescription = errorDescription
	i.require(issueFieldErrorDescription)
}

// SetEndUser sets the EndUser field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Issue) SetEndUser(endUser map[string]interface{}) {
	i.EndUser = endUser
	i.require(issueFieldEndUser)
}

// SetFirstIncidentTime sets the FirstIncidentTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Issue) SetFirstIncidentTime(firstIncidentTime *time.Time) {
	i.FirstIncidentTime = firstIncidentTime
	i.require(issueFieldFirstIncidentTime)
}

// SetLastIncidentTime sets the LastIncidentTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Issue) SetLastIncidentTime(lastIncidentTime *time.Time) {
	i.LastIncidentTime = lastIncidentTime
	i.require(issueFieldLastIncidentTime)
}

// SetIsMuted sets the IsMuted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Issue) SetIsMuted(isMuted *bool) {
	i.IsMuted = isMuted
	i.require(issueFieldIsMuted)
}

// SetErrorDetails sets the ErrorDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Issue) SetErrorDetails(errorDetails []string) {
	i.ErrorDetails = errorDetails
	i.require(issueFieldErrorDetails)
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	type embed Issue
	var unmarshaler = struct {
		embed
		FirstIncidentTime *internal.DateTime `json:"first_incident_time,omitempty"`
		LastIncidentTime  *internal.DateTime `json:"last_incident_time,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Issue(unmarshaler.embed)
	i.FirstIncidentTime = unmarshaler.FirstIncidentTime.TimePtr()
	i.LastIncidentTime = unmarshaler.LastIncidentTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Issue) MarshalJSON() ([]byte, error) {
	type embed Issue
	var marshaler = struct {
		embed
		FirstIncidentTime *internal.DateTime `json:"first_incident_time,omitempty"`
		LastIncidentTime  *internal.DateTime `json:"last_incident_time,omitempty"`
	}{
		embed:             embed(*i),
		FirstIncidentTime: internal.NewOptionalDateTime(i.FirstIncidentTime),
		LastIncidentTime:  internal.NewOptionalDateTime(i.LastIncidentTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *Issue) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// * `ONGOING` - ONGOING
// * `RESOLVED` - RESOLVED
type IssueStatus struct {
	IssueStatusEnum IssueStatusEnum
	String          string

	typ string
}

func (i *IssueStatus) GetIssueStatusEnum() IssueStatusEnum {
	if i == nil {
		return ""
	}
	return i.IssueStatusEnum
}

func (i *IssueStatus) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typ = "IssueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	if i.typ == "IssueStatusEnum" || i.IssueStatusEnum != "" {
		return json.Marshal(i.IssueStatusEnum)
	}
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	if i.typ == "IssueStatusEnum" || i.IssueStatusEnum != "" {
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	}
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// * `ONGOING` - ONGOING
// * `RESOLVED` - RESOLVED
type IssueStatusEnum string

const (
	IssueStatusEnumOngoing  IssueStatusEnum = "ONGOING"
	IssueStatusEnumResolved IssueStatusEnum = "RESOLVED"
)

func NewIssueStatusEnumFromString(s string) (IssueStatusEnum, error) {
	switch s {
	case "ONGOING":
		return IssueStatusEnumOngoing, nil
	case "RESOLVED":
		return IssueStatusEnumResolved, nil
	}
	var t IssueStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatusEnum) Ptr() *IssueStatusEnum {
	return &i
}

var (
	paginatedIssueListFieldNext     = big.NewInt(1 << 0)
	paginatedIssueListFieldPrevious = big.NewInt(1 << 1)
	paginatedIssueListFieldResults  = big.NewInt(1 << 2)
)

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty" url:"next,omitempty"`
	Previous *string  `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty" url:"results,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedIssueList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedIssueList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedIssueList) GetResults() []*Issue {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedIssueList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedIssueList) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedIssueList) SetNext(next *string) {
	p.Next = next
	p.require(paginatedIssueListFieldNext)
}

// SetPrevious sets the Previous field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedIssueList) SetPrevious(previous *string) {
	p.Previous = previous
	p.require(paginatedIssueListFieldPrevious)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedIssueList) SetResults(results []*Issue) {
	p.Results = results
	p.require(paginatedIssueListFieldResults)
}

func (p *PaginatedIssueList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedIssueList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedIssueList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedIssueList) MarshalJSON() ([]byte, error) {
	type embed PaginatedIssueList
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedIssueList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
