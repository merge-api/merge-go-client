// Code generated by Fern. DO NOT EDIT.

package ats

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

// * `SUPER_ADMIN` - SUPER_ADMIN
// * `ADMIN` - ADMIN
// * `TEAM_MEMBER` - TEAM_MEMBER
// * `LIMITED_TEAM_MEMBER` - LIMITED_TEAM_MEMBER
// * `INTERVIEWER` - INTERVIEWER
type AccessRoleEnum string

const (
	AccessRoleEnumSuperAdmin        AccessRoleEnum = "SUPER_ADMIN"
	AccessRoleEnumAdmin             AccessRoleEnum = "ADMIN"
	AccessRoleEnumTeamMember        AccessRoleEnum = "TEAM_MEMBER"
	AccessRoleEnumLimitedTeamMember AccessRoleEnum = "LIMITED_TEAM_MEMBER"
	AccessRoleEnumInterviewer       AccessRoleEnum = "INTERVIEWER"
)

func NewAccessRoleEnumFromString(s string) (AccessRoleEnum, error) {
	switch s {
	case "SUPER_ADMIN":
		return AccessRoleEnumSuperAdmin, nil
	case "ADMIN":
		return AccessRoleEnumAdmin, nil
	case "TEAM_MEMBER":
		return AccessRoleEnumTeamMember, nil
	case "LIMITED_TEAM_MEMBER":
		return AccessRoleEnumLimitedTeamMember, nil
	case "INTERVIEWER":
		return AccessRoleEnumInterviewer, nil
	}
	var t AccessRoleEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccessRoleEnum) Ptr() *AccessRoleEnum {
	return &a
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name" url:"name"`
	// Optional. This shortened name appears in places with limited space, usually in conjunction with the platform's logo (e.g., Merge Link menu).<br><br>Example: <i>Workforce Now (in lieu of ADP Workforce Now), SuccessFactors (in lieu of SAP SuccessFactors)</i>
	AbbreviatedName *string `json:"abbreviated_name,omitempty" url:"abbreviated_name,omitempty"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty" url:"categories,omitempty"`
	// Company logo in rectangular shape.
	Image *string `json:"image,omitempty" url:"image,omitempty"`
	// Company logo in square shape.
	SquareImage *string `json:"square_image,omitempty" url:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	Slug  *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]interface{} `json:"api_endpoints_to_documentation_urls,omitempty" url:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty" url:"webhook_setup_guide_url,omitempty"`
	// Category or categories this integration is in beta status for.
	CategoryBetaStatus map[string]interface{} `json:"category_beta_status,omitempty" url:"category_beta_status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountIntegration) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AccountIntegration) GetAbbreviatedName() *string {
	if a == nil {
		return nil
	}
	return a.AbbreviatedName
}

func (a *AccountIntegration) GetCategories() []CategoriesEnum {
	if a == nil {
		return nil
	}
	return a.Categories
}

func (a *AccountIntegration) GetImage() *string {
	if a == nil {
		return nil
	}
	return a.Image
}

func (a *AccountIntegration) GetSquareImage() *string {
	if a == nil {
		return nil
	}
	return a.SquareImage
}

func (a *AccountIntegration) GetColor() *string {
	if a == nil {
		return nil
	}
	return a.Color
}

func (a *AccountIntegration) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *AccountIntegration) GetApiEndpointsToDocumentationUrls() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.ApiEndpointsToDocumentationUrls
}

func (a *AccountIntegration) GetWebhookSetupGuideUrl() *string {
	if a == nil {
		return nil
	}
	return a.WebhookSetupGuideUrl
}

func (a *AccountIntegration) GetCategoryBetaStatus() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.CategoryBetaStatus
}

func (a *AccountIntegration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountIntegration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountIntegration) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The Application Object
// ### Description
// The Application Object is used to represent a candidate's journey through a particular Job's recruiting process. If a Candidate applies for multiple Jobs, there will be a separate Application for each Job if the third-party integration allows it.
//
// ### Usage Example
// Fetch from the `LIST Applications` endpoint and filter by `ID` to show all applications.
type Application struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The candidate applying.
	Candidate *ApplicationCandidate `json:"candidate,omitempty" url:"candidate,omitempty"`
	// The job being applied for.
	Job *ApplicationJob `json:"job,omitempty" url:"job,omitempty"`
	// When the application was submitted.
	AppliedAt *time.Time `json:"applied_at,omitempty" url:"applied_at,omitempty"`
	// When the application was rejected.
	RejectedAt *time.Time               `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	Offers     []*ApplicationOffersItem `json:"offers,omitempty" url:"offers,omitempty"`
	// The application's source.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The user credited for this application.
	CreditedTo               *ApplicationCreditedTo                     `json:"credited_to,omitempty" url:"credited_to,omitempty"`
	ScreeningQuestionAnswers []*ApplicationScreeningQuestionAnswersItem `json:"screening_question_answers,omitempty" url:"screening_question_answers,omitempty"`
	// The application's current stage.
	CurrentStage *ApplicationCurrentStage `json:"current_stage,omitempty" url:"current_stage,omitempty"`
	// The application's reason for rejection.
	RejectReason *ApplicationRejectReason `json:"reject_reason,omitempty" url:"reject_reason,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Application) GetId() *string {
	if a == nil {
		return nil
	}
	return a.Id
}

func (a *Application) GetRemoteId() *string {
	if a == nil {
		return nil
	}
	return a.RemoteId
}

func (a *Application) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *Application) GetModifiedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.ModifiedAt
}

func (a *Application) GetCandidate() *ApplicationCandidate {
	if a == nil {
		return nil
	}
	return a.Candidate
}

func (a *Application) GetJob() *ApplicationJob {
	if a == nil {
		return nil
	}
	return a.Job
}

func (a *Application) GetAppliedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.AppliedAt
}

func (a *Application) GetRejectedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.RejectedAt
}

func (a *Application) GetOffers() []*ApplicationOffersItem {
	if a == nil {
		return nil
	}
	return a.Offers
}

func (a *Application) GetSource() *string {
	if a == nil {
		return nil
	}
	return a.Source
}

func (a *Application) GetCreditedTo() *ApplicationCreditedTo {
	if a == nil {
		return nil
	}
	return a.CreditedTo
}

func (a *Application) GetScreeningQuestionAnswers() []*ApplicationScreeningQuestionAnswersItem {
	if a == nil {
		return nil
	}
	return a.ScreeningQuestionAnswers
}

func (a *Application) GetCurrentStage() *ApplicationCurrentStage {
	if a == nil {
		return nil
	}
	return a.CurrentStage
}

func (a *Application) GetRejectReason() *ApplicationRejectReason {
	if a == nil {
		return nil
	}
	return a.RejectReason
}

func (a *Application) GetRemoteWasDeleted() *bool {
	if a == nil {
		return nil
	}
	return a.RemoteWasDeleted
}

func (a *Application) GetFieldMappings() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.FieldMappings
}

func (a *Application) GetRemoteData() []*RemoteData {
	if a == nil {
		return nil
	}
	return a.RemoteData
}

func (a *Application) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Application) UnmarshalJSON(data []byte) error {
	type embed Application
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
		AppliedAt  *internal.DateTime `json:"applied_at,omitempty"`
		RejectedAt *internal.DateTime `json:"rejected_at,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Application(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	a.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	a.AppliedAt = unmarshaler.AppliedAt.TimePtr()
	a.RejectedAt = unmarshaler.RejectedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Application) MarshalJSON() ([]byte, error) {
	type embed Application
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
		AppliedAt  *internal.DateTime `json:"applied_at,omitempty"`
		RejectedAt *internal.DateTime `json:"rejected_at,omitempty"`
	}{
		embed:      embed(*a),
		CreatedAt:  internal.NewOptionalDateTime(a.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(a.ModifiedAt),
		AppliedAt:  internal.NewOptionalDateTime(a.AppliedAt),
		RejectedAt: internal.NewOptionalDateTime(a.RejectedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Application) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The candidate applying.
type ApplicationCandidate struct {
	String    string
	Candidate *Candidate

	typ string
}

func (a *ApplicationCandidate) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationCandidate) GetCandidate() *Candidate {
	if a == nil {
		return nil
	}
	return a.Candidate
}

func (a *ApplicationCandidate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueCandidate := new(Candidate)
	if err := json.Unmarshal(data, &valueCandidate); err == nil {
		a.typ = "Candidate"
		a.Candidate = valueCandidate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationCandidate) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "Candidate" || a.Candidate != nil {
		return json.Marshal(a.Candidate)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationCandidateVisitor interface {
	VisitString(string) error
	VisitCandidate(*Candidate) error
}

func (a *ApplicationCandidate) Accept(visitor ApplicationCandidateVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "Candidate" || a.Candidate != nil {
		return visitor.VisitCandidate(a.Candidate)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The user credited for this application.
type ApplicationCreditedTo struct {
	String     string
	RemoteUser *RemoteUser

	typ string
}

func (a *ApplicationCreditedTo) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationCreditedTo) GetRemoteUser() *RemoteUser {
	if a == nil {
		return nil
	}
	return a.RemoteUser
}

func (a *ApplicationCreditedTo) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		a.typ = "RemoteUser"
		a.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationCreditedTo) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "RemoteUser" || a.RemoteUser != nil {
		return json.Marshal(a.RemoteUser)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationCreditedToVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (a *ApplicationCreditedTo) Accept(visitor ApplicationCreditedToVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "RemoteUser" || a.RemoteUser != nil {
		return visitor.VisitRemoteUser(a.RemoteUser)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The application's current stage.
type ApplicationCurrentStage struct {
	String            string
	JobInterviewStage *JobInterviewStage

	typ string
}

func (a *ApplicationCurrentStage) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationCurrentStage) GetJobInterviewStage() *JobInterviewStage {
	if a == nil {
		return nil
	}
	return a.JobInterviewStage
}

func (a *ApplicationCurrentStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueJobInterviewStage := new(JobInterviewStage)
	if err := json.Unmarshal(data, &valueJobInterviewStage); err == nil {
		a.typ = "JobInterviewStage"
		a.JobInterviewStage = valueJobInterviewStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationCurrentStage) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "JobInterviewStage" || a.JobInterviewStage != nil {
		return json.Marshal(a.JobInterviewStage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationCurrentStageVisitor interface {
	VisitString(string) error
	VisitJobInterviewStage(*JobInterviewStage) error
}

func (a *ApplicationCurrentStage) Accept(visitor ApplicationCurrentStageVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "JobInterviewStage" || a.JobInterviewStage != nil {
		return visitor.VisitJobInterviewStage(a.JobInterviewStage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The job being applied for.
type ApplicationJob struct {
	String string
	Job    *Job

	typ string
}

func (a *ApplicationJob) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationJob) GetJob() *Job {
	if a == nil {
		return nil
	}
	return a.Job
}

func (a *ApplicationJob) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueJob := new(Job)
	if err := json.Unmarshal(data, &valueJob); err == nil {
		a.typ = "Job"
		a.Job = valueJob
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationJob) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "Job" || a.Job != nil {
		return json.Marshal(a.Job)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationJobVisitor interface {
	VisitString(string) error
	VisitJob(*Job) error
}

func (a *ApplicationJob) Accept(visitor ApplicationJobVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "Job" || a.Job != nil {
		return visitor.VisitJob(a.Job)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationOffersItem struct {
	String string
	Offer  *Offer

	typ string
}

func (a *ApplicationOffersItem) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationOffersItem) GetOffer() *Offer {
	if a == nil {
		return nil
	}
	return a.Offer
}

func (a *ApplicationOffersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueOffer := new(Offer)
	if err := json.Unmarshal(data, &valueOffer); err == nil {
		a.typ = "Offer"
		a.Offer = valueOffer
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationOffersItem) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "Offer" || a.Offer != nil {
		return json.Marshal(a.Offer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationOffersItemVisitor interface {
	VisitString(string) error
	VisitOffer(*Offer) error
}

func (a *ApplicationOffersItem) Accept(visitor ApplicationOffersItemVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "Offer" || a.Offer != nil {
		return visitor.VisitOffer(a.Offer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The application's reason for rejection.
type ApplicationRejectReason struct {
	String       string
	RejectReason *RejectReason

	typ string
}

func (a *ApplicationRejectReason) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationRejectReason) GetRejectReason() *RejectReason {
	if a == nil {
		return nil
	}
	return a.RejectReason
}

func (a *ApplicationRejectReason) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueRejectReason := new(RejectReason)
	if err := json.Unmarshal(data, &valueRejectReason); err == nil {
		a.typ = "RejectReason"
		a.RejectReason = valueRejectReason
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRejectReason) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "RejectReason" || a.RejectReason != nil {
		return json.Marshal(a.RejectReason)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRejectReasonVisitor interface {
	VisitString(string) error
	VisitRejectReason(*RejectReason) error
}

func (a *ApplicationRejectReason) Accept(visitor ApplicationRejectReasonVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "RejectReason" || a.RejectReason != nil {
		return visitor.VisitRejectReason(a.RejectReason)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationScreeningQuestionAnswersItem struct {
	String                  string
	ScreeningQuestionAnswer *ScreeningQuestionAnswer

	typ string
}

func (a *ApplicationScreeningQuestionAnswersItem) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationScreeningQuestionAnswersItem) GetScreeningQuestionAnswer() *ScreeningQuestionAnswer {
	if a == nil {
		return nil
	}
	return a.ScreeningQuestionAnswer
}

func (a *ApplicationScreeningQuestionAnswersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueScreeningQuestionAnswer := new(ScreeningQuestionAnswer)
	if err := json.Unmarshal(data, &valueScreeningQuestionAnswer); err == nil {
		a.typ = "ScreeningQuestionAnswer"
		a.ScreeningQuestionAnswer = valueScreeningQuestionAnswer
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationScreeningQuestionAnswersItem) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "ScreeningQuestionAnswer" || a.ScreeningQuestionAnswer != nil {
		return json.Marshal(a.ScreeningQuestionAnswer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationScreeningQuestionAnswersItemVisitor interface {
	VisitString(string) error
	VisitScreeningQuestionAnswer(*ScreeningQuestionAnswer) error
}

func (a *ApplicationScreeningQuestionAnswersItem) Accept(visitor ApplicationScreeningQuestionAnswersItemVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "ScreeningQuestionAnswer" || a.ScreeningQuestionAnswer != nil {
		return visitor.VisitScreeningQuestionAnswer(a.ScreeningQuestionAnswer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// # The Attachment Object
// ### Description
// The `Attachment` object is used to represent a file attached to a candidate.
// ### Usage Example
// Fetch from the `LIST Attachments` endpoint and view attachments accessible by a company.
type Attachment struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The attachment's name.
	FileName *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	// The attachment's url.
	FileUrl   *string `json:"file_url,omitempty" url:"file_url,omitempty"`
	Candidate *string `json:"candidate,omitempty" url:"candidate,omitempty"`
	// The attachment's type.
	//
	// * `RESUME` - RESUME
	// * `COVER_LETTER` - COVER_LETTER
	// * `OFFER_LETTER` - OFFER_LETTER
	// * `OTHER` - OTHER
	AttachmentType *AttachmentTypeEnum `json:"attachment_type,omitempty" url:"attachment_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Attachment) GetId() *string {
	if a == nil {
		return nil
	}
	return a.Id
}

func (a *Attachment) GetRemoteId() *string {
	if a == nil {
		return nil
	}
	return a.RemoteId
}

func (a *Attachment) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *Attachment) GetModifiedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.ModifiedAt
}

func (a *Attachment) GetFileName() *string {
	if a == nil {
		return nil
	}
	return a.FileName
}

func (a *Attachment) GetFileUrl() *string {
	if a == nil {
		return nil
	}
	return a.FileUrl
}

func (a *Attachment) GetCandidate() *string {
	if a == nil {
		return nil
	}
	return a.Candidate
}

func (a *Attachment) GetAttachmentType() *AttachmentTypeEnum {
	if a == nil {
		return nil
	}
	return a.AttachmentType
}

func (a *Attachment) GetRemoteWasDeleted() *bool {
	if a == nil {
		return nil
	}
	return a.RemoteWasDeleted
}

func (a *Attachment) GetFieldMappings() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.FieldMappings
}

func (a *Attachment) GetRemoteData() []*RemoteData {
	if a == nil {
		return nil
	}
	return a.RemoteData
}

func (a *Attachment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Attachment) UnmarshalJSON(data []byte) error {
	type embed Attachment
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Attachment(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	a.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Attachment) MarshalJSON() ([]byte, error) {
	type embed Attachment
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*a),
		CreatedAt:  internal.NewOptionalDateTime(a.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(a.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Attachment) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// * `RESUME` - RESUME
// * `COVER_LETTER` - COVER_LETTER
// * `OFFER_LETTER` - OFFER_LETTER
// * `OTHER` - OTHER
type AttachmentTypeEnum string

const (
	AttachmentTypeEnumResume      AttachmentTypeEnum = "RESUME"
	AttachmentTypeEnumCoverLetter AttachmentTypeEnum = "COVER_LETTER"
	AttachmentTypeEnumOfferLetter AttachmentTypeEnum = "OFFER_LETTER"
	AttachmentTypeEnumOther       AttachmentTypeEnum = "OTHER"
)

func NewAttachmentTypeEnumFromString(s string) (AttachmentTypeEnum, error) {
	switch s {
	case "RESUME":
		return AttachmentTypeEnumResume, nil
	case "COVER_LETTER":
		return AttachmentTypeEnumCoverLetter, nil
	case "OFFER_LETTER":
		return AttachmentTypeEnumOfferLetter, nil
	case "OTHER":
		return AttachmentTypeEnumOther, nil
	}
	var t AttachmentTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttachmentTypeEnum) Ptr() *AttachmentTypeEnum {
	return &a
}

// # The Candidate Object
// ### Description
// The `Candidate` object is used to represent profile information about a given Candidate. Because it is specific to a Candidate, this information stays constant across applications.
// ### Usage Example
// Fetch from the `LIST Candidates` endpoint and filter by `ID` to show all candidates.
type Candidate struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The candidate's first name.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// The candidate's last name.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`
	// The candidate's current company.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// The candidate's current title.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// When the third party's candidate was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's candidate was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// When the most recent interaction with the candidate occurred.
	LastInteractionAt *time.Time `json:"last_interaction_at,omitempty" url:"last_interaction_at,omitempty"`
	// Whether or not the candidate is private.
	IsPrivate *bool `json:"is_private,omitempty" url:"is_private,omitempty"`
	// Whether or not the candidate can be emailed.
	CanEmail *bool `json:"can_email,omitempty" url:"can_email,omitempty"`
	// The candidate's locations.
	Locations      []*string       `json:"locations,omitempty" url:"locations,omitempty"`
	PhoneNumbers   []*PhoneNumber  `json:"phone_numbers,omitempty" url:"phone_numbers,omitempty"`
	EmailAddresses []*EmailAddress `json:"email_addresses,omitempty" url:"email_addresses,omitempty"`
	Urls           []*Url          `json:"urls,omitempty" url:"urls,omitempty"`
	// Array of `Tag` names as strings.
	Tags []*string `json:"tags,omitempty" url:"tags,omitempty"`
	// Array of `Application` object IDs.
	Applications []*CandidateApplicationsItem `json:"applications,omitempty" url:"applications,omitempty"`
	// Array of `Attachment` object IDs.
	Attachments []*CandidateAttachmentsItem `json:"attachments,omitempty" url:"attachments,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Candidate) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *Candidate) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *Candidate) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *Candidate) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *Candidate) GetFirstName() *string {
	if c == nil {
		return nil
	}
	return c.FirstName
}

func (c *Candidate) GetLastName() *string {
	if c == nil {
		return nil
	}
	return c.LastName
}

func (c *Candidate) GetCompany() *string {
	if c == nil {
		return nil
	}
	return c.Company
}

func (c *Candidate) GetTitle() *string {
	if c == nil {
		return nil
	}
	return c.Title
}

func (c *Candidate) GetRemoteCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.RemoteCreatedAt
}

func (c *Candidate) GetRemoteUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.RemoteUpdatedAt
}

func (c *Candidate) GetLastInteractionAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.LastInteractionAt
}

func (c *Candidate) GetIsPrivate() *bool {
	if c == nil {
		return nil
	}
	return c.IsPrivate
}

func (c *Candidate) GetCanEmail() *bool {
	if c == nil {
		return nil
	}
	return c.CanEmail
}

func (c *Candidate) GetLocations() []*string {
	if c == nil {
		return nil
	}
	return c.Locations
}

func (c *Candidate) GetPhoneNumbers() []*PhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumbers
}

func (c *Candidate) GetEmailAddresses() []*EmailAddress {
	if c == nil {
		return nil
	}
	return c.EmailAddresses
}

func (c *Candidate) GetUrls() []*Url {
	if c == nil {
		return nil
	}
	return c.Urls
}

func (c *Candidate) GetTags() []*string {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *Candidate) GetApplications() []*CandidateApplicationsItem {
	if c == nil {
		return nil
	}
	return c.Applications
}

func (c *Candidate) GetAttachments() []*CandidateAttachmentsItem {
	if c == nil {
		return nil
	}
	return c.Attachments
}

func (c *Candidate) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *Candidate) GetFieldMappings() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FieldMappings
}

func (c *Candidate) GetRemoteData() []*RemoteData {
	if c == nil {
		return nil
	}
	return c.RemoteData
}

func (c *Candidate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Candidate) UnmarshalJSON(data []byte) error {
	type embed Candidate
	var unmarshaler = struct {
		embed
		CreatedAt         *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt        *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt   *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt   *internal.DateTime `json:"remote_updated_at,omitempty"`
		LastInteractionAt *internal.DateTime `json:"last_interaction_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Candidate(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	c.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	c.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	c.LastInteractionAt = unmarshaler.LastInteractionAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Candidate) MarshalJSON() ([]byte, error) {
	type embed Candidate
	var marshaler = struct {
		embed
		CreatedAt         *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt        *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt   *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt   *internal.DateTime `json:"remote_updated_at,omitempty"`
		LastInteractionAt *internal.DateTime `json:"last_interaction_at,omitempty"`
	}{
		embed:             embed(*c),
		CreatedAt:         internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt:        internal.NewOptionalDateTime(c.ModifiedAt),
		RemoteCreatedAt:   internal.NewOptionalDateTime(c.RemoteCreatedAt),
		RemoteUpdatedAt:   internal.NewOptionalDateTime(c.RemoteUpdatedAt),
		LastInteractionAt: internal.NewOptionalDateTime(c.LastInteractionAt),
	}
	return json.Marshal(marshaler)
}

func (c *Candidate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CandidateApplicationsItem struct {
	String      string
	Application *Application

	typ string
}

func (c *CandidateApplicationsItem) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CandidateApplicationsItem) GetApplication() *Application {
	if c == nil {
		return nil
	}
	return c.Application
}

func (c *CandidateApplicationsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		c.typ = "Application"
		c.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CandidateApplicationsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Application" || c.Application != nil {
		return json.Marshal(c.Application)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CandidateApplicationsItemVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (c *CandidateApplicationsItem) Accept(visitor CandidateApplicationsItemVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Application" || c.Application != nil {
		return visitor.VisitApplication(c.Application)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CandidateAttachmentsItem struct {
	String     string
	Attachment *Attachment

	typ string
}

func (c *CandidateAttachmentsItem) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CandidateAttachmentsItem) GetAttachment() *Attachment {
	if c == nil {
		return nil
	}
	return c.Attachment
}

func (c *CandidateAttachmentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueAttachment := new(Attachment)
	if err := json.Unmarshal(data, &valueAttachment); err == nil {
		c.typ = "Attachment"
		c.Attachment = valueAttachment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CandidateAttachmentsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Attachment" || c.Attachment != nil {
		return json.Marshal(c.Attachment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CandidateAttachmentsItemVisitor interface {
	VisitString(string) error
	VisitAttachment(*Attachment) error
}

func (c *CandidateAttachmentsItem) Accept(visitor CandidateAttachmentsItemVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Attachment" || c.Attachment != nil {
		return visitor.VisitAttachment(c.Attachment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoriesEnum string

const (
	CategoriesEnumHris        CategoriesEnum = "hris"
	CategoriesEnumAts         CategoriesEnum = "ats"
	CategoriesEnumAccounting  CategoriesEnum = "accounting"
	CategoriesEnumTicketing   CategoriesEnum = "ticketing"
	CategoriesEnumCrm         CategoriesEnum = "crm"
	CategoriesEnumMktg        CategoriesEnum = "mktg"
	CategoriesEnumFilestorage CategoriesEnum = "filestorage"
)

func NewCategoriesEnumFromString(s string) (CategoriesEnum, error) {
	switch s {
	case "hris":
		return CategoriesEnumHris, nil
	case "ats":
		return CategoriesEnumAts, nil
	case "accounting":
		return CategoriesEnumAccounting, nil
	case "ticketing":
		return CategoriesEnumTicketing, nil
	case "crm":
		return CategoriesEnumCrm, nil
	case "mktg":
		return CategoriesEnumMktg, nil
	case "filestorage":
		return CategoriesEnumFilestorage, nil
	}
	var t CategoriesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoriesEnum) Ptr() *CategoriesEnum {
	return &c
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoryEnum string

const (
	CategoryEnumHris        CategoryEnum = "hris"
	CategoryEnumAts         CategoryEnum = "ats"
	CategoryEnumAccounting  CategoryEnum = "accounting"
	CategoryEnumTicketing   CategoryEnum = "ticketing"
	CategoryEnumCrm         CategoryEnum = "crm"
	CategoryEnumMktg        CategoryEnum = "mktg"
	CategoryEnumFilestorage CategoryEnum = "filestorage"
)

func NewCategoryEnumFromString(s string) (CategoryEnum, error) {
	switch s {
	case "hris":
		return CategoryEnumHris, nil
	case "ats":
		return CategoryEnumAts, nil
	case "accounting":
		return CategoryEnumAccounting, nil
	case "ticketing":
		return CategoryEnumTicketing, nil
	case "crm":
		return CategoryEnumCrm, nil
	case "mktg":
		return CategoryEnumMktg, nil
	case "filestorage":
		return CategoryEnumFilestorage, nil
	}
	var t CategoryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryEnum) Ptr() *CategoryEnum {
	return &c
}

// # The DataPassthrough Object
// ### Description
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method" url:"method"`
	// The path of the request in the third party's platform.
	Path string `json:"path" url:"path"`
	// An optional override of the third party's base url for the request.
	BaseUrlOverride *string `json:"base_url_override,omitempty" url:"base_url_override,omitempty"`
	// The data with the request. You must include a `request_format` parameter matching the data's format
	Data *string `json:"data,omitempty" url:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty" url:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`
	RequestFormat *RequestFormatEnum     `json:"request_format,omitempty" url:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty" url:"normalize_response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DataPassthroughRequest) GetMethod() MethodEnum {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DataPassthroughRequest) GetPath() string {
	if d == nil {
		return ""
	}
	return d.Path
}

func (d *DataPassthroughRequest) GetBaseUrlOverride() *string {
	if d == nil {
		return nil
	}
	return d.BaseUrlOverride
}

func (d *DataPassthroughRequest) GetData() *string {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DataPassthroughRequest) GetMultipartFormData() []*MultipartFormFieldRequest {
	if d == nil {
		return nil
	}
	return d.MultipartFormData
}

func (d *DataPassthroughRequest) GetHeaders() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DataPassthroughRequest) GetRequestFormat() *RequestFormatEnum {
	if d == nil {
		return nil
	}
	return d.RequestFormat
}

func (d *DataPassthroughRequest) GetNormalizeResponse() *bool {
	if d == nil {
		return nil
	}
	return d.NormalizeResponse
}

func (d *DataPassthroughRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DataPassthroughRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DataPassthroughRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataPassthroughRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataPassthroughRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModeLog struct {
	LogId         string                `json:"log_id" url:"log_id"`
	DashboardView string                `json:"dashboard_view" url:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary" url:"log_summary"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModeLog) GetLogId() string {
	if d == nil {
		return ""
	}
	return d.LogId
}

func (d *DebugModeLog) GetDashboardView() string {
	if d == nil {
		return ""
	}
	return d.DashboardView
}

func (d *DebugModeLog) GetLogSummary() *DebugModelLogSummary {
	if d == nil {
		return nil
	}
	return d.LogSummary
}

func (d *DebugModeLog) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModeLog) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModeLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModeLog(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModeLog) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModelLogSummary struct {
	Url        string `json:"url" url:"url"`
	Method     string `json:"method" url:"method"`
	StatusCode int    `json:"status_code" url:"status_code"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModelLogSummary) GetUrl() string {
	if d == nil {
		return ""
	}
	return d.Url
}

func (d *DebugModelLogSummary) GetMethod() string {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DebugModelLogSummary) GetStatusCode() int {
	if d == nil {
		return 0
	}
	return d.StatusCode
}

func (d *DebugModelLogSummary) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModelLogSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModelLogSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModelLogSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModelLogSummary) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The Department Object
// ### Description
// The `Department` object is used to represent a department within a company.
// ### Usage Example
// Fetch from the `LIST Departments` endpoint and view the departments within a company.
type Department struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The department's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Department) GetId() *string {
	if d == nil {
		return nil
	}
	return d.Id
}

func (d *Department) GetRemoteId() *string {
	if d == nil {
		return nil
	}
	return d.RemoteId
}

func (d *Department) GetCreatedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *Department) GetModifiedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.ModifiedAt
}

func (d *Department) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *Department) GetRemoteWasDeleted() *bool {
	if d == nil {
		return nil
	}
	return d.RemoteWasDeleted
}

func (d *Department) GetFieldMappings() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.FieldMappings
}

func (d *Department) GetRemoteData() []*RemoteData {
	if d == nil {
		return nil
	}
	return d.RemoteData
}

func (d *Department) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Department) UnmarshalJSON(data []byte) error {
	type embed Department
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Department(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	d.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Department) MarshalJSON() ([]byte, error) {
	type embed Department
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*d),
		CreatedAt:  internal.NewOptionalDateTime(d.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(d.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (d *Department) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The EmailAddress Object
// ### Description
// The `EmailAddress` object is used to represent a candidate's email address.
// ### Usage Example
// Fetch from the `GET Candidate` endpoint and view their email addresses.
type EmailAddress struct {
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The email address.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// The type of email address.
	//
	// * `PERSONAL` - PERSONAL
	// * `WORK` - WORK
	// * `OTHER` - OTHER
	EmailAddressType *EmailAddressTypeEnum `json:"email_address_type,omitempty" url:"email_address_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailAddress) GetCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *EmailAddress) GetModifiedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.ModifiedAt
}

func (e *EmailAddress) GetValue() *string {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *EmailAddress) GetEmailAddressType() *EmailAddressTypeEnum {
	if e == nil {
		return nil
	}
	return e.EmailAddressType
}

func (e *EmailAddress) GetRemoteWasDeleted() *bool {
	if e == nil {
		return nil
	}
	return e.RemoteWasDeleted
}

func (e *EmailAddress) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailAddress) UnmarshalJSON(data []byte) error {
	type embed EmailAddress
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmailAddress(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	e.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailAddress) MarshalJSON() ([]byte, error) {
	type embed EmailAddress
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*e),
		CreatedAt:  internal.NewOptionalDateTime(e.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(e.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EmailAddress) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// * `PERSONAL` - PERSONAL
// * `WORK` - WORK
// * `OTHER` - OTHER
type EmailAddressTypeEnum string

const (
	EmailAddressTypeEnumPersonal EmailAddressTypeEnum = "PERSONAL"
	EmailAddressTypeEnumWork     EmailAddressTypeEnum = "WORK"
	EmailAddressTypeEnumOther    EmailAddressTypeEnum = "OTHER"
)

func NewEmailAddressTypeEnumFromString(s string) (EmailAddressTypeEnum, error) {
	switch s {
	case "PERSONAL":
		return EmailAddressTypeEnumPersonal, nil
	case "WORK":
		return EmailAddressTypeEnumWork, nil
	case "OTHER":
		return EmailAddressTypeEnumOther, nil
	}
	var t EmailAddressTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmailAddressTypeEnum) Ptr() *EmailAddressTypeEnum {
	return &e
}

// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum string

const (
	EncodingEnumRaw        EncodingEnum = "RAW"
	EncodingEnumBase64     EncodingEnum = "BASE64"
	EncodingEnumGzipBase64 EncodingEnum = "GZIP_BASE64"
)

func NewEncodingEnumFromString(s string) (EncodingEnum, error) {
	switch s {
	case "RAW":
		return EncodingEnumRaw, nil
	case "BASE64":
		return EncodingEnumBase64, nil
	case "GZIP_BASE64":
		return EncodingEnumGzipBase64, nil
	}
	var t EncodingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncodingEnum) Ptr() *EncodingEnum {
	return &e
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorValidationProblem) GetSource() *ValidationProblemSource {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *ErrorValidationProblem) GetTitle() string {
	if e == nil {
		return ""
	}
	return e.Title
}

func (e *ErrorValidationProblem) GetDetail() string {
	if e == nil {
		return ""
	}
	return e.Detail
}

func (e *ErrorValidationProblem) GetProblemType() string {
	if e == nil {
		return ""
	}
	return e.ProblemType
}

func (e *ErrorValidationProblem) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorValidationProblem) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FieldPermissionDeserializerRequest struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty" url:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty" url:"disabled_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FieldPermissionDeserializerRequest) GetEnabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.EnabledFields
}

func (f *FieldPermissionDeserializerRequest) GetDisabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.DisabledFields
}

func (f *FieldPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializerRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type IndividualCommonModelScopeDeserializerRequest struct {
	ModelName        string                                         `json:"model_name" url:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializerRequest `json:"model_permissions,omitempty" url:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializerRequest            `json:"field_permissions,omitempty" url:"field_permissions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelName() string {
	if i == nil {
		return ""
	}
	return i.ModelName
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelPermissions() map[string]*ModelPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.ModelPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetFieldPermissions() *FieldPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.FieldPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualCommonModelScopeDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializerRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// # The Job Object
// ### Description
// The `Job` object can be used to track any jobs that are currently or will be open/closed for applications.
// ### Usage Example
// Fetch from the `LIST Jobs` endpoint to show all job postings.
type Job struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The job's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The job's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The job's code. Typically an additional identifier used to reference the particular job that is displayed on the ATS.
	Code *string `json:"code,omitempty" url:"code,omitempty"`
	// The job's status.
	//
	// * `OPEN` - OPEN
	// * `CLOSED` - CLOSED
	// * `DRAFT` - DRAFT
	// * `ARCHIVED` - ARCHIVED
	// * `PENDING` - PENDING
	Status *JobStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// The job's type.
	//
	// * `POSTING` - POSTING
	// * `REQUISITION` - REQUISITION
	// * `PROFILE` - PROFILE
	Type *JobTypeEnum `json:"type,omitempty" url:"type,omitempty"`
	// IDs of `JobPosting` objects that serve as job postings for this `Job`.
	JobPostings    []*string `json:"job_postings,omitempty" url:"job_postings,omitempty"`
	JobPostingUrls []*Url    `json:"job_posting_urls,omitempty" url:"job_posting_urls,omitempty"`
	// When the third party's job was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's job was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// Whether the job is confidential.
	Confidential *bool `json:"confidential,omitempty" url:"confidential,omitempty"`
	// IDs of `Department` objects for this `Job`.
	Departments []*JobDepartmentsItem `json:"departments,omitempty" url:"departments,omitempty"`
	// IDs of `Office` objects for this `Job`.
	Offices []*JobOfficesItem `json:"offices,omitempty" url:"offices,omitempty"`
	// IDs of `RemoteUser` objects that serve as hiring managers for this `Job`.
	HiringManagers []*JobHiringManagersItem `json:"hiring_managers,omitempty" url:"hiring_managers,omitempty"`
	// IDs of `RemoteUser` objects that serve as recruiters for this `Job`.
	Recruiters []*JobRecruitersItem `json:"recruiters,omitempty" url:"recruiters,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *Job) GetId() *string {
	if j == nil {
		return nil
	}
	return j.Id
}

func (j *Job) GetRemoteId() *string {
	if j == nil {
		return nil
	}
	return j.RemoteId
}

func (j *Job) GetCreatedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.CreatedAt
}

func (j *Job) GetModifiedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.ModifiedAt
}

func (j *Job) GetName() *string {
	if j == nil {
		return nil
	}
	return j.Name
}

func (j *Job) GetDescription() *string {
	if j == nil {
		return nil
	}
	return j.Description
}

func (j *Job) GetCode() *string {
	if j == nil {
		return nil
	}
	return j.Code
}

func (j *Job) GetStatus() *JobStatusEnum {
	if j == nil {
		return nil
	}
	return j.Status
}

func (j *Job) GetType() *JobTypeEnum {
	if j == nil {
		return nil
	}
	return j.Type
}

func (j *Job) GetJobPostings() []*string {
	if j == nil {
		return nil
	}
	return j.JobPostings
}

func (j *Job) GetJobPostingUrls() []*Url {
	if j == nil {
		return nil
	}
	return j.JobPostingUrls
}

func (j *Job) GetRemoteCreatedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.RemoteCreatedAt
}

func (j *Job) GetRemoteUpdatedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.RemoteUpdatedAt
}

func (j *Job) GetConfidential() *bool {
	if j == nil {
		return nil
	}
	return j.Confidential
}

func (j *Job) GetDepartments() []*JobDepartmentsItem {
	if j == nil {
		return nil
	}
	return j.Departments
}

func (j *Job) GetOffices() []*JobOfficesItem {
	if j == nil {
		return nil
	}
	return j.Offices
}

func (j *Job) GetHiringManagers() []*JobHiringManagersItem {
	if j == nil {
		return nil
	}
	return j.HiringManagers
}

func (j *Job) GetRecruiters() []*JobRecruitersItem {
	if j == nil {
		return nil
	}
	return j.Recruiters
}

func (j *Job) GetRemoteWasDeleted() *bool {
	if j == nil {
		return nil
	}
	return j.RemoteWasDeleted
}

func (j *Job) GetFieldMappings() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.FieldMappings
}

func (j *Job) GetRemoteData() []*RemoteData {
	if j == nil {
		return nil
	}
	return j.RemoteData
}

func (j *Job) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *Job) UnmarshalJSON(data []byte) error {
	type embed Job
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = Job(unmarshaler.embed)
	j.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	j.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	j.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	j.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *Job) MarshalJSON() ([]byte, error) {
	type embed Job
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*j),
		CreatedAt:       internal.NewOptionalDateTime(j.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(j.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(j.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(j.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (j *Job) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobDepartmentsItem struct {
	String     string
	Department *Department

	typ string
}

func (j *JobDepartmentsItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JobDepartmentsItem) GetDepartment() *Department {
	if j == nil {
		return nil
	}
	return j.Department
}

func (j *JobDepartmentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueDepartment := new(Department)
	if err := json.Unmarshal(data, &valueDepartment); err == nil {
		j.typ = "Department"
		j.Department = valueDepartment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobDepartmentsItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Department" || j.Department != nil {
		return json.Marshal(j.Department)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobDepartmentsItemVisitor interface {
	VisitString(string) error
	VisitDepartment(*Department) error
}

func (j *JobDepartmentsItem) Accept(visitor JobDepartmentsItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Department" || j.Department != nil {
		return visitor.VisitDepartment(j.Department)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobHiringManagersItem struct {
	String     string
	RemoteUser *RemoteUser

	typ string
}

func (j *JobHiringManagersItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JobHiringManagersItem) GetRemoteUser() *RemoteUser {
	if j == nil {
		return nil
	}
	return j.RemoteUser
}

func (j *JobHiringManagersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		j.typ = "RemoteUser"
		j.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobHiringManagersItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "RemoteUser" || j.RemoteUser != nil {
		return json.Marshal(j.RemoteUser)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobHiringManagersItemVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (j *JobHiringManagersItem) Accept(visitor JobHiringManagersItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "RemoteUser" || j.RemoteUser != nil {
		return visitor.VisitRemoteUser(j.RemoteUser)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// # The JobInterviewStage Object
// ### Description
// The `JobInterviewStage` object is used to represent a particular recruiting stage for an `Application`. A given `Application` typically has the `JobInterviewStage` object represented in the current_stage field.
// ### Usage Example
// Fetch from the `LIST JobInterviewStages` endpoint and view the job interview stages used by a company.
type JobInterviewStage struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// Standard stage names are offered by ATS systems but can be modified by users.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This field is populated only if the stage is specific to a particular job. If the stage is generic, this field will not be populated.
	Job *JobInterviewStageJob `json:"job,omitempty" url:"job,omitempty"`
	// The stages order, with the lowest values ordered first. If the third-party does not return details on the order of stages, this field will not be populated.
	StageOrder *int `json:"stage_order,omitempty" url:"stage_order,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JobInterviewStage) GetId() *string {
	if j == nil {
		return nil
	}
	return j.Id
}

func (j *JobInterviewStage) GetRemoteId() *string {
	if j == nil {
		return nil
	}
	return j.RemoteId
}

func (j *JobInterviewStage) GetCreatedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.CreatedAt
}

func (j *JobInterviewStage) GetModifiedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.ModifiedAt
}

func (j *JobInterviewStage) GetName() *string {
	if j == nil {
		return nil
	}
	return j.Name
}

func (j *JobInterviewStage) GetJob() *JobInterviewStageJob {
	if j == nil {
		return nil
	}
	return j.Job
}

func (j *JobInterviewStage) GetStageOrder() *int {
	if j == nil {
		return nil
	}
	return j.StageOrder
}

func (j *JobInterviewStage) GetRemoteWasDeleted() *bool {
	if j == nil {
		return nil
	}
	return j.RemoteWasDeleted
}

func (j *JobInterviewStage) GetFieldMappings() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.FieldMappings
}

func (j *JobInterviewStage) GetRemoteData() []*RemoteData {
	if j == nil {
		return nil
	}
	return j.RemoteData
}

func (j *JobInterviewStage) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobInterviewStage) UnmarshalJSON(data []byte) error {
	type embed JobInterviewStage
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = JobInterviewStage(unmarshaler.embed)
	j.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	j.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobInterviewStage) MarshalJSON() ([]byte, error) {
	type embed JobInterviewStage
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*j),
		CreatedAt:  internal.NewOptionalDateTime(j.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(j.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (j *JobInterviewStage) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// This field is populated only if the stage is specific to a particular job. If the stage is generic, this field will not be populated.
type JobInterviewStageJob struct {
	String string
	Job    *Job

	typ string
}

func (j *JobInterviewStageJob) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JobInterviewStageJob) GetJob() *Job {
	if j == nil {
		return nil
	}
	return j.Job
}

func (j *JobInterviewStageJob) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueJob := new(Job)
	if err := json.Unmarshal(data, &valueJob); err == nil {
		j.typ = "Job"
		j.Job = valueJob
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobInterviewStageJob) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Job" || j.Job != nil {
		return json.Marshal(j.Job)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobInterviewStageJobVisitor interface {
	VisitString(string) error
	VisitJob(*Job) error
}

func (j *JobInterviewStageJob) Accept(visitor JobInterviewStageJobVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Job" || j.Job != nil {
		return visitor.VisitJob(j.Job)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobOfficesItem struct {
	String string
	Office *Office

	typ string
}

func (j *JobOfficesItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JobOfficesItem) GetOffice() *Office {
	if j == nil {
		return nil
	}
	return j.Office
}

func (j *JobOfficesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueOffice := new(Office)
	if err := json.Unmarshal(data, &valueOffice); err == nil {
		j.typ = "Office"
		j.Office = valueOffice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobOfficesItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Office" || j.Office != nil {
		return json.Marshal(j.Office)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobOfficesItemVisitor interface {
	VisitString(string) error
	VisitOffice(*Office) error
}

func (j *JobOfficesItem) Accept(visitor JobOfficesItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Office" || j.Office != nil {
		return visitor.VisitOffice(j.Office)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobRecruitersItem struct {
	String     string
	RemoteUser *RemoteUser

	typ string
}

func (j *JobRecruitersItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JobRecruitersItem) GetRemoteUser() *RemoteUser {
	if j == nil {
		return nil
	}
	return j.RemoteUser
}

func (j *JobRecruitersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		j.typ = "RemoteUser"
		j.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobRecruitersItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "RemoteUser" || j.RemoteUser != nil {
		return json.Marshal(j.RemoteUser)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JobRecruitersItemVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (j *JobRecruitersItem) Accept(visitor JobRecruitersItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "RemoteUser" || j.RemoteUser != nil {
		return visitor.VisitRemoteUser(j.RemoteUser)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// * `OPEN` - OPEN
// * `CLOSED` - CLOSED
// * `DRAFT` - DRAFT
// * `ARCHIVED` - ARCHIVED
// * `PENDING` - PENDING
type JobStatusEnum string

const (
	JobStatusEnumOpen     JobStatusEnum = "OPEN"
	JobStatusEnumClosed   JobStatusEnum = "CLOSED"
	JobStatusEnumDraft    JobStatusEnum = "DRAFT"
	JobStatusEnumArchived JobStatusEnum = "ARCHIVED"
	JobStatusEnumPending  JobStatusEnum = "PENDING"
)

func NewJobStatusEnumFromString(s string) (JobStatusEnum, error) {
	switch s {
	case "OPEN":
		return JobStatusEnumOpen, nil
	case "CLOSED":
		return JobStatusEnumClosed, nil
	case "DRAFT":
		return JobStatusEnumDraft, nil
	case "ARCHIVED":
		return JobStatusEnumArchived, nil
	case "PENDING":
		return JobStatusEnumPending, nil
	}
	var t JobStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobStatusEnum) Ptr() *JobStatusEnum {
	return &j
}

// * `POSTING` - POSTING
// * `REQUISITION` - REQUISITION
// * `PROFILE` - PROFILE
type JobTypeEnum string

const (
	JobTypeEnumPosting     JobTypeEnum = "POSTING"
	JobTypeEnumRequisition JobTypeEnum = "REQUISITION"
	JobTypeEnumProfile     JobTypeEnum = "PROFILE"
)

func NewJobTypeEnumFromString(s string) (JobTypeEnum, error) {
	switch s {
	case "POSTING":
		return JobTypeEnumPosting, nil
	case "REQUISITION":
		return JobTypeEnumRequisition, nil
	case "PROFILE":
		return JobTypeEnumProfile, nil
	}
	var t JobTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobTypeEnum) Ptr() *JobTypeEnum {
	return &j
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type LastSyncResultEnum string

const (
	LastSyncResultEnumSyncing         LastSyncResultEnum = "SYNCING"
	LastSyncResultEnumDone            LastSyncResultEnum = "DONE"
	LastSyncResultEnumFailed          LastSyncResultEnum = "FAILED"
	LastSyncResultEnumDisabled        LastSyncResultEnum = "DISABLED"
	LastSyncResultEnumPaused          LastSyncResultEnum = "PAUSED"
	LastSyncResultEnumPartiallySynced LastSyncResultEnum = "PARTIALLY_SYNCED"
)

func NewLastSyncResultEnumFromString(s string) (LastSyncResultEnum, error) {
	switch s {
	case "SYNCING":
		return LastSyncResultEnumSyncing, nil
	case "DONE":
		return LastSyncResultEnumDone, nil
	case "FAILED":
		return LastSyncResultEnumFailed, nil
	case "DISABLED":
		return LastSyncResultEnumDisabled, nil
	case "PAUSED":
		return LastSyncResultEnumPaused, nil
	case "PARTIALLY_SYNCED":
		return LastSyncResultEnumPartiallySynced, nil
	}
	var t LastSyncResultEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LastSyncResultEnum) Ptr() *LastSyncResultEnum {
	return &l
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status" url:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request" url:"can_make_request"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LinkedAccountStatus) GetLinkedAccountStatus() string {
	if l == nil {
		return ""
	}
	return l.LinkedAccountStatus
}

func (l *LinkedAccountStatus) GetCanMakeRequest() bool {
	if l == nil {
		return false
	}
	return l.CanMakeRequest
}

func (l *LinkedAccountStatus) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkedAccountStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedAccountStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedAccountStatus(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedAccountStatus) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MetaResponse struct {
	RequestSchema                  map[string]interface{} `json:"request_schema" url:"request_schema"`
	RemoteFieldClasses             map[string]interface{} `json:"remote_field_classes,omitempty" url:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus   `json:"status,omitempty" url:"status,omitempty"`
	HasConditionalParams           bool                   `json:"has_conditional_params" url:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                   `json:"has_required_linked_account_params" url:"has_required_linked_account_params"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetaResponse) GetRequestSchema() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RequestSchema
}

func (m *MetaResponse) GetRemoteFieldClasses() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RemoteFieldClasses
}

func (m *MetaResponse) GetStatus() *LinkedAccountStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

func (m *MetaResponse) GetHasConditionalParams() bool {
	if m == nil {
		return false
	}
	return m.HasConditionalParams
}

func (m *MetaResponse) GetHasRequiredLinkedAccountParams() bool {
	if m == nil {
		return false
	}
	return m.HasRequiredLinkedAccountParams
}

func (m *MetaResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetaResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// * `GET` - GET
// * `OPTIONS` - OPTIONS
// * `HEAD` - HEAD
// * `POST` - POST
// * `PUT` - PUT
// * `PATCH` - PATCH
// * `DELETE` - DELETE
type MethodEnum string

const (
	MethodEnumGet     MethodEnum = "GET"
	MethodEnumOptions MethodEnum = "OPTIONS"
	MethodEnumHead    MethodEnum = "HEAD"
	MethodEnumPost    MethodEnum = "POST"
	MethodEnumPut     MethodEnum = "PUT"
	MethodEnumPatch   MethodEnum = "PATCH"
	MethodEnumDelete  MethodEnum = "DELETE"
)

func NewMethodEnumFromString(s string) (MethodEnum, error) {
	switch s {
	case "GET":
		return MethodEnumGet, nil
	case "OPTIONS":
		return MethodEnumOptions, nil
	case "HEAD":
		return MethodEnumHead, nil
	case "POST":
		return MethodEnumPost, nil
	case "PUT":
		return MethodEnumPut, nil
	case "PATCH":
		return MethodEnumPatch, nil
	case "DELETE":
		return MethodEnumDelete, nil
	}
	var t MethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodEnum) Ptr() *MethodEnum {
	return &m
}

// # The ModelOperation Object
// ### Description
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name" url:"model_name"`
	AvailableOperations    []string `json:"available_operations" url:"available_operations"`
	RequiredPostParameters []string `json:"required_post_parameters" url:"required_post_parameters"`
	SupportedFields        []string `json:"supported_fields" url:"supported_fields"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelOperation) GetModelName() string {
	if m == nil {
		return ""
	}
	return m.ModelName
}

func (m *ModelOperation) GetAvailableOperations() []string {
	if m == nil {
		return nil
	}
	return m.AvailableOperations
}

func (m *ModelOperation) GetRequiredPostParameters() []string {
	if m == nil {
		return nil
	}
	return m.RequiredPostParameters
}

func (m *ModelOperation) GetSupportedFields() []string {
	if m == nil {
		return nil
	}
	return m.SupportedFields
}

func (m *ModelOperation) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelOperation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelOperation) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializerRequest struct {
	IsEnabled *bool `json:"is_enabled,omitempty" url:"is_enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelPermissionDeserializerRequest) GetIsEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.IsEnabled
}

func (m *ModelPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializerRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The MultipartFormField Object
// ### Description
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name" url:"name"`
	// The data for the form field.
	Data string `json:"data" url:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// * `RAW` - RAW
	// * `BASE64` - BASE64
	// * `GZIP_BASE64` - GZIP_BASE64
	Encoding *EncodingEnum `json:"encoding,omitempty" url:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MultipartFormFieldRequest) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MultipartFormFieldRequest) GetData() string {
	if m == nil {
		return ""
	}
	return m.Data
}

func (m *MultipartFormFieldRequest) GetEncoding() *EncodingEnum {
	if m == nil {
		return nil
	}
	return m.Encoding
}

func (m *MultipartFormFieldRequest) GetFileName() *string {
	if m == nil {
		return nil
	}
	return m.FileName
}

func (m *MultipartFormFieldRequest) GetContentType() *string {
	if m == nil {
		return nil
	}
	return m.ContentType
}

func (m *MultipartFormFieldRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipartFormFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipartFormFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipartFormFieldRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipartFormFieldRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The Offer Object
// ### Description
// The `Offer` object is used to represent an offer for a candidate's application specific to a job.
// ### Usage Example
// Fetch from the `LIST Offers` endpoint and filter by `ID` to show all offers.
type Offer struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The application who is receiving the offer.
	Application *OfferApplication `json:"application,omitempty" url:"application,omitempty"`
	// The user who created the offer.
	Creator *OfferCreator `json:"creator,omitempty" url:"creator,omitempty"`
	// When the third party's offer was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the offer was closed.
	ClosedAt *time.Time `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// When the offer was sent.
	SentAt *time.Time `json:"sent_at,omitempty" url:"sent_at,omitempty"`
	// The employment start date on the offer.
	StartDate *time.Time `json:"start_date,omitempty" url:"start_date,omitempty"`
	// The offer's status.
	//
	// * `DRAFT` - DRAFT
	// * `APPROVAL-SENT` - APPROVAL-SENT
	// * `APPROVED` - APPROVED
	// * `SENT` - SENT
	// * `SENT-MANUALLY` - SENT-MANUALLY
	// * `OPENED` - OPENED
	// * `DENIED` - DENIED
	// * `SIGNED` - SIGNED
	// * `DEPRECATED` - DEPRECATED
	Status *OfferStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Offer) GetId() *string {
	if o == nil {
		return nil
	}
	return o.Id
}

func (o *Offer) GetRemoteId() *string {
	if o == nil {
		return nil
	}
	return o.RemoteId
}

func (o *Offer) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Offer) GetModifiedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.ModifiedAt
}

func (o *Offer) GetApplication() *OfferApplication {
	if o == nil {
		return nil
	}
	return o.Application
}

func (o *Offer) GetCreator() *OfferCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

func (o *Offer) GetRemoteCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.RemoteCreatedAt
}

func (o *Offer) GetClosedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.ClosedAt
}

func (o *Offer) GetSentAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.SentAt
}

func (o *Offer) GetStartDate() *time.Time {
	if o == nil {
		return nil
	}
	return o.StartDate
}

func (o *Offer) GetStatus() *OfferStatusEnum {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Offer) GetRemoteWasDeleted() *bool {
	if o == nil {
		return nil
	}
	return o.RemoteWasDeleted
}

func (o *Offer) GetFieldMappings() map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.FieldMappings
}

func (o *Offer) GetRemoteData() []*RemoteData {
	if o == nil {
		return nil
	}
	return o.RemoteData
}

func (o *Offer) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Offer) UnmarshalJSON(data []byte) error {
	type embed Offer
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		ClosedAt        *internal.DateTime `json:"closed_at,omitempty"`
		SentAt          *internal.DateTime `json:"sent_at,omitempty"`
		StartDate       *internal.DateTime `json:"start_date,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Offer(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	o.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	o.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	o.ClosedAt = unmarshaler.ClosedAt.TimePtr()
	o.SentAt = unmarshaler.SentAt.TimePtr()
	o.StartDate = unmarshaler.StartDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Offer) MarshalJSON() ([]byte, error) {
	type embed Offer
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		ClosedAt        *internal.DateTime `json:"closed_at,omitempty"`
		SentAt          *internal.DateTime `json:"sent_at,omitempty"`
		StartDate       *internal.DateTime `json:"start_date,omitempty"`
	}{
		embed:           embed(*o),
		CreatedAt:       internal.NewOptionalDateTime(o.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(o.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(o.RemoteCreatedAt),
		ClosedAt:        internal.NewOptionalDateTime(o.ClosedAt),
		SentAt:          internal.NewOptionalDateTime(o.SentAt),
		StartDate:       internal.NewOptionalDateTime(o.StartDate),
	}
	return json.Marshal(marshaler)
}

func (o *Offer) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The application who is receiving the offer.
type OfferApplication struct {
	String      string
	Application *Application

	typ string
}

func (o *OfferApplication) GetString() string {
	if o == nil {
		return ""
	}
	return o.String
}

func (o *OfferApplication) GetApplication() *Application {
	if o == nil {
		return nil
	}
	return o.Application
}

func (o *OfferApplication) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typ = "String"
		o.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		o.typ = "Application"
		o.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OfferApplication) MarshalJSON() ([]byte, error) {
	if o.typ == "String" || o.String != "" {
		return json.Marshal(o.String)
	}
	if o.typ == "Application" || o.Application != nil {
		return json.Marshal(o.Application)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OfferApplicationVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (o *OfferApplication) Accept(visitor OfferApplicationVisitor) error {
	if o.typ == "String" || o.String != "" {
		return visitor.VisitString(o.String)
	}
	if o.typ == "Application" || o.Application != nil {
		return visitor.VisitApplication(o.Application)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

// The user who created the offer.
type OfferCreator struct {
	String     string
	RemoteUser *RemoteUser

	typ string
}

func (o *OfferCreator) GetString() string {
	if o == nil {
		return ""
	}
	return o.String
}

func (o *OfferCreator) GetRemoteUser() *RemoteUser {
	if o == nil {
		return nil
	}
	return o.RemoteUser
}

func (o *OfferCreator) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typ = "String"
		o.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		o.typ = "RemoteUser"
		o.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OfferCreator) MarshalJSON() ([]byte, error) {
	if o.typ == "String" || o.String != "" {
		return json.Marshal(o.String)
	}
	if o.typ == "RemoteUser" || o.RemoteUser != nil {
		return json.Marshal(o.RemoteUser)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OfferCreatorVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (o *OfferCreator) Accept(visitor OfferCreatorVisitor) error {
	if o.typ == "String" || o.String != "" {
		return visitor.VisitString(o.String)
	}
	if o.typ == "RemoteUser" || o.RemoteUser != nil {
		return visitor.VisitRemoteUser(o.RemoteUser)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

// * `DRAFT` - DRAFT
// * `APPROVAL-SENT` - APPROVAL-SENT
// * `APPROVED` - APPROVED
// * `SENT` - SENT
// * `SENT-MANUALLY` - SENT-MANUALLY
// * `OPENED` - OPENED
// * `DENIED` - DENIED
// * `SIGNED` - SIGNED
// * `DEPRECATED` - DEPRECATED
type OfferStatusEnum string

const (
	OfferStatusEnumDraft        OfferStatusEnum = "DRAFT"
	OfferStatusEnumApprovalSent OfferStatusEnum = "APPROVAL-SENT"
	OfferStatusEnumApproved     OfferStatusEnum = "APPROVED"
	OfferStatusEnumSent         OfferStatusEnum = "SENT"
	OfferStatusEnumSentManually OfferStatusEnum = "SENT-MANUALLY"
	OfferStatusEnumOpened       OfferStatusEnum = "OPENED"
	OfferStatusEnumDenied       OfferStatusEnum = "DENIED"
	OfferStatusEnumSigned       OfferStatusEnum = "SIGNED"
	OfferStatusEnumDeprecated   OfferStatusEnum = "DEPRECATED"
)

func NewOfferStatusEnumFromString(s string) (OfferStatusEnum, error) {
	switch s {
	case "DRAFT":
		return OfferStatusEnumDraft, nil
	case "APPROVAL-SENT":
		return OfferStatusEnumApprovalSent, nil
	case "APPROVED":
		return OfferStatusEnumApproved, nil
	case "SENT":
		return OfferStatusEnumSent, nil
	case "SENT-MANUALLY":
		return OfferStatusEnumSentManually, nil
	case "OPENED":
		return OfferStatusEnumOpened, nil
	case "DENIED":
		return OfferStatusEnumDenied, nil
	case "SIGNED":
		return OfferStatusEnumSigned, nil
	case "DEPRECATED":
		return OfferStatusEnumDeprecated, nil
	}
	var t OfferStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OfferStatusEnum) Ptr() *OfferStatusEnum {
	return &o
}

// # The Office Object
// ### Description
// The `Office` object is used to represent an office within a company. A given `Job` has the `Office` ID in its offices field.
// ### Usage Example
// Fetch from the `LIST Offices` endpoint and view the offices within a company.
type Office struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The office's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The office's location.
	Location *string `json:"location,omitempty" url:"location,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Office) GetId() *string {
	if o == nil {
		return nil
	}
	return o.Id
}

func (o *Office) GetRemoteId() *string {
	if o == nil {
		return nil
	}
	return o.RemoteId
}

func (o *Office) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Office) GetModifiedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.ModifiedAt
}

func (o *Office) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Office) GetLocation() *string {
	if o == nil {
		return nil
	}
	return o.Location
}

func (o *Office) GetRemoteWasDeleted() *bool {
	if o == nil {
		return nil
	}
	return o.RemoteWasDeleted
}

func (o *Office) GetFieldMappings() map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.FieldMappings
}

func (o *Office) GetRemoteData() []*RemoteData {
	if o == nil {
		return nil
	}
	return o.RemoteData
}

func (o *Office) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Office) UnmarshalJSON(data []byte) error {
	type embed Office
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Office(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	o.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Office) MarshalJSON() ([]byte, error) {
	type embed Office
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*o),
		CreatedAt:  internal.NewOptionalDateTime(o.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(o.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (o *Office) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// # The PhoneNumber Object
// ### Description
// The `PhoneNumber` object is used to represent a candidate's phone number.
// ### Usage Example
// Fetch from the `GET Candidate` endpoint and view their phone numbers.
type PhoneNumber struct {
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The phone number.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// The type of phone number.
	//
	// * `HOME` - HOME
	// * `WORK` - WORK
	// * `MOBILE` - MOBILE
	// * `SKYPE` - SKYPE
	// * `OTHER` - OTHER
	PhoneNumberType *PhoneNumberTypeEnum `json:"phone_number_type,omitempty" url:"phone_number_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PhoneNumber) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PhoneNumber) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *PhoneNumber) GetValue() *string {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *PhoneNumber) GetPhoneNumberType() *PhoneNumberTypeEnum {
	if p == nil {
		return nil
	}
	return p.PhoneNumberType
}

func (p *PhoneNumber) GetRemoteWasDeleted() *bool {
	if p == nil {
		return nil
	}
	return p.RemoteWasDeleted
}

func (p *PhoneNumber) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhoneNumber) UnmarshalJSON(data []byte) error {
	type embed PhoneNumber
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PhoneNumber(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhoneNumber) MarshalJSON() ([]byte, error) {
	type embed PhoneNumber
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*p),
		CreatedAt:  internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(p.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PhoneNumber) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// * `HOME` - HOME
// * `WORK` - WORK
// * `MOBILE` - MOBILE
// * `SKYPE` - SKYPE
// * `OTHER` - OTHER
type PhoneNumberTypeEnum string

const (
	PhoneNumberTypeEnumHome   PhoneNumberTypeEnum = "HOME"
	PhoneNumberTypeEnumWork   PhoneNumberTypeEnum = "WORK"
	PhoneNumberTypeEnumMobile PhoneNumberTypeEnum = "MOBILE"
	PhoneNumberTypeEnumSkype  PhoneNumberTypeEnum = "SKYPE"
	PhoneNumberTypeEnumOther  PhoneNumberTypeEnum = "OTHER"
)

func NewPhoneNumberTypeEnumFromString(s string) (PhoneNumberTypeEnum, error) {
	switch s {
	case "HOME":
		return PhoneNumberTypeEnumHome, nil
	case "WORK":
		return PhoneNumberTypeEnumWork, nil
	case "MOBILE":
		return PhoneNumberTypeEnumMobile, nil
	case "SKYPE":
		return PhoneNumberTypeEnumSkype, nil
	case "OTHER":
		return PhoneNumberTypeEnumOther, nil
	}
	var t PhoneNumberTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PhoneNumberTypeEnum) Ptr() *PhoneNumberTypeEnum {
	return &p
}

// # The RejectReason Object
// ### Description
// The `RejectReason` object is used to represent a reason for rejecting an application. These can typically be configured within an ATS system.
// ### Usage Example
// Fetch from the `LIST RejectReasons` endpoint and filter by `ID` to show all reasons.
type RejectReason struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The rejection reasons name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RejectReason) GetId() *string {
	if r == nil {
		return nil
	}
	return r.Id
}

func (r *RejectReason) GetRemoteId() *string {
	if r == nil {
		return nil
	}
	return r.RemoteId
}

func (r *RejectReason) GetCreatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *RejectReason) GetModifiedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.ModifiedAt
}

func (r *RejectReason) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RejectReason) GetRemoteWasDeleted() *bool {
	if r == nil {
		return nil
	}
	return r.RemoteWasDeleted
}

func (r *RejectReason) GetFieldMappings() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.FieldMappings
}

func (r *RejectReason) GetRemoteData() []*RemoteData {
	if r == nil {
		return nil
	}
	return r.RemoteData
}

func (r *RejectReason) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RejectReason) UnmarshalJSON(data []byte) error {
	type embed RejectReason
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RejectReason(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	r.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RejectReason) MarshalJSON() ([]byte, error) {
	type embed RejectReason
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*r),
		CreatedAt:  internal.NewOptionalDateTime(r.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(r.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (r *RejectReason) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteData Object
// ### Description
// The `RemoteData` object is used to represent the full data pulled from the third-party API for an object.
//
// ### Usage Example
// TODO
type RemoteData struct {
	// The third-party API path that is being called.
	Path string      `json:"path" url:"path"`
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteData) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteData) GetData() interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RemoteData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteData) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteKey Object
// ### Description
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name" url:"name"`
	Key  string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteKey) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

func (r *RemoteKey) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *RemoteKey) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteKey) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteResponse Object
// ### Description
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                 `json:"method" url:"method"`
	Path            string                 `json:"path" url:"path"`
	Status          int                    `json:"status" url:"status"`
	Response        interface{}            `json:"response" url:"response"`
	ResponseHeaders map[string]interface{} `json:"response_headers,omitempty" url:"response_headers,omitempty"`
	ResponseType    *ResponseTypeEnum      `json:"response_type,omitempty" url:"response_type,omitempty"`
	Headers         map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteResponse) GetMethod() string {
	if r == nil {
		return ""
	}
	return r.Method
}

func (r *RemoteResponse) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteResponse) GetStatus() int {
	if r == nil {
		return 0
	}
	return r.Status
}

func (r *RemoteResponse) GetResponse() interface{} {
	if r == nil {
		return nil
	}
	return r.Response
}

func (r *RemoteResponse) GetResponseHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.ResponseHeaders
}

func (r *RemoteResponse) GetResponseType() *ResponseTypeEnum {
	if r == nil {
		return nil
	}
	return r.ResponseType
}

func (r *RemoteResponse) GetHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Headers
}

func (r *RemoteResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteUser Object
// ### Description
// The `RemoteUser` object is used to represent a user with a login to the ATS system.
// ### Usage Example
// Fetch from the `LIST RemoteUsers` endpoint to show all users for a third party.
type RemoteUser struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The user's first name.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// The user's last name.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`
	// The user's email.
	Email *string `json:"email,omitempty" url:"email,omitempty"`
	// Whether the user's account had been disabled.
	Disabled *bool `json:"disabled,omitempty" url:"disabled,omitempty"`
	// When the third party's user was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// The user's role.
	//
	// * `SUPER_ADMIN` - SUPER_ADMIN
	// * `ADMIN` - ADMIN
	// * `TEAM_MEMBER` - TEAM_MEMBER
	// * `LIMITED_TEAM_MEMBER` - LIMITED_TEAM_MEMBER
	// * `INTERVIEWER` - INTERVIEWER
	AccessRole *AccessRoleEnum `json:"access_role,omitempty" url:"access_role,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteUser) GetId() *string {
	if r == nil {
		return nil
	}
	return r.Id
}

func (r *RemoteUser) GetRemoteId() *string {
	if r == nil {
		return nil
	}
	return r.RemoteId
}

func (r *RemoteUser) GetCreatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *RemoteUser) GetModifiedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.ModifiedAt
}

func (r *RemoteUser) GetFirstName() *string {
	if r == nil {
		return nil
	}
	return r.FirstName
}

func (r *RemoteUser) GetLastName() *string {
	if r == nil {
		return nil
	}
	return r.LastName
}

func (r *RemoteUser) GetEmail() *string {
	if r == nil {
		return nil
	}
	return r.Email
}

func (r *RemoteUser) GetDisabled() *bool {
	if r == nil {
		return nil
	}
	return r.Disabled
}

func (r *RemoteUser) GetRemoteCreatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.RemoteCreatedAt
}

func (r *RemoteUser) GetAccessRole() *AccessRoleEnum {
	if r == nil {
		return nil
	}
	return r.AccessRole
}

func (r *RemoteUser) GetRemoteWasDeleted() *bool {
	if r == nil {
		return nil
	}
	return r.RemoteWasDeleted
}

func (r *RemoteUser) GetFieldMappings() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.FieldMappings
}

func (r *RemoteUser) GetRemoteData() []*RemoteData {
	if r == nil {
		return nil
	}
	return r.RemoteData
}

func (r *RemoteUser) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteUser) UnmarshalJSON(data []byte) error {
	type embed RemoteUser
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RemoteUser(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	r.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	r.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteUser) MarshalJSON() ([]byte, error) {
	type embed RemoteUser
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
	}{
		embed:           embed(*r),
		CreatedAt:       internal.NewOptionalDateTime(r.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(r.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(r.RemoteCreatedAt),
	}
	return json.Marshal(marshaler)
}

func (r *RemoteUser) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// * `JSON` - JSON
// * `XML` - XML
// * `MULTIPART` - MULTIPART
type RequestFormatEnum string

const (
	RequestFormatEnumJson      RequestFormatEnum = "JSON"
	RequestFormatEnumXml       RequestFormatEnum = "XML"
	RequestFormatEnumMultipart RequestFormatEnum = "MULTIPART"
)

func NewRequestFormatEnumFromString(s string) (RequestFormatEnum, error) {
	switch s {
	case "JSON":
		return RequestFormatEnumJson, nil
	case "XML":
		return RequestFormatEnumXml, nil
	case "MULTIPART":
		return RequestFormatEnumMultipart, nil
	}
	var t RequestFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestFormatEnum) Ptr() *RequestFormatEnum {
	return &r
}

// * `JSON` - JSON
// * `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum string

const (
	ResponseTypeEnumJson       ResponseTypeEnum = "JSON"
	ResponseTypeEnumBase64Gzip ResponseTypeEnum = "BASE64_GZIP"
)

func NewResponseTypeEnumFromString(s string) (ResponseTypeEnum, error) {
	switch s {
	case "JSON":
		return ResponseTypeEnumJson, nil
	case "BASE64_GZIP":
		return ResponseTypeEnumBase64Gzip, nil
	}
	var t ResponseTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTypeEnum) Ptr() *ResponseTypeEnum {
	return &r
}

// # The ScheduledInterview Object
// ### Description
// The `ScheduledInterview` object is used to represent a scheduled interview for a given candidates application to a job. An `Application` can have multiple `ScheduledInterview`s depending on the particular hiring process.
// ### Usage Example
// Fetch from the `LIST ScheduledInterviews` endpoint and filter by `interviewers` to show all office locations.
type ScheduledInterview struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The application being interviewed.
	Application *ScheduledInterviewApplication `json:"application,omitempty" url:"application,omitempty"`
	// The stage of the interview.
	JobInterviewStage *ScheduledInterviewJobInterviewStage `json:"job_interview_stage,omitempty" url:"job_interview_stage,omitempty"`
	// The user organizing the interview.
	Organizer *ScheduledInterviewOrganizer `json:"organizer,omitempty" url:"organizer,omitempty"`
	// Array of `RemoteUser` IDs.
	Interviewers []*ScheduledInterviewInterviewersItem `json:"interviewers,omitempty" url:"interviewers,omitempty"`
	// The interview's location.
	Location *string `json:"location,omitempty" url:"location,omitempty"`
	// When the interview was started.
	StartAt *time.Time `json:"start_at,omitempty" url:"start_at,omitempty"`
	// When the interview was ended.
	EndAt *time.Time `json:"end_at,omitempty" url:"end_at,omitempty"`
	// When the third party's interview was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's interview was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// The interview's status.
	//
	// * `SCHEDULED` - SCHEDULED
	// * `AWAITING_FEEDBACK` - AWAITING_FEEDBACK
	// * `COMPLETE` - COMPLETE
	Status *ScheduledInterviewStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduledInterview) GetId() *string {
	if s == nil {
		return nil
	}
	return s.Id
}

func (s *ScheduledInterview) GetRemoteId() *string {
	if s == nil {
		return nil
	}
	return s.RemoteId
}

func (s *ScheduledInterview) GetCreatedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *ScheduledInterview) GetModifiedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ModifiedAt
}

func (s *ScheduledInterview) GetApplication() *ScheduledInterviewApplication {
	if s == nil {
		return nil
	}
	return s.Application
}

func (s *ScheduledInterview) GetJobInterviewStage() *ScheduledInterviewJobInterviewStage {
	if s == nil {
		return nil
	}
	return s.JobInterviewStage
}

func (s *ScheduledInterview) GetOrganizer() *ScheduledInterviewOrganizer {
	if s == nil {
		return nil
	}
	return s.Organizer
}

func (s *ScheduledInterview) GetInterviewers() []*ScheduledInterviewInterviewersItem {
	if s == nil {
		return nil
	}
	return s.Interviewers
}

func (s *ScheduledInterview) GetLocation() *string {
	if s == nil {
		return nil
	}
	return s.Location
}

func (s *ScheduledInterview) GetStartAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.StartAt
}

func (s *ScheduledInterview) GetEndAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.EndAt
}

func (s *ScheduledInterview) GetRemoteCreatedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.RemoteCreatedAt
}

func (s *ScheduledInterview) GetRemoteUpdatedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.RemoteUpdatedAt
}

func (s *ScheduledInterview) GetStatus() *ScheduledInterviewStatusEnum {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *ScheduledInterview) GetRemoteWasDeleted() *bool {
	if s == nil {
		return nil
	}
	return s.RemoteWasDeleted
}

func (s *ScheduledInterview) GetFieldMappings() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.FieldMappings
}

func (s *ScheduledInterview) GetRemoteData() []*RemoteData {
	if s == nil {
		return nil
	}
	return s.RemoteData
}

func (s *ScheduledInterview) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduledInterview) UnmarshalJSON(data []byte) error {
	type embed ScheduledInterview
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		StartAt         *internal.DateTime `json:"start_at,omitempty"`
		EndAt           *internal.DateTime `json:"end_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ScheduledInterview(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	s.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	s.StartAt = unmarshaler.StartAt.TimePtr()
	s.EndAt = unmarshaler.EndAt.TimePtr()
	s.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	s.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduledInterview) MarshalJSON() ([]byte, error) {
	type embed ScheduledInterview
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		StartAt         *internal.DateTime `json:"start_at,omitempty"`
		EndAt           *internal.DateTime `json:"end_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*s),
		CreatedAt:       internal.NewOptionalDateTime(s.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(s.ModifiedAt),
		StartAt:         internal.NewOptionalDateTime(s.StartAt),
		EndAt:           internal.NewOptionalDateTime(s.EndAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(s.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(s.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *ScheduledInterview) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The application being interviewed.
type ScheduledInterviewApplication struct {
	String      string
	Application *Application

	typ string
}

func (s *ScheduledInterviewApplication) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *ScheduledInterviewApplication) GetApplication() *Application {
	if s == nil {
		return nil
	}
	return s.Application
}

func (s *ScheduledInterviewApplication) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		s.typ = "Application"
		s.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewApplication) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Application" || s.Application != nil {
		return json.Marshal(s.Application)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScheduledInterviewApplicationVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (s *ScheduledInterviewApplication) Accept(visitor ScheduledInterviewApplicationVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Application" || s.Application != nil {
		return visitor.VisitApplication(s.Application)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScheduledInterviewInterviewersItem struct {
	String     string
	RemoteUser *RemoteUser

	typ string
}

func (s *ScheduledInterviewInterviewersItem) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *ScheduledInterviewInterviewersItem) GetRemoteUser() *RemoteUser {
	if s == nil {
		return nil
	}
	return s.RemoteUser
}

func (s *ScheduledInterviewInterviewersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		s.typ = "RemoteUser"
		s.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewInterviewersItem) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "RemoteUser" || s.RemoteUser != nil {
		return json.Marshal(s.RemoteUser)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScheduledInterviewInterviewersItemVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (s *ScheduledInterviewInterviewersItem) Accept(visitor ScheduledInterviewInterviewersItemVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "RemoteUser" || s.RemoteUser != nil {
		return visitor.VisitRemoteUser(s.RemoteUser)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// The stage of the interview.
type ScheduledInterviewJobInterviewStage struct {
	String            string
	JobInterviewStage *JobInterviewStage

	typ string
}

func (s *ScheduledInterviewJobInterviewStage) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *ScheduledInterviewJobInterviewStage) GetJobInterviewStage() *JobInterviewStage {
	if s == nil {
		return nil
	}
	return s.JobInterviewStage
}

func (s *ScheduledInterviewJobInterviewStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	valueJobInterviewStage := new(JobInterviewStage)
	if err := json.Unmarshal(data, &valueJobInterviewStage); err == nil {
		s.typ = "JobInterviewStage"
		s.JobInterviewStage = valueJobInterviewStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewJobInterviewStage) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "JobInterviewStage" || s.JobInterviewStage != nil {
		return json.Marshal(s.JobInterviewStage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScheduledInterviewJobInterviewStageVisitor interface {
	VisitString(string) error
	VisitJobInterviewStage(*JobInterviewStage) error
}

func (s *ScheduledInterviewJobInterviewStage) Accept(visitor ScheduledInterviewJobInterviewStageVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "JobInterviewStage" || s.JobInterviewStage != nil {
		return visitor.VisitJobInterviewStage(s.JobInterviewStage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// The user organizing the interview.
type ScheduledInterviewOrganizer struct {
	String     string
	RemoteUser *RemoteUser

	typ string
}

func (s *ScheduledInterviewOrganizer) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *ScheduledInterviewOrganizer) GetRemoteUser() *RemoteUser {
	if s == nil {
		return nil
	}
	return s.RemoteUser
}

func (s *ScheduledInterviewOrganizer) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		s.typ = "RemoteUser"
		s.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewOrganizer) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "RemoteUser" || s.RemoteUser != nil {
		return json.Marshal(s.RemoteUser)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScheduledInterviewOrganizerVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (s *ScheduledInterviewOrganizer) Accept(visitor ScheduledInterviewOrganizerVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "RemoteUser" || s.RemoteUser != nil {
		return visitor.VisitRemoteUser(s.RemoteUser)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// * `SCHEDULED` - SCHEDULED
// * `AWAITING_FEEDBACK` - AWAITING_FEEDBACK
// * `COMPLETE` - COMPLETE
type ScheduledInterviewStatusEnum string

const (
	ScheduledInterviewStatusEnumScheduled        ScheduledInterviewStatusEnum = "SCHEDULED"
	ScheduledInterviewStatusEnumAwaitingFeedback ScheduledInterviewStatusEnum = "AWAITING_FEEDBACK"
	ScheduledInterviewStatusEnumComplete         ScheduledInterviewStatusEnum = "COMPLETE"
)

func NewScheduledInterviewStatusEnumFromString(s string) (ScheduledInterviewStatusEnum, error) {
	switch s {
	case "SCHEDULED":
		return ScheduledInterviewStatusEnumScheduled, nil
	case "AWAITING_FEEDBACK":
		return ScheduledInterviewStatusEnumAwaitingFeedback, nil
	case "COMPLETE":
		return ScheduledInterviewStatusEnumComplete, nil
	}
	var t ScheduledInterviewStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduledInterviewStatusEnum) Ptr() *ScheduledInterviewStatusEnum {
	return &s
}

// # The ScreeningQuestion Object
// ### Description
// The `ScreeningQuestion` object is used to represent questions asked to screen candidates for a job.
//
// ### Usage Example
// TODO
type ScreeningQuestion struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The job associated with the screening question.
	Job *ScreeningQuestionJob `json:"job,omitempty" url:"job,omitempty"`
	// The description of the screening question
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The title of the screening question
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// The data type for the screening question.
	//
	// * `DATE` - DATE
	// * `FILE` - FILE
	// * `SINGLE_SELECT` - SINGLE_SELECT
	// * `MULTI_SELECT` - MULTI_SELECT
	// * `SINGLE_LINE_TEXT` - SINGLE_LINE_TEXT
	// * `MULTI_LINE_TEXT` - MULTI_LINE_TEXT
	// * `NUMERIC` - NUMERIC
	// * `BOOLEAN` - BOOLEAN
	Type *ScreeningQuestionTypeEnum `json:"type,omitempty" url:"type,omitempty"`
	// Whether or not the screening question is required.
	Required *bool         `json:"required,omitempty" url:"required,omitempty"`
	Options  []interface{} `json:"options,omitempty" url:"options,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScreeningQuestion) GetId() *string {
	if s == nil {
		return nil
	}
	return s.Id
}

func (s *ScreeningQuestion) GetRemoteId() *string {
	if s == nil {
		return nil
	}
	return s.RemoteId
}

func (s *ScreeningQuestion) GetCreatedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *ScreeningQuestion) GetModifiedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ModifiedAt
}

func (s *ScreeningQuestion) GetJob() *ScreeningQuestionJob {
	if s == nil {
		return nil
	}
	return s.Job
}

func (s *ScreeningQuestion) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *ScreeningQuestion) GetTitle() *string {
	if s == nil {
		return nil
	}
	return s.Title
}

func (s *ScreeningQuestion) GetType() *ScreeningQuestionTypeEnum {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *ScreeningQuestion) GetRequired() *bool {
	if s == nil {
		return nil
	}
	return s.Required
}

func (s *ScreeningQuestion) GetOptions() []interface{} {
	if s == nil {
		return nil
	}
	return s.Options
}

func (s *ScreeningQuestion) GetRemoteWasDeleted() *bool {
	if s == nil {
		return nil
	}
	return s.RemoteWasDeleted
}

func (s *ScreeningQuestion) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScreeningQuestion) UnmarshalJSON(data []byte) error {
	type embed ScreeningQuestion
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ScreeningQuestion(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	s.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScreeningQuestion) MarshalJSON() ([]byte, error) {
	type embed ScreeningQuestion
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*s),
		CreatedAt:  internal.NewOptionalDateTime(s.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(s.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (s *ScreeningQuestion) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// # The ScreeningQuestionAnswer Object
// ### Description
// The `ScreeningQuestionAnswer` object is used to represent candidate responses to a screening question, for a specific application.
//
// ### Usage Example
// TODO
type ScreeningQuestionAnswer struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The screening question associated with the candidates answer. To determine the data type of the answer, you can expand on the screening question by adding `screening_question_answers.question` to the `expand` query parameter.
	Question *ScreeningQuestionAnswerQuestion `json:"question,omitempty" url:"question,omitempty"`
	// The candidates response to the screening question.
	Answer *string `json:"answer,omitempty" url:"answer,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScreeningQuestionAnswer) GetId() *string {
	if s == nil {
		return nil
	}
	return s.Id
}

func (s *ScreeningQuestionAnswer) GetRemoteId() *string {
	if s == nil {
		return nil
	}
	return s.RemoteId
}

func (s *ScreeningQuestionAnswer) GetCreatedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *ScreeningQuestionAnswer) GetModifiedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ModifiedAt
}

func (s *ScreeningQuestionAnswer) GetQuestion() *ScreeningQuestionAnswerQuestion {
	if s == nil {
		return nil
	}
	return s.Question
}

func (s *ScreeningQuestionAnswer) GetAnswer() *string {
	if s == nil {
		return nil
	}
	return s.Answer
}

func (s *ScreeningQuestionAnswer) GetRemoteWasDeleted() *bool {
	if s == nil {
		return nil
	}
	return s.RemoteWasDeleted
}

func (s *ScreeningQuestionAnswer) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScreeningQuestionAnswer) UnmarshalJSON(data []byte) error {
	type embed ScreeningQuestionAnswer
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ScreeningQuestionAnswer(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	s.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScreeningQuestionAnswer) MarshalJSON() ([]byte, error) {
	type embed ScreeningQuestionAnswer
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*s),
		CreatedAt:  internal.NewOptionalDateTime(s.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(s.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (s *ScreeningQuestionAnswer) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The screening question associated with the candidates answer. To determine the data type of the answer, you can expand on the screening question by adding `screening_question_answers.question` to the `expand` query parameter.
type ScreeningQuestionAnswerQuestion struct {
	String            string
	ScreeningQuestion *ScreeningQuestion

	typ string
}

func (s *ScreeningQuestionAnswerQuestion) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *ScreeningQuestionAnswerQuestion) GetScreeningQuestion() *ScreeningQuestion {
	if s == nil {
		return nil
	}
	return s.ScreeningQuestion
}

func (s *ScreeningQuestionAnswerQuestion) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	valueScreeningQuestion := new(ScreeningQuestion)
	if err := json.Unmarshal(data, &valueScreeningQuestion); err == nil {
		s.typ = "ScreeningQuestion"
		s.ScreeningQuestion = valueScreeningQuestion
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScreeningQuestionAnswerQuestion) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "ScreeningQuestion" || s.ScreeningQuestion != nil {
		return json.Marshal(s.ScreeningQuestion)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScreeningQuestionAnswerQuestionVisitor interface {
	VisitString(string) error
	VisitScreeningQuestion(*ScreeningQuestion) error
}

func (s *ScreeningQuestionAnswerQuestion) Accept(visitor ScreeningQuestionAnswerQuestionVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "ScreeningQuestion" || s.ScreeningQuestion != nil {
		return visitor.VisitScreeningQuestion(s.ScreeningQuestion)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// The job associated with the screening question.
type ScreeningQuestionJob struct {
	String string
	Job    *Job

	typ string
}

func (s *ScreeningQuestionJob) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *ScreeningQuestionJob) GetJob() *Job {
	if s == nil {
		return nil
	}
	return s.Job
}

func (s *ScreeningQuestionJob) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	valueJob := new(Job)
	if err := json.Unmarshal(data, &valueJob); err == nil {
		s.typ = "Job"
		s.Job = valueJob
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScreeningQuestionJob) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Job" || s.Job != nil {
		return json.Marshal(s.Job)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScreeningQuestionJobVisitor interface {
	VisitString(string) error
	VisitJob(*Job) error
}

func (s *ScreeningQuestionJob) Accept(visitor ScreeningQuestionJobVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Job" || s.Job != nil {
		return visitor.VisitJob(s.Job)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// # The ScreeningQuestionOption Object
// ### Description
// The `ScreeningQuestionOption` object is used to represent options for a `ScreeningQuestion` object
//
// ### Usage Example
// TODO
type ScreeningQuestionOption struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// Available response options
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScreeningQuestionOption) GetId() *string {
	if s == nil {
		return nil
	}
	return s.Id
}

func (s *ScreeningQuestionOption) GetRemoteId() *string {
	if s == nil {
		return nil
	}
	return s.RemoteId
}

func (s *ScreeningQuestionOption) GetCreatedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *ScreeningQuestionOption) GetModifiedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ModifiedAt
}

func (s *ScreeningQuestionOption) GetLabel() *string {
	if s == nil {
		return nil
	}
	return s.Label
}

func (s *ScreeningQuestionOption) GetRemoteWasDeleted() *bool {
	if s == nil {
		return nil
	}
	return s.RemoteWasDeleted
}

func (s *ScreeningQuestionOption) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScreeningQuestionOption) UnmarshalJSON(data []byte) error {
	type embed ScreeningQuestionOption
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ScreeningQuestionOption(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	s.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScreeningQuestionOption) MarshalJSON() ([]byte, error) {
	type embed ScreeningQuestionOption
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*s),
		CreatedAt:  internal.NewOptionalDateTime(s.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(s.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (s *ScreeningQuestionOption) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// * `DATE` - DATE
// * `FILE` - FILE
// * `SINGLE_SELECT` - SINGLE_SELECT
// * `MULTI_SELECT` - MULTI_SELECT
// * `SINGLE_LINE_TEXT` - SINGLE_LINE_TEXT
// * `MULTI_LINE_TEXT` - MULTI_LINE_TEXT
// * `NUMERIC` - NUMERIC
// * `BOOLEAN` - BOOLEAN
type ScreeningQuestionTypeEnum string

const (
	ScreeningQuestionTypeEnumDate           ScreeningQuestionTypeEnum = "DATE"
	ScreeningQuestionTypeEnumFile           ScreeningQuestionTypeEnum = "FILE"
	ScreeningQuestionTypeEnumSingleSelect   ScreeningQuestionTypeEnum = "SINGLE_SELECT"
	ScreeningQuestionTypeEnumMultiSelect    ScreeningQuestionTypeEnum = "MULTI_SELECT"
	ScreeningQuestionTypeEnumSingleLineText ScreeningQuestionTypeEnum = "SINGLE_LINE_TEXT"
	ScreeningQuestionTypeEnumMultiLineText  ScreeningQuestionTypeEnum = "MULTI_LINE_TEXT"
	ScreeningQuestionTypeEnumNumeric        ScreeningQuestionTypeEnum = "NUMERIC"
	ScreeningQuestionTypeEnumBoolean        ScreeningQuestionTypeEnum = "BOOLEAN"
)

func NewScreeningQuestionTypeEnumFromString(s string) (ScreeningQuestionTypeEnum, error) {
	switch s {
	case "DATE":
		return ScreeningQuestionTypeEnumDate, nil
	case "FILE":
		return ScreeningQuestionTypeEnumFile, nil
	case "SINGLE_SELECT":
		return ScreeningQuestionTypeEnumSingleSelect, nil
	case "MULTI_SELECT":
		return ScreeningQuestionTypeEnumMultiSelect, nil
	case "SINGLE_LINE_TEXT":
		return ScreeningQuestionTypeEnumSingleLineText, nil
	case "MULTI_LINE_TEXT":
		return ScreeningQuestionTypeEnumMultiLineText, nil
	case "NUMERIC":
		return ScreeningQuestionTypeEnumNumeric, nil
	case "BOOLEAN":
		return ScreeningQuestionTypeEnumBoolean, nil
	}
	var t ScreeningQuestionTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScreeningQuestionTypeEnum) Ptr() *ScreeningQuestionTypeEnum {
	return &s
}

// * `IN_NEXT_SYNC` - IN_NEXT_SYNC
// * `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum string

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = "IN_NEXT_SYNC"
	SelectiveSyncConfigurationsUsageEnumInLastSync SelectiveSyncConfigurationsUsageEnum = "IN_LAST_SYNC"
)

func NewSelectiveSyncConfigurationsUsageEnumFromString(s string) (SelectiveSyncConfigurationsUsageEnum, error) {
	switch s {
	case "IN_NEXT_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInNextSync, nil
	case "IN_LAST_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInLastSync, nil
	}
	var t SelectiveSyncConfigurationsUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SelectiveSyncConfigurationsUsageEnum) Ptr() *SelectiveSyncConfigurationsUsageEnum {
	return &s
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type StatusFd5Enum string

const (
	StatusFd5EnumSyncing         StatusFd5Enum = "SYNCING"
	StatusFd5EnumDone            StatusFd5Enum = "DONE"
	StatusFd5EnumFailed          StatusFd5Enum = "FAILED"
	StatusFd5EnumDisabled        StatusFd5Enum = "DISABLED"
	StatusFd5EnumPaused          StatusFd5Enum = "PAUSED"
	StatusFd5EnumPartiallySynced StatusFd5Enum = "PARTIALLY_SYNCED"
)

func NewStatusFd5EnumFromString(s string) (StatusFd5Enum, error) {
	switch s {
	case "SYNCING":
		return StatusFd5EnumSyncing, nil
	case "DONE":
		return StatusFd5EnumDone, nil
	case "FAILED":
		return StatusFd5EnumFailed, nil
	case "DISABLED":
		return StatusFd5EnumDisabled, nil
	case "PAUSED":
		return StatusFd5EnumPaused, nil
	case "PARTIALLY_SYNCED":
		return StatusFd5EnumPartiallySynced, nil
	}
	var t StatusFd5Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusFd5Enum) Ptr() *StatusFd5Enum {
	return &s
}

// # The SyncStatus Object
// ### Description
// The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name" url:"model_name"`
	ModelId                          string                                `json:"model_id" url:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty" url:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty" url:"next_sync_start,omitempty"`
	LastSyncResult                   *LastSyncResultEnum                   `json:"last_sync_result,omitempty" url:"last_sync_result,omitempty"`
	LastSyncFinished                 *time.Time                            `json:"last_sync_finished,omitempty" url:"last_sync_finished,omitempty"`
	Status                           StatusFd5Enum                         `json:"status" url:"status"`
	IsInitialSync                    bool                                  `json:"is_initial_sync" url:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty" url:"selective_sync_configurations_usage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncStatus) GetModelName() string {
	if s == nil {
		return ""
	}
	return s.ModelName
}

func (s *SyncStatus) GetModelId() string {
	if s == nil {
		return ""
	}
	return s.ModelId
}

func (s *SyncStatus) GetLastSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncStart
}

func (s *SyncStatus) GetNextSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.NextSyncStart
}

func (s *SyncStatus) GetLastSyncResult() *LastSyncResultEnum {
	if s == nil {
		return nil
	}
	return s.LastSyncResult
}

func (s *SyncStatus) GetLastSyncFinished() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncFinished
}

func (s *SyncStatus) GetStatus() StatusFd5Enum {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SyncStatus) GetIsInitialSync() bool {
	if s == nil {
		return false
	}
	return s.IsInitialSync
}

func (s *SyncStatus) GetSelectiveSyncConfigurationsUsage() *SelectiveSyncConfigurationsUsageEnum {
	if s == nil {
		return nil
	}
	return s.SelectiveSyncConfigurationsUsage
}

func (s *SyncStatus) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncStatus) UnmarshalJSON(data []byte) error {
	type embed SyncStatus
	var unmarshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SyncStatus(unmarshaler.embed)
	s.LastSyncStart = unmarshaler.LastSyncStart.TimePtr()
	s.NextSyncStart = unmarshaler.NextSyncStart.TimePtr()
	s.LastSyncFinished = unmarshaler.LastSyncFinished.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatus) MarshalJSON() ([]byte, error) {
	type embed SyncStatus
	var marshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed:            embed(*s),
		LastSyncStart:    internal.NewOptionalDateTime(s.LastSyncStart),
		NextSyncStart:    internal.NewOptionalDateTime(s.NextSyncStart),
		LastSyncFinished: internal.NewOptionalDateTime(s.LastSyncFinished),
	}
	return json.Marshal(marshaler)
}

func (s *SyncStatus) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// # The Url Object
// ### Description
// The `Url` object is used to represent hyperlinks associated with the parent model.
// ### Usage Example
// Fetch from the `GET Candidate` endpoint and view their website urls.
type Url struct {
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The site's url.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// The type of site.
	//
	// * `PERSONAL` - PERSONAL
	// * `COMPANY` - COMPANY
	// * `PORTFOLIO` - PORTFOLIO
	// * `BLOG` - BLOG
	// * `SOCIAL_MEDIA` - SOCIAL_MEDIA
	// * `OTHER` - OTHER
	// * `JOB_POSTING` - JOB_POSTING
	UrlType *UrlTypeEnum `json:"url_type,omitempty" url:"url_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *Url) GetCreatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *Url) GetModifiedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.ModifiedAt
}

func (u *Url) GetValue() *string {
	if u == nil {
		return nil
	}
	return u.Value
}

func (u *Url) GetUrlType() *UrlTypeEnum {
	if u == nil {
		return nil
	}
	return u.UrlType
}

func (u *Url) GetRemoteWasDeleted() *bool {
	if u == nil {
		return nil
	}
	return u.RemoteWasDeleted
}

func (u *Url) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Url) UnmarshalJSON(data []byte) error {
	type embed Url
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = Url(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	u.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *Url) MarshalJSON() ([]byte, error) {
	type embed Url
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*u),
		CreatedAt:  internal.NewOptionalDateTime(u.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(u.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (u *Url) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// * `PERSONAL` - PERSONAL
// * `COMPANY` - COMPANY
// * `PORTFOLIO` - PORTFOLIO
// * `BLOG` - BLOG
// * `SOCIAL_MEDIA` - SOCIAL_MEDIA
// * `OTHER` - OTHER
// * `JOB_POSTING` - JOB_POSTING
type UrlTypeEnum string

const (
	UrlTypeEnumPersonal    UrlTypeEnum = "PERSONAL"
	UrlTypeEnumCompany     UrlTypeEnum = "COMPANY"
	UrlTypeEnumPortfolio   UrlTypeEnum = "PORTFOLIO"
	UrlTypeEnumBlog        UrlTypeEnum = "BLOG"
	UrlTypeEnumSocialMedia UrlTypeEnum = "SOCIAL_MEDIA"
	UrlTypeEnumOther       UrlTypeEnum = "OTHER"
	UrlTypeEnumJobPosting  UrlTypeEnum = "JOB_POSTING"
)

func NewUrlTypeEnumFromString(s string) (UrlTypeEnum, error) {
	switch s {
	case "PERSONAL":
		return UrlTypeEnumPersonal, nil
	case "COMPANY":
		return UrlTypeEnumCompany, nil
	case "PORTFOLIO":
		return UrlTypeEnumPortfolio, nil
	case "BLOG":
		return UrlTypeEnumBlog, nil
	case "SOCIAL_MEDIA":
		return UrlTypeEnumSocialMedia, nil
	case "OTHER":
		return UrlTypeEnumOther, nil
	case "JOB_POSTING":
		return UrlTypeEnumJobPosting, nil
	}
	var t UrlTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UrlTypeEnum) Ptr() *UrlTypeEnum {
	return &u
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer" url:"pointer"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValidationProblemSource) GetPointer() string {
	if v == nil {
		return ""
	}
	return v.Pointer
}

func (v *ValidationProblemSource) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationProblemSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationProblemSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationProblemSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationProblemSource) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WarningValidationProblem) GetSource() *ValidationProblemSource {
	if w == nil {
		return nil
	}
	return w.Source
}

func (w *WarningValidationProblem) GetTitle() string {
	if w == nil {
		return ""
	}
	return w.Title
}

func (w *WarningValidationProblem) GetDetail() string {
	if w == nil {
		return ""
	}
	return w.Detail
}

func (w *WarningValidationProblem) GetProblemType() string {
	if w == nil {
		return ""
	}
	return w.ProblemType
}

func (w *WarningValidationProblem) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WarningValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler WarningValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WarningValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WarningValidationProblem) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
