// This file was auto-generated by Fern from our API Definition.

package ats

import (
	json "encoding/json"
	fmt "fmt"
	strconv "strconv"
	time "time"
)

// - `SUPER_ADMIN` - SUPER_ADMIN
// - `ADMIN` - ADMIN
// - `TEAM_MEMBER` - TEAM_MEMBER
// - `LIMITED_TEAM_MEMBER` - LIMITED_TEAM_MEMBER
// - `INTERVIEWER` - INTERVIEWER
type AccessRoleEnum uint

const (
	AccessRoleEnumSuperAdmin AccessRoleEnum = iota + 1
	AccessRoleEnumAdmin
	AccessRoleEnumTeamMember
	AccessRoleEnumLimitedTeamMember
	AccessRoleEnumInterviewer
)

func (a AccessRoleEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AccessRoleEnumSuperAdmin:
		return "SUPER_ADMIN"
	case AccessRoleEnumAdmin:
		return "ADMIN"
	case AccessRoleEnumTeamMember:
		return "TEAM_MEMBER"
	case AccessRoleEnumLimitedTeamMember:
		return "LIMITED_TEAM_MEMBER"
	case AccessRoleEnumInterviewer:
		return "INTERVIEWER"
	}
}

func (a AccessRoleEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AccessRoleEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SUPER_ADMIN":
		value := AccessRoleEnumSuperAdmin
		*a = value
	case "ADMIN":
		value := AccessRoleEnumAdmin
		*a = value
	case "TEAM_MEMBER":
		value := AccessRoleEnumTeamMember
		*a = value
	case "LIMITED_TEAM_MEMBER":
		value := AccessRoleEnumLimitedTeamMember
		*a = value
	case "INTERVIEWER":
		value := AccessRoleEnumInterviewer
		*a = value
	}
	return nil
}

type AccountDetails struct {
	Id                      *string       `json:"id,omitempty"`
	Integration             *string       `json:"integration,omitempty"`
	IntegrationSlug         *string       `json:"integration_slug,omitempty"`
	Category                *CategoryEnum `json:"category,omitempty"`
	EndUserOriginId         *string       `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName *string       `json:"end_user_organization_name,omitempty"`
	EndUserEmailAddress     *string       `json:"end_user_email_address,omitempty"`
	Status                  *string       `json:"status,omitempty"`
	WebhookListenerUrl      *string       `json:"webhook_listener_url,omitempty"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool   `json:"is_duplicate,omitempty"`
	AccountType *string `json:"account_type,omitempty"`
}

// # The LinkedAccount Object
//
// ### Description
//
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
//
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                             `json:"id"`
	Category                *CategoryEnum                      `json:"category,omitempty"`
	Status                  AccountDetailsAndActionsStatusEnum `json:"status,omitempty"`
	StatusDetail            *string                            `json:"status_detail,omitempty"`
	EndUserOriginId         *string                            `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                             `json:"end_user_organization_name"`
	EndUserEmailAddress     string                             `json:"end_user_email_address"`
	WebhookListenerUrl      string                             `json:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty"`
	AccountType string                               `json:"account_type"`
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name"`
	Categories               []CategoriesEnum  `json:"categories,omitempty"`
	Image                    *string           `json:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty"`
	Color                    string            `json:"color"`
	Slug                     string            `json:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty"`
}

// - `COMPLETE` - COMPLETE
// - `INCOMPLETE` - INCOMPLETE
// - `RELINK_NEEDED` - RELINK_NEEDED
type AccountDetailsAndActionsStatusEnum uint

const (
	AccountDetailsAndActionsStatusEnumComplete AccountDetailsAndActionsStatusEnum = iota + 1
	AccountDetailsAndActionsStatusEnumIncomplete
	AccountDetailsAndActionsStatusEnumRelinkNeeded
)

func (a AccountDetailsAndActionsStatusEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AccountDetailsAndActionsStatusEnumComplete:
		return "COMPLETE"
	case AccountDetailsAndActionsStatusEnumIncomplete:
		return "INCOMPLETE"
	case AccountDetailsAndActionsStatusEnumRelinkNeeded:
		return "RELINK_NEEDED"
	}
}

func (a AccountDetailsAndActionsStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AccountDetailsAndActionsStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "COMPLETE":
		value := AccountDetailsAndActionsStatusEnumComplete
		*a = value
	case "INCOMPLETE":
		value := AccountDetailsAndActionsStatusEnumIncomplete
		*a = value
	case "RELINK_NEEDED":
		value := AccountDetailsAndActionsStatusEnumRelinkNeeded
		*a = value
	}
	return nil
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty"`
	// Company logo in rectangular shape. <b>Upload an image with a clear background.</b>
	Image *string `json:"image,omitempty"`
	// Company logo in square shape. <b>Upload an image with a white background.</b>
	SquareImage *string `json:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	// If checked, this integration will not appear in the linking flow, and will appear elsewhere with a Beta tag.
	IsInBeta *bool `json:"is_in_beta,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]any `json:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty"`
}

type AccountToken struct {
	AccountToken string              `json:"account_token"`
	Integration  *AccountIntegration `json:"integration,omitempty"`
}

// # The Activity Object
//
// ### Description
//
// The `Activity` object is used to represent an activity for a candidate performed by a user.
//
// ### Usage Example
//
// Fetch from the `LIST Activities` endpoint and filter by `ID` to show all activities.
type Activity struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user that performed the action.
	User *ActivityUser `json:"user,omitempty"`
	// When the third party's activity was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The activity's type.
	//
	// - `NOTE` - NOTE
	// - `EMAIL` - EMAIL
	// - `OTHER` - OTHER
	ActivityType *ActivityActivityType `json:"activity_type,omitempty"`
	// The activity's subject.
	Subject *string `json:"subject,omitempty"`
	// The activity's body.
	Body *string `json:"body,omitempty"`
	// The activity's visibility.
	//
	// - `ADMIN_ONLY` - ADMIN_ONLY
	// - `PUBLIC` - PUBLIC
	// - `PRIVATE` - PRIVATE
	Visibility *ActivityVisibility `json:"visibility,omitempty"`
	// The activity’s candidate.
	Candidate *string `json:"candidate,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The activity's type.
//
// - `NOTE` - NOTE
// - `EMAIL` - EMAIL
// - `OTHER` - OTHER
type ActivityActivityType struct {
	typeName         string
	ActivityTypeEnum ActivityTypeEnum
	String           string
}

func NewActivityActivityTypeFromActivityTypeEnum(value ActivityTypeEnum) *ActivityActivityType {
	return &ActivityActivityType{typeName: "activityTypeEnum", ActivityTypeEnum: value}
}

func NewActivityActivityTypeFromString(value string) *ActivityActivityType {
	return &ActivityActivityType{typeName: "string", String: value}
}

func (a *ActivityActivityType) UnmarshalJSON(data []byte) error {
	var valueActivityTypeEnum ActivityTypeEnum
	if err := json.Unmarshal(data, &valueActivityTypeEnum); err == nil {
		a.typeName = "activityTypeEnum"
		a.ActivityTypeEnum = valueActivityTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActivityActivityType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "activityTypeEnum":
		return json.Marshal(a.ActivityTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type ActivityActivityTypeVisitor interface {
	VisitActivityTypeEnum(ActivityTypeEnum) error
	VisitString(string) error
}

func (a *ActivityActivityType) Accept(visitor ActivityActivityTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "activityTypeEnum":
		return visitor.VisitActivityTypeEnum(a.ActivityTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The Activity Object
//
// ### Description
//
// The `Activity` object is used to represent an activity for a candidate performed by a user.
//
// ### Usage Example
//
// Fetch from the `LIST Activities` endpoint and filter by `ID` to show all activities.
type ActivityRequest struct {
	// The user that performed the action.
	User *ActivityRequestUser `json:"user,omitempty"`
	// The activity's type.
	//
	// - `NOTE` - NOTE
	// - `EMAIL` - EMAIL
	// - `OTHER` - OTHER
	ActivityType *ActivityRequestActivityType `json:"activity_type,omitempty"`
	// The activity's subject.
	Subject *string `json:"subject,omitempty"`
	// The activity's body.
	Body *string `json:"body,omitempty"`
	// The activity's visibility.
	//
	// - `ADMIN_ONLY` - ADMIN_ONLY
	// - `PUBLIC` - PUBLIC
	// - `PRIVATE` - PRIVATE
	Visibility *ActivityRequestVisibility `json:"visibility,omitempty"`
	// The activity’s candidate.
	Candidate           *string        `json:"candidate,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

// The activity's type.
//
// - `NOTE` - NOTE
// - `EMAIL` - EMAIL
// - `OTHER` - OTHER
type ActivityRequestActivityType struct {
	typeName         string
	ActivityTypeEnum ActivityTypeEnum
	String           string
}

func NewActivityRequestActivityTypeFromActivityTypeEnum(value ActivityTypeEnum) *ActivityRequestActivityType {
	return &ActivityRequestActivityType{typeName: "activityTypeEnum", ActivityTypeEnum: value}
}

func NewActivityRequestActivityTypeFromString(value string) *ActivityRequestActivityType {
	return &ActivityRequestActivityType{typeName: "string", String: value}
}

func (a *ActivityRequestActivityType) UnmarshalJSON(data []byte) error {
	var valueActivityTypeEnum ActivityTypeEnum
	if err := json.Unmarshal(data, &valueActivityTypeEnum); err == nil {
		a.typeName = "activityTypeEnum"
		a.ActivityTypeEnum = valueActivityTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActivityRequestActivityType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "activityTypeEnum":
		return json.Marshal(a.ActivityTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type ActivityRequestActivityTypeVisitor interface {
	VisitActivityTypeEnum(ActivityTypeEnum) error
	VisitString(string) error
}

func (a *ActivityRequestActivityType) Accept(visitor ActivityRequestActivityTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "activityTypeEnum":
		return visitor.VisitActivityTypeEnum(a.ActivityTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The user that performed the action.
type ActivityRequestUser struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewActivityRequestUserFromString(value string) *ActivityRequestUser {
	return &ActivityRequestUser{typeName: "string", String: value}
}

func NewActivityRequestUserFromRemoteUser(value *RemoteUser) *ActivityRequestUser {
	return &ActivityRequestUser{typeName: "remoteUser", RemoteUser: value}
}

func (a *ActivityRequestUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		a.typeName = "remoteUser"
		a.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActivityRequestUser) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "remoteUser":
		return json.Marshal(a.RemoteUser)
	}
}

type ActivityRequestUserVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (a *ActivityRequestUser) Accept(visitor ActivityRequestUserVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(a.RemoteUser)
	}
}

// The activity's visibility.
//
// - `ADMIN_ONLY` - ADMIN_ONLY
// - `PUBLIC` - PUBLIC
// - `PRIVATE` - PRIVATE
type ActivityRequestVisibility struct {
	typeName       string
	VisibilityEnum VisibilityEnum
	String         string
}

func NewActivityRequestVisibilityFromVisibilityEnum(value VisibilityEnum) *ActivityRequestVisibility {
	return &ActivityRequestVisibility{typeName: "visibilityEnum", VisibilityEnum: value}
}

func NewActivityRequestVisibilityFromString(value string) *ActivityRequestVisibility {
	return &ActivityRequestVisibility{typeName: "string", String: value}
}

func (a *ActivityRequestVisibility) UnmarshalJSON(data []byte) error {
	var valueVisibilityEnum VisibilityEnum
	if err := json.Unmarshal(data, &valueVisibilityEnum); err == nil {
		a.typeName = "visibilityEnum"
		a.VisibilityEnum = valueVisibilityEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActivityRequestVisibility) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "visibilityEnum":
		return json.Marshal(a.VisibilityEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type ActivityRequestVisibilityVisitor interface {
	VisitVisibilityEnum(VisibilityEnum) error
	VisitString(string) error
}

func (a *ActivityRequestVisibility) Accept(visitor ActivityRequestVisibilityVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "visibilityEnum":
		return visitor.VisitVisibilityEnum(a.VisibilityEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

type ActivityResponse struct {
	Model    *Activity                   `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// - `NOTE` - NOTE
// - `EMAIL` - EMAIL
// - `OTHER` - OTHER
type ActivityTypeEnum uint

const (
	ActivityTypeEnumNote ActivityTypeEnum = iota + 1
	ActivityTypeEnumEmail
	ActivityTypeEnumOther
)

func (a ActivityTypeEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case ActivityTypeEnumNote:
		return "NOTE"
	case ActivityTypeEnumEmail:
		return "EMAIL"
	case ActivityTypeEnumOther:
		return "OTHER"
	}
}

func (a ActivityTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *ActivityTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "NOTE":
		value := ActivityTypeEnumNote
		*a = value
	case "EMAIL":
		value := ActivityTypeEnumEmail
		*a = value
	case "OTHER":
		value := ActivityTypeEnumOther
		*a = value
	}
	return nil
}

// The user that performed the action.
type ActivityUser struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewActivityUserFromString(value string) *ActivityUser {
	return &ActivityUser{typeName: "string", String: value}
}

func NewActivityUserFromRemoteUser(value *RemoteUser) *ActivityUser {
	return &ActivityUser{typeName: "remoteUser", RemoteUser: value}
}

func (a *ActivityUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		a.typeName = "remoteUser"
		a.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActivityUser) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "remoteUser":
		return json.Marshal(a.RemoteUser)
	}
}

type ActivityUserVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (a *ActivityUser) Accept(visitor ActivityUserVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(a.RemoteUser)
	}
}

// The activity's visibility.
//
// - `ADMIN_ONLY` - ADMIN_ONLY
// - `PUBLIC` - PUBLIC
// - `PRIVATE` - PRIVATE
type ActivityVisibility struct {
	typeName       string
	VisibilityEnum VisibilityEnum
	String         string
}

func NewActivityVisibilityFromVisibilityEnum(value VisibilityEnum) *ActivityVisibility {
	return &ActivityVisibility{typeName: "visibilityEnum", VisibilityEnum: value}
}

func NewActivityVisibilityFromString(value string) *ActivityVisibility {
	return &ActivityVisibility{typeName: "string", String: value}
}

func (a *ActivityVisibility) UnmarshalJSON(data []byte) error {
	var valueVisibilityEnum VisibilityEnum
	if err := json.Unmarshal(data, &valueVisibilityEnum); err == nil {
		a.typeName = "visibilityEnum"
		a.VisibilityEnum = valueVisibilityEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActivityVisibility) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "visibilityEnum":
		return json.Marshal(a.VisibilityEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type ActivityVisibilityVisitor interface {
	VisitVisibilityEnum(VisibilityEnum) error
	VisitString(string) error
}

func (a *ActivityVisibility) Accept(visitor ActivityVisibilityVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "visibilityEnum":
		return visitor.VisitVisibilityEnum(a.VisibilityEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The Application Object
//
// ### Description
//
// The Application Object is used to represent a candidate's journey through a particular Job's recruiting process. If a Candidate applies for multiple Jobs, there will be a separate Application for each Job if the third-party integration allows it.
//
// ### Usage Example
//
// Fetch from the `LIST Applications` endpoint and filter by `ID` to show all applications.
type Application struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The candidate applying.
	Candidate *ApplicationCandidate `json:"candidate,omitempty"`
	// The job being applied for.
	Job *ApplicationJob `json:"job,omitempty"`
	// When the application was submitted.
	AppliedAt *time.Time `json:"applied_at,omitempty"`
	// When the application was rejected.
	RejectedAt *time.Time `json:"rejected_at,omitempty"`
	// The application's source.
	Source *string `json:"source,omitempty"`
	// The user credited for this application.
	CreditedTo *ApplicationCreditedTo `json:"credited_to,omitempty"`
	// The application's current stage.
	CurrentStage *ApplicationCurrentStage `json:"current_stage,omitempty"`
	// The application's reason for rejection.
	RejectReason     *ApplicationRejectReason `json:"reject_reason,omitempty"`
	RemoteWasDeleted *bool                    `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time               `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The candidate applying.
type ApplicationCandidate struct {
	typeName  string
	String    string
	Candidate *Candidate
}

func NewApplicationCandidateFromString(value string) *ApplicationCandidate {
	return &ApplicationCandidate{typeName: "string", String: value}
}

func NewApplicationCandidateFromCandidate(value *Candidate) *ApplicationCandidate {
	return &ApplicationCandidate{typeName: "candidate", Candidate: value}
}

func (a *ApplicationCandidate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueCandidate := new(Candidate)
	if err := json.Unmarshal(data, &valueCandidate); err == nil {
		a.typeName = "candidate"
		a.Candidate = valueCandidate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationCandidate) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "candidate":
		return json.Marshal(a.Candidate)
	}
}

type ApplicationCandidateVisitor interface {
	VisitString(string) error
	VisitCandidate(*Candidate) error
}

func (a *ApplicationCandidate) Accept(visitor ApplicationCandidateVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "candidate":
		return visitor.VisitCandidate(a.Candidate)
	}
}

// The user credited for this application.
type ApplicationCreditedTo struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewApplicationCreditedToFromString(value string) *ApplicationCreditedTo {
	return &ApplicationCreditedTo{typeName: "string", String: value}
}

func NewApplicationCreditedToFromRemoteUser(value *RemoteUser) *ApplicationCreditedTo {
	return &ApplicationCreditedTo{typeName: "remoteUser", RemoteUser: value}
}

func (a *ApplicationCreditedTo) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		a.typeName = "remoteUser"
		a.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationCreditedTo) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "remoteUser":
		return json.Marshal(a.RemoteUser)
	}
}

type ApplicationCreditedToVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (a *ApplicationCreditedTo) Accept(visitor ApplicationCreditedToVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(a.RemoteUser)
	}
}

// The application's current stage.
type ApplicationCurrentStage struct {
	typeName          string
	String            string
	JobInterviewStage *JobInterviewStage
}

func NewApplicationCurrentStageFromString(value string) *ApplicationCurrentStage {
	return &ApplicationCurrentStage{typeName: "string", String: value}
}

func NewApplicationCurrentStageFromJobInterviewStage(value *JobInterviewStage) *ApplicationCurrentStage {
	return &ApplicationCurrentStage{typeName: "jobInterviewStage", JobInterviewStage: value}
}

func (a *ApplicationCurrentStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueJobInterviewStage := new(JobInterviewStage)
	if err := json.Unmarshal(data, &valueJobInterviewStage); err == nil {
		a.typeName = "jobInterviewStage"
		a.JobInterviewStage = valueJobInterviewStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationCurrentStage) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "jobInterviewStage":
		return json.Marshal(a.JobInterviewStage)
	}
}

type ApplicationCurrentStageVisitor interface {
	VisitString(string) error
	VisitJobInterviewStage(*JobInterviewStage) error
}

func (a *ApplicationCurrentStage) Accept(visitor ApplicationCurrentStageVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "jobInterviewStage":
		return visitor.VisitJobInterviewStage(a.JobInterviewStage)
	}
}

// The job being applied for.
type ApplicationJob struct {
	typeName string
	String   string
	Job      *Job
}

func NewApplicationJobFromString(value string) *ApplicationJob {
	return &ApplicationJob{typeName: "string", String: value}
}

func NewApplicationJobFromJob(value *Job) *ApplicationJob {
	return &ApplicationJob{typeName: "job", Job: value}
}

func (a *ApplicationJob) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueJob := new(Job)
	if err := json.Unmarshal(data, &valueJob); err == nil {
		a.typeName = "job"
		a.Job = valueJob
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationJob) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "job":
		return json.Marshal(a.Job)
	}
}

type ApplicationJobVisitor interface {
	VisitString(string) error
	VisitJob(*Job) error
}

func (a *ApplicationJob) Accept(visitor ApplicationJobVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "job":
		return visitor.VisitJob(a.Job)
	}
}

// The application's reason for rejection.
type ApplicationRejectReason struct {
	typeName     string
	String       string
	RejectReason *RejectReason
}

func NewApplicationRejectReasonFromString(value string) *ApplicationRejectReason {
	return &ApplicationRejectReason{typeName: "string", String: value}
}

func NewApplicationRejectReasonFromRejectReason(value *RejectReason) *ApplicationRejectReason {
	return &ApplicationRejectReason{typeName: "rejectReason", RejectReason: value}
}

func (a *ApplicationRejectReason) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueRejectReason := new(RejectReason)
	if err := json.Unmarshal(data, &valueRejectReason); err == nil {
		a.typeName = "rejectReason"
		a.RejectReason = valueRejectReason
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRejectReason) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "rejectReason":
		return json.Marshal(a.RejectReason)
	}
}

type ApplicationRejectReasonVisitor interface {
	VisitString(string) error
	VisitRejectReason(*RejectReason) error
}

func (a *ApplicationRejectReason) Accept(visitor ApplicationRejectReasonVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "rejectReason":
		return visitor.VisitRejectReason(a.RejectReason)
	}
}

// # The Application Object
//
// ### Description
//
// The Application Object is used to represent a candidate's journey through a particular Job's recruiting process. If a Candidate applies for multiple Jobs, there will be a separate Application for each Job if the third-party integration allows it.
//
// ### Usage Example
//
// Fetch from the `LIST Applications` endpoint and filter by `ID` to show all applications.
type ApplicationRequest struct {
	// The candidate applying.
	Candidate *ApplicationRequestCandidate `json:"candidate,omitempty"`
	// The job being applied for.
	Job *ApplicationRequestJob `json:"job,omitempty"`
	// When the application was submitted.
	AppliedAt *time.Time `json:"applied_at,omitempty"`
	// When the application was rejected.
	RejectedAt *time.Time `json:"rejected_at,omitempty"`
	// The application's source.
	Source *string `json:"source,omitempty"`
	// The user credited for this application.
	CreditedTo *ApplicationRequestCreditedTo `json:"credited_to,omitempty"`
	// The application's current stage.
	CurrentStage *ApplicationRequestCurrentStage `json:"current_stage,omitempty"`
	// The application's reason for rejection.
	RejectReason        *ApplicationRequestRejectReason `json:"reject_reason,omitempty"`
	RemoteTemplateId    *string                         `json:"remote_template_id,omitempty"`
	IntegrationParams   map[string]any                  `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any                  `json:"linked_account_params,omitempty"`
}

// The candidate applying.
type ApplicationRequestCandidate struct {
	typeName  string
	String    string
	Candidate *Candidate
}

func NewApplicationRequestCandidateFromString(value string) *ApplicationRequestCandidate {
	return &ApplicationRequestCandidate{typeName: "string", String: value}
}

func NewApplicationRequestCandidateFromCandidate(value *Candidate) *ApplicationRequestCandidate {
	return &ApplicationRequestCandidate{typeName: "candidate", Candidate: value}
}

func (a *ApplicationRequestCandidate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueCandidate := new(Candidate)
	if err := json.Unmarshal(data, &valueCandidate); err == nil {
		a.typeName = "candidate"
		a.Candidate = valueCandidate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestCandidate) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "candidate":
		return json.Marshal(a.Candidate)
	}
}

type ApplicationRequestCandidateVisitor interface {
	VisitString(string) error
	VisitCandidate(*Candidate) error
}

func (a *ApplicationRequestCandidate) Accept(visitor ApplicationRequestCandidateVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "candidate":
		return visitor.VisitCandidate(a.Candidate)
	}
}

// The user credited for this application.
type ApplicationRequestCreditedTo struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewApplicationRequestCreditedToFromString(value string) *ApplicationRequestCreditedTo {
	return &ApplicationRequestCreditedTo{typeName: "string", String: value}
}

func NewApplicationRequestCreditedToFromRemoteUser(value *RemoteUser) *ApplicationRequestCreditedTo {
	return &ApplicationRequestCreditedTo{typeName: "remoteUser", RemoteUser: value}
}

func (a *ApplicationRequestCreditedTo) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		a.typeName = "remoteUser"
		a.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestCreditedTo) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "remoteUser":
		return json.Marshal(a.RemoteUser)
	}
}

type ApplicationRequestCreditedToVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (a *ApplicationRequestCreditedTo) Accept(visitor ApplicationRequestCreditedToVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(a.RemoteUser)
	}
}

// The application's current stage.
type ApplicationRequestCurrentStage struct {
	typeName          string
	String            string
	JobInterviewStage *JobInterviewStage
}

func NewApplicationRequestCurrentStageFromString(value string) *ApplicationRequestCurrentStage {
	return &ApplicationRequestCurrentStage{typeName: "string", String: value}
}

func NewApplicationRequestCurrentStageFromJobInterviewStage(value *JobInterviewStage) *ApplicationRequestCurrentStage {
	return &ApplicationRequestCurrentStage{typeName: "jobInterviewStage", JobInterviewStage: value}
}

func (a *ApplicationRequestCurrentStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueJobInterviewStage := new(JobInterviewStage)
	if err := json.Unmarshal(data, &valueJobInterviewStage); err == nil {
		a.typeName = "jobInterviewStage"
		a.JobInterviewStage = valueJobInterviewStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestCurrentStage) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "jobInterviewStage":
		return json.Marshal(a.JobInterviewStage)
	}
}

type ApplicationRequestCurrentStageVisitor interface {
	VisitString(string) error
	VisitJobInterviewStage(*JobInterviewStage) error
}

func (a *ApplicationRequestCurrentStage) Accept(visitor ApplicationRequestCurrentStageVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "jobInterviewStage":
		return visitor.VisitJobInterviewStage(a.JobInterviewStage)
	}
}

// The job being applied for.
type ApplicationRequestJob struct {
	typeName string
	String   string
	Job      *Job
}

func NewApplicationRequestJobFromString(value string) *ApplicationRequestJob {
	return &ApplicationRequestJob{typeName: "string", String: value}
}

func NewApplicationRequestJobFromJob(value *Job) *ApplicationRequestJob {
	return &ApplicationRequestJob{typeName: "job", Job: value}
}

func (a *ApplicationRequestJob) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueJob := new(Job)
	if err := json.Unmarshal(data, &valueJob); err == nil {
		a.typeName = "job"
		a.Job = valueJob
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestJob) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "job":
		return json.Marshal(a.Job)
	}
}

type ApplicationRequestJobVisitor interface {
	VisitString(string) error
	VisitJob(*Job) error
}

func (a *ApplicationRequestJob) Accept(visitor ApplicationRequestJobVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "job":
		return visitor.VisitJob(a.Job)
	}
}

// The application's reason for rejection.
type ApplicationRequestRejectReason struct {
	typeName     string
	String       string
	RejectReason *RejectReason
}

func NewApplicationRequestRejectReasonFromString(value string) *ApplicationRequestRejectReason {
	return &ApplicationRequestRejectReason{typeName: "string", String: value}
}

func NewApplicationRequestRejectReasonFromRejectReason(value *RejectReason) *ApplicationRequestRejectReason {
	return &ApplicationRequestRejectReason{typeName: "rejectReason", RejectReason: value}
}

func (a *ApplicationRequestRejectReason) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueRejectReason := new(RejectReason)
	if err := json.Unmarshal(data, &valueRejectReason); err == nil {
		a.typeName = "rejectReason"
		a.RejectReason = valueRejectReason
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestRejectReason) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "rejectReason":
		return json.Marshal(a.RejectReason)
	}
}

type ApplicationRequestRejectReasonVisitor interface {
	VisitString(string) error
	VisitRejectReason(*RejectReason) error
}

func (a *ApplicationRequestRejectReason) Accept(visitor ApplicationRequestRejectReasonVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "rejectReason":
		return visitor.VisitRejectReason(a.RejectReason)
	}
}

type ApplicationResponse struct {
	Model    *Application                `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type AsyncPassthroughReciept struct {
	AsyncPassthroughReceiptId string `json:"async_passthrough_receipt_id"`
}

// # The Attachment Object
//
// ### Description
//
// The `Attachment` object is used to represent a file attached to a candidate.
//
// ### Usage Example
//
// Fetch from the `LIST Attachments` endpoint and view attachments accessible by a company.
type Attachment struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The attachment's name.
	FileName *string `json:"file_name,omitempty"`
	// The attachment's url.
	FileUrl   *string `json:"file_url,omitempty"`
	Candidate *string `json:"candidate,omitempty"`
	// The attachment's type.
	//
	// - `RESUME` - RESUME
	// - `COVER_LETTER` - COVER_LETTER
	// - `OFFER_LETTER` - OFFER_LETTER
	// - `OTHER` - OTHER
	AttachmentType   *AttachmentAttachmentType `json:"attachment_type,omitempty"`
	RemoteWasDeleted *bool                     `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time                `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The attachment's type.
//
// - `RESUME` - RESUME
// - `COVER_LETTER` - COVER_LETTER
// - `OFFER_LETTER` - OFFER_LETTER
// - `OTHER` - OTHER
type AttachmentAttachmentType struct {
	typeName           string
	AttachmentTypeEnum AttachmentTypeEnum
	String             string
}

func NewAttachmentAttachmentTypeFromAttachmentTypeEnum(value AttachmentTypeEnum) *AttachmentAttachmentType {
	return &AttachmentAttachmentType{typeName: "attachmentTypeEnum", AttachmentTypeEnum: value}
}

func NewAttachmentAttachmentTypeFromString(value string) *AttachmentAttachmentType {
	return &AttachmentAttachmentType{typeName: "string", String: value}
}

func (a *AttachmentAttachmentType) UnmarshalJSON(data []byte) error {
	var valueAttachmentTypeEnum AttachmentTypeEnum
	if err := json.Unmarshal(data, &valueAttachmentTypeEnum); err == nil {
		a.typeName = "attachmentTypeEnum"
		a.AttachmentTypeEnum = valueAttachmentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AttachmentAttachmentType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "attachmentTypeEnum":
		return json.Marshal(a.AttachmentTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AttachmentAttachmentTypeVisitor interface {
	VisitAttachmentTypeEnum(AttachmentTypeEnum) error
	VisitString(string) error
}

func (a *AttachmentAttachmentType) Accept(visitor AttachmentAttachmentTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "attachmentTypeEnum":
		return visitor.VisitAttachmentTypeEnum(a.AttachmentTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The Attachment Object
//
// ### Description
//
// The `Attachment` object is used to represent a file attached to a candidate.
//
// ### Usage Example
//
// Fetch from the `LIST Attachments` endpoint and view attachments accessible by a company.
type AttachmentRequest struct {
	// The attachment's name.
	FileName *string `json:"file_name,omitempty"`
	// The attachment's url.
	FileUrl   *string `json:"file_url,omitempty"`
	Candidate *string `json:"candidate,omitempty"`
	// The attachment's type.
	//
	// - `RESUME` - RESUME
	// - `COVER_LETTER` - COVER_LETTER
	// - `OFFER_LETTER` - OFFER_LETTER
	// - `OTHER` - OTHER
	AttachmentType      *AttachmentRequestAttachmentType `json:"attachment_type,omitempty"`
	IntegrationParams   map[string]any                   `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any                   `json:"linked_account_params,omitempty"`
}

// The attachment's type.
//
// - `RESUME` - RESUME
// - `COVER_LETTER` - COVER_LETTER
// - `OFFER_LETTER` - OFFER_LETTER
// - `OTHER` - OTHER
type AttachmentRequestAttachmentType struct {
	typeName           string
	AttachmentTypeEnum AttachmentTypeEnum
	String             string
}

func NewAttachmentRequestAttachmentTypeFromAttachmentTypeEnum(value AttachmentTypeEnum) *AttachmentRequestAttachmentType {
	return &AttachmentRequestAttachmentType{typeName: "attachmentTypeEnum", AttachmentTypeEnum: value}
}

func NewAttachmentRequestAttachmentTypeFromString(value string) *AttachmentRequestAttachmentType {
	return &AttachmentRequestAttachmentType{typeName: "string", String: value}
}

func (a *AttachmentRequestAttachmentType) UnmarshalJSON(data []byte) error {
	var valueAttachmentTypeEnum AttachmentTypeEnum
	if err := json.Unmarshal(data, &valueAttachmentTypeEnum); err == nil {
		a.typeName = "attachmentTypeEnum"
		a.AttachmentTypeEnum = valueAttachmentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AttachmentRequestAttachmentType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "attachmentTypeEnum":
		return json.Marshal(a.AttachmentTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AttachmentRequestAttachmentTypeVisitor interface {
	VisitAttachmentTypeEnum(AttachmentTypeEnum) error
	VisitString(string) error
}

func (a *AttachmentRequestAttachmentType) Accept(visitor AttachmentRequestAttachmentTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "attachmentTypeEnum":
		return visitor.VisitAttachmentTypeEnum(a.AttachmentTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

type AttachmentResponse struct {
	Model    *Attachment                 `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// - `RESUME` - RESUME
// - `COVER_LETTER` - COVER_LETTER
// - `OFFER_LETTER` - OFFER_LETTER
// - `OTHER` - OTHER
type AttachmentTypeEnum uint

const (
	AttachmentTypeEnumResume AttachmentTypeEnum = iota + 1
	AttachmentTypeEnumCoverLetter
	AttachmentTypeEnumOfferLetter
	AttachmentTypeEnumOther
)

func (a AttachmentTypeEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AttachmentTypeEnumResume:
		return "RESUME"
	case AttachmentTypeEnumCoverLetter:
		return "COVER_LETTER"
	case AttachmentTypeEnumOfferLetter:
		return "OFFER_LETTER"
	case AttachmentTypeEnumOther:
		return "OTHER"
	}
}

func (a AttachmentTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AttachmentTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "RESUME":
		value := AttachmentTypeEnumResume
		*a = value
	case "COVER_LETTER":
		value := AttachmentTypeEnumCoverLetter
		*a = value
	case "OFFER_LETTER":
		value := AttachmentTypeEnumOfferLetter
		*a = value
	case "OTHER":
		value := AttachmentTypeEnumOther
		*a = value
	}
	return nil
}

type AuditLogEvent struct {
	Id *string `json:"id,omitempty"`
	// The User's full name at the time of this Event occurring.
	UserName *string `json:"user_name,omitempty"`
	// The User's email at the time of this Event occurring.
	UserEmail *string `json:"user_email,omitempty"`
	// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
	//
	// - `ADMIN` - ADMIN
	// - `DEVELOPER` - DEVELOPER
	// - `MEMBER` - MEMBER
	// - `API` - API
	// - `SYSTEM` - SYSTEM
	// - `MERGE_TEAM` - MERGE_TEAM
	Role      *AuditLogEventRole `json:"role,omitempty"`
	IpAddress string             `json:"ip_address"`
	// Designates the type of event that occurred.
	//
	// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
	// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
	// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
	// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
	// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
	// - `INVITED_USER` - INVITED_USER
	// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
	// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
	// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
	// - `CREATED_DESTINATION` - CREATED_DESTINATION
	// - `DELETED_DESTINATION` - DELETED_DESTINATION
	// - `CHANGED_SCOPES` - CHANGED_SCOPES
	// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
	// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
	// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
	// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
	// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
	// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
	// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
	// - `RESET_PASSWORD` - RESET_PASSWORD
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
	EventType        *AuditLogEventEventType `json:"event_type,omitempty"`
	EventDescription string                  `json:"event_description"`
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
}

// Designates the type of event that occurred.
//
// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
type AuditLogEventEventType struct {
	typeName      string
	EventTypeEnum EventTypeEnum
	String        string
}

func NewAuditLogEventEventTypeFromEventTypeEnum(value EventTypeEnum) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "eventTypeEnum", EventTypeEnum: value}
}

func NewAuditLogEventEventTypeFromString(value string) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "string", String: value}
}

func (a *AuditLogEventEventType) UnmarshalJSON(data []byte) error {
	var valueEventTypeEnum EventTypeEnum
	if err := json.Unmarshal(data, &valueEventTypeEnum); err == nil {
		a.typeName = "eventTypeEnum"
		a.EventTypeEnum = valueEventTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventEventType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return json.Marshal(a.EventTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventEventTypeVisitor interface {
	VisitEventTypeEnum(EventTypeEnum) error
	VisitString(string) error
}

func (a *AuditLogEventEventType) Accept(visitor AuditLogEventEventTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return visitor.VisitEventTypeEnum(a.EventTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
//
// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type AuditLogEventRole struct {
	typeName string
	RoleEnum RoleEnum
	String   string
}

func NewAuditLogEventRoleFromRoleEnum(value RoleEnum) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "roleEnum", RoleEnum: value}
}

func NewAuditLogEventRoleFromString(value string) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "string", String: value}
}

func (a *AuditLogEventRole) UnmarshalJSON(data []byte) error {
	var valueRoleEnum RoleEnum
	if err := json.Unmarshal(data, &valueRoleEnum); err == nil {
		a.typeName = "roleEnum"
		a.RoleEnum = valueRoleEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventRole) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return json.Marshal(a.RoleEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventRoleVisitor interface {
	VisitRoleEnum(RoleEnum) error
	VisitString(string) error
}

func (a *AuditLogEventRole) Accept(visitor AuditLogEventRoleVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return visitor.VisitRoleEnum(a.RoleEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The AvailableActions Object
//
// ### Description
//
// The `Activity` object is used to see all available model/operation combinations for an integration.
//
// ### Usage Example
//
// Fetch all the actions available for the `Zenefits` integration.
type AvailableActions struct {
	Integration              *AccountIntegration `json:"integration,omitempty"`
	PassthroughAvailable     bool                `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation   `json:"available_model_operations,omitempty"`
}

// # The Candidate Object
//
// ### Description
//
// The `Candidate` object is used to represent profile information about a given Candidate. Because it is specific to a Candidate, this information stays constant across applications.
//
// ### Usage Example
//
// Fetch from the `LIST Candidates` endpoint and filter by `ID` to show all candidates.
type Candidate struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The candidate's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The candidate's last name.
	LastName *string `json:"last_name,omitempty"`
	// The candidate's current company.
	Company *string `json:"company,omitempty"`
	// The candidate's current title.
	Title *string `json:"title,omitempty"`
	// When the third party's candidate was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's candidate was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// When the most recent interaction with the candidate occurred.
	LastInteractionAt *time.Time `json:"last_interaction_at,omitempty"`
	// Whether or not the candidate is private.
	IsPrivate *bool `json:"is_private,omitempty"`
	// Whether or not the candidate can be emailed.
	CanEmail *bool `json:"can_email,omitempty"`
	// The candidate's locations.
	Locations      []*string       `json:"locations,omitempty"`
	PhoneNumbers   []*PhoneNumber  `json:"phone_numbers,omitempty"`
	EmailAddresses []*EmailAddress `json:"email_addresses,omitempty"`
	Urls           []*Url          `json:"urls,omitempty"`
	// Array of `Tag` names as strings.
	Tags []*string `json:"tags,omitempty"`
	// Array of `Application` object IDs.
	Applications []*CandidateApplicationsItem `json:"applications,omitempty"`
	// Array of `Attachment` object IDs.
	Attachments      []*CandidateAttachmentsItem `json:"attachments,omitempty"`
	RemoteWasDeleted *bool                       `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time                  `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

type CandidateApplicationsItem struct {
	typeName    string
	String      string
	Application *Application
}

func NewCandidateApplicationsItemFromString(value string) *CandidateApplicationsItem {
	return &CandidateApplicationsItem{typeName: "string", String: value}
}

func NewCandidateApplicationsItemFromApplication(value *Application) *CandidateApplicationsItem {
	return &CandidateApplicationsItem{typeName: "application", Application: value}
}

func (c *CandidateApplicationsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		c.typeName = "application"
		c.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CandidateApplicationsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "application":
		return json.Marshal(c.Application)
	}
}

type CandidateApplicationsItemVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (c *CandidateApplicationsItem) Accept(visitor CandidateApplicationsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "application":
		return visitor.VisitApplication(c.Application)
	}
}

type CandidateAttachmentsItem struct {
	typeName   string
	String     string
	Attachment *Attachment
}

func NewCandidateAttachmentsItemFromString(value string) *CandidateAttachmentsItem {
	return &CandidateAttachmentsItem{typeName: "string", String: value}
}

func NewCandidateAttachmentsItemFromAttachment(value *Attachment) *CandidateAttachmentsItem {
	return &CandidateAttachmentsItem{typeName: "attachment", Attachment: value}
}

func (c *CandidateAttachmentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueAttachment := new(Attachment)
	if err := json.Unmarshal(data, &valueAttachment); err == nil {
		c.typeName = "attachment"
		c.Attachment = valueAttachment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CandidateAttachmentsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "attachment":
		return json.Marshal(c.Attachment)
	}
}

type CandidateAttachmentsItemVisitor interface {
	VisitString(string) error
	VisitAttachment(*Attachment) error
}

func (c *CandidateAttachmentsItem) Accept(visitor CandidateAttachmentsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "attachment":
		return visitor.VisitAttachment(c.Attachment)
	}
}

// # The Candidate Object
//
// ### Description
//
// The `Candidate` object is used to represent profile information about a given Candidate. Because it is specific to a Candidate, this information stays constant across applications.
//
// ### Usage Example
//
// Fetch from the `LIST Candidates` endpoint and filter by `ID` to show all candidates.
type CandidateRequest struct {
	// The candidate's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The candidate's last name.
	LastName *string `json:"last_name,omitempty"`
	// The candidate's current company.
	Company *string `json:"company,omitempty"`
	// The candidate's current title.
	Title *string `json:"title,omitempty"`
	// When the most recent interaction with the candidate occurred.
	LastInteractionAt *time.Time `json:"last_interaction_at,omitempty"`
	// Whether or not the candidate is private.
	IsPrivate *bool `json:"is_private,omitempty"`
	// Whether or not the candidate can be emailed.
	CanEmail *bool `json:"can_email,omitempty"`
	// The candidate's locations.
	Locations      []*string              `json:"locations,omitempty"`
	PhoneNumbers   []*PhoneNumberRequest  `json:"phone_numbers,omitempty"`
	EmailAddresses []*EmailAddressRequest `json:"email_addresses,omitempty"`
	Urls           []*UrlRequest          `json:"urls,omitempty"`
	// Array of `Tag` names as strings.
	Tags []*string `json:"tags,omitempty"`
	// Array of `Application` object IDs.
	Applications []*CandidateRequestApplicationsItem `json:"applications,omitempty"`
	// Array of `Attachment` object IDs.
	Attachments         []*CandidateRequestAttachmentsItem `json:"attachments,omitempty"`
	RemoteTemplateId    *string                            `json:"remote_template_id,omitempty"`
	IntegrationParams   map[string]any                     `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any                     `json:"linked_account_params,omitempty"`
}

type CandidateRequestApplicationsItem struct {
	typeName    string
	String      string
	Application *Application
}

func NewCandidateRequestApplicationsItemFromString(value string) *CandidateRequestApplicationsItem {
	return &CandidateRequestApplicationsItem{typeName: "string", String: value}
}

func NewCandidateRequestApplicationsItemFromApplication(value *Application) *CandidateRequestApplicationsItem {
	return &CandidateRequestApplicationsItem{typeName: "application", Application: value}
}

func (c *CandidateRequestApplicationsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		c.typeName = "application"
		c.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CandidateRequestApplicationsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "application":
		return json.Marshal(c.Application)
	}
}

type CandidateRequestApplicationsItemVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (c *CandidateRequestApplicationsItem) Accept(visitor CandidateRequestApplicationsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "application":
		return visitor.VisitApplication(c.Application)
	}
}

type CandidateRequestAttachmentsItem struct {
	typeName   string
	String     string
	Attachment *Attachment
}

func NewCandidateRequestAttachmentsItemFromString(value string) *CandidateRequestAttachmentsItem {
	return &CandidateRequestAttachmentsItem{typeName: "string", String: value}
}

func NewCandidateRequestAttachmentsItemFromAttachment(value *Attachment) *CandidateRequestAttachmentsItem {
	return &CandidateRequestAttachmentsItem{typeName: "attachment", Attachment: value}
}

func (c *CandidateRequestAttachmentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueAttachment := new(Attachment)
	if err := json.Unmarshal(data, &valueAttachment); err == nil {
		c.typeName = "attachment"
		c.Attachment = valueAttachment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CandidateRequestAttachmentsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "attachment":
		return json.Marshal(c.Attachment)
	}
}

type CandidateRequestAttachmentsItemVisitor interface {
	VisitString(string) error
	VisitAttachment(*Attachment) error
}

func (c *CandidateRequestAttachmentsItem) Accept(visitor CandidateRequestAttachmentsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "attachment":
		return visitor.VisitAttachment(c.Attachment)
	}
}

type CandidateResponse struct {
	Model    *Candidate                  `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoriesEnum uint

const (
	CategoriesEnumHris CategoriesEnum = iota + 1
	CategoriesEnumAts
	CategoriesEnumAccounting
	CategoriesEnumTicketing
	CategoriesEnumCrm
	CategoriesEnumMktg
	CategoriesEnumFilestorage
)

func (c CategoriesEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoriesEnumHris:
		return "hris"
	case CategoriesEnumAts:
		return "ats"
	case CategoriesEnumAccounting:
		return "accounting"
	case CategoriesEnumTicketing:
		return "ticketing"
	case CategoriesEnumCrm:
		return "crm"
	case CategoriesEnumMktg:
		return "mktg"
	case CategoriesEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoriesEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoriesEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoriesEnumHris
		*c = value
	case "ats":
		value := CategoriesEnumAts
		*c = value
	case "accounting":
		value := CategoriesEnumAccounting
		*c = value
	case "ticketing":
		value := CategoriesEnumTicketing
		*c = value
	case "crm":
		value := CategoriesEnumCrm
		*c = value
	case "mktg":
		value := CategoriesEnumMktg
		*c = value
	case "filestorage":
		value := CategoriesEnumFilestorage
		*c = value
	}
	return nil
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoryEnum uint

const (
	CategoryEnumHris CategoryEnum = iota + 1
	CategoryEnumAts
	CategoryEnumAccounting
	CategoryEnumTicketing
	CategoryEnumCrm
	CategoryEnumMktg
	CategoryEnumFilestorage
)

func (c CategoryEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoryEnumHris:
		return "hris"
	case CategoryEnumAts:
		return "ats"
	case CategoryEnumAccounting:
		return "accounting"
	case CategoryEnumTicketing:
		return "ticketing"
	case CategoryEnumCrm:
		return "crm"
	case CategoryEnumMktg:
		return "mktg"
	case CategoryEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoryEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoryEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoryEnumHris
		*c = value
	case "ats":
		value := CategoryEnumAts
		*c = value
	case "accounting":
		value := CategoryEnumAccounting
		*c = value
	case "ticketing":
		value := CategoryEnumTicketing
		*c = value
	case "crm":
		value := CategoryEnumCrm
		*c = value
	case "mktg":
		value := CategoryEnumMktg
		*c = value
	case "filestorage":
		value := CategoryEnumFilestorage
		*c = value
	}
	return nil
}

type CommonModelScopesBodyRequest struct {
	ModelId        string               `json:"model_id"`
	EnabledActions []EnabledActionsEnum `json:"enabled_actions,omitempty"`
	DisabledFields []string             `json:"disabled_fields,omitempty"`
}

type ConditionSchema struct {
	// The ID of the condition schema. This ID is used when updating selective syncs for a linked account.
	Id string `json:"id"`
	// The common model for which a condition schema is defined.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing _native condition_ name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
	// Whether this condition can only be applied once. If false, the condition can be AND'd together multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
	// The type of value(s) that can be set for this condition.
	//
	// - `BOOLEAN` - BOOLEAN
	// - `DATE` - DATE
	// - `DATE_TIME` - DATE_TIME
	// - `INTEGER` - INTEGER
	// - `FLOAT` - FLOAT
	// - `STRING` - STRING
	// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
	ConditionType *ConditionSchemaConditionType `json:"condition_type,omitempty"`
	// The schemas for the operators that can be used on a condition.
	Operators []*OperatorSchema `json:"operators,omitempty"`
}

// The type of value(s) that can be set for this condition.
//
// - `BOOLEAN` - BOOLEAN
// - `DATE` - DATE
// - `DATE_TIME` - DATE_TIME
// - `INTEGER` - INTEGER
// - `FLOAT` - FLOAT
// - `STRING` - STRING
// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionSchemaConditionType struct {
	typeName          string
	ConditionTypeEnum ConditionTypeEnum
	String            string
}

func NewConditionSchemaConditionTypeFromConditionTypeEnum(value ConditionTypeEnum) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "conditionTypeEnum", ConditionTypeEnum: value}
}

func NewConditionSchemaConditionTypeFromString(value string) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "string", String: value}
}

func (c *ConditionSchemaConditionType) UnmarshalJSON(data []byte) error {
	var valueConditionTypeEnum ConditionTypeEnum
	if err := json.Unmarshal(data, &valueConditionTypeEnum); err == nil {
		c.typeName = "conditionTypeEnum"
		c.ConditionTypeEnum = valueConditionTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConditionSchemaConditionType) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return json.Marshal(c.ConditionTypeEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type ConditionSchemaConditionTypeVisitor interface {
	VisitConditionTypeEnum(ConditionTypeEnum) error
	VisitString(string) error
}

func (c *ConditionSchemaConditionType) Accept(visitor ConditionSchemaConditionTypeVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return visitor.VisitConditionTypeEnum(c.ConditionTypeEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// - `BOOLEAN` - BOOLEAN
// - `DATE` - DATE
// - `DATE_TIME` - DATE_TIME
// - `INTEGER` - INTEGER
// - `FLOAT` - FLOAT
// - `STRING` - STRING
// - `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionTypeEnum uint

const (
	ConditionTypeEnumBoolean ConditionTypeEnum = iota + 1
	ConditionTypeEnumDate
	ConditionTypeEnumDateTime
	ConditionTypeEnumInteger
	ConditionTypeEnumFloat
	ConditionTypeEnumString
	ConditionTypeEnumListOfStrings
)

func (c ConditionTypeEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case ConditionTypeEnumBoolean:
		return "BOOLEAN"
	case ConditionTypeEnumDate:
		return "DATE"
	case ConditionTypeEnumDateTime:
		return "DATE_TIME"
	case ConditionTypeEnumInteger:
		return "INTEGER"
	case ConditionTypeEnumFloat:
		return "FLOAT"
	case ConditionTypeEnumString:
		return "STRING"
	case ConditionTypeEnumListOfStrings:
		return "LIST_OF_STRINGS"
	}
}

func (c ConditionTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *ConditionTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "BOOLEAN":
		value := ConditionTypeEnumBoolean
		*c = value
	case "DATE":
		value := ConditionTypeEnumDate
		*c = value
	case "DATE_TIME":
		value := ConditionTypeEnumDateTime
		*c = value
	case "INTEGER":
		value := ConditionTypeEnumInteger
		*c = value
	case "FLOAT":
		value := ConditionTypeEnumFloat
		*c = value
	case "STRING":
		value := ConditionTypeEnumString
		*c = value
	case "LIST_OF_STRINGS":
		value := ConditionTypeEnumListOfStrings
		*c = value
	}
	return nil
}

// # The DataPassthrough Object
//
// ### Description
//
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
//
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method          MethodEnum `json:"method,omitempty"`
	Path            string     `json:"path"`
	BaseUrlOverride *string    `json:"base_url_override,omitempty"`
	Data            *string    `json:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]any     `json:"headers,omitempty"`
	RequestFormat *RequestFormatEnum `json:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty"`
}

type DebugModeLog struct {
	LogId         string                `json:"log_id"`
	DashboardView string                `json:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary,omitempty"`
}

type DebugModelLogSummary struct {
	Url        string `json:"url"`
	Method     string `json:"method"`
	StatusCode int    `json:"status_code"`
}

// # The Department Object
//
// ### Description
//
// The `Department` object is used to represent a department within a company.
//
// ### Usage Example
//
// Fetch from the `LIST Departments` endpoint and view the departments within a company.
type Department struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The department's name.
	Name *string `json:"name,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// - `YES_I_HAVE_A_DISABILITY_OR_PREVIOUSLY_HAD_A_DISABILITY` - YES_I_HAVE_A_DISABILITY_OR_PREVIOUSLY_HAD_A_DISABILITY
// - `NO_I_DONT_HAVE_A_DISABILITY` - NO_I_DONT_HAVE_A_DISABILITY
// - `I_DONT_WISH_TO_ANSWER` - I_DONT_WISH_TO_ANSWER
type DisabilityStatusEnum uint

const (
	DisabilityStatusEnumYesIHaveADisabilityOrPreviouslyHadADisability DisabilityStatusEnum = iota + 1
	DisabilityStatusEnumNoIDontHaveADisability
	DisabilityStatusEnumIDontWishToAnswer
)

func (d DisabilityStatusEnum) String() string {
	switch d {
	default:
		return strconv.Itoa(int(d))
	case DisabilityStatusEnumYesIHaveADisabilityOrPreviouslyHadADisability:
		return "YES_I_HAVE_A_DISABILITY_OR_PREVIOUSLY_HAD_A_DISABILITY"
	case DisabilityStatusEnumNoIDontHaveADisability:
		return "NO_I_DONT_HAVE_A_DISABILITY"
	case DisabilityStatusEnumIDontWishToAnswer:
		return "I_DONT_WISH_TO_ANSWER"
	}
}

func (d DisabilityStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", d.String())), nil
}

func (d *DisabilityStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "YES_I_HAVE_A_DISABILITY_OR_PREVIOUSLY_HAD_A_DISABILITY":
		value := DisabilityStatusEnumYesIHaveADisabilityOrPreviouslyHadADisability
		*d = value
	case "NO_I_DONT_HAVE_A_DISABILITY":
		value := DisabilityStatusEnumNoIDontHaveADisability
		*d = value
	case "I_DONT_WISH_TO_ANSWER":
		value := DisabilityStatusEnumIDontWishToAnswer
		*d = value
	}
	return nil
}

// # The EEOC Object
//
// ### Description
//
// The `EEOC` object is used to represent the Equal Employment Opportunity Commission information for a candidate (race, gender, veteran status, disability status).
//
// ### Usage Example
//
// Fetch from the `LIST EEOCs` endpoint and filter by `candidate` to show all EEOC information for a candidate.
type Eeoc struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The candidate being represented.
	Candidate *EeocCandidate `json:"candidate,omitempty"`
	// When the information was submitted.
	SubmittedAt *time.Time `json:"submitted_at,omitempty"`
	// The candidate's race.
	//
	// - `AMERICAN_INDIAN_OR_ALASKAN_NATIVE` - AMERICAN_INDIAN_OR_ALASKAN_NATIVE
	// - `ASIAN` - ASIAN
	// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
	// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
	// - `WHITE` - WHITE
	// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
	// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
	// - `DECLINE_TO_SELF_IDENTIFY` - DECLINE_TO_SELF_IDENTIFY
	Race *EeocRace `json:"race,omitempty"`
	// The candidate's gender.
	//
	// - `MALE` - MALE
	// - `FEMALE` - FEMALE
	// - `NON-BINARY` - NON-BINARY
	// - `OTHER` - OTHER
	// - `DECLINE_TO_SELF_IDENTIFY` - DECLINE_TO_SELF_IDENTIFY
	Gender *EeocGender `json:"gender,omitempty"`
	// The candidate's veteran status.
	//
	// - `I_AM_NOT_A_PROTECTED_VETERAN` - I_AM_NOT_A_PROTECTED_VETERAN
	// - `I_IDENTIFY_AS_ONE_OR_MORE_OF_THE_CLASSIFICATIONS_OF_A_PROTECTED_VETERAN` - I_IDENTIFY_AS_ONE_OR_MORE_OF_THE_CLASSIFICATIONS_OF_A_PROTECTED_VETERAN
	// - `I_DONT_WISH_TO_ANSWER` - I_DONT_WISH_TO_ANSWER
	VeteranStatus *EeocVeteranStatus `json:"veteran_status,omitempty"`
	// The candidate's disability status.
	//
	// - `YES_I_HAVE_A_DISABILITY_OR_PREVIOUSLY_HAD_A_DISABILITY` - YES_I_HAVE_A_DISABILITY_OR_PREVIOUSLY_HAD_A_DISABILITY
	// - `NO_I_DONT_HAVE_A_DISABILITY` - NO_I_DONT_HAVE_A_DISABILITY
	// - `I_DONT_WISH_TO_ANSWER` - I_DONT_WISH_TO_ANSWER
	DisabilityStatus *EeocDisabilityStatus `json:"disability_status,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The candidate being represented.
type EeocCandidate struct {
	typeName  string
	String    string
	Candidate *Candidate
}

func NewEeocCandidateFromString(value string) *EeocCandidate {
	return &EeocCandidate{typeName: "string", String: value}
}

func NewEeocCandidateFromCandidate(value *Candidate) *EeocCandidate {
	return &EeocCandidate{typeName: "candidate", Candidate: value}
}

func (e *EeocCandidate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueCandidate := new(Candidate)
	if err := json.Unmarshal(data, &valueCandidate); err == nil {
		e.typeName = "candidate"
		e.Candidate = valueCandidate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EeocCandidate) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "candidate":
		return json.Marshal(e.Candidate)
	}
}

type EeocCandidateVisitor interface {
	VisitString(string) error
	VisitCandidate(*Candidate) error
}

func (e *EeocCandidate) Accept(visitor EeocCandidateVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "candidate":
		return visitor.VisitCandidate(e.Candidate)
	}
}

// The candidate's disability status.
//
// - `YES_I_HAVE_A_DISABILITY_OR_PREVIOUSLY_HAD_A_DISABILITY` - YES_I_HAVE_A_DISABILITY_OR_PREVIOUSLY_HAD_A_DISABILITY
// - `NO_I_DONT_HAVE_A_DISABILITY` - NO_I_DONT_HAVE_A_DISABILITY
// - `I_DONT_WISH_TO_ANSWER` - I_DONT_WISH_TO_ANSWER
type EeocDisabilityStatus struct {
	typeName             string
	DisabilityStatusEnum DisabilityStatusEnum
	String               string
}

func NewEeocDisabilityStatusFromDisabilityStatusEnum(value DisabilityStatusEnum) *EeocDisabilityStatus {
	return &EeocDisabilityStatus{typeName: "disabilityStatusEnum", DisabilityStatusEnum: value}
}

func NewEeocDisabilityStatusFromString(value string) *EeocDisabilityStatus {
	return &EeocDisabilityStatus{typeName: "string", String: value}
}

func (e *EeocDisabilityStatus) UnmarshalJSON(data []byte) error {
	var valueDisabilityStatusEnum DisabilityStatusEnum
	if err := json.Unmarshal(data, &valueDisabilityStatusEnum); err == nil {
		e.typeName = "disabilityStatusEnum"
		e.DisabilityStatusEnum = valueDisabilityStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EeocDisabilityStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "disabilityStatusEnum":
		return json.Marshal(e.DisabilityStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EeocDisabilityStatusVisitor interface {
	VisitDisabilityStatusEnum(DisabilityStatusEnum) error
	VisitString(string) error
}

func (e *EeocDisabilityStatus) Accept(visitor EeocDisabilityStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "disabilityStatusEnum":
		return visitor.VisitDisabilityStatusEnum(e.DisabilityStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The candidate's gender.
//
// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `DECLINE_TO_SELF_IDENTIFY` - DECLINE_TO_SELF_IDENTIFY
type EeocGender struct {
	typeName   string
	GenderEnum GenderEnum
	String     string
}

func NewEeocGenderFromGenderEnum(value GenderEnum) *EeocGender {
	return &EeocGender{typeName: "genderEnum", GenderEnum: value}
}

func NewEeocGenderFromString(value string) *EeocGender {
	return &EeocGender{typeName: "string", String: value}
}

func (e *EeocGender) UnmarshalJSON(data []byte) error {
	var valueGenderEnum GenderEnum
	if err := json.Unmarshal(data, &valueGenderEnum); err == nil {
		e.typeName = "genderEnum"
		e.GenderEnum = valueGenderEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EeocGender) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return json.Marshal(e.GenderEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EeocGenderVisitor interface {
	VisitGenderEnum(GenderEnum) error
	VisitString(string) error
}

func (e *EeocGender) Accept(visitor EeocGenderVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "genderEnum":
		return visitor.VisitGenderEnum(e.GenderEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The candidate's race.
//
// - `AMERICAN_INDIAN_OR_ALASKAN_NATIVE` - AMERICAN_INDIAN_OR_ALASKAN_NATIVE
// - `ASIAN` - ASIAN
// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// - `WHITE` - WHITE
// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// - `DECLINE_TO_SELF_IDENTIFY` - DECLINE_TO_SELF_IDENTIFY
type EeocRace struct {
	typeName string
	RaceEnum RaceEnum
	String   string
}

func NewEeocRaceFromRaceEnum(value RaceEnum) *EeocRace {
	return &EeocRace{typeName: "raceEnum", RaceEnum: value}
}

func NewEeocRaceFromString(value string) *EeocRace {
	return &EeocRace{typeName: "string", String: value}
}

func (e *EeocRace) UnmarshalJSON(data []byte) error {
	var valueRaceEnum RaceEnum
	if err := json.Unmarshal(data, &valueRaceEnum); err == nil {
		e.typeName = "raceEnum"
		e.RaceEnum = valueRaceEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EeocRace) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "raceEnum":
		return json.Marshal(e.RaceEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EeocRaceVisitor interface {
	VisitRaceEnum(RaceEnum) error
	VisitString(string) error
}

func (e *EeocRace) Accept(visitor EeocRaceVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "raceEnum":
		return visitor.VisitRaceEnum(e.RaceEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The candidate's veteran status.
//
// - `I_AM_NOT_A_PROTECTED_VETERAN` - I_AM_NOT_A_PROTECTED_VETERAN
// - `I_IDENTIFY_AS_ONE_OR_MORE_OF_THE_CLASSIFICATIONS_OF_A_PROTECTED_VETERAN` - I_IDENTIFY_AS_ONE_OR_MORE_OF_THE_CLASSIFICATIONS_OF_A_PROTECTED_VETERAN
// - `I_DONT_WISH_TO_ANSWER` - I_DONT_WISH_TO_ANSWER
type EeocVeteranStatus struct {
	typeName          string
	VeteranStatusEnum VeteranStatusEnum
	String            string
}

func NewEeocVeteranStatusFromVeteranStatusEnum(value VeteranStatusEnum) *EeocVeteranStatus {
	return &EeocVeteranStatus{typeName: "veteranStatusEnum", VeteranStatusEnum: value}
}

func NewEeocVeteranStatusFromString(value string) *EeocVeteranStatus {
	return &EeocVeteranStatus{typeName: "string", String: value}
}

func (e *EeocVeteranStatus) UnmarshalJSON(data []byte) error {
	var valueVeteranStatusEnum VeteranStatusEnum
	if err := json.Unmarshal(data, &valueVeteranStatusEnum); err == nil {
		e.typeName = "veteranStatusEnum"
		e.VeteranStatusEnum = valueVeteranStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EeocVeteranStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "veteranStatusEnum":
		return json.Marshal(e.VeteranStatusEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EeocVeteranStatusVisitor interface {
	VisitVeteranStatusEnum(VeteranStatusEnum) error
	VisitString(string) error
}

func (e *EeocVeteranStatus) Accept(visitor EeocVeteranStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "veteranStatusEnum":
		return visitor.VisitVeteranStatusEnum(e.VeteranStatusEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// # The EmailAddress Object
//
// ### Description
//
// The `EmailAddress` object is used to represent a candidate's email address.
//
// ### Usage Example
//
// Fetch from the `GET Candidate` endpoint and view their email addresses.
type EmailAddress struct {
	// The email address.
	Value *string `json:"value,omitempty"`
	// The type of email address.
	//
	// - `PERSONAL` - PERSONAL
	// - `WORK` - WORK
	// - `OTHER` - OTHER
	EmailAddressType *EmailAddressEmailAddressType `json:"email_address_type,omitempty"`
	CreatedAt        *time.Time                    `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// The type of email address.
//
// - `PERSONAL` - PERSONAL
// - `WORK` - WORK
// - `OTHER` - OTHER
type EmailAddressEmailAddressType struct {
	typeName             string
	EmailAddressTypeEnum EmailAddressTypeEnum
	String               string
}

func NewEmailAddressEmailAddressTypeFromEmailAddressTypeEnum(value EmailAddressTypeEnum) *EmailAddressEmailAddressType {
	return &EmailAddressEmailAddressType{typeName: "emailAddressTypeEnum", EmailAddressTypeEnum: value}
}

func NewEmailAddressEmailAddressTypeFromString(value string) *EmailAddressEmailAddressType {
	return &EmailAddressEmailAddressType{typeName: "string", String: value}
}

func (e *EmailAddressEmailAddressType) UnmarshalJSON(data []byte) error {
	var valueEmailAddressTypeEnum EmailAddressTypeEnum
	if err := json.Unmarshal(data, &valueEmailAddressTypeEnum); err == nil {
		e.typeName = "emailAddressTypeEnum"
		e.EmailAddressTypeEnum = valueEmailAddressTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmailAddressEmailAddressType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "emailAddressTypeEnum":
		return json.Marshal(e.EmailAddressTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmailAddressEmailAddressTypeVisitor interface {
	VisitEmailAddressTypeEnum(EmailAddressTypeEnum) error
	VisitString(string) error
}

func (e *EmailAddressEmailAddressType) Accept(visitor EmailAddressEmailAddressTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "emailAddressTypeEnum":
		return visitor.VisitEmailAddressTypeEnum(e.EmailAddressTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// # The EmailAddress Object
//
// ### Description
//
// The `EmailAddress` object is used to represent a candidate's email address.
//
// ### Usage Example
//
// Fetch from the `GET Candidate` endpoint and view their email addresses.
type EmailAddressRequest struct {
	// The email address.
	Value *string `json:"value,omitempty"`
	// The type of email address.
	//
	// - `PERSONAL` - PERSONAL
	// - `WORK` - WORK
	// - `OTHER` - OTHER
	EmailAddressType    *EmailAddressRequestEmailAddressType `json:"email_address_type,omitempty"`
	IntegrationParams   map[string]any                       `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any                       `json:"linked_account_params,omitempty"`
}

// The type of email address.
//
// - `PERSONAL` - PERSONAL
// - `WORK` - WORK
// - `OTHER` - OTHER
type EmailAddressRequestEmailAddressType struct {
	typeName             string
	EmailAddressTypeEnum EmailAddressTypeEnum
	String               string
}

func NewEmailAddressRequestEmailAddressTypeFromEmailAddressTypeEnum(value EmailAddressTypeEnum) *EmailAddressRequestEmailAddressType {
	return &EmailAddressRequestEmailAddressType{typeName: "emailAddressTypeEnum", EmailAddressTypeEnum: value}
}

func NewEmailAddressRequestEmailAddressTypeFromString(value string) *EmailAddressRequestEmailAddressType {
	return &EmailAddressRequestEmailAddressType{typeName: "string", String: value}
}

func (e *EmailAddressRequestEmailAddressType) UnmarshalJSON(data []byte) error {
	var valueEmailAddressTypeEnum EmailAddressTypeEnum
	if err := json.Unmarshal(data, &valueEmailAddressTypeEnum); err == nil {
		e.typeName = "emailAddressTypeEnum"
		e.EmailAddressTypeEnum = valueEmailAddressTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmailAddressRequestEmailAddressType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "emailAddressTypeEnum":
		return json.Marshal(e.EmailAddressTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmailAddressRequestEmailAddressTypeVisitor interface {
	VisitEmailAddressTypeEnum(EmailAddressTypeEnum) error
	VisitString(string) error
}

func (e *EmailAddressRequestEmailAddressType) Accept(visitor EmailAddressRequestEmailAddressTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "emailAddressTypeEnum":
		return visitor.VisitEmailAddressTypeEnum(e.EmailAddressTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// - `PERSONAL` - PERSONAL
// - `WORK` - WORK
// - `OTHER` - OTHER
type EmailAddressTypeEnum uint

const (
	EmailAddressTypeEnumPersonal EmailAddressTypeEnum = iota + 1
	EmailAddressTypeEnumWork
	EmailAddressTypeEnumOther
)

func (e EmailAddressTypeEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EmailAddressTypeEnumPersonal:
		return "PERSONAL"
	case EmailAddressTypeEnumWork:
		return "WORK"
	case EmailAddressTypeEnumOther:
		return "OTHER"
	}
}

func (e EmailAddressTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EmailAddressTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "PERSONAL":
		value := EmailAddressTypeEnumPersonal
		*e = value
	case "WORK":
		value := EmailAddressTypeEnumWork
		*e = value
	case "OTHER":
		value := EmailAddressTypeEnumOther
		*e = value
	}
	return nil
}

// - `READ` - READ
// - `WRITE` - WRITE
type EnabledActionsEnum uint

const (
	EnabledActionsEnumRead EnabledActionsEnum = iota + 1
	EnabledActionsEnumWrite
)

func (e EnabledActionsEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EnabledActionsEnumRead:
		return "READ"
	case EnabledActionsEnumWrite:
		return "WRITE"
	}
}

func (e EnabledActionsEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EnabledActionsEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "READ":
		value := EnabledActionsEnumRead
		*e = value
	case "WRITE":
		value := EnabledActionsEnumWrite
		*e = value
	}
	return nil
}

// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum uint

const (
	EncodingEnumRaw EncodingEnum = iota + 1
	EncodingEnumBase64
	EncodingEnumGzipBase64
)

func (e EncodingEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EncodingEnumRaw:
		return "RAW"
	case EncodingEnumBase64:
		return "BASE64"
	case EncodingEnumGzipBase64:
		return "GZIP_BASE64"
	}
}

func (e EncodingEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EncodingEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "RAW":
		value := EncodingEnumRaw
		*e = value
	case "BASE64":
		value := EncodingEnumBase64
		*e = value
	case "GZIP_BASE64":
		value := EncodingEnumGzipBase64
		*e = value
	}
	return nil
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
type EventTypeEnum uint

const (
	EventTypeEnumCreatedRemoteProductionApiKey EventTypeEnum = iota + 1
	EventTypeEnumDeletedRemoteProductionApiKey
	EventTypeEnumCreatedTestApiKey
	EventTypeEnumDeletedTestApiKey
	EventTypeEnumRegeneratedProductionApiKey
	EventTypeEnumInvitedUser
	EventTypeEnumTwoFactorAuthEnabled
	EventTypeEnumTwoFactorAuthDisabled
	EventTypeEnumDeletedLinkedAccount
	EventTypeEnumCreatedDestination
	EventTypeEnumDeletedDestination
	EventTypeEnumChangedScopes
	EventTypeEnumChangedPersonalInformation
	EventTypeEnumChangedOrganizationSettings
	EventTypeEnumEnabledIntegration
	EventTypeEnumDisabledIntegration
	EventTypeEnumEnabledCategory
	EventTypeEnumDisabledCategory
	EventTypeEnumChangedPassword
	EventTypeEnumResetPassword
	EventTypeEnumEnabledRedactUnmappedDataForOrganization
	EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount
	EventTypeEnumDisabledRedactUnmappedDataForOrganization
	EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount
	EventTypeEnumCreatedIntegrationWideFieldMapping
	EventTypeEnumCreatedLinkedAccountFieldMapping
	EventTypeEnumChangedIntegrationWideFieldMapping
	EventTypeEnumChangedLinkedAccountFieldMapping
	EventTypeEnumDeletedIntegrationWideFieldMapping
	EventTypeEnumDeletedLinkedAccountFieldMapping
)

func (e EventTypeEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EventTypeEnumCreatedRemoteProductionApiKey:
		return "CREATED_REMOTE_PRODUCTION_API_KEY"
	case EventTypeEnumDeletedRemoteProductionApiKey:
		return "DELETED_REMOTE_PRODUCTION_API_KEY"
	case EventTypeEnumCreatedTestApiKey:
		return "CREATED_TEST_API_KEY"
	case EventTypeEnumDeletedTestApiKey:
		return "DELETED_TEST_API_KEY"
	case EventTypeEnumRegeneratedProductionApiKey:
		return "REGENERATED_PRODUCTION_API_KEY"
	case EventTypeEnumInvitedUser:
		return "INVITED_USER"
	case EventTypeEnumTwoFactorAuthEnabled:
		return "TWO_FACTOR_AUTH_ENABLED"
	case EventTypeEnumTwoFactorAuthDisabled:
		return "TWO_FACTOR_AUTH_DISABLED"
	case EventTypeEnumDeletedLinkedAccount:
		return "DELETED_LINKED_ACCOUNT"
	case EventTypeEnumCreatedDestination:
		return "CREATED_DESTINATION"
	case EventTypeEnumDeletedDestination:
		return "DELETED_DESTINATION"
	case EventTypeEnumChangedScopes:
		return "CHANGED_SCOPES"
	case EventTypeEnumChangedPersonalInformation:
		return "CHANGED_PERSONAL_INFORMATION"
	case EventTypeEnumChangedOrganizationSettings:
		return "CHANGED_ORGANIZATION_SETTINGS"
	case EventTypeEnumEnabledIntegration:
		return "ENABLED_INTEGRATION"
	case EventTypeEnumDisabledIntegration:
		return "DISABLED_INTEGRATION"
	case EventTypeEnumEnabledCategory:
		return "ENABLED_CATEGORY"
	case EventTypeEnumDisabledCategory:
		return "DISABLED_CATEGORY"
	case EventTypeEnumChangedPassword:
		return "CHANGED_PASSWORD"
	case EventTypeEnumResetPassword:
		return "RESET_PASSWORD"
	case EventTypeEnumEnabledRedactUnmappedDataForOrganization:
		return "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	case EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount:
		return "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	case EventTypeEnumDisabledRedactUnmappedDataForOrganization:
		return "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	case EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount:
		return "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	case EventTypeEnumCreatedIntegrationWideFieldMapping:
		return "CREATED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumCreatedLinkedAccountFieldMapping:
		return "CREATED_LINKED_ACCOUNT_FIELD_MAPPING"
	case EventTypeEnumChangedIntegrationWideFieldMapping:
		return "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumChangedLinkedAccountFieldMapping:
		return "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING"
	case EventTypeEnumDeletedIntegrationWideFieldMapping:
		return "DELETED_INTEGRATION_WIDE_FIELD_MAPPING"
	case EventTypeEnumDeletedLinkedAccountFieldMapping:
		return "DELETED_LINKED_ACCOUNT_FIELD_MAPPING"
	}
}

func (e EventTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EventTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "CREATED_REMOTE_PRODUCTION_API_KEY":
		value := EventTypeEnumCreatedRemoteProductionApiKey
		*e = value
	case "DELETED_REMOTE_PRODUCTION_API_KEY":
		value := EventTypeEnumDeletedRemoteProductionApiKey
		*e = value
	case "CREATED_TEST_API_KEY":
		value := EventTypeEnumCreatedTestApiKey
		*e = value
	case "DELETED_TEST_API_KEY":
		value := EventTypeEnumDeletedTestApiKey
		*e = value
	case "REGENERATED_PRODUCTION_API_KEY":
		value := EventTypeEnumRegeneratedProductionApiKey
		*e = value
	case "INVITED_USER":
		value := EventTypeEnumInvitedUser
		*e = value
	case "TWO_FACTOR_AUTH_ENABLED":
		value := EventTypeEnumTwoFactorAuthEnabled
		*e = value
	case "TWO_FACTOR_AUTH_DISABLED":
		value := EventTypeEnumTwoFactorAuthDisabled
		*e = value
	case "DELETED_LINKED_ACCOUNT":
		value := EventTypeEnumDeletedLinkedAccount
		*e = value
	case "CREATED_DESTINATION":
		value := EventTypeEnumCreatedDestination
		*e = value
	case "DELETED_DESTINATION":
		value := EventTypeEnumDeletedDestination
		*e = value
	case "CHANGED_SCOPES":
		value := EventTypeEnumChangedScopes
		*e = value
	case "CHANGED_PERSONAL_INFORMATION":
		value := EventTypeEnumChangedPersonalInformation
		*e = value
	case "CHANGED_ORGANIZATION_SETTINGS":
		value := EventTypeEnumChangedOrganizationSettings
		*e = value
	case "ENABLED_INTEGRATION":
		value := EventTypeEnumEnabledIntegration
		*e = value
	case "DISABLED_INTEGRATION":
		value := EventTypeEnumDisabledIntegration
		*e = value
	case "ENABLED_CATEGORY":
		value := EventTypeEnumEnabledCategory
		*e = value
	case "DISABLED_CATEGORY":
		value := EventTypeEnumDisabledCategory
		*e = value
	case "CHANGED_PASSWORD":
		value := EventTypeEnumChangedPassword
		*e = value
	case "RESET_PASSWORD":
		value := EventTypeEnumResetPassword
		*e = value
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		value := EventTypeEnumEnabledRedactUnmappedDataForOrganization
		*e = value
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		value := EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount
		*e = value
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		value := EventTypeEnumDisabledRedactUnmappedDataForOrganization
		*e = value
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		value := EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount
		*e = value
	case "CREATED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumCreatedIntegrationWideFieldMapping
		*e = value
	case "CREATED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumCreatedLinkedAccountFieldMapping
		*e = value
	case "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumChangedIntegrationWideFieldMapping
		*e = value
	case "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumChangedLinkedAccountFieldMapping
		*e = value
	case "DELETED_INTEGRATION_WIDE_FIELD_MAPPING":
		value := EventTypeEnumDeletedIntegrationWideFieldMapping
		*e = value
	case "DELETED_LINKED_ACCOUNT_FIELD_MAPPING":
		value := EventTypeEnumDeletedLinkedAccountFieldMapping
		*e = value
	}
	return nil
}

// - `MALE` - MALE
// - `FEMALE` - FEMALE
// - `NON-BINARY` - NON-BINARY
// - `OTHER` - OTHER
// - `DECLINE_TO_SELF_IDENTIFY` - DECLINE_TO_SELF_IDENTIFY
type GenderEnum uint

const (
	GenderEnumMale GenderEnum = iota + 1
	GenderEnumFemale
	GenderEnumNonBinary
	GenderEnumOther
	GenderEnumDeclineToSelfIdentify
)

func (g GenderEnum) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GenderEnumMale:
		return "MALE"
	case GenderEnumFemale:
		return "FEMALE"
	case GenderEnumNonBinary:
		return "NON-BINARY"
	case GenderEnumOther:
		return "OTHER"
	case GenderEnumDeclineToSelfIdentify:
		return "DECLINE_TO_SELF_IDENTIFY"
	}
}

func (g GenderEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GenderEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "MALE":
		value := GenderEnumMale
		*g = value
	case "FEMALE":
		value := GenderEnumFemale
		*g = value
	case "NON-BINARY":
		value := GenderEnumNonBinary
		*g = value
	case "OTHER":
		value := GenderEnumOther
		*g = value
	case "DECLINE_TO_SELF_IDENTIFY":
		value := GenderEnumDeclineToSelfIdentify
		*g = value
	}
	return nil
}

type Issue struct {
	Id *string `json:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// - `ONGOING` - ONGOING
	// - `RESOLVED` - RESOLVED
	Status            *IssueStatus   `json:"status,omitempty"`
	ErrorDescription  string         `json:"error_description"`
	EndUser           map[string]any `json:"end_user,omitempty"`
	FirstIncidentTime *time.Time     `json:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time     `json:"last_incident_time,omitempty"`
	IsMuted           *bool          `json:"is_muted,omitempty"`
	ErrorDetails      []string       `json:"error_details,omitempty"`
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatus struct {
	typeName        string
	IssueStatusEnum IssueStatusEnum
	String          string
}

func NewIssueStatusFromIssueStatusEnum(value IssueStatusEnum) *IssueStatus {
	return &IssueStatus{typeName: "issueStatusEnum", IssueStatusEnum: value}
}

func NewIssueStatusFromString(value string) *IssueStatus {
	return &IssueStatus{typeName: "string", String: value}
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typeName = "issueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return json.Marshal(i.IssueStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatusEnum uint

const (
	IssueStatusEnumOngoing IssueStatusEnum = iota + 1
	IssueStatusEnumResolved
)

func (i IssueStatusEnum) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssueStatusEnumOngoing:
		return "ONGOING"
	case IssueStatusEnumResolved:
		return "RESOLVED"
	}
}

func (i IssueStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssueStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ONGOING":
		value := IssueStatusEnumOngoing
		*i = value
	case "RESOLVED":
		value := IssueStatusEnumResolved
		*i = value
	}
	return nil
}

// # The Job Object
//
// ### Description
//
// The `Job` object can be used to track any jobs that are currently or will be open/closed for applications.
//
// ### Usage Example
//
// Fetch from the `LIST Jobs` endpoint to show all job postings.
type Job struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The job's name.
	Name *string `json:"name,omitempty"`
	// The job's description.
	Description *string `json:"description,omitempty"`
	// The job's code. Typically an additional identifier used to reference the particular job that is displayed on the ATS.
	Code *string `json:"code,omitempty"`
	// The job's status.
	//
	// - `OPEN` - OPEN
	// - `CLOSED` - CLOSED
	// - `DRAFT` - DRAFT
	// - `ARCHIVED` - ARCHIVED
	// - `PENDING` - PENDING
	Status         *JobStatus `json:"status,omitempty"`
	JobPostingUrls []*Url     `json:"job_posting_urls,omitempty"`
	// When the third party's job was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's job was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Whether the job is confidential.
	Confidential *bool `json:"confidential,omitempty"`
	// IDs of `Department` objects for this `Job`.
	Departments []*JobDepartmentsItem `json:"departments,omitempty"`
	// IDs of `Office` objects for this `Job`.
	Offices []*JobOfficesItem `json:"offices,omitempty"`
	// IDs of `RemoteUser` objects that serve as hiring managers for this `Job`.
	HiringManagers []*JobHiringManagersItem `json:"hiring_managers,omitempty"`
	// IDs of `RemoteUser` objects that serve as recruiters for this `Job`.
	Recruiters []*JobRecruitersItem `json:"recruiters,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

type JobDepartmentsItem struct {
	typeName   string
	String     string
	Department *Department
}

func NewJobDepartmentsItemFromString(value string) *JobDepartmentsItem {
	return &JobDepartmentsItem{typeName: "string", String: value}
}

func NewJobDepartmentsItemFromDepartment(value *Department) *JobDepartmentsItem {
	return &JobDepartmentsItem{typeName: "department", Department: value}
}

func (j *JobDepartmentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueDepartment := new(Department)
	if err := json.Unmarshal(data, &valueDepartment); err == nil {
		j.typeName = "department"
		j.Department = valueDepartment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobDepartmentsItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "department":
		return json.Marshal(j.Department)
	}
}

type JobDepartmentsItemVisitor interface {
	VisitString(string) error
	VisitDepartment(*Department) error
}

func (j *JobDepartmentsItem) Accept(visitor JobDepartmentsItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "department":
		return visitor.VisitDepartment(j.Department)
	}
}

type JobHiringManagersItem struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewJobHiringManagersItemFromString(value string) *JobHiringManagersItem {
	return &JobHiringManagersItem{typeName: "string", String: value}
}

func NewJobHiringManagersItemFromRemoteUser(value *RemoteUser) *JobHiringManagersItem {
	return &JobHiringManagersItem{typeName: "remoteUser", RemoteUser: value}
}

func (j *JobHiringManagersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		j.typeName = "remoteUser"
		j.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobHiringManagersItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "remoteUser":
		return json.Marshal(j.RemoteUser)
	}
}

type JobHiringManagersItemVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (j *JobHiringManagersItem) Accept(visitor JobHiringManagersItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(j.RemoteUser)
	}
}

// # The JobInterviewStage Object
//
// ### Description
//
// The `JobInterviewStage` object is used to represent a particular recruiting stage for an `Application`. A given `Application` typically has the `JobInterviewStage` object represented in the current_stage field.
//
// ### Usage Example
//
// Fetch from the `LIST JobInterviewStages` endpoint and view the job interview stages used by a company.
type JobInterviewStage struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// Standard stage names are offered by ATS systems but can be modified by users.
	Name *string `json:"name,omitempty"`
	// This field is populated only if the stage is specific to a particular job. If the stage is generic, this field will not be populated.
	Job *JobInterviewStageJob `json:"job,omitempty"`
	// The stage’s order, with the lowest values ordered first. If the third-party does not return details on the order of stages, this field will not be populated.
	StageOrder *int `json:"stage_order,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// This field is populated only if the stage is specific to a particular job. If the stage is generic, this field will not be populated.
type JobInterviewStageJob struct {
	typeName string
	String   string
	Job      *Job
}

func NewJobInterviewStageJobFromString(value string) *JobInterviewStageJob {
	return &JobInterviewStageJob{typeName: "string", String: value}
}

func NewJobInterviewStageJobFromJob(value *Job) *JobInterviewStageJob {
	return &JobInterviewStageJob{typeName: "job", Job: value}
}

func (j *JobInterviewStageJob) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueJob := new(Job)
	if err := json.Unmarshal(data, &valueJob); err == nil {
		j.typeName = "job"
		j.Job = valueJob
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobInterviewStageJob) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "job":
		return json.Marshal(j.Job)
	}
}

type JobInterviewStageJobVisitor interface {
	VisitString(string) error
	VisitJob(*Job) error
}

func (j *JobInterviewStageJob) Accept(visitor JobInterviewStageJobVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "job":
		return visitor.VisitJob(j.Job)
	}
}

type JobOfficesItem struct {
	typeName string
	String   string
	Office   *Office
}

func NewJobOfficesItemFromString(value string) *JobOfficesItem {
	return &JobOfficesItem{typeName: "string", String: value}
}

func NewJobOfficesItemFromOffice(value *Office) *JobOfficesItem {
	return &JobOfficesItem{typeName: "office", Office: value}
}

func (j *JobOfficesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueOffice := new(Office)
	if err := json.Unmarshal(data, &valueOffice); err == nil {
		j.typeName = "office"
		j.Office = valueOffice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobOfficesItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "office":
		return json.Marshal(j.Office)
	}
}

type JobOfficesItemVisitor interface {
	VisitString(string) error
	VisitOffice(*Office) error
}

func (j *JobOfficesItem) Accept(visitor JobOfficesItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "office":
		return visitor.VisitOffice(j.Office)
	}
}

type JobRecruitersItem struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewJobRecruitersItemFromString(value string) *JobRecruitersItem {
	return &JobRecruitersItem{typeName: "string", String: value}
}

func NewJobRecruitersItemFromRemoteUser(value *RemoteUser) *JobRecruitersItem {
	return &JobRecruitersItem{typeName: "remoteUser", RemoteUser: value}
}

func (j *JobRecruitersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		j.typeName = "remoteUser"
		j.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobRecruitersItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "remoteUser":
		return json.Marshal(j.RemoteUser)
	}
}

type JobRecruitersItemVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (j *JobRecruitersItem) Accept(visitor JobRecruitersItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(j.RemoteUser)
	}
}

// The job's status.
//
// - `OPEN` - OPEN
// - `CLOSED` - CLOSED
// - `DRAFT` - DRAFT
// - `ARCHIVED` - ARCHIVED
// - `PENDING` - PENDING
type JobStatus struct {
	typeName      string
	JobStatusEnum JobStatusEnum
	String        string
}

func NewJobStatusFromJobStatusEnum(value JobStatusEnum) *JobStatus {
	return &JobStatus{typeName: "jobStatusEnum", JobStatusEnum: value}
}

func NewJobStatusFromString(value string) *JobStatus {
	return &JobStatus{typeName: "string", String: value}
}

func (j *JobStatus) UnmarshalJSON(data []byte) error {
	var valueJobStatusEnum JobStatusEnum
	if err := json.Unmarshal(data, &valueJobStatusEnum); err == nil {
		j.typeName = "jobStatusEnum"
		j.JobStatusEnum = valueJobStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JobStatus) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "jobStatusEnum":
		return json.Marshal(j.JobStatusEnum)
	case "string":
		return json.Marshal(j.String)
	}
}

type JobStatusVisitor interface {
	VisitJobStatusEnum(JobStatusEnum) error
	VisitString(string) error
}

func (j *JobStatus) Accept(visitor JobStatusVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "jobStatusEnum":
		return visitor.VisitJobStatusEnum(j.JobStatusEnum)
	case "string":
		return visitor.VisitString(j.String)
	}
}

// - `OPEN` - OPEN
// - `CLOSED` - CLOSED
// - `DRAFT` - DRAFT
// - `ARCHIVED` - ARCHIVED
// - `PENDING` - PENDING
type JobStatusEnum uint

const (
	JobStatusEnumOpen JobStatusEnum = iota + 1
	JobStatusEnumClosed
	JobStatusEnumDraft
	JobStatusEnumArchived
	JobStatusEnumPending
)

func (j JobStatusEnum) String() string {
	switch j {
	default:
		return strconv.Itoa(int(j))
	case JobStatusEnumOpen:
		return "OPEN"
	case JobStatusEnumClosed:
		return "CLOSED"
	case JobStatusEnumDraft:
		return "DRAFT"
	case JobStatusEnumArchived:
		return "ARCHIVED"
	case JobStatusEnumPending:
		return "PENDING"
	}
}

func (j JobStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", j.String())), nil
}

func (j *JobStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "OPEN":
		value := JobStatusEnumOpen
		*j = value
	case "CLOSED":
		value := JobStatusEnumClosed
		*j = value
	case "DRAFT":
		value := JobStatusEnumDraft
		*j = value
	case "ARCHIVED":
		value := JobStatusEnumArchived
		*j = value
	case "PENDING":
		value := JobStatusEnumPending
		*j = value
	}
	return nil
}

type LinkToken struct {
	LinkToken       string  `json:"link_token"`
	IntegrationName *string `json:"integration_name,omitempty"`
	MagicLinkUrl    *string `json:"magic_link_url,omitempty"`
}

type LinkedAccountCondition struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The common model for a specific condition.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing _native condition_ name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The operator for a specific condition.
	Operator string `json:"operator"`
	Value    *any   `json:"value,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
}

type LinkedAccountConditionRequest struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The operator for a specific condition.
	Operator string `json:"operator"`
	Value    any    `json:"value,omitempty"`
}

type LinkedAccountSelectiveSyncConfiguration struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountCondition `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountSelectiveSyncConfigurationRequest struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountConditionRequest `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request"`
}

type MetaResponse struct {
	RequestSchema                  map[string]any       `json:"request_schema,omitempty"`
	RemoteFieldClasses             map[string]any       `json:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus `json:"status,omitempty"`
	HasConditionalParams           bool                 `json:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                 `json:"has_required_linked_account_params"`
}

// - `GET` - GET
// - `OPTIONS` - OPTIONS
// - `HEAD` - HEAD
// - `POST` - POST
// - `PUT` - PUT
// - `PATCH` - PATCH
// - `DELETE` - DELETE
type MethodEnum uint

const (
	MethodEnumGet MethodEnum = iota + 1
	MethodEnumOptions
	MethodEnumHead
	MethodEnumPost
	MethodEnumPut
	MethodEnumPatch
	MethodEnumDelete
)

func (m MethodEnum) String() string {
	switch m {
	default:
		return strconv.Itoa(int(m))
	case MethodEnumGet:
		return "GET"
	case MethodEnumOptions:
		return "OPTIONS"
	case MethodEnumHead:
		return "HEAD"
	case MethodEnumPost:
		return "POST"
	case MethodEnumPut:
		return "PUT"
	case MethodEnumPatch:
		return "PATCH"
	case MethodEnumDelete:
		return "DELETE"
	}
}

func (m MethodEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", m.String())), nil
}

func (m *MethodEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GET":
		value := MethodEnumGet
		*m = value
	case "OPTIONS":
		value := MethodEnumOptions
		*m = value
	case "HEAD":
		value := MethodEnumHead
		*m = value
	case "POST":
		value := MethodEnumPost
		*m = value
	case "PUT":
		value := MethodEnumPut
		*m = value
	case "PATCH":
		value := MethodEnumPatch
		*m = value
	case "DELETE":
		value := MethodEnumDelete
		*m = value
	}
	return nil
}

// # The ModelOperation Object
//
// ### Description
//
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
//
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name"`
	AvailableOperations    []string `json:"available_operations,omitempty"`
	RequiredPostParameters []string `json:"required_post_parameters,omitempty"`
	SupportedFields        []string `json:"supported_fields,omitempty"`
}

// # The MultipartFormField Object
//
// ### Description
//
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
//
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name"`
	// The data for the form field.
	Data string `json:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// - `RAW` - RAW
	// - `BASE64` - BASE64
	// - `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty"`
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	typeName     string
	EncodingEnum EncodingEnum
	String       string
}

func NewMultipartFormFieldRequestEncodingFromEncodingEnum(value EncodingEnum) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "encodingEnum", EncodingEnum: value}
}

func NewMultipartFormFieldRequestEncodingFromString(value string) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "string", String: value}
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typeName = "encodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return json.Marshal(m.EncodingEnum)
	case "string":
		return json.Marshal(m.String)
	}
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	case "string":
		return visitor.VisitString(m.String)
	}
}

// # The Offer Object
//
// ### Description
//
// The `Offer` object is used to represent an offer for a candidate's application specific to a job.
//
// ### Usage Example
//
// Fetch from the `LIST Offers` endpoint and filter by `ID` to show all offers.
type Offer struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The application who is receiving the offer.
	Application *OfferApplication `json:"application,omitempty"`
	// The user who created the offer.
	Creator *OfferCreator `json:"creator,omitempty"`
	// When the third party's offer was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the offer was closed.
	ClosedAt *time.Time `json:"closed_at,omitempty"`
	// When the offer was sent.
	SentAt *time.Time `json:"sent_at,omitempty"`
	// The employment start date on the offer.
	StartDate *time.Time `json:"start_date,omitempty"`
	// The offer's status.
	//
	// - `DRAFT` - DRAFT
	// - `APPROVAL-SENT` - APPROVAL-SENT
	// - `APPROVED` - APPROVED
	// - `SENT` - SENT
	// - `SENT-MANUALLY` - SENT-MANUALLY
	// - `OPENED` - OPENED
	// - `DENIED` - DENIED
	// - `SIGNED` - SIGNED
	// - `DEPRECATED` - DEPRECATED
	Status *OfferStatus `json:"status,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The application who is receiving the offer.
type OfferApplication struct {
	typeName    string
	String      string
	Application *Application
}

func NewOfferApplicationFromString(value string) *OfferApplication {
	return &OfferApplication{typeName: "string", String: value}
}

func NewOfferApplicationFromApplication(value *Application) *OfferApplication {
	return &OfferApplication{typeName: "application", Application: value}
}

func (o *OfferApplication) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		o.typeName = "application"
		o.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OfferApplication) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "application":
		return json.Marshal(o.Application)
	}
}

type OfferApplicationVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (o *OfferApplication) Accept(visitor OfferApplicationVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "application":
		return visitor.VisitApplication(o.Application)
	}
}

// The user who created the offer.
type OfferCreator struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewOfferCreatorFromString(value string) *OfferCreator {
	return &OfferCreator{typeName: "string", String: value}
}

func NewOfferCreatorFromRemoteUser(value *RemoteUser) *OfferCreator {
	return &OfferCreator{typeName: "remoteUser", RemoteUser: value}
}

func (o *OfferCreator) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		o.typeName = "remoteUser"
		o.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OfferCreator) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "remoteUser":
		return json.Marshal(o.RemoteUser)
	}
}

type OfferCreatorVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (o *OfferCreator) Accept(visitor OfferCreatorVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(o.RemoteUser)
	}
}

// The offer's status.
//
// - `DRAFT` - DRAFT
// - `APPROVAL-SENT` - APPROVAL-SENT
// - `APPROVED` - APPROVED
// - `SENT` - SENT
// - `SENT-MANUALLY` - SENT-MANUALLY
// - `OPENED` - OPENED
// - `DENIED` - DENIED
// - `SIGNED` - SIGNED
// - `DEPRECATED` - DEPRECATED
type OfferStatus struct {
	typeName        string
	OfferStatusEnum OfferStatusEnum
	String          string
}

func NewOfferStatusFromOfferStatusEnum(value OfferStatusEnum) *OfferStatus {
	return &OfferStatus{typeName: "offerStatusEnum", OfferStatusEnum: value}
}

func NewOfferStatusFromString(value string) *OfferStatus {
	return &OfferStatus{typeName: "string", String: value}
}

func (o *OfferStatus) UnmarshalJSON(data []byte) error {
	var valueOfferStatusEnum OfferStatusEnum
	if err := json.Unmarshal(data, &valueOfferStatusEnum); err == nil {
		o.typeName = "offerStatusEnum"
		o.OfferStatusEnum = valueOfferStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OfferStatus) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "offerStatusEnum":
		return json.Marshal(o.OfferStatusEnum)
	case "string":
		return json.Marshal(o.String)
	}
}

type OfferStatusVisitor interface {
	VisitOfferStatusEnum(OfferStatusEnum) error
	VisitString(string) error
}

func (o *OfferStatus) Accept(visitor OfferStatusVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "offerStatusEnum":
		return visitor.VisitOfferStatusEnum(o.OfferStatusEnum)
	case "string":
		return visitor.VisitString(o.String)
	}
}

// - `DRAFT` - DRAFT
// - `APPROVAL-SENT` - APPROVAL-SENT
// - `APPROVED` - APPROVED
// - `SENT` - SENT
// - `SENT-MANUALLY` - SENT-MANUALLY
// - `OPENED` - OPENED
// - `DENIED` - DENIED
// - `SIGNED` - SIGNED
// - `DEPRECATED` - DEPRECATED
type OfferStatusEnum uint

const (
	OfferStatusEnumDraft OfferStatusEnum = iota + 1
	OfferStatusEnumApprovalSent
	OfferStatusEnumApproved
	OfferStatusEnumSent
	OfferStatusEnumSentManually
	OfferStatusEnumOpened
	OfferStatusEnumDenied
	OfferStatusEnumSigned
	OfferStatusEnumDeprecated
)

func (o OfferStatusEnum) String() string {
	switch o {
	default:
		return strconv.Itoa(int(o))
	case OfferStatusEnumDraft:
		return "DRAFT"
	case OfferStatusEnumApprovalSent:
		return "APPROVAL-SENT"
	case OfferStatusEnumApproved:
		return "APPROVED"
	case OfferStatusEnumSent:
		return "SENT"
	case OfferStatusEnumSentManually:
		return "SENT-MANUALLY"
	case OfferStatusEnumOpened:
		return "OPENED"
	case OfferStatusEnumDenied:
		return "DENIED"
	case OfferStatusEnumSigned:
		return "SIGNED"
	case OfferStatusEnumDeprecated:
		return "DEPRECATED"
	}
}

func (o OfferStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", o.String())), nil
}

func (o *OfferStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "DRAFT":
		value := OfferStatusEnumDraft
		*o = value
	case "APPROVAL-SENT":
		value := OfferStatusEnumApprovalSent
		*o = value
	case "APPROVED":
		value := OfferStatusEnumApproved
		*o = value
	case "SENT":
		value := OfferStatusEnumSent
		*o = value
	case "SENT-MANUALLY":
		value := OfferStatusEnumSentManually
		*o = value
	case "OPENED":
		value := OfferStatusEnumOpened
		*o = value
	case "DENIED":
		value := OfferStatusEnumDenied
		*o = value
	case "SIGNED":
		value := OfferStatusEnumSigned
		*o = value
	case "DEPRECATED":
		value := OfferStatusEnumDeprecated
		*o = value
	}
	return nil
}

// # The Office Object
//
// ### Description
//
// The `Office` object is used to represent an office within a company. A given `Job` has the `Office` ID in its offices field.
//
// ### Usage Example
//
// Fetch from the `LIST Offices` endpoint and view the offices within a company.
type Office struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The office's name.
	Name *string `json:"name,omitempty"`
	// The office's location.
	Location *string `json:"location,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

type OperatorSchema struct {
	// The operator for which an operator schema is defined.
	Operator *string `json:"operator,omitempty"`
	// Whether the operator can be repeated multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
}

// - `DEFINITELY_NO` - DEFINITELY_NO
// - `NO` - NO
// - `YES` - YES
// - `STRONG_YES` - STRONG_YES
// - `NO_DECISION` - NO_DECISION
type OverallRecommendationEnum uint

const (
	OverallRecommendationEnumDefinitelyNo OverallRecommendationEnum = iota + 1
	OverallRecommendationEnumNo
	OverallRecommendationEnumYes
	OverallRecommendationEnumStrongYes
	OverallRecommendationEnumNoDecision
)

func (o OverallRecommendationEnum) String() string {
	switch o {
	default:
		return strconv.Itoa(int(o))
	case OverallRecommendationEnumDefinitelyNo:
		return "DEFINITELY_NO"
	case OverallRecommendationEnumNo:
		return "NO"
	case OverallRecommendationEnumYes:
		return "YES"
	case OverallRecommendationEnumStrongYes:
		return "STRONG_YES"
	case OverallRecommendationEnumNoDecision:
		return "NO_DECISION"
	}
}

func (o OverallRecommendationEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", o.String())), nil
}

func (o *OverallRecommendationEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "DEFINITELY_NO":
		value := OverallRecommendationEnumDefinitelyNo
		*o = value
	case "NO":
		value := OverallRecommendationEnumNo
		*o = value
	case "YES":
		value := OverallRecommendationEnumYes
		*o = value
	case "STRONG_YES":
		value := OverallRecommendationEnumStrongYes
		*o = value
	case "NO_DECISION":
		value := OverallRecommendationEnumNoDecision
		*o = value
	}
	return nil
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty"`
}

type PaginatedActivityList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*Activity `json:"results,omitempty"`
}

type PaginatedApplicationList struct {
	Next     *string        `json:"next,omitempty"`
	Previous *string        `json:"previous,omitempty"`
	Results  []*Application `json:"results,omitempty"`
}

type PaginatedAttachmentList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*Attachment `json:"results,omitempty"`
}

type PaginatedAuditLogEventList struct {
	Next     *string          `json:"next,omitempty"`
	Previous *string          `json:"previous,omitempty"`
	Results  []*AuditLogEvent `json:"results,omitempty"`
}

type PaginatedCandidateList struct {
	Next     *string      `json:"next,omitempty"`
	Previous *string      `json:"previous,omitempty"`
	Results  []*Candidate `json:"results,omitempty"`
}

type PaginatedConditionSchemaList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*ConditionSchema `json:"results,omitempty"`
}

type PaginatedDepartmentList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*Department `json:"results,omitempty"`
}

type PaginatedEeocList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Eeoc `json:"results,omitempty"`
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty"`
}

type PaginatedJobInterviewStageList struct {
	Next     *string              `json:"next,omitempty"`
	Previous *string              `json:"previous,omitempty"`
	Results  []*JobInterviewStage `json:"results,omitempty"`
}

type PaginatedJobList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Job  `json:"results,omitempty"`
}

type PaginatedOfferList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Offer `json:"results,omitempty"`
}

type PaginatedOfficeList struct {
	Next     *string   `json:"next,omitempty"`
	Previous *string   `json:"previous,omitempty"`
	Results  []*Office `json:"results,omitempty"`
}

type PaginatedRejectReasonList struct {
	Next     *string         `json:"next,omitempty"`
	Previous *string         `json:"previous,omitempty"`
	Results  []*RejectReason `json:"results,omitempty"`
}

type PaginatedRemoteUserList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*RemoteUser `json:"results,omitempty"`
}

type PaginatedScheduledInterviewList struct {
	Next     *string               `json:"next,omitempty"`
	Previous *string               `json:"previous,omitempty"`
	Results  []*ScheduledInterview `json:"results,omitempty"`
}

type PaginatedScorecardList struct {
	Next     *string      `json:"next,omitempty"`
	Previous *string      `json:"previous,omitempty"`
	Results  []*Scorecard `json:"results,omitempty"`
}

type PaginatedScreeningQuestionList struct {
	Next     *string              `json:"next,omitempty"`
	Previous *string              `json:"previous,omitempty"`
	Results  []*ScreeningQuestion `json:"results,omitempty"`
}

type PaginatedSyncStatusList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*SyncStatus `json:"results,omitempty"`
}

type PaginatedTagList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Tag  `json:"results,omitempty"`
}

// # The Candidate Object
//
// ### Description
//
// The `Candidate` object is used to represent profile information about a given Candidate. Because it is specific to a Candidate, this information stays constant across applications.
//
// ### Usage Example
//
// Fetch from the `LIST Candidates` endpoint and filter by `ID` to show all candidates.
type PatchedCandidateRequest struct {
	// The candidate's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The candidate's last name.
	LastName *string `json:"last_name,omitempty"`
	// The candidate's current company.
	Company *string `json:"company,omitempty"`
	// The candidate's current title.
	Title *string `json:"title,omitempty"`
	// When the most recent interaction with the candidate occurred.
	LastInteractionAt *time.Time `json:"last_interaction_at,omitempty"`
	// Whether or not the candidate is private.
	IsPrivate *bool `json:"is_private,omitempty"`
	// Whether or not the candidate can be emailed.
	CanEmail *bool `json:"can_email,omitempty"`
	// The candidate's locations.
	Locations      []*string              `json:"locations,omitempty"`
	PhoneNumbers   []*PhoneNumberRequest  `json:"phone_numbers,omitempty"`
	EmailAddresses []*EmailAddressRequest `json:"email_addresses,omitempty"`
	Urls           []*UrlRequest          `json:"urls,omitempty"`
	// Array of `Tag` names as strings.
	Tags []*string `json:"tags,omitempty"`
	// Array of `Application` object IDs.
	Applications []*string `json:"applications,omitempty"`
	// Array of `Attachment` object IDs.
	Attachments         []*string      `json:"attachments,omitempty"`
	RemoteTemplateId    *string        `json:"remote_template_id,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

// # The PhoneNumber Object
//
// ### Description
//
// The `PhoneNumber` object is used to represent a candidate's phone number.
//
// ### Usage Example
//
// Fetch from the `GET Candidate` endpoint and view their phone numbers.
type PhoneNumber struct {
	// The phone number.
	Value *string `json:"value,omitempty"`
	// The type of phone number.
	//
	// - `HOME` - HOME
	// - `WORK` - WORK
	// - `MOBILE` - MOBILE
	// - `SKYPE` - SKYPE
	// - `OTHER` - OTHER
	PhoneNumberType *PhoneNumberPhoneNumberType `json:"phone_number_type,omitempty"`
	CreatedAt       *time.Time                  `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// The type of phone number.
//
// - `HOME` - HOME
// - `WORK` - WORK
// - `MOBILE` - MOBILE
// - `SKYPE` - SKYPE
// - `OTHER` - OTHER
type PhoneNumberPhoneNumberType struct {
	typeName            string
	PhoneNumberTypeEnum PhoneNumberTypeEnum
	String              string
}

func NewPhoneNumberPhoneNumberTypeFromPhoneNumberTypeEnum(value PhoneNumberTypeEnum) *PhoneNumberPhoneNumberType {
	return &PhoneNumberPhoneNumberType{typeName: "phoneNumberTypeEnum", PhoneNumberTypeEnum: value}
}

func NewPhoneNumberPhoneNumberTypeFromString(value string) *PhoneNumberPhoneNumberType {
	return &PhoneNumberPhoneNumberType{typeName: "string", String: value}
}

func (p *PhoneNumberPhoneNumberType) UnmarshalJSON(data []byte) error {
	var valuePhoneNumberTypeEnum PhoneNumberTypeEnum
	if err := json.Unmarshal(data, &valuePhoneNumberTypeEnum); err == nil {
		p.typeName = "phoneNumberTypeEnum"
		p.PhoneNumberTypeEnum = valuePhoneNumberTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PhoneNumberPhoneNumberType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "phoneNumberTypeEnum":
		return json.Marshal(p.PhoneNumberTypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PhoneNumberPhoneNumberTypeVisitor interface {
	VisitPhoneNumberTypeEnum(PhoneNumberTypeEnum) error
	VisitString(string) error
}

func (p *PhoneNumberPhoneNumberType) Accept(visitor PhoneNumberPhoneNumberTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "phoneNumberTypeEnum":
		return visitor.VisitPhoneNumberTypeEnum(p.PhoneNumberTypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// # The PhoneNumber Object
//
// ### Description
//
// The `PhoneNumber` object is used to represent a candidate's phone number.
//
// ### Usage Example
//
// Fetch from the `GET Candidate` endpoint and view their phone numbers.
type PhoneNumberRequest struct {
	// The phone number.
	Value *string `json:"value,omitempty"`
	// The type of phone number.
	//
	// - `HOME` - HOME
	// - `WORK` - WORK
	// - `MOBILE` - MOBILE
	// - `SKYPE` - SKYPE
	// - `OTHER` - OTHER
	PhoneNumberType     *PhoneNumberRequestPhoneNumberType `json:"phone_number_type,omitempty"`
	IntegrationParams   map[string]any                     `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any                     `json:"linked_account_params,omitempty"`
}

// The type of phone number.
//
// - `HOME` - HOME
// - `WORK` - WORK
// - `MOBILE` - MOBILE
// - `SKYPE` - SKYPE
// - `OTHER` - OTHER
type PhoneNumberRequestPhoneNumberType struct {
	typeName            string
	PhoneNumberTypeEnum PhoneNumberTypeEnum
	String              string
}

func NewPhoneNumberRequestPhoneNumberTypeFromPhoneNumberTypeEnum(value PhoneNumberTypeEnum) *PhoneNumberRequestPhoneNumberType {
	return &PhoneNumberRequestPhoneNumberType{typeName: "phoneNumberTypeEnum", PhoneNumberTypeEnum: value}
}

func NewPhoneNumberRequestPhoneNumberTypeFromString(value string) *PhoneNumberRequestPhoneNumberType {
	return &PhoneNumberRequestPhoneNumberType{typeName: "string", String: value}
}

func (p *PhoneNumberRequestPhoneNumberType) UnmarshalJSON(data []byte) error {
	var valuePhoneNumberTypeEnum PhoneNumberTypeEnum
	if err := json.Unmarshal(data, &valuePhoneNumberTypeEnum); err == nil {
		p.typeName = "phoneNumberTypeEnum"
		p.PhoneNumberTypeEnum = valuePhoneNumberTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PhoneNumberRequestPhoneNumberType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "phoneNumberTypeEnum":
		return json.Marshal(p.PhoneNumberTypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PhoneNumberRequestPhoneNumberTypeVisitor interface {
	VisitPhoneNumberTypeEnum(PhoneNumberTypeEnum) error
	VisitString(string) error
}

func (p *PhoneNumberRequestPhoneNumberType) Accept(visitor PhoneNumberRequestPhoneNumberTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "phoneNumberTypeEnum":
		return visitor.VisitPhoneNumberTypeEnum(p.PhoneNumberTypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// - `HOME` - HOME
// - `WORK` - WORK
// - `MOBILE` - MOBILE
// - `SKYPE` - SKYPE
// - `OTHER` - OTHER
type PhoneNumberTypeEnum uint

const (
	PhoneNumberTypeEnumHome PhoneNumberTypeEnum = iota + 1
	PhoneNumberTypeEnumWork
	PhoneNumberTypeEnumMobile
	PhoneNumberTypeEnumSkype
	PhoneNumberTypeEnumOther
)

func (p PhoneNumberTypeEnum) String() string {
	switch p {
	default:
		return strconv.Itoa(int(p))
	case PhoneNumberTypeEnumHome:
		return "HOME"
	case PhoneNumberTypeEnumWork:
		return "WORK"
	case PhoneNumberTypeEnumMobile:
		return "MOBILE"
	case PhoneNumberTypeEnumSkype:
		return "SKYPE"
	case PhoneNumberTypeEnumOther:
		return "OTHER"
	}
}

func (p PhoneNumberTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", p.String())), nil
}

func (p *PhoneNumberTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "HOME":
		value := PhoneNumberTypeEnumHome
		*p = value
	case "WORK":
		value := PhoneNumberTypeEnumWork
		*p = value
	case "MOBILE":
		value := PhoneNumberTypeEnumMobile
		*p = value
	case "SKYPE":
		value := PhoneNumberTypeEnumSkype
		*p = value
	case "OTHER":
		value := PhoneNumberTypeEnumOther
		*p = value
	}
	return nil
}

// - `AMERICAN_INDIAN_OR_ALASKAN_NATIVE` - AMERICAN_INDIAN_OR_ALASKAN_NATIVE
// - `ASIAN` - ASIAN
// - `BLACK_OR_AFRICAN_AMERICAN` - BLACK_OR_AFRICAN_AMERICAN
// - `HISPANIC_OR_LATINO` - HISPANIC_OR_LATINO
// - `WHITE` - WHITE
// - `NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER` - NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER
// - `TWO_OR_MORE_RACES` - TWO_OR_MORE_RACES
// - `DECLINE_TO_SELF_IDENTIFY` - DECLINE_TO_SELF_IDENTIFY
type RaceEnum uint

const (
	RaceEnumAmericanIndianOrAlaskanNative RaceEnum = iota + 1
	RaceEnumAsian
	RaceEnumBlackOrAfricanAmerican
	RaceEnumHispanicOrLatino
	RaceEnumWhite
	RaceEnumNativeHawaiianOrOtherPacificIslander
	RaceEnumTwoOrMoreRaces
	RaceEnumDeclineToSelfIdentify
)

func (r RaceEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RaceEnumAmericanIndianOrAlaskanNative:
		return "AMERICAN_INDIAN_OR_ALASKAN_NATIVE"
	case RaceEnumAsian:
		return "ASIAN"
	case RaceEnumBlackOrAfricanAmerican:
		return "BLACK_OR_AFRICAN_AMERICAN"
	case RaceEnumHispanicOrLatino:
		return "HISPANIC_OR_LATINO"
	case RaceEnumWhite:
		return "WHITE"
	case RaceEnumNativeHawaiianOrOtherPacificIslander:
		return "NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER"
	case RaceEnumTwoOrMoreRaces:
		return "TWO_OR_MORE_RACES"
	case RaceEnumDeclineToSelfIdentify:
		return "DECLINE_TO_SELF_IDENTIFY"
	}
}

func (r RaceEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RaceEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "AMERICAN_INDIAN_OR_ALASKAN_NATIVE":
		value := RaceEnumAmericanIndianOrAlaskanNative
		*r = value
	case "ASIAN":
		value := RaceEnumAsian
		*r = value
	case "BLACK_OR_AFRICAN_AMERICAN":
		value := RaceEnumBlackOrAfricanAmerican
		*r = value
	case "HISPANIC_OR_LATINO":
		value := RaceEnumHispanicOrLatino
		*r = value
	case "WHITE":
		value := RaceEnumWhite
		*r = value
	case "NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER":
		value := RaceEnumNativeHawaiianOrOtherPacificIslander
		*r = value
	case "TWO_OR_MORE_RACES":
		value := RaceEnumTwoOrMoreRaces
		*r = value
	case "DECLINE_TO_SELF_IDENTIFY":
		value := RaceEnumDeclineToSelfIdentify
		*r = value
	}
	return nil
}

// - `GENERAL_CUSTOMER_REQUEST` - GENERAL_CUSTOMER_REQUEST
// - `GDPR` - GDPR
// - `OTHER` - OTHER
type ReasonEnum uint

const (
	ReasonEnumGeneralCustomerRequest ReasonEnum = iota + 1
	ReasonEnumGdpr
	ReasonEnumOther
)

func (r ReasonEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case ReasonEnumGeneralCustomerRequest:
		return "GENERAL_CUSTOMER_REQUEST"
	case ReasonEnumGdpr:
		return "GDPR"
	case ReasonEnumOther:
		return "OTHER"
	}
}

func (r ReasonEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *ReasonEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GENERAL_CUSTOMER_REQUEST":
		value := ReasonEnumGeneralCustomerRequest
		*r = value
	case "GDPR":
		value := ReasonEnumGdpr
		*r = value
	case "OTHER":
		value := ReasonEnumOther
		*r = value
	}
	return nil
}

// # The RejectReason Object
//
// ### Description
//
// The `RejectReason` object is used to represent a reason for rejecting an application. These can typically be configured within an ATS system.
//
// ### Usage Example
//
// Fetch from the `LIST RejectReasons` endpoint and filter by `ID` to show all reasons.
type RejectReason struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The rejection reason’s name.
	Name *string `json:"name,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

type RemoteData struct {
	Path string         `json:"path"`
	Data map[string]any `json:"data,omitempty"`
}

// # The RemoteKey Object
//
// ### Description
//
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
//
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name"`
	Key  string `json:"key"`
}

// # The RemoteResponse Object
//
// ### Description
//
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
//
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                      `json:"method"`
	Path            string                      `json:"path"`
	Status          int                         `json:"status"`
	Response        any                         `json:"response,omitempty"`
	ResponseHeaders map[string]any              `json:"response_headers,omitempty"`
	ResponseType    *RemoteResponseResponseType `json:"response_type,omitempty"`
	Headers         map[string]any              `json:"headers,omitempty"`
}

type RemoteResponseResponseType struct {
	typeName         string
	ResponseTypeEnum ResponseTypeEnum
	String           string
}

func NewRemoteResponseResponseTypeFromResponseTypeEnum(value ResponseTypeEnum) *RemoteResponseResponseType {
	return &RemoteResponseResponseType{typeName: "responseTypeEnum", ResponseTypeEnum: value}
}

func NewRemoteResponseResponseTypeFromString(value string) *RemoteResponseResponseType {
	return &RemoteResponseResponseType{typeName: "string", String: value}
}

func (r *RemoteResponseResponseType) UnmarshalJSON(data []byte) error {
	var valueResponseTypeEnum ResponseTypeEnum
	if err := json.Unmarshal(data, &valueResponseTypeEnum); err == nil {
		r.typeName = "responseTypeEnum"
		r.ResponseTypeEnum = valueResponseTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteResponseResponseType) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "responseTypeEnum":
		return json.Marshal(r.ResponseTypeEnum)
	case "string":
		return json.Marshal(r.String)
	}
}

type RemoteResponseResponseTypeVisitor interface {
	VisitResponseTypeEnum(ResponseTypeEnum) error
	VisitString(string) error
}

func (r *RemoteResponseResponseType) Accept(visitor RemoteResponseResponseTypeVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "responseTypeEnum":
		return visitor.VisitResponseTypeEnum(r.ResponseTypeEnum)
	case "string":
		return visitor.VisitString(r.String)
	}
}

// # The RemoteUser Object
//
// ### Description
//
// The `RemoteUser` object is used to represent a user with a login to the ATS system.
//
// ### Usage Example
//
// Fetch from the `LIST RemoteUsers` endpoint to show all users for a third party.
type RemoteUser struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The user's last name.
	LastName *string `json:"last_name,omitempty"`
	// The user's email.
	Email *string `json:"email,omitempty"`
	// Whether the user's account had been disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// When the third party's user was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The user's role.
	//
	// - `SUPER_ADMIN` - SUPER_ADMIN
	// - `ADMIN` - ADMIN
	// - `TEAM_MEMBER` - TEAM_MEMBER
	// - `LIMITED_TEAM_MEMBER` - LIMITED_TEAM_MEMBER
	// - `INTERVIEWER` - INTERVIEWER
	AccessRole *RemoteUserAccessRole `json:"access_role,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The user's role.
//
// - `SUPER_ADMIN` - SUPER_ADMIN
// - `ADMIN` - ADMIN
// - `TEAM_MEMBER` - TEAM_MEMBER
// - `LIMITED_TEAM_MEMBER` - LIMITED_TEAM_MEMBER
// - `INTERVIEWER` - INTERVIEWER
type RemoteUserAccessRole struct {
	typeName       string
	AccessRoleEnum AccessRoleEnum
	String         string
}

func NewRemoteUserAccessRoleFromAccessRoleEnum(value AccessRoleEnum) *RemoteUserAccessRole {
	return &RemoteUserAccessRole{typeName: "accessRoleEnum", AccessRoleEnum: value}
}

func NewRemoteUserAccessRoleFromString(value string) *RemoteUserAccessRole {
	return &RemoteUserAccessRole{typeName: "string", String: value}
}

func (r *RemoteUserAccessRole) UnmarshalJSON(data []byte) error {
	var valueAccessRoleEnum AccessRoleEnum
	if err := json.Unmarshal(data, &valueAccessRoleEnum); err == nil {
		r.typeName = "accessRoleEnum"
		r.AccessRoleEnum = valueAccessRoleEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteUserAccessRole) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "accessRoleEnum":
		return json.Marshal(r.AccessRoleEnum)
	case "string":
		return json.Marshal(r.String)
	}
}

type RemoteUserAccessRoleVisitor interface {
	VisitAccessRoleEnum(AccessRoleEnum) error
	VisitString(string) error
}

func (r *RemoteUserAccessRole) Accept(visitor RemoteUserAccessRoleVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "accessRoleEnum":
		return visitor.VisitAccessRoleEnum(r.AccessRoleEnum)
	case "string":
		return visitor.VisitString(r.String)
	}
}

// - `JSON` - JSON
// - `XML` - XML
// - `MULTIPART` - MULTIPART
type RequestFormatEnum uint

const (
	RequestFormatEnumJson RequestFormatEnum = iota + 1
	RequestFormatEnumXml
	RequestFormatEnumMultipart
)

func (r RequestFormatEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RequestFormatEnumJson:
		return "JSON"
	case RequestFormatEnumXml:
		return "XML"
	case RequestFormatEnumMultipart:
		return "MULTIPART"
	}
}

func (r RequestFormatEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RequestFormatEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := RequestFormatEnumJson
		*r = value
	case "XML":
		value := RequestFormatEnumXml
		*r = value
	case "MULTIPART":
		value := RequestFormatEnumMultipart
		*r = value
	}
	return nil
}

// - `JSON` - JSON
// - `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum uint

const (
	ResponseTypeEnumJson ResponseTypeEnum = iota + 1
	ResponseTypeEnumBase64Gzip
)

func (r ResponseTypeEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case ResponseTypeEnumJson:
		return "JSON"
	case ResponseTypeEnumBase64Gzip:
		return "BASE64_GZIP"
	}
}

func (r ResponseTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *ResponseTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := ResponseTypeEnumJson
		*r = value
	case "BASE64_GZIP":
		value := ResponseTypeEnumBase64Gzip
		*r = value
	}
	return nil
}

// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type RoleEnum uint

const (
	RoleEnumAdmin RoleEnum = iota + 1
	RoleEnumDeveloper
	RoleEnumMember
	RoleEnumApi
	RoleEnumSystem
	RoleEnumMergeTeam
)

func (r RoleEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RoleEnumAdmin:
		return "ADMIN"
	case RoleEnumDeveloper:
		return "DEVELOPER"
	case RoleEnumMember:
		return "MEMBER"
	case RoleEnumApi:
		return "API"
	case RoleEnumSystem:
		return "SYSTEM"
	case RoleEnumMergeTeam:
		return "MERGE_TEAM"
	}
}

func (r RoleEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RoleEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ADMIN":
		value := RoleEnumAdmin
		*r = value
	case "DEVELOPER":
		value := RoleEnumDeveloper
		*r = value
	case "MEMBER":
		value := RoleEnumMember
		*r = value
	case "API":
		value := RoleEnumApi
		*r = value
	case "SYSTEM":
		value := RoleEnumSystem
		*r = value
	case "MERGE_TEAM":
		value := RoleEnumMergeTeam
		*r = value
	}
	return nil
}

// # The ScheduledInterview Object
//
// ### Description
//
// The `ScheduledInterview` object is used to represent a scheduled interview for a given candidate’s application to a job. An `Application` can have multiple `ScheduledInterview`s depending on the particular hiring process.
//
// ### Usage Example
//
// Fetch from the `LIST ScheduledInterviews` endpoint and filter by `interviewers` to show all office locations.
type ScheduledInterview struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The application being interviewed.
	Application *ScheduledInterviewApplication `json:"application,omitempty"`
	// The stage of the interview.
	JobInterviewStage *ScheduledInterviewJobInterviewStage `json:"job_interview_stage,omitempty"`
	// The user organizing the interview.
	Organizer *ScheduledInterviewOrganizer `json:"organizer,omitempty"`
	// Array of `RemoteUser` IDs.
	Interviewers []*ScheduledInterviewInterviewersItem `json:"interviewers,omitempty"`
	// The interview's location.
	Location *string `json:"location,omitempty"`
	// When the interview was started.
	StartAt *time.Time `json:"start_at,omitempty"`
	// When the interview was ended.
	EndAt *time.Time `json:"end_at,omitempty"`
	// When the third party's interview was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's interview was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// The interview's status.
	//
	// - `SCHEDULED` - SCHEDULED
	// - `AWAITING_FEEDBACK` - AWAITING_FEEDBACK
	// - `COMPLETE` - COMPLETE
	Status *ScheduledInterviewStatus `json:"status,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The application being interviewed.
type ScheduledInterviewApplication struct {
	typeName    string
	String      string
	Application *Application
}

func NewScheduledInterviewApplicationFromString(value string) *ScheduledInterviewApplication {
	return &ScheduledInterviewApplication{typeName: "string", String: value}
}

func NewScheduledInterviewApplicationFromApplication(value *Application) *ScheduledInterviewApplication {
	return &ScheduledInterviewApplication{typeName: "application", Application: value}
}

func (s *ScheduledInterviewApplication) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		s.typeName = "application"
		s.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewApplication) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "application":
		return json.Marshal(s.Application)
	}
}

type ScheduledInterviewApplicationVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (s *ScheduledInterviewApplication) Accept(visitor ScheduledInterviewApplicationVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "application":
		return visitor.VisitApplication(s.Application)
	}
}

type ScheduledInterviewInterviewersItem struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewScheduledInterviewInterviewersItemFromString(value string) *ScheduledInterviewInterviewersItem {
	return &ScheduledInterviewInterviewersItem{typeName: "string", String: value}
}

func NewScheduledInterviewInterviewersItemFromRemoteUser(value *RemoteUser) *ScheduledInterviewInterviewersItem {
	return &ScheduledInterviewInterviewersItem{typeName: "remoteUser", RemoteUser: value}
}

func (s *ScheduledInterviewInterviewersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		s.typeName = "remoteUser"
		s.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewInterviewersItem) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "remoteUser":
		return json.Marshal(s.RemoteUser)
	}
}

type ScheduledInterviewInterviewersItemVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (s *ScheduledInterviewInterviewersItem) Accept(visitor ScheduledInterviewInterviewersItemVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(s.RemoteUser)
	}
}

// The stage of the interview.
type ScheduledInterviewJobInterviewStage struct {
	typeName          string
	String            string
	JobInterviewStage *JobInterviewStage
}

func NewScheduledInterviewJobInterviewStageFromString(value string) *ScheduledInterviewJobInterviewStage {
	return &ScheduledInterviewJobInterviewStage{typeName: "string", String: value}
}

func NewScheduledInterviewJobInterviewStageFromJobInterviewStage(value *JobInterviewStage) *ScheduledInterviewJobInterviewStage {
	return &ScheduledInterviewJobInterviewStage{typeName: "jobInterviewStage", JobInterviewStage: value}
}

func (s *ScheduledInterviewJobInterviewStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueJobInterviewStage := new(JobInterviewStage)
	if err := json.Unmarshal(data, &valueJobInterviewStage); err == nil {
		s.typeName = "jobInterviewStage"
		s.JobInterviewStage = valueJobInterviewStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewJobInterviewStage) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "jobInterviewStage":
		return json.Marshal(s.JobInterviewStage)
	}
}

type ScheduledInterviewJobInterviewStageVisitor interface {
	VisitString(string) error
	VisitJobInterviewStage(*JobInterviewStage) error
}

func (s *ScheduledInterviewJobInterviewStage) Accept(visitor ScheduledInterviewJobInterviewStageVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "jobInterviewStage":
		return visitor.VisitJobInterviewStage(s.JobInterviewStage)
	}
}

// The user organizing the interview.
type ScheduledInterviewOrganizer struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewScheduledInterviewOrganizerFromString(value string) *ScheduledInterviewOrganizer {
	return &ScheduledInterviewOrganizer{typeName: "string", String: value}
}

func NewScheduledInterviewOrganizerFromRemoteUser(value *RemoteUser) *ScheduledInterviewOrganizer {
	return &ScheduledInterviewOrganizer{typeName: "remoteUser", RemoteUser: value}
}

func (s *ScheduledInterviewOrganizer) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		s.typeName = "remoteUser"
		s.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewOrganizer) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "remoteUser":
		return json.Marshal(s.RemoteUser)
	}
}

type ScheduledInterviewOrganizerVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (s *ScheduledInterviewOrganizer) Accept(visitor ScheduledInterviewOrganizerVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(s.RemoteUser)
	}
}

// # The ScheduledInterview Object
//
// ### Description
//
// The `ScheduledInterview` object is used to represent a scheduled interview for a given candidate’s application to a job. An `Application` can have multiple `ScheduledInterview`s depending on the particular hiring process.
//
// ### Usage Example
//
// Fetch from the `LIST ScheduledInterviews` endpoint and filter by `interviewers` to show all office locations.
type ScheduledInterviewRequest struct {
	// The application being interviewed.
	Application *ScheduledInterviewRequestApplication `json:"application,omitempty"`
	// The stage of the interview.
	JobInterviewStage *ScheduledInterviewRequestJobInterviewStage `json:"job_interview_stage,omitempty"`
	// The user organizing the interview.
	Organizer *ScheduledInterviewRequestOrganizer `json:"organizer,omitempty"`
	// Array of `RemoteUser` IDs.
	Interviewers []*ScheduledInterviewRequestInterviewersItem `json:"interviewers,omitempty"`
	// The interview's location.
	Location *string `json:"location,omitempty"`
	// When the interview was started.
	StartAt *time.Time `json:"start_at,omitempty"`
	// When the interview was ended.
	EndAt *time.Time `json:"end_at,omitempty"`
	// The interview's status.
	//
	// - `SCHEDULED` - SCHEDULED
	// - `AWAITING_FEEDBACK` - AWAITING_FEEDBACK
	// - `COMPLETE` - COMPLETE
	Status              *ScheduledInterviewRequestStatus `json:"status,omitempty"`
	IntegrationParams   map[string]any                   `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any                   `json:"linked_account_params,omitempty"`
}

// The application being interviewed.
type ScheduledInterviewRequestApplication struct {
	typeName    string
	String      string
	Application *Application
}

func NewScheduledInterviewRequestApplicationFromString(value string) *ScheduledInterviewRequestApplication {
	return &ScheduledInterviewRequestApplication{typeName: "string", String: value}
}

func NewScheduledInterviewRequestApplicationFromApplication(value *Application) *ScheduledInterviewRequestApplication {
	return &ScheduledInterviewRequestApplication{typeName: "application", Application: value}
}

func (s *ScheduledInterviewRequestApplication) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		s.typeName = "application"
		s.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewRequestApplication) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "application":
		return json.Marshal(s.Application)
	}
}

type ScheduledInterviewRequestApplicationVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (s *ScheduledInterviewRequestApplication) Accept(visitor ScheduledInterviewRequestApplicationVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "application":
		return visitor.VisitApplication(s.Application)
	}
}

type ScheduledInterviewRequestInterviewersItem struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewScheduledInterviewRequestInterviewersItemFromString(value string) *ScheduledInterviewRequestInterviewersItem {
	return &ScheduledInterviewRequestInterviewersItem{typeName: "string", String: value}
}

func NewScheduledInterviewRequestInterviewersItemFromRemoteUser(value *RemoteUser) *ScheduledInterviewRequestInterviewersItem {
	return &ScheduledInterviewRequestInterviewersItem{typeName: "remoteUser", RemoteUser: value}
}

func (s *ScheduledInterviewRequestInterviewersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		s.typeName = "remoteUser"
		s.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewRequestInterviewersItem) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "remoteUser":
		return json.Marshal(s.RemoteUser)
	}
}

type ScheduledInterviewRequestInterviewersItemVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (s *ScheduledInterviewRequestInterviewersItem) Accept(visitor ScheduledInterviewRequestInterviewersItemVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(s.RemoteUser)
	}
}

// The stage of the interview.
type ScheduledInterviewRequestJobInterviewStage struct {
	typeName          string
	String            string
	JobInterviewStage *JobInterviewStage
}

func NewScheduledInterviewRequestJobInterviewStageFromString(value string) *ScheduledInterviewRequestJobInterviewStage {
	return &ScheduledInterviewRequestJobInterviewStage{typeName: "string", String: value}
}

func NewScheduledInterviewRequestJobInterviewStageFromJobInterviewStage(value *JobInterviewStage) *ScheduledInterviewRequestJobInterviewStage {
	return &ScheduledInterviewRequestJobInterviewStage{typeName: "jobInterviewStage", JobInterviewStage: value}
}

func (s *ScheduledInterviewRequestJobInterviewStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueJobInterviewStage := new(JobInterviewStage)
	if err := json.Unmarshal(data, &valueJobInterviewStage); err == nil {
		s.typeName = "jobInterviewStage"
		s.JobInterviewStage = valueJobInterviewStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewRequestJobInterviewStage) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "jobInterviewStage":
		return json.Marshal(s.JobInterviewStage)
	}
}

type ScheduledInterviewRequestJobInterviewStageVisitor interface {
	VisitString(string) error
	VisitJobInterviewStage(*JobInterviewStage) error
}

func (s *ScheduledInterviewRequestJobInterviewStage) Accept(visitor ScheduledInterviewRequestJobInterviewStageVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "jobInterviewStage":
		return visitor.VisitJobInterviewStage(s.JobInterviewStage)
	}
}

// The user organizing the interview.
type ScheduledInterviewRequestOrganizer struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewScheduledInterviewRequestOrganizerFromString(value string) *ScheduledInterviewRequestOrganizer {
	return &ScheduledInterviewRequestOrganizer{typeName: "string", String: value}
}

func NewScheduledInterviewRequestOrganizerFromRemoteUser(value *RemoteUser) *ScheduledInterviewRequestOrganizer {
	return &ScheduledInterviewRequestOrganizer{typeName: "remoteUser", RemoteUser: value}
}

func (s *ScheduledInterviewRequestOrganizer) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		s.typeName = "remoteUser"
		s.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewRequestOrganizer) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "remoteUser":
		return json.Marshal(s.RemoteUser)
	}
}

type ScheduledInterviewRequestOrganizerVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (s *ScheduledInterviewRequestOrganizer) Accept(visitor ScheduledInterviewRequestOrganizerVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(s.RemoteUser)
	}
}

// The interview's status.
//
// - `SCHEDULED` - SCHEDULED
// - `AWAITING_FEEDBACK` - AWAITING_FEEDBACK
// - `COMPLETE` - COMPLETE
type ScheduledInterviewRequestStatus struct {
	typeName                     string
	ScheduledInterviewStatusEnum ScheduledInterviewStatusEnum
	String                       string
}

func NewScheduledInterviewRequestStatusFromScheduledInterviewStatusEnum(value ScheduledInterviewStatusEnum) *ScheduledInterviewRequestStatus {
	return &ScheduledInterviewRequestStatus{typeName: "scheduledInterviewStatusEnum", ScheduledInterviewStatusEnum: value}
}

func NewScheduledInterviewRequestStatusFromString(value string) *ScheduledInterviewRequestStatus {
	return &ScheduledInterviewRequestStatus{typeName: "string", String: value}
}

func (s *ScheduledInterviewRequestStatus) UnmarshalJSON(data []byte) error {
	var valueScheduledInterviewStatusEnum ScheduledInterviewStatusEnum
	if err := json.Unmarshal(data, &valueScheduledInterviewStatusEnum); err == nil {
		s.typeName = "scheduledInterviewStatusEnum"
		s.ScheduledInterviewStatusEnum = valueScheduledInterviewStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewRequestStatus) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "scheduledInterviewStatusEnum":
		return json.Marshal(s.ScheduledInterviewStatusEnum)
	case "string":
		return json.Marshal(s.String)
	}
}

type ScheduledInterviewRequestStatusVisitor interface {
	VisitScheduledInterviewStatusEnum(ScheduledInterviewStatusEnum) error
	VisitString(string) error
}

func (s *ScheduledInterviewRequestStatus) Accept(visitor ScheduledInterviewRequestStatusVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "scheduledInterviewStatusEnum":
		return visitor.VisitScheduledInterviewStatusEnum(s.ScheduledInterviewStatusEnum)
	case "string":
		return visitor.VisitString(s.String)
	}
}

type ScheduledInterviewResponse struct {
	Model    *ScheduledInterview         `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// The interview's status.
//
// - `SCHEDULED` - SCHEDULED
// - `AWAITING_FEEDBACK` - AWAITING_FEEDBACK
// - `COMPLETE` - COMPLETE
type ScheduledInterviewStatus struct {
	typeName                     string
	ScheduledInterviewStatusEnum ScheduledInterviewStatusEnum
	String                       string
}

func NewScheduledInterviewStatusFromScheduledInterviewStatusEnum(value ScheduledInterviewStatusEnum) *ScheduledInterviewStatus {
	return &ScheduledInterviewStatus{typeName: "scheduledInterviewStatusEnum", ScheduledInterviewStatusEnum: value}
}

func NewScheduledInterviewStatusFromString(value string) *ScheduledInterviewStatus {
	return &ScheduledInterviewStatus{typeName: "string", String: value}
}

func (s *ScheduledInterviewStatus) UnmarshalJSON(data []byte) error {
	var valueScheduledInterviewStatusEnum ScheduledInterviewStatusEnum
	if err := json.Unmarshal(data, &valueScheduledInterviewStatusEnum); err == nil {
		s.typeName = "scheduledInterviewStatusEnum"
		s.ScheduledInterviewStatusEnum = valueScheduledInterviewStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScheduledInterviewStatus) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "scheduledInterviewStatusEnum":
		return json.Marshal(s.ScheduledInterviewStatusEnum)
	case "string":
		return json.Marshal(s.String)
	}
}

type ScheduledInterviewStatusVisitor interface {
	VisitScheduledInterviewStatusEnum(ScheduledInterviewStatusEnum) error
	VisitString(string) error
}

func (s *ScheduledInterviewStatus) Accept(visitor ScheduledInterviewStatusVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "scheduledInterviewStatusEnum":
		return visitor.VisitScheduledInterviewStatusEnum(s.ScheduledInterviewStatusEnum)
	case "string":
		return visitor.VisitString(s.String)
	}
}

// - `SCHEDULED` - SCHEDULED
// - `AWAITING_FEEDBACK` - AWAITING_FEEDBACK
// - `COMPLETE` - COMPLETE
type ScheduledInterviewStatusEnum uint

const (
	ScheduledInterviewStatusEnumScheduled ScheduledInterviewStatusEnum = iota + 1
	ScheduledInterviewStatusEnumAwaitingFeedback
	ScheduledInterviewStatusEnumComplete
)

func (s ScheduledInterviewStatusEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case ScheduledInterviewStatusEnumScheduled:
		return "SCHEDULED"
	case ScheduledInterviewStatusEnumAwaitingFeedback:
		return "AWAITING_FEEDBACK"
	case ScheduledInterviewStatusEnumComplete:
		return "COMPLETE"
	}
}

func (s ScheduledInterviewStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *ScheduledInterviewStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SCHEDULED":
		value := ScheduledInterviewStatusEnumScheduled
		*s = value
	case "AWAITING_FEEDBACK":
		value := ScheduledInterviewStatusEnumAwaitingFeedback
		*s = value
	case "COMPLETE":
		value := ScheduledInterviewStatusEnumComplete
		*s = value
	}
	return nil
}

// # The Scorecard Object
//
// ### Description
//
// The `Scorecard` object is used to represent an interviewer's candidate recommendation based on a particular interview.
//
// ### Usage Example
//
// Fetch from the `LIST Scorecards` endpoint and filter by `application` to show all scorecard for an applicant.
type Scorecard struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The application being scored.
	Application *ScorecardApplication `json:"application,omitempty"`
	// The interview being scored.
	Interview *ScorecardInterview `json:"interview,omitempty"`
	// The interviewer doing the scoring.
	Interviewer *ScorecardInterviewer `json:"interviewer,omitempty"`
	// When the third party's scorecard was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the scorecard was submitted.
	SubmittedAt *time.Time `json:"submitted_at,omitempty"`
	// The inteviewer's recommendation.
	//
	// - `DEFINITELY_NO` - DEFINITELY_NO
	// - `NO` - NO
	// - `YES` - YES
	// - `STRONG_YES` - STRONG_YES
	// - `NO_DECISION` - NO_DECISION
	OverallRecommendation *ScorecardOverallRecommendation `json:"overall_recommendation,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
}

// The application being scored.
type ScorecardApplication struct {
	typeName    string
	String      string
	Application *Application
}

func NewScorecardApplicationFromString(value string) *ScorecardApplication {
	return &ScorecardApplication{typeName: "string", String: value}
}

func NewScorecardApplicationFromApplication(value *Application) *ScorecardApplication {
	return &ScorecardApplication{typeName: "application", Application: value}
}

func (s *ScorecardApplication) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueApplication := new(Application)
	if err := json.Unmarshal(data, &valueApplication); err == nil {
		s.typeName = "application"
		s.Application = valueApplication
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScorecardApplication) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "application":
		return json.Marshal(s.Application)
	}
}

type ScorecardApplicationVisitor interface {
	VisitString(string) error
	VisitApplication(*Application) error
}

func (s *ScorecardApplication) Accept(visitor ScorecardApplicationVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "application":
		return visitor.VisitApplication(s.Application)
	}
}

// The interview being scored.
type ScorecardInterview struct {
	typeName           string
	String             string
	ScheduledInterview *ScheduledInterview
}

func NewScorecardInterviewFromString(value string) *ScorecardInterview {
	return &ScorecardInterview{typeName: "string", String: value}
}

func NewScorecardInterviewFromScheduledInterview(value *ScheduledInterview) *ScorecardInterview {
	return &ScorecardInterview{typeName: "scheduledInterview", ScheduledInterview: value}
}

func (s *ScorecardInterview) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueScheduledInterview := new(ScheduledInterview)
	if err := json.Unmarshal(data, &valueScheduledInterview); err == nil {
		s.typeName = "scheduledInterview"
		s.ScheduledInterview = valueScheduledInterview
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScorecardInterview) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "scheduledInterview":
		return json.Marshal(s.ScheduledInterview)
	}
}

type ScorecardInterviewVisitor interface {
	VisitString(string) error
	VisitScheduledInterview(*ScheduledInterview) error
}

func (s *ScorecardInterview) Accept(visitor ScorecardInterviewVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "scheduledInterview":
		return visitor.VisitScheduledInterview(s.ScheduledInterview)
	}
}

// The interviewer doing the scoring.
type ScorecardInterviewer struct {
	typeName   string
	String     string
	RemoteUser *RemoteUser
}

func NewScorecardInterviewerFromString(value string) *ScorecardInterviewer {
	return &ScorecardInterviewer{typeName: "string", String: value}
}

func NewScorecardInterviewerFromRemoteUser(value *RemoteUser) *ScorecardInterviewer {
	return &ScorecardInterviewer{typeName: "remoteUser", RemoteUser: value}
}

func (s *ScorecardInterviewer) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		s.typeName = "remoteUser"
		s.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScorecardInterviewer) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "remoteUser":
		return json.Marshal(s.RemoteUser)
	}
}

type ScorecardInterviewerVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (s *ScorecardInterviewer) Accept(visitor ScorecardInterviewerVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "remoteUser":
		return visitor.VisitRemoteUser(s.RemoteUser)
	}
}

// The inteviewer's recommendation.
//
// - `DEFINITELY_NO` - DEFINITELY_NO
// - `NO` - NO
// - `YES` - YES
// - `STRONG_YES` - STRONG_YES
// - `NO_DECISION` - NO_DECISION
type ScorecardOverallRecommendation struct {
	typeName                  string
	OverallRecommendationEnum OverallRecommendationEnum
	String                    string
}

func NewScorecardOverallRecommendationFromOverallRecommendationEnum(value OverallRecommendationEnum) *ScorecardOverallRecommendation {
	return &ScorecardOverallRecommendation{typeName: "overallRecommendationEnum", OverallRecommendationEnum: value}
}

func NewScorecardOverallRecommendationFromString(value string) *ScorecardOverallRecommendation {
	return &ScorecardOverallRecommendation{typeName: "string", String: value}
}

func (s *ScorecardOverallRecommendation) UnmarshalJSON(data []byte) error {
	var valueOverallRecommendationEnum OverallRecommendationEnum
	if err := json.Unmarshal(data, &valueOverallRecommendationEnum); err == nil {
		s.typeName = "overallRecommendationEnum"
		s.OverallRecommendationEnum = valueOverallRecommendationEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScorecardOverallRecommendation) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "overallRecommendationEnum":
		return json.Marshal(s.OverallRecommendationEnum)
	case "string":
		return json.Marshal(s.String)
	}
}

type ScorecardOverallRecommendationVisitor interface {
	VisitOverallRecommendationEnum(OverallRecommendationEnum) error
	VisitString(string) error
}

func (s *ScorecardOverallRecommendation) Accept(visitor ScorecardOverallRecommendationVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "overallRecommendationEnum":
		return visitor.VisitOverallRecommendationEnum(s.OverallRecommendationEnum)
	case "string":
		return visitor.VisitString(s.String)
	}
}

// # The ScreeningQuestion Object
//
// ### Description
//
// The `ScreeningQuestion` object is used to represent questions asked to screen candidates for a job.
//
// ### Usage Example
//
// TODO
type ScreeningQuestion struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The job associated with the screening question.
	Job *ScreeningQuestionJob `json:"job,omitempty"`
	// The description of the screening question
	Description *string `json:"description,omitempty"`
	// The title of the screening question
	Title *string `json:"title,omitempty"`
	// The data type for the screening question.
	//
	// - `DATE` - DATE
	// - `FILE` - FILE
	// - `SINGLE_SELECT` - SINGLE_SELECT
	// - `MULTI_SELECT` - MULTI_SELECT
	// - `SINGLE_LINE_TEXT` - SINGLE_LINE_TEXT
	// - `MULTI_LINE_TEXT` - MULTI_LINE_TEXT
	// - `NUMERIC` - NUMERIC
	// - `BOOLEAN` - BOOLEAN
	Type *ScreeningQuestionType `json:"type,omitempty"`
	// Whether or not the screening question is required.
	Required  *bool      `json:"required,omitempty"`
	Options   []any      `json:"options,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// The job associated with the screening question.
type ScreeningQuestionJob struct {
	typeName string
	String   string
	Job      *Job
}

func NewScreeningQuestionJobFromString(value string) *ScreeningQuestionJob {
	return &ScreeningQuestionJob{typeName: "string", String: value}
}

func NewScreeningQuestionJobFromJob(value *Job) *ScreeningQuestionJob {
	return &ScreeningQuestionJob{typeName: "job", Job: value}
}

func (s *ScreeningQuestionJob) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueJob := new(Job)
	if err := json.Unmarshal(data, &valueJob); err == nil {
		s.typeName = "job"
		s.Job = valueJob
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScreeningQuestionJob) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "job":
		return json.Marshal(s.Job)
	}
}

type ScreeningQuestionJobVisitor interface {
	VisitString(string) error
	VisitJob(*Job) error
}

func (s *ScreeningQuestionJob) Accept(visitor ScreeningQuestionJobVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "job":
		return visitor.VisitJob(s.Job)
	}
}

// # The ScreeningQuestionOption Object
//
// ### Description
//
// # The `ScreeningQuestionOption` object is used to represent options for a `ScreeningQuestion` object
//
// ### Usage Example
//
// TODO
type ScreeningQuestionOption struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// Available response options
	Label     *string    `json:"label,omitempty"`
	Id        *string    `json:"id,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// The data type for the screening question.
//
// - `DATE` - DATE
// - `FILE` - FILE
// - `SINGLE_SELECT` - SINGLE_SELECT
// - `MULTI_SELECT` - MULTI_SELECT
// - `SINGLE_LINE_TEXT` - SINGLE_LINE_TEXT
// - `MULTI_LINE_TEXT` - MULTI_LINE_TEXT
// - `NUMERIC` - NUMERIC
// - `BOOLEAN` - BOOLEAN
type ScreeningQuestionType struct {
	typeName string
	TypeEnum TypeEnum
	String   string
}

func NewScreeningQuestionTypeFromTypeEnum(value TypeEnum) *ScreeningQuestionType {
	return &ScreeningQuestionType{typeName: "typeEnum", TypeEnum: value}
}

func NewScreeningQuestionTypeFromString(value string) *ScreeningQuestionType {
	return &ScreeningQuestionType{typeName: "string", String: value}
}

func (s *ScreeningQuestionType) UnmarshalJSON(data []byte) error {
	var valueTypeEnum TypeEnum
	if err := json.Unmarshal(data, &valueTypeEnum); err == nil {
		s.typeName = "typeEnum"
		s.TypeEnum = valueTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScreeningQuestionType) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "typeEnum":
		return json.Marshal(s.TypeEnum)
	case "string":
		return json.Marshal(s.String)
	}
}

type ScreeningQuestionTypeVisitor interface {
	VisitTypeEnum(TypeEnum) error
	VisitString(string) error
}

func (s *ScreeningQuestionType) Accept(visitor ScreeningQuestionTypeVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "typeEnum":
		return visitor.VisitTypeEnum(s.TypeEnum)
	case "string":
		return visitor.VisitString(s.String)
	}
}

// - `IN_NEXT_SYNC` - IN_NEXT_SYNC
// - `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum uint

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = iota + 1
	SelectiveSyncConfigurationsUsageEnumInLastSync
)

func (s SelectiveSyncConfigurationsUsageEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SelectiveSyncConfigurationsUsageEnumInNextSync:
		return "IN_NEXT_SYNC"
	case SelectiveSyncConfigurationsUsageEnumInLastSync:
		return "IN_LAST_SYNC"
	}
}

func (s SelectiveSyncConfigurationsUsageEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SelectiveSyncConfigurationsUsageEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "IN_NEXT_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInNextSync
		*s = value
	case "IN_LAST_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInLastSync
		*s = value
	}
	return nil
}

// # The SyncStatus Object
//
// ### Description
//
// # The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
//
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name"`
	ModelId                          string                                `json:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty"`
	Status                           SyncStatusStatusEnum                  `json:"status,omitempty"`
	IsInitialSync                    bool                                  `json:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty"`
}

// - `SYNCING` - SYNCING
// - `DONE` - DONE
// - `FAILED` - FAILED
// - `DISABLED` - DISABLED
// - `PAUSED` - PAUSED
// - `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type SyncStatusStatusEnum uint

const (
	SyncStatusStatusEnumSyncing SyncStatusStatusEnum = iota + 1
	SyncStatusStatusEnumDone
	SyncStatusStatusEnumFailed
	SyncStatusStatusEnumDisabled
	SyncStatusStatusEnumPaused
	SyncStatusStatusEnumPartiallySynced
)

func (s SyncStatusStatusEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SyncStatusStatusEnumSyncing:
		return "SYNCING"
	case SyncStatusStatusEnumDone:
		return "DONE"
	case SyncStatusStatusEnumFailed:
		return "FAILED"
	case SyncStatusStatusEnumDisabled:
		return "DISABLED"
	case SyncStatusStatusEnumPaused:
		return "PAUSED"
	case SyncStatusStatusEnumPartiallySynced:
		return "PARTIALLY_SYNCED"
	}
}

func (s SyncStatusStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SyncStatusStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SYNCING":
		value := SyncStatusStatusEnumSyncing
		*s = value
	case "DONE":
		value := SyncStatusStatusEnumDone
		*s = value
	case "FAILED":
		value := SyncStatusStatusEnumFailed
		*s = value
	case "DISABLED":
		value := SyncStatusStatusEnumDisabled
		*s = value
	case "PAUSED":
		value := SyncStatusStatusEnumPaused
		*s = value
	case "PARTIALLY_SYNCED":
		value := SyncStatusStatusEnumPartiallySynced
		*s = value
	}
	return nil
}

// # The Tag Object
//
// ### Description
//
// The `Tag` object is used to represent a tag for a candidate.
//
// ### Usage Example
//
// Fetch from the `LIST Tags` endpoint and view the tags used within a company.
type Tag struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The tag's name.
	Name *string `json:"name,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	CreatedAt        *time.Time `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time       `json:"modified_at,omitempty"`
	FieldMappings map[string]any   `json:"field_mappings,omitempty"`
	RemoteData    []map[string]any `json:"remote_data,omitempty"`
}

// - `DATE` - DATE
// - `FILE` - FILE
// - `SINGLE_SELECT` - SINGLE_SELECT
// - `MULTI_SELECT` - MULTI_SELECT
// - `SINGLE_LINE_TEXT` - SINGLE_LINE_TEXT
// - `MULTI_LINE_TEXT` - MULTI_LINE_TEXT
// - `NUMERIC` - NUMERIC
// - `BOOLEAN` - BOOLEAN
type TypeEnum uint

const (
	TypeEnumDate TypeEnum = iota + 1
	TypeEnumFile
	TypeEnumSingleSelect
	TypeEnumMultiSelect
	TypeEnumSingleLineText
	TypeEnumMultiLineText
	TypeEnumNumeric
	TypeEnumBoolean
)

func (t TypeEnum) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TypeEnumDate:
		return "DATE"
	case TypeEnumFile:
		return "FILE"
	case TypeEnumSingleSelect:
		return "SINGLE_SELECT"
	case TypeEnumMultiSelect:
		return "MULTI_SELECT"
	case TypeEnumSingleLineText:
		return "SINGLE_LINE_TEXT"
	case TypeEnumMultiLineText:
		return "MULTI_LINE_TEXT"
	case TypeEnumNumeric:
		return "NUMERIC"
	case TypeEnumBoolean:
		return "BOOLEAN"
	}
}

func (t TypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "DATE":
		value := TypeEnumDate
		*t = value
	case "FILE":
		value := TypeEnumFile
		*t = value
	case "SINGLE_SELECT":
		value := TypeEnumSingleSelect
		*t = value
	case "MULTI_SELECT":
		value := TypeEnumMultiSelect
		*t = value
	case "SINGLE_LINE_TEXT":
		value := TypeEnumSingleLineText
		*t = value
	case "MULTI_LINE_TEXT":
		value := TypeEnumMultiLineText
		*t = value
	case "NUMERIC":
		value := TypeEnumNumeric
		*t = value
	case "BOOLEAN":
		value := TypeEnumBoolean
		*t = value
	}
	return nil
}

// # The Url Object
//
// ### Description
//
// The `Url` object is used to represent hyperlinks associated with the parent model.
//
// ### Usage Example
//
// Fetch from the `GET Candidate` endpoint and view their website urls.
type Url struct {
	// The site's url.
	Value *string `json:"value,omitempty"`
	// The type of site.
	//
	// - `PERSONAL` - PERSONAL
	// - `COMPANY` - COMPANY
	// - `PORTFOLIO` - PORTFOLIO
	// - `BLOG` - BLOG
	// - `SOCIAL_MEDIA` - SOCIAL_MEDIA
	// - `OTHER` - OTHER
	// - `JOB_POSTING` - JOB_POSTING
	UrlType   *UrlUrlType `json:"url_type,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// # The Url Object
//
// ### Description
//
// The `Url` object is used to represent hyperlinks associated with the parent model.
//
// ### Usage Example
//
// Fetch from the `GET Candidate` endpoint and view their website urls.
type UrlRequest struct {
	// The site's url.
	Value *string `json:"value,omitempty"`
	// The type of site.
	//
	// - `PERSONAL` - PERSONAL
	// - `COMPANY` - COMPANY
	// - `PORTFOLIO` - PORTFOLIO
	// - `BLOG` - BLOG
	// - `SOCIAL_MEDIA` - SOCIAL_MEDIA
	// - `OTHER` - OTHER
	// - `JOB_POSTING` - JOB_POSTING
	UrlType             *UrlRequestUrlType `json:"url_type,omitempty"`
	IntegrationParams   map[string]any     `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any     `json:"linked_account_params,omitempty"`
}

// The type of site.
//
// - `PERSONAL` - PERSONAL
// - `COMPANY` - COMPANY
// - `PORTFOLIO` - PORTFOLIO
// - `BLOG` - BLOG
// - `SOCIAL_MEDIA` - SOCIAL_MEDIA
// - `OTHER` - OTHER
// - `JOB_POSTING` - JOB_POSTING
type UrlRequestUrlType struct {
	typeName    string
	UrlTypeEnum UrlTypeEnum
	String      string
}

func NewUrlRequestUrlTypeFromUrlTypeEnum(value UrlTypeEnum) *UrlRequestUrlType {
	return &UrlRequestUrlType{typeName: "urlTypeEnum", UrlTypeEnum: value}
}

func NewUrlRequestUrlTypeFromString(value string) *UrlRequestUrlType {
	return &UrlRequestUrlType{typeName: "string", String: value}
}

func (u *UrlRequestUrlType) UnmarshalJSON(data []byte) error {
	var valueUrlTypeEnum UrlTypeEnum
	if err := json.Unmarshal(data, &valueUrlTypeEnum); err == nil {
		u.typeName = "urlTypeEnum"
		u.UrlTypeEnum = valueUrlTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UrlRequestUrlType) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "urlTypeEnum":
		return json.Marshal(u.UrlTypeEnum)
	case "string":
		return json.Marshal(u.String)
	}
}

type UrlRequestUrlTypeVisitor interface {
	VisitUrlTypeEnum(UrlTypeEnum) error
	VisitString(string) error
}

func (u *UrlRequestUrlType) Accept(visitor UrlRequestUrlTypeVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "urlTypeEnum":
		return visitor.VisitUrlTypeEnum(u.UrlTypeEnum)
	case "string":
		return visitor.VisitString(u.String)
	}
}

// - `PERSONAL` - PERSONAL
// - `COMPANY` - COMPANY
// - `PORTFOLIO` - PORTFOLIO
// - `BLOG` - BLOG
// - `SOCIAL_MEDIA` - SOCIAL_MEDIA
// - `OTHER` - OTHER
// - `JOB_POSTING` - JOB_POSTING
type UrlTypeEnum uint

const (
	UrlTypeEnumPersonal UrlTypeEnum = iota + 1
	UrlTypeEnumCompany
	UrlTypeEnumPortfolio
	UrlTypeEnumBlog
	UrlTypeEnumSocialMedia
	UrlTypeEnumOther
	UrlTypeEnumJobPosting
)

func (u UrlTypeEnum) String() string {
	switch u {
	default:
		return strconv.Itoa(int(u))
	case UrlTypeEnumPersonal:
		return "PERSONAL"
	case UrlTypeEnumCompany:
		return "COMPANY"
	case UrlTypeEnumPortfolio:
		return "PORTFOLIO"
	case UrlTypeEnumBlog:
		return "BLOG"
	case UrlTypeEnumSocialMedia:
		return "SOCIAL_MEDIA"
	case UrlTypeEnumOther:
		return "OTHER"
	case UrlTypeEnumJobPosting:
		return "JOB_POSTING"
	}
}

func (u UrlTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", u.String())), nil
}

func (u *UrlTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "PERSONAL":
		value := UrlTypeEnumPersonal
		*u = value
	case "COMPANY":
		value := UrlTypeEnumCompany
		*u = value
	case "PORTFOLIO":
		value := UrlTypeEnumPortfolio
		*u = value
	case "BLOG":
		value := UrlTypeEnumBlog
		*u = value
	case "SOCIAL_MEDIA":
		value := UrlTypeEnumSocialMedia
		*u = value
	case "OTHER":
		value := UrlTypeEnumOther
		*u = value
	case "JOB_POSTING":
		value := UrlTypeEnumJobPosting
		*u = value
	}
	return nil
}

// The type of site.
//
// - `PERSONAL` - PERSONAL
// - `COMPANY` - COMPANY
// - `PORTFOLIO` - PORTFOLIO
// - `BLOG` - BLOG
// - `SOCIAL_MEDIA` - SOCIAL_MEDIA
// - `OTHER` - OTHER
// - `JOB_POSTING` - JOB_POSTING
type UrlUrlType struct {
	typeName    string
	UrlTypeEnum UrlTypeEnum
	String      string
}

func NewUrlUrlTypeFromUrlTypeEnum(value UrlTypeEnum) *UrlUrlType {
	return &UrlUrlType{typeName: "urlTypeEnum", UrlTypeEnum: value}
}

func NewUrlUrlTypeFromString(value string) *UrlUrlType {
	return &UrlUrlType{typeName: "string", String: value}
}

func (u *UrlUrlType) UnmarshalJSON(data []byte) error {
	var valueUrlTypeEnum UrlTypeEnum
	if err := json.Unmarshal(data, &valueUrlTypeEnum); err == nil {
		u.typeName = "urlTypeEnum"
		u.UrlTypeEnum = valueUrlTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UrlUrlType) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "urlTypeEnum":
		return json.Marshal(u.UrlTypeEnum)
	case "string":
		return json.Marshal(u.String)
	}
}

type UrlUrlTypeVisitor interface {
	VisitUrlTypeEnum(UrlTypeEnum) error
	VisitString(string) error
}

func (u *UrlUrlType) Accept(visitor UrlUrlTypeVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "urlTypeEnum":
		return visitor.VisitUrlTypeEnum(u.UrlTypeEnum)
	case "string":
		return visitor.VisitString(u.String)
	}
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer"`
}

// - `I_AM_NOT_A_PROTECTED_VETERAN` - I_AM_NOT_A_PROTECTED_VETERAN
// - `I_IDENTIFY_AS_ONE_OR_MORE_OF_THE_CLASSIFICATIONS_OF_A_PROTECTED_VETERAN` - I_IDENTIFY_AS_ONE_OR_MORE_OF_THE_CLASSIFICATIONS_OF_A_PROTECTED_VETERAN
// - `I_DONT_WISH_TO_ANSWER` - I_DONT_WISH_TO_ANSWER
type VeteranStatusEnum uint

const (
	VeteranStatusEnumIAmNotAProtectedVeteran VeteranStatusEnum = iota + 1
	VeteranStatusEnumIIdentifyAsOneOrMoreOfTheClassificationsOfAProtectedVeteran
	VeteranStatusEnumIDontWishToAnswer
)

func (v VeteranStatusEnum) String() string {
	switch v {
	default:
		return strconv.Itoa(int(v))
	case VeteranStatusEnumIAmNotAProtectedVeteran:
		return "I_AM_NOT_A_PROTECTED_VETERAN"
	case VeteranStatusEnumIIdentifyAsOneOrMoreOfTheClassificationsOfAProtectedVeteran:
		return "I_IDENTIFY_AS_ONE_OR_MORE_OF_THE_CLASSIFICATIONS_OF_A_PROTECTED_VETERAN"
	case VeteranStatusEnumIDontWishToAnswer:
		return "I_DONT_WISH_TO_ANSWER"
	}
}

func (v VeteranStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", v.String())), nil
}

func (v *VeteranStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "I_AM_NOT_A_PROTECTED_VETERAN":
		value := VeteranStatusEnumIAmNotAProtectedVeteran
		*v = value
	case "I_IDENTIFY_AS_ONE_OR_MORE_OF_THE_CLASSIFICATIONS_OF_A_PROTECTED_VETERAN":
		value := VeteranStatusEnumIIdentifyAsOneOrMoreOfTheClassificationsOfAProtectedVeteran
		*v = value
	case "I_DONT_WISH_TO_ANSWER":
		value := VeteranStatusEnumIDontWishToAnswer
		*v = value
	}
	return nil
}

// - `ADMIN_ONLY` - ADMIN_ONLY
// - `PUBLIC` - PUBLIC
// - `PRIVATE` - PRIVATE
type VisibilityEnum uint

const (
	VisibilityEnumAdminOnly VisibilityEnum = iota + 1
	VisibilityEnumPublic
	VisibilityEnumPrivate
)

func (v VisibilityEnum) String() string {
	switch v {
	default:
		return strconv.Itoa(int(v))
	case VisibilityEnumAdminOnly:
		return "ADMIN_ONLY"
	case VisibilityEnumPublic:
		return "PUBLIC"
	case VisibilityEnumPrivate:
		return "PRIVATE"
	}
}

func (v VisibilityEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", v.String())), nil
}

func (v *VisibilityEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ADMIN_ONLY":
		value := VisibilityEnumAdminOnly
		*v = value
	case "PUBLIC":
		value := VisibilityEnumPublic
		*v = value
	case "PRIVATE":
		value := VisibilityEnumPrivate
		*v = value
	}
	return nil
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

type WebhookReceiver struct {
	Event    string  `json:"event"`
	IsActive bool    `json:"is_active"`
	Key      *string `json:"key,omitempty"`
}
