// Code generated by Fern. DO NOT EDIT.

package ats

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type UpdateApplicationStageRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool `json:"-" url:"run_async,omitempty"`
	// The interview stage to move the application to.
	JobInterviewStage *string `json:"job_interview_stage,omitempty" url:"-"`
	RemoteUserId      *string `json:"remote_user_id,omitempty" url:"-"`
}

type ApplicationEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync     *bool               `json:"-" url:"run_async,omitempty"`
	Model        *ApplicationRequest `json:"model,omitempty" url:"-"`
	RemoteUserId string              `json:"remote_user_id" url:"-"`
}

type ApplicationsListRequest struct {
	// If provided, will only return applications for this candidate.
	CandidateId *string `json:"-" url:"candidate_id,omitempty"`
	// If provided, will only return objects created after this datetime.
	CreatedAfter *time.Time `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *time.Time `json:"-" url:"created_before,omitempty"`
	// If provided, will only return applications credited to this user.
	CreditedToId *string `json:"-" url:"credited_to_id,omitempty"`
	// If provided, will only return applications at this interview stage.
	CurrentStageId *string `json:"-" url:"current_stage_id,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*ApplicationsListRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return applications for this job.
	JobId *string `json:"-" url:"job_id,omitempty"`
	// If provided, only objects synced by Merge after this date time will be returned.
	ModifiedAfter *time.Time `json:"-" url:"modified_after,omitempty"`
	// If provided, only objects synced by Merge before this date time will be returned.
	ModifiedBefore *time.Time `json:"-" url:"modified_before,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// If provided, will only return applications with this reject reason.
	RejectReasonId *string `json:"-" url:"reject_reason_id,omitempty"`
	// The API provider's ID for the given object.
	RemoteId *string `json:"-" url:"remote_id,omitempty"`
	// If provided, will only return applications with this source.
	Source *string `json:"-" url:"source,omitempty"`
}

type ApplicationsMetaPostRetrieveRequest struct {
	// The template ID associated with the nested application in the request.
	ApplicationRemoteTemplateId *string `json:"-" url:"application_remote_template_id,omitempty"`
}

type ApplicationsRetrieveRequest struct {
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*ApplicationsRetrieveRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
}

type ApplicationsListRequestExpandItem string

const (
	ApplicationsListRequestExpandItemCandidate                        ApplicationsListRequestExpandItem = "candidate"
	ApplicationsListRequestExpandItemCreditedTo                       ApplicationsListRequestExpandItem = "credited_to"
	ApplicationsListRequestExpandItemCurrentStage                     ApplicationsListRequestExpandItem = "current_stage"
	ApplicationsListRequestExpandItemJob                              ApplicationsListRequestExpandItem = "job"
	ApplicationsListRequestExpandItemOffers                           ApplicationsListRequestExpandItem = "offers"
	ApplicationsListRequestExpandItemRejectReason                     ApplicationsListRequestExpandItem = "reject_reason"
	ApplicationsListRequestExpandItemScreeningQuestionAnswers         ApplicationsListRequestExpandItem = "screening_question_answers"
	ApplicationsListRequestExpandItemScreeningQuestionAnswersQuestion ApplicationsListRequestExpandItem = "screening_question_answers.question"
)

func NewApplicationsListRequestExpandItemFromString(s string) (ApplicationsListRequestExpandItem, error) {
	switch s {
	case "candidate":
		return ApplicationsListRequestExpandItemCandidate, nil
	case "credited_to":
		return ApplicationsListRequestExpandItemCreditedTo, nil
	case "current_stage":
		return ApplicationsListRequestExpandItemCurrentStage, nil
	case "job":
		return ApplicationsListRequestExpandItemJob, nil
	case "offers":
		return ApplicationsListRequestExpandItemOffers, nil
	case "reject_reason":
		return ApplicationsListRequestExpandItemRejectReason, nil
	case "screening_question_answers":
		return ApplicationsListRequestExpandItemScreeningQuestionAnswers, nil
	case "screening_question_answers.question":
		return ApplicationsListRequestExpandItemScreeningQuestionAnswersQuestion, nil
	}
	var t ApplicationsListRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApplicationsListRequestExpandItem) Ptr() *ApplicationsListRequestExpandItem {
	return &a
}

type ApplicationsRetrieveRequestExpandItem string

const (
	ApplicationsRetrieveRequestExpandItemCandidate                        ApplicationsRetrieveRequestExpandItem = "candidate"
	ApplicationsRetrieveRequestExpandItemCreditedTo                       ApplicationsRetrieveRequestExpandItem = "credited_to"
	ApplicationsRetrieveRequestExpandItemCurrentStage                     ApplicationsRetrieveRequestExpandItem = "current_stage"
	ApplicationsRetrieveRequestExpandItemJob                              ApplicationsRetrieveRequestExpandItem = "job"
	ApplicationsRetrieveRequestExpandItemOffers                           ApplicationsRetrieveRequestExpandItem = "offers"
	ApplicationsRetrieveRequestExpandItemRejectReason                     ApplicationsRetrieveRequestExpandItem = "reject_reason"
	ApplicationsRetrieveRequestExpandItemScreeningQuestionAnswers         ApplicationsRetrieveRequestExpandItem = "screening_question_answers"
	ApplicationsRetrieveRequestExpandItemScreeningQuestionAnswersQuestion ApplicationsRetrieveRequestExpandItem = "screening_question_answers.question"
)

func NewApplicationsRetrieveRequestExpandItemFromString(s string) (ApplicationsRetrieveRequestExpandItem, error) {
	switch s {
	case "candidate":
		return ApplicationsRetrieveRequestExpandItemCandidate, nil
	case "credited_to":
		return ApplicationsRetrieveRequestExpandItemCreditedTo, nil
	case "current_stage":
		return ApplicationsRetrieveRequestExpandItemCurrentStage, nil
	case "job":
		return ApplicationsRetrieveRequestExpandItemJob, nil
	case "offers":
		return ApplicationsRetrieveRequestExpandItemOffers, nil
	case "reject_reason":
		return ApplicationsRetrieveRequestExpandItemRejectReason, nil
	case "screening_question_answers":
		return ApplicationsRetrieveRequestExpandItemScreeningQuestionAnswers, nil
	case "screening_question_answers.question":
		return ApplicationsRetrieveRequestExpandItemScreeningQuestionAnswersQuestion, nil
	}
	var t ApplicationsRetrieveRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApplicationsRetrieveRequestExpandItem) Ptr() *ApplicationsRetrieveRequestExpandItem {
	return &a
}

// # The Application Object
// ### Description
// The Application Object is used to represent a candidate's journey through a particular Job's recruiting process. If a Candidate applies for multiple Jobs, there will be a separate Application for each Job if the third-party integration allows it.
//
// ### Usage Example
// Fetch from the `LIST Applications` endpoint and filter by `ID` to show all applications.
type ApplicationRequest struct {
	// The candidate applying.
	Candidate *ApplicationRequestCandidate `json:"candidate,omitempty" url:"candidate,omitempty"`
	// The job being applied for.
	Job *ApplicationRequestJob `json:"job,omitempty" url:"job,omitempty"`
	// When the application was submitted.
	AppliedAt *time.Time `json:"applied_at,omitempty" url:"applied_at,omitempty"`
	// When the application was rejected.
	RejectedAt *time.Time                      `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	Offers     []*ApplicationRequestOffersItem `json:"offers,omitempty" url:"offers,omitempty"`
	// The application's source.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The user credited for this application.
	CreditedTo               *ApplicationRequestCreditedTo                     `json:"credited_to,omitempty" url:"credited_to,omitempty"`
	ScreeningQuestionAnswers []*ApplicationRequestScreeningQuestionAnswersItem `json:"screening_question_answers,omitempty" url:"screening_question_answers,omitempty"`
	// The application's current stage.
	CurrentStage *ApplicationRequestCurrentStage `json:"current_stage,omitempty" url:"current_stage,omitempty"`
	// The application's reason for rejection.
	RejectReason        *ApplicationRequestRejectReason `json:"reject_reason,omitempty" url:"reject_reason,omitempty"`
	RemoteTemplateId    *string                         `json:"remote_template_id,omitempty" url:"remote_template_id,omitempty"`
	IntegrationParams   map[string]interface{}          `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}          `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApplicationRequest) GetCandidate() *ApplicationRequestCandidate {
	if a == nil {
		return nil
	}
	return a.Candidate
}

func (a *ApplicationRequest) GetJob() *ApplicationRequestJob {
	if a == nil {
		return nil
	}
	return a.Job
}

func (a *ApplicationRequest) GetAppliedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.AppliedAt
}

func (a *ApplicationRequest) GetRejectedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.RejectedAt
}

func (a *ApplicationRequest) GetOffers() []*ApplicationRequestOffersItem {
	if a == nil {
		return nil
	}
	return a.Offers
}

func (a *ApplicationRequest) GetSource() *string {
	if a == nil {
		return nil
	}
	return a.Source
}

func (a *ApplicationRequest) GetCreditedTo() *ApplicationRequestCreditedTo {
	if a == nil {
		return nil
	}
	return a.CreditedTo
}

func (a *ApplicationRequest) GetScreeningQuestionAnswers() []*ApplicationRequestScreeningQuestionAnswersItem {
	if a == nil {
		return nil
	}
	return a.ScreeningQuestionAnswers
}

func (a *ApplicationRequest) GetCurrentStage() *ApplicationRequestCurrentStage {
	if a == nil {
		return nil
	}
	return a.CurrentStage
}

func (a *ApplicationRequest) GetRejectReason() *ApplicationRequestRejectReason {
	if a == nil {
		return nil
	}
	return a.RejectReason
}

func (a *ApplicationRequest) GetRemoteTemplateId() *string {
	if a == nil {
		return nil
	}
	return a.RemoteTemplateId
}

func (a *ApplicationRequest) GetIntegrationParams() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.IntegrationParams
}

func (a *ApplicationRequest) GetLinkedAccountParams() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.LinkedAccountParams
}

func (a *ApplicationRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApplicationRequest) UnmarshalJSON(data []byte) error {
	type embed ApplicationRequest
	var unmarshaler = struct {
		embed
		AppliedAt  *internal.DateTime `json:"applied_at,omitempty"`
		RejectedAt *internal.DateTime `json:"rejected_at,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApplicationRequest(unmarshaler.embed)
	a.AppliedAt = unmarshaler.AppliedAt.TimePtr()
	a.RejectedAt = unmarshaler.RejectedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApplicationRequest) MarshalJSON() ([]byte, error) {
	type embed ApplicationRequest
	var marshaler = struct {
		embed
		AppliedAt  *internal.DateTime `json:"applied_at,omitempty"`
		RejectedAt *internal.DateTime `json:"rejected_at,omitempty"`
	}{
		embed:      embed(*a),
		AppliedAt:  internal.NewOptionalDateTime(a.AppliedAt),
		RejectedAt: internal.NewOptionalDateTime(a.RejectedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ApplicationRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The candidate applying.
type ApplicationRequestCandidate struct {
	String    string
	Candidate *Candidate

	typ string
}

func (a *ApplicationRequestCandidate) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationRequestCandidate) GetCandidate() *Candidate {
	if a == nil {
		return nil
	}
	return a.Candidate
}

func (a *ApplicationRequestCandidate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueCandidate := new(Candidate)
	if err := json.Unmarshal(data, &valueCandidate); err == nil {
		a.typ = "Candidate"
		a.Candidate = valueCandidate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestCandidate) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "Candidate" || a.Candidate != nil {
		return json.Marshal(a.Candidate)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestCandidateVisitor interface {
	VisitString(string) error
	VisitCandidate(*Candidate) error
}

func (a *ApplicationRequestCandidate) Accept(visitor ApplicationRequestCandidateVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "Candidate" || a.Candidate != nil {
		return visitor.VisitCandidate(a.Candidate)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The user credited for this application.
type ApplicationRequestCreditedTo struct {
	String     string
	RemoteUser *RemoteUser

	typ string
}

func (a *ApplicationRequestCreditedTo) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationRequestCreditedTo) GetRemoteUser() *RemoteUser {
	if a == nil {
		return nil
	}
	return a.RemoteUser
}

func (a *ApplicationRequestCreditedTo) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueRemoteUser := new(RemoteUser)
	if err := json.Unmarshal(data, &valueRemoteUser); err == nil {
		a.typ = "RemoteUser"
		a.RemoteUser = valueRemoteUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestCreditedTo) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "RemoteUser" || a.RemoteUser != nil {
		return json.Marshal(a.RemoteUser)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestCreditedToVisitor interface {
	VisitString(string) error
	VisitRemoteUser(*RemoteUser) error
}

func (a *ApplicationRequestCreditedTo) Accept(visitor ApplicationRequestCreditedToVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "RemoteUser" || a.RemoteUser != nil {
		return visitor.VisitRemoteUser(a.RemoteUser)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The application's current stage.
type ApplicationRequestCurrentStage struct {
	String            string
	JobInterviewStage *JobInterviewStage

	typ string
}

func (a *ApplicationRequestCurrentStage) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationRequestCurrentStage) GetJobInterviewStage() *JobInterviewStage {
	if a == nil {
		return nil
	}
	return a.JobInterviewStage
}

func (a *ApplicationRequestCurrentStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueJobInterviewStage := new(JobInterviewStage)
	if err := json.Unmarshal(data, &valueJobInterviewStage); err == nil {
		a.typ = "JobInterviewStage"
		a.JobInterviewStage = valueJobInterviewStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestCurrentStage) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "JobInterviewStage" || a.JobInterviewStage != nil {
		return json.Marshal(a.JobInterviewStage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestCurrentStageVisitor interface {
	VisitString(string) error
	VisitJobInterviewStage(*JobInterviewStage) error
}

func (a *ApplicationRequestCurrentStage) Accept(visitor ApplicationRequestCurrentStageVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "JobInterviewStage" || a.JobInterviewStage != nil {
		return visitor.VisitJobInterviewStage(a.JobInterviewStage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The job being applied for.
type ApplicationRequestJob struct {
	String string
	Job    *Job

	typ string
}

func (a *ApplicationRequestJob) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationRequestJob) GetJob() *Job {
	if a == nil {
		return nil
	}
	return a.Job
}

func (a *ApplicationRequestJob) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueJob := new(Job)
	if err := json.Unmarshal(data, &valueJob); err == nil {
		a.typ = "Job"
		a.Job = valueJob
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestJob) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "Job" || a.Job != nil {
		return json.Marshal(a.Job)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestJobVisitor interface {
	VisitString(string) error
	VisitJob(*Job) error
}

func (a *ApplicationRequestJob) Accept(visitor ApplicationRequestJobVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "Job" || a.Job != nil {
		return visitor.VisitJob(a.Job)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestOffersItem struct {
	String string
	Offer  *Offer

	typ string
}

func (a *ApplicationRequestOffersItem) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationRequestOffersItem) GetOffer() *Offer {
	if a == nil {
		return nil
	}
	return a.Offer
}

func (a *ApplicationRequestOffersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueOffer := new(Offer)
	if err := json.Unmarshal(data, &valueOffer); err == nil {
		a.typ = "Offer"
		a.Offer = valueOffer
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestOffersItem) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "Offer" || a.Offer != nil {
		return json.Marshal(a.Offer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestOffersItemVisitor interface {
	VisitString(string) error
	VisitOffer(*Offer) error
}

func (a *ApplicationRequestOffersItem) Accept(visitor ApplicationRequestOffersItemVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "Offer" || a.Offer != nil {
		return visitor.VisitOffer(a.Offer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The application's reason for rejection.
type ApplicationRequestRejectReason struct {
	String       string
	RejectReason *RejectReason

	typ string
}

func (a *ApplicationRequestRejectReason) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationRequestRejectReason) GetRejectReason() *RejectReason {
	if a == nil {
		return nil
	}
	return a.RejectReason
}

func (a *ApplicationRequestRejectReason) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueRejectReason := new(RejectReason)
	if err := json.Unmarshal(data, &valueRejectReason); err == nil {
		a.typ = "RejectReason"
		a.RejectReason = valueRejectReason
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestRejectReason) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "RejectReason" || a.RejectReason != nil {
		return json.Marshal(a.RejectReason)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestRejectReasonVisitor interface {
	VisitString(string) error
	VisitRejectReason(*RejectReason) error
}

func (a *ApplicationRequestRejectReason) Accept(visitor ApplicationRequestRejectReasonVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "RejectReason" || a.RejectReason != nil {
		return visitor.VisitRejectReason(a.RejectReason)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestScreeningQuestionAnswersItem struct {
	String                         string
	ScreeningQuestionAnswerRequest *ScreeningQuestionAnswerRequest

	typ string
}

func (a *ApplicationRequestScreeningQuestionAnswersItem) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *ApplicationRequestScreeningQuestionAnswersItem) GetScreeningQuestionAnswerRequest() *ScreeningQuestionAnswerRequest {
	if a == nil {
		return nil
	}
	return a.ScreeningQuestionAnswerRequest
}

func (a *ApplicationRequestScreeningQuestionAnswersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueScreeningQuestionAnswerRequest := new(ScreeningQuestionAnswerRequest)
	if err := json.Unmarshal(data, &valueScreeningQuestionAnswerRequest); err == nil {
		a.typ = "ScreeningQuestionAnswerRequest"
		a.ScreeningQuestionAnswerRequest = valueScreeningQuestionAnswerRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ApplicationRequestScreeningQuestionAnswersItem) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "ScreeningQuestionAnswerRequest" || a.ScreeningQuestionAnswerRequest != nil {
		return json.Marshal(a.ScreeningQuestionAnswerRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationRequestScreeningQuestionAnswersItemVisitor interface {
	VisitString(string) error
	VisitScreeningQuestionAnswerRequest(*ScreeningQuestionAnswerRequest) error
}

func (a *ApplicationRequestScreeningQuestionAnswersItem) Accept(visitor ApplicationRequestScreeningQuestionAnswersItemVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "ScreeningQuestionAnswerRequest" || a.ScreeningQuestionAnswerRequest != nil {
		return visitor.VisitScreeningQuestionAnswerRequest(a.ScreeningQuestionAnswerRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ApplicationResponse struct {
	Model    *Application                `json:"model" url:"model"`
	Warnings []*WarningValidationProblem `json:"warnings" url:"warnings"`
	Errors   []*ErrorValidationProblem   `json:"errors" url:"errors"`
	Logs     []*DebugModeLog             `json:"logs,omitempty" url:"logs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApplicationResponse) GetModel() *Application {
	if a == nil {
		return nil
	}
	return a.Model
}

func (a *ApplicationResponse) GetWarnings() []*WarningValidationProblem {
	if a == nil {
		return nil
	}
	return a.Warnings
}

func (a *ApplicationResponse) GetErrors() []*ErrorValidationProblem {
	if a == nil {
		return nil
	}
	return a.Errors
}

func (a *ApplicationResponse) GetLogs() []*DebugModeLog {
	if a == nil {
		return nil
	}
	return a.Logs
}

func (a *ApplicationResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApplicationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApplicationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApplicationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApplicationResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type PaginatedApplicationList struct {
	Next     *string        `json:"next,omitempty" url:"next,omitempty"`
	Previous *string        `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*Application `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedApplicationList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedApplicationList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedApplicationList) GetResults() []*Application {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedApplicationList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedApplicationList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedApplicationList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedApplicationList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedApplicationList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The ScreeningQuestionAnswer Object
// ### Description
// The `ScreeningQuestionAnswer` object is used to represent candidate responses to a screening question, for a specific application.
//
// ### Usage Example
// TODO
type ScreeningQuestionAnswerRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The screening question associated with the candidate’s answer. To determine the data type of the answer, you can expand on the screening question by adding `screening_question_answers.question` to the `expand` query parameter.
	Question *ScreeningQuestionAnswerRequestQuestion `json:"question,omitempty" url:"question,omitempty"`
	// The candidate’s response to the screening question.
	Answer              *string                `json:"answer,omitempty" url:"answer,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScreeningQuestionAnswerRequest) GetRemoteId() *string {
	if s == nil {
		return nil
	}
	return s.RemoteId
}

func (s *ScreeningQuestionAnswerRequest) GetQuestion() *ScreeningQuestionAnswerRequestQuestion {
	if s == nil {
		return nil
	}
	return s.Question
}

func (s *ScreeningQuestionAnswerRequest) GetAnswer() *string {
	if s == nil {
		return nil
	}
	return s.Answer
}

func (s *ScreeningQuestionAnswerRequest) GetIntegrationParams() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.IntegrationParams
}

func (s *ScreeningQuestionAnswerRequest) GetLinkedAccountParams() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.LinkedAccountParams
}

func (s *ScreeningQuestionAnswerRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScreeningQuestionAnswerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ScreeningQuestionAnswerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScreeningQuestionAnswerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScreeningQuestionAnswerRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The screening question associated with the candidate’s answer. To determine the data type of the answer, you can expand on the screening question by adding `screening_question_answers.question` to the `expand` query parameter.
type ScreeningQuestionAnswerRequestQuestion struct {
	String            string
	ScreeningQuestion *ScreeningQuestion

	typ string
}

func (s *ScreeningQuestionAnswerRequestQuestion) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *ScreeningQuestionAnswerRequestQuestion) GetScreeningQuestion() *ScreeningQuestion {
	if s == nil {
		return nil
	}
	return s.ScreeningQuestion
}

func (s *ScreeningQuestionAnswerRequestQuestion) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	valueScreeningQuestion := new(ScreeningQuestion)
	if err := json.Unmarshal(data, &valueScreeningQuestion); err == nil {
		s.typ = "ScreeningQuestion"
		s.ScreeningQuestion = valueScreeningQuestion
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScreeningQuestionAnswerRequestQuestion) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "ScreeningQuestion" || s.ScreeningQuestion != nil {
		return json.Marshal(s.ScreeningQuestion)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScreeningQuestionAnswerRequestQuestionVisitor interface {
	VisitString(string) error
	VisitScreeningQuestion(*ScreeningQuestion) error
}

func (s *ScreeningQuestionAnswerRequestQuestion) Accept(visitor ScreeningQuestionAnswerRequestQuestionVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "ScreeningQuestion" || s.ScreeningQuestion != nil {
		return visitor.VisitScreeningQuestion(s.ScreeningQuestion)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}
