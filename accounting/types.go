// This file was auto-generated by Fern from our API Definition.

package accounting

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/merge-api/merge-go-client/core"
	time "time"
)

// # The Account Object
//
// ### Description
//
// An `Account` represents a category in a company’s ledger in which a financial transaction is recorded against. The aggregation of each `Account` object is often referred to as the **Chart of Accounts**.
//
// An `Account` can be classified into one of the following categories, determined through the `classification` field:
//
// - **Asset:** Accounts Receivable and Bank Accounts
// - **Liability:** Accounts Payable and Credit Card Accounts
// - **Equity:** Treasury Accounts and Retained Earnings
// - **Revenue:** Income and Other Income
// - **Expense:** Cost of Goods Sold and Office Expenses
//
// ### Usage Example
//
// Fetch from the `LIST Accounts` endpoint and view a company's accounts.
type Account struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The account's name.
	Name *string `json:"name,omitempty"`
	// The account's description.
	Description *string `json:"description,omitempty"`
	// The account's broadest grouping.
	//
	// - `ASSET` - ASSET
	// - `EQUITY` - EQUITY
	// - `EXPENSE` - EXPENSE
	// - `LIABILITY` - LIABILITY
	// - `REVENUE` - REVENUE
	Classification *AccountClassification `json:"classification,omitempty"`
	// The account's type is a narrower and more specific grouping within the account's classification.
	Type *string `json:"type,omitempty"`
	// Normalized account type- which is a narrower and more specific grouping within the account's classification.
	//
	// - `BANK` - BANK
	// - `CREDIT_CARD` - CREDIT_CARD
	// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	// - `FIXED_ASSET` - FIXED_ASSET
	// - `OTHER_ASSET` - OTHER_ASSET
	// - `OTHER_CURRENT_ASSET` - OTHER_CURRENT_ASSET
	// - `OTHER_EXPENSE` - OTHER_EXPENSE
	// - `OTHER_INCOME` - OTHER_INCOME
	// - `COST_OF_GOODS_SOLD` - COST_OF_GOODS_SOLD
	// - `OTHER_CURRENT_LIABILITY` - OTHER_CURRENT_LIABILITY
	// - `LONG_TERM_LIABILITY` - LONG_TERM_LIABILITY
	// - `NON_POSTING` - NON_POSTING
	AccountType *AccountAccountType `json:"account_type,omitempty"`
	// The account's status.
	//
	// - `ACTIVE` - ACTIVE
	// - `PENDING` - PENDING
	// - `INACTIVE` - INACTIVE
	Status *AccountStatus `json:"status,omitempty"`
	// The account's current balance.
	CurrentBalance *float64 `json:"current_balance,omitempty"`
	// The account's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *AccountCurrency `json:"currency,omitempty"`
	// The account's number.
	AccountNumber *string `json:"account_number,omitempty"`
	// ID of the parent account.
	ParentAccount *string `json:"parent_account,omitempty"`
	// The company the account belongs to.
	Company *string `json:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type unmarshaler Account
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Account(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Account) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Normalized account type- which is a narrower and more specific grouping within the account's classification.
//
// - `BANK` - BANK
// - `CREDIT_CARD` - CREDIT_CARD
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// - `FIXED_ASSET` - FIXED_ASSET
// - `OTHER_ASSET` - OTHER_ASSET
// - `OTHER_CURRENT_ASSET` - OTHER_CURRENT_ASSET
// - `OTHER_EXPENSE` - OTHER_EXPENSE
// - `OTHER_INCOME` - OTHER_INCOME
// - `COST_OF_GOODS_SOLD` - COST_OF_GOODS_SOLD
// - `OTHER_CURRENT_LIABILITY` - OTHER_CURRENT_LIABILITY
// - `LONG_TERM_LIABILITY` - LONG_TERM_LIABILITY
// - `NON_POSTING` - NON_POSTING
type AccountAccountType struct {
	typeName               string
	AccountAccountTypeEnum AccountAccountTypeEnum
	String                 string
}

func NewAccountAccountTypeFromAccountAccountTypeEnum(value AccountAccountTypeEnum) *AccountAccountType {
	return &AccountAccountType{typeName: "accountAccountTypeEnum", AccountAccountTypeEnum: value}
}

func NewAccountAccountTypeFromString(value string) *AccountAccountType {
	return &AccountAccountType{typeName: "string", String: value}
}

func (a *AccountAccountType) UnmarshalJSON(data []byte) error {
	var valueAccountAccountTypeEnum AccountAccountTypeEnum
	if err := json.Unmarshal(data, &valueAccountAccountTypeEnum); err == nil {
		a.typeName = "accountAccountTypeEnum"
		a.AccountAccountTypeEnum = valueAccountAccountTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountAccountType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "accountAccountTypeEnum":
		return json.Marshal(a.AccountAccountTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountAccountTypeVisitor interface {
	VisitAccountAccountTypeEnum(AccountAccountTypeEnum) error
	VisitString(string) error
}

func (a *AccountAccountType) Accept(visitor AccountAccountTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "accountAccountTypeEnum":
		return visitor.VisitAccountAccountTypeEnum(a.AccountAccountTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// - `BANK` - BANK
// - `CREDIT_CARD` - CREDIT_CARD
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// - `FIXED_ASSET` - FIXED_ASSET
// - `OTHER_ASSET` - OTHER_ASSET
// - `OTHER_CURRENT_ASSET` - OTHER_CURRENT_ASSET
// - `OTHER_EXPENSE` - OTHER_EXPENSE
// - `OTHER_INCOME` - OTHER_INCOME
// - `COST_OF_GOODS_SOLD` - COST_OF_GOODS_SOLD
// - `OTHER_CURRENT_LIABILITY` - OTHER_CURRENT_LIABILITY
// - `LONG_TERM_LIABILITY` - LONG_TERM_LIABILITY
// - `NON_POSTING` - NON_POSTING
type AccountAccountTypeEnum string

const (
	AccountAccountTypeEnumBank                  AccountAccountTypeEnum = "BANK"
	AccountAccountTypeEnumCreditCard            AccountAccountTypeEnum = "CREDIT_CARD"
	AccountAccountTypeEnumAccountsPayable       AccountAccountTypeEnum = "ACCOUNTS_PAYABLE"
	AccountAccountTypeEnumAccountsReceivable    AccountAccountTypeEnum = "ACCOUNTS_RECEIVABLE"
	AccountAccountTypeEnumFixedAsset            AccountAccountTypeEnum = "FIXED_ASSET"
	AccountAccountTypeEnumOtherAsset            AccountAccountTypeEnum = "OTHER_ASSET"
	AccountAccountTypeEnumOtherCurrentAsset     AccountAccountTypeEnum = "OTHER_CURRENT_ASSET"
	AccountAccountTypeEnumOtherExpense          AccountAccountTypeEnum = "OTHER_EXPENSE"
	AccountAccountTypeEnumOtherIncome           AccountAccountTypeEnum = "OTHER_INCOME"
	AccountAccountTypeEnumCostOfGoodsSold       AccountAccountTypeEnum = "COST_OF_GOODS_SOLD"
	AccountAccountTypeEnumOtherCurrentLiability AccountAccountTypeEnum = "OTHER_CURRENT_LIABILITY"
	AccountAccountTypeEnumLongTermLiability     AccountAccountTypeEnum = "LONG_TERM_LIABILITY"
	AccountAccountTypeEnumNonPosting            AccountAccountTypeEnum = "NON_POSTING"
)

func NewAccountAccountTypeEnumFromString(s string) (AccountAccountTypeEnum, error) {
	switch s {
	case "BANK":
		return AccountAccountTypeEnumBank, nil
	case "CREDIT_CARD":
		return AccountAccountTypeEnumCreditCard, nil
	case "ACCOUNTS_PAYABLE":
		return AccountAccountTypeEnumAccountsPayable, nil
	case "ACCOUNTS_RECEIVABLE":
		return AccountAccountTypeEnumAccountsReceivable, nil
	case "FIXED_ASSET":
		return AccountAccountTypeEnumFixedAsset, nil
	case "OTHER_ASSET":
		return AccountAccountTypeEnumOtherAsset, nil
	case "OTHER_CURRENT_ASSET":
		return AccountAccountTypeEnumOtherCurrentAsset, nil
	case "OTHER_EXPENSE":
		return AccountAccountTypeEnumOtherExpense, nil
	case "OTHER_INCOME":
		return AccountAccountTypeEnumOtherIncome, nil
	case "COST_OF_GOODS_SOLD":
		return AccountAccountTypeEnumCostOfGoodsSold, nil
	case "OTHER_CURRENT_LIABILITY":
		return AccountAccountTypeEnumOtherCurrentLiability, nil
	case "LONG_TERM_LIABILITY":
		return AccountAccountTypeEnumLongTermLiability, nil
	case "NON_POSTING":
		return AccountAccountTypeEnumNonPosting, nil
	}
	var t AccountAccountTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountAccountTypeEnum) Ptr() *AccountAccountTypeEnum {
	return &a
}

// The account's broadest grouping.
//
// - `ASSET` - ASSET
// - `EQUITY` - EQUITY
// - `EXPENSE` - EXPENSE
// - `LIABILITY` - LIABILITY
// - `REVENUE` - REVENUE
type AccountClassification struct {
	typeName           string
	ClassificationEnum ClassificationEnum
	String             string
}

func NewAccountClassificationFromClassificationEnum(value ClassificationEnum) *AccountClassification {
	return &AccountClassification{typeName: "classificationEnum", ClassificationEnum: value}
}

func NewAccountClassificationFromString(value string) *AccountClassification {
	return &AccountClassification{typeName: "string", String: value}
}

func (a *AccountClassification) UnmarshalJSON(data []byte) error {
	var valueClassificationEnum ClassificationEnum
	if err := json.Unmarshal(data, &valueClassificationEnum); err == nil {
		a.typeName = "classificationEnum"
		a.ClassificationEnum = valueClassificationEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountClassification) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "classificationEnum":
		return json.Marshal(a.ClassificationEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountClassificationVisitor interface {
	VisitClassificationEnum(ClassificationEnum) error
	VisitString(string) error
}

func (a *AccountClassification) Accept(visitor AccountClassificationVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "classificationEnum":
		return visitor.VisitClassificationEnum(a.ClassificationEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The account's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type AccountCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewAccountCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *AccountCurrency {
	return &AccountCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewAccountCurrencyFromString(value string) *AccountCurrency {
	return &AccountCurrency{typeName: "string", String: value}
}

func (a *AccountCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		a.typeName = "transactionCurrencyEnum"
		a.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountCurrency) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "transactionCurrencyEnum":
		return json.Marshal(a.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (a *AccountCurrency) Accept(visitor AccountCurrencyVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(a.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

type AccountDetails struct {
	Id                      *string       `json:"id,omitempty"`
	Integration             *string       `json:"integration,omitempty"`
	IntegrationSlug         *string       `json:"integration_slug,omitempty"`
	Category                *CategoryEnum `json:"category,omitempty"`
	EndUserOriginId         *string       `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName *string       `json:"end_user_organization_name,omitempty"`
	EndUserEmailAddress     *string       `json:"end_user_email_address,omitempty"`
	Status                  *string       `json:"status,omitempty"`
	WebhookListenerUrl      *string       `json:"webhook_listener_url,omitempty"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool   `json:"is_duplicate,omitempty"`
	AccountType *string `json:"account_type,omitempty"`
	// The time at which account completes the linking flow.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetails(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The LinkedAccount Object
//
// ### Description
//
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
//
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                             `json:"id"`
	Category                *CategoryEnum                      `json:"category,omitempty"`
	Status                  AccountDetailsAndActionsStatusEnum `json:"status,omitempty"`
	StatusDetail            *string                            `json:"status_detail,omitempty"`
	EndUserOriginId         *string                            `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                             `json:"end_user_organization_name"`
	EndUserEmailAddress     string                             `json:"end_user_email_address"`
	// The tenant or domain the customer has provided access to.
	Subdomain          *string `json:"subdomain,omitempty"`
	WebhookListenerUrl string  `json:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty"`
	AccountType string                               `json:"account_type"`
	CompletedAt time.Time                            `json:"completed_at"`

	_rawJSON json.RawMessage
}

func (a *AccountDetailsAndActions) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetailsAndActions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetailsAndActions(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetailsAndActions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name"`
	Categories               []CategoriesEnum  `json:"categories,omitempty"`
	Image                    *string           `json:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty"`
	Color                    string            `json:"color"`
	Slug                     string            `json:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountDetailsAndActionsIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetailsAndActionsIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetailsAndActionsIntegration(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetailsAndActionsIntegration) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// - `COMPLETE` - COMPLETE
// - `INCOMPLETE` - INCOMPLETE
// - `RELINK_NEEDED` - RELINK_NEEDED
// - `IDLE` - IDLE
type AccountDetailsAndActionsStatusEnum string

const (
	AccountDetailsAndActionsStatusEnumComplete     AccountDetailsAndActionsStatusEnum = "COMPLETE"
	AccountDetailsAndActionsStatusEnumIncomplete   AccountDetailsAndActionsStatusEnum = "INCOMPLETE"
	AccountDetailsAndActionsStatusEnumRelinkNeeded AccountDetailsAndActionsStatusEnum = "RELINK_NEEDED"
	AccountDetailsAndActionsStatusEnumIdle         AccountDetailsAndActionsStatusEnum = "IDLE"
)

func NewAccountDetailsAndActionsStatusEnumFromString(s string) (AccountDetailsAndActionsStatusEnum, error) {
	switch s {
	case "COMPLETE":
		return AccountDetailsAndActionsStatusEnumComplete, nil
	case "INCOMPLETE":
		return AccountDetailsAndActionsStatusEnumIncomplete, nil
	case "RELINK_NEEDED":
		return AccountDetailsAndActionsStatusEnumRelinkNeeded, nil
	case "IDLE":
		return AccountDetailsAndActionsStatusEnumIdle, nil
	}
	var t AccountDetailsAndActionsStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountDetailsAndActionsStatusEnum) Ptr() *AccountDetailsAndActionsStatusEnum {
	return &a
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name"`
	// Optional. This shortened name appears in places with limited space, usually in conjunction with the platform's logo (e.g., Merge Link menu).<br><br>Example: <i>Workforce Now (in lieu of ADP Workforce Now), SuccessFactors (in lieu of SAP SuccessFactors)</i>
	AbbreviatedName *string `json:"abbreviated_name,omitempty"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty"`
	// Company logo in rectangular shape.
	Image *string `json:"image,omitempty"`
	// Company logo in square shape.
	SquareImage *string `json:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]interface{} `json:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty"`
	// Category or categories this integration is in beta status for.
	CategoryBetaStatus map[string]interface{} `json:"category_beta_status,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountIntegration(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountIntegration) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The Account Object
//
// ### Description
//
// An `Account` represents a category in a company’s ledger in which a financial transaction is recorded against. The aggregation of each `Account` object is often referred to as the **Chart of Accounts**.
//
// An `Account` can be classified into one of the following categories, determined through the `classification` field:
//
// - **Asset:** Accounts Receivable and Bank Accounts
// - **Liability:** Accounts Payable and Credit Card Accounts
// - **Equity:** Treasury Accounts and Retained Earnings
// - **Revenue:** Income and Other Income
// - **Expense:** Cost of Goods Sold and Office Expenses
//
// ### Usage Example
//
// Fetch from the `LIST Accounts` endpoint and view a company's accounts.
type AccountRequest struct {
	// The account's name.
	Name *string `json:"name,omitempty"`
	// The account's description.
	Description *string `json:"description,omitempty"`
	// The account's broadest grouping.
	//
	// - `ASSET` - ASSET
	// - `EQUITY` - EQUITY
	// - `EXPENSE` - EXPENSE
	// - `LIABILITY` - LIABILITY
	// - `REVENUE` - REVENUE
	Classification *AccountRequestClassification `json:"classification,omitempty"`
	// The account's type is a narrower and more specific grouping within the account's classification.
	Type *string `json:"type,omitempty"`
	// Normalized account type- which is a narrower and more specific grouping within the account's classification.
	//
	// - `BANK` - BANK
	// - `CREDIT_CARD` - CREDIT_CARD
	// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	// - `FIXED_ASSET` - FIXED_ASSET
	// - `OTHER_ASSET` - OTHER_ASSET
	// - `OTHER_CURRENT_ASSET` - OTHER_CURRENT_ASSET
	// - `OTHER_EXPENSE` - OTHER_EXPENSE
	// - `OTHER_INCOME` - OTHER_INCOME
	// - `COST_OF_GOODS_SOLD` - COST_OF_GOODS_SOLD
	// - `OTHER_CURRENT_LIABILITY` - OTHER_CURRENT_LIABILITY
	// - `LONG_TERM_LIABILITY` - LONG_TERM_LIABILITY
	// - `NON_POSTING` - NON_POSTING
	AccountType *AccountRequestAccountType `json:"account_type,omitempty"`
	// The account's status.
	//
	// - `ACTIVE` - ACTIVE
	// - `PENDING` - PENDING
	// - `INACTIVE` - INACTIVE
	Status *AccountRequestStatus `json:"status,omitempty"`
	// The account's current balance.
	CurrentBalance *float64 `json:"current_balance,omitempty"`
	// The account's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *AccountRequestCurrency `json:"currency,omitempty"`
	// The account's number.
	AccountNumber *string `json:"account_number,omitempty"`
	// ID of the parent account.
	ParentAccount *string `json:"parent_account,omitempty"`
	// The company the account belongs to.
	Company             *string                `json:"company,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Normalized account type- which is a narrower and more specific grouping within the account's classification.
//
// - `BANK` - BANK
// - `CREDIT_CARD` - CREDIT_CARD
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// - `FIXED_ASSET` - FIXED_ASSET
// - `OTHER_ASSET` - OTHER_ASSET
// - `OTHER_CURRENT_ASSET` - OTHER_CURRENT_ASSET
// - `OTHER_EXPENSE` - OTHER_EXPENSE
// - `OTHER_INCOME` - OTHER_INCOME
// - `COST_OF_GOODS_SOLD` - COST_OF_GOODS_SOLD
// - `OTHER_CURRENT_LIABILITY` - OTHER_CURRENT_LIABILITY
// - `LONG_TERM_LIABILITY` - LONG_TERM_LIABILITY
// - `NON_POSTING` - NON_POSTING
type AccountRequestAccountType struct {
	typeName               string
	AccountAccountTypeEnum AccountAccountTypeEnum
	String                 string
}

func NewAccountRequestAccountTypeFromAccountAccountTypeEnum(value AccountAccountTypeEnum) *AccountRequestAccountType {
	return &AccountRequestAccountType{typeName: "accountAccountTypeEnum", AccountAccountTypeEnum: value}
}

func NewAccountRequestAccountTypeFromString(value string) *AccountRequestAccountType {
	return &AccountRequestAccountType{typeName: "string", String: value}
}

func (a *AccountRequestAccountType) UnmarshalJSON(data []byte) error {
	var valueAccountAccountTypeEnum AccountAccountTypeEnum
	if err := json.Unmarshal(data, &valueAccountAccountTypeEnum); err == nil {
		a.typeName = "accountAccountTypeEnum"
		a.AccountAccountTypeEnum = valueAccountAccountTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountRequestAccountType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "accountAccountTypeEnum":
		return json.Marshal(a.AccountAccountTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountRequestAccountTypeVisitor interface {
	VisitAccountAccountTypeEnum(AccountAccountTypeEnum) error
	VisitString(string) error
}

func (a *AccountRequestAccountType) Accept(visitor AccountRequestAccountTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "accountAccountTypeEnum":
		return visitor.VisitAccountAccountTypeEnum(a.AccountAccountTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The account's broadest grouping.
//
// - `ASSET` - ASSET
// - `EQUITY` - EQUITY
// - `EXPENSE` - EXPENSE
// - `LIABILITY` - LIABILITY
// - `REVENUE` - REVENUE
type AccountRequestClassification struct {
	typeName           string
	ClassificationEnum ClassificationEnum
	String             string
}

func NewAccountRequestClassificationFromClassificationEnum(value ClassificationEnum) *AccountRequestClassification {
	return &AccountRequestClassification{typeName: "classificationEnum", ClassificationEnum: value}
}

func NewAccountRequestClassificationFromString(value string) *AccountRequestClassification {
	return &AccountRequestClassification{typeName: "string", String: value}
}

func (a *AccountRequestClassification) UnmarshalJSON(data []byte) error {
	var valueClassificationEnum ClassificationEnum
	if err := json.Unmarshal(data, &valueClassificationEnum); err == nil {
		a.typeName = "classificationEnum"
		a.ClassificationEnum = valueClassificationEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountRequestClassification) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "classificationEnum":
		return json.Marshal(a.ClassificationEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountRequestClassificationVisitor interface {
	VisitClassificationEnum(ClassificationEnum) error
	VisitString(string) error
}

func (a *AccountRequestClassification) Accept(visitor AccountRequestClassificationVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "classificationEnum":
		return visitor.VisitClassificationEnum(a.ClassificationEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The account's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type AccountRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewAccountRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *AccountRequestCurrency {
	return &AccountRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewAccountRequestCurrencyFromString(value string) *AccountRequestCurrency {
	return &AccountRequestCurrency{typeName: "string", String: value}
}

func (a *AccountRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		a.typeName = "transactionCurrencyEnum"
		a.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountRequestCurrency) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "transactionCurrencyEnum":
		return json.Marshal(a.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (a *AccountRequestCurrency) Accept(visitor AccountRequestCurrencyVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(a.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The account's status.
//
// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type AccountRequestStatus struct {
	typeName          string
	AccountStatusEnum AccountStatusEnum
	String            string
}

func NewAccountRequestStatusFromAccountStatusEnum(value AccountStatusEnum) *AccountRequestStatus {
	return &AccountRequestStatus{typeName: "accountStatusEnum", AccountStatusEnum: value}
}

func NewAccountRequestStatusFromString(value string) *AccountRequestStatus {
	return &AccountRequestStatus{typeName: "string", String: value}
}

func (a *AccountRequestStatus) UnmarshalJSON(data []byte) error {
	var valueAccountStatusEnum AccountStatusEnum
	if err := json.Unmarshal(data, &valueAccountStatusEnum); err == nil {
		a.typeName = "accountStatusEnum"
		a.AccountStatusEnum = valueAccountStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountRequestStatus) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "accountStatusEnum":
		return json.Marshal(a.AccountStatusEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountRequestStatusVisitor interface {
	VisitAccountStatusEnum(AccountStatusEnum) error
	VisitString(string) error
}

func (a *AccountRequestStatus) Accept(visitor AccountRequestStatusVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "accountStatusEnum":
		return visitor.VisitAccountStatusEnum(a.AccountStatusEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

type AccountResponse struct {
	Model    *Account                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountResponse(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The account's status.
//
// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type AccountStatus struct {
	typeName          string
	AccountStatusEnum AccountStatusEnum
	String            string
}

func NewAccountStatusFromAccountStatusEnum(value AccountStatusEnum) *AccountStatus {
	return &AccountStatus{typeName: "accountStatusEnum", AccountStatusEnum: value}
}

func NewAccountStatusFromString(value string) *AccountStatus {
	return &AccountStatus{typeName: "string", String: value}
}

func (a *AccountStatus) UnmarshalJSON(data []byte) error {
	var valueAccountStatusEnum AccountStatusEnum
	if err := json.Unmarshal(data, &valueAccountStatusEnum); err == nil {
		a.typeName = "accountStatusEnum"
		a.AccountStatusEnum = valueAccountStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountStatus) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "accountStatusEnum":
		return json.Marshal(a.AccountStatusEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountStatusVisitor interface {
	VisitAccountStatusEnum(AccountStatusEnum) error
	VisitString(string) error
}

func (a *AccountStatus) Accept(visitor AccountStatusVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "accountStatusEnum":
		return visitor.VisitAccountStatusEnum(a.AccountStatusEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// - `ACTIVE` - ACTIVE
// - `PENDING` - PENDING
// - `INACTIVE` - INACTIVE
type AccountStatusEnum string

const (
	AccountStatusEnumActive   AccountStatusEnum = "ACTIVE"
	AccountStatusEnumPending  AccountStatusEnum = "PENDING"
	AccountStatusEnumInactive AccountStatusEnum = "INACTIVE"
)

func NewAccountStatusEnumFromString(s string) (AccountStatusEnum, error) {
	switch s {
	case "ACTIVE":
		return AccountStatusEnumActive, nil
	case "PENDING":
		return AccountStatusEnumPending, nil
	case "INACTIVE":
		return AccountStatusEnumInactive, nil
	}
	var t AccountStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountStatusEnum) Ptr() *AccountStatusEnum {
	return &a
}

type AccountToken struct {
	AccountToken string              `json:"account_token"`
	Integration  *AccountIntegration `json:"integration,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountToken) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountToken(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountToken) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The Accounting Attachment Object
//
// ### Description
//
// The `AccountingAttachment` object is used to represent a company's attachments.
//
// ### Usage Example
//
// Fetch from the `LIST AccountingAttachments` endpoint and view a company's attachments.
type AccountingAttachment struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The attachment's name.
	FileName *string `json:"file_name,omitempty"`
	// The attachment's url.
	FileUrl *string `json:"file_url,omitempty"`
	// The company the accounting attachment belongs to.
	Company *string `json:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountingAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountingAttachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountingAttachment(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingAttachment) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The Accounting Attachment Object
//
// ### Description
//
// The `AccountingAttachment` object is used to represent a company's attachments.
//
// ### Usage Example
//
// Fetch from the `LIST AccountingAttachments` endpoint and view a company's attachments.
type AccountingAttachmentRequest struct {
	// The attachment's name.
	FileName *string `json:"file_name,omitempty"`
	// The attachment's url.
	FileUrl *string `json:"file_url,omitempty"`
	// The company the accounting attachment belongs to.
	Company             *string                `json:"company,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountingAttachmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountingAttachmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountingAttachmentRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingAttachmentRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountingAttachmentResponse struct {
	Model    *AccountingAttachment       `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountingAttachmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountingAttachmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountingAttachmentResponse(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingAttachmentResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The AccountingPeriod Object
//
// ### Description
//
// The `AccountingPeriod` object is used to define a period of time in which events occurred.
//
// ### Usage Example
//
// Common models like `Invoice` and `Transaction` will have `AccountingPeriod` objects which will denote when they occurred.
type AccountingPeriod struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// Name of the accounting period.
	Name   *string                 `json:"name,omitempty"`
	Status *AccountingPeriodStatus `json:"status,omitempty"`
	// Beginning date of the period
	StartDate *time.Time `json:"start_date,omitempty"`
	// End date of the period
	EndDate       *time.Time             `json:"end_date,omitempty"`
	FieldMappings map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountingPeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountingPeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountingPeriod(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingPeriod) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountingPeriodStatus struct {
	typeName      string
	Status895Enum Status895Enum
	String        string
}

func NewAccountingPeriodStatusFromStatus895Enum(value Status895Enum) *AccountingPeriodStatus {
	return &AccountingPeriodStatus{typeName: "status895Enum", Status895Enum: value}
}

func NewAccountingPeriodStatusFromString(value string) *AccountingPeriodStatus {
	return &AccountingPeriodStatus{typeName: "string", String: value}
}

func (a *AccountingPeriodStatus) UnmarshalJSON(data []byte) error {
	var valueStatus895Enum Status895Enum
	if err := json.Unmarshal(data, &valueStatus895Enum); err == nil {
		a.typeName = "status895Enum"
		a.Status895Enum = valueStatus895Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountingPeriodStatus) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "status895Enum":
		return json.Marshal(a.Status895Enum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AccountingPeriodStatusVisitor interface {
	VisitStatus895Enum(Status895Enum) error
	VisitString(string) error
}

func (a *AccountingPeriodStatus) Accept(visitor AccountingPeriodStatusVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "status895Enum":
		return visitor.VisitStatus895Enum(a.Status895Enum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The AccountingPhoneNumber Object
//
// ### Description
//
// The `AccountingPhoneNumber` object is used to represent a contact's or company's phone number.
//
// ### Usage Example
//
// Fetch from the `GET CompanyInfo` endpoint and view the company's phone numbers.
type AccountingPhoneNumber struct {
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The phone number.
	Number *string `json:"number,omitempty"`
	// The phone number's type.
	Type *string `json:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountingPhoneNumber) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountingPhoneNumber
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountingPhoneNumber(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingPhoneNumber) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The AccountingPhoneNumber Object
//
// ### Description
//
// The `AccountingPhoneNumber` object is used to represent a contact's or company's phone number.
//
// ### Usage Example
//
// Fetch from the `GET CompanyInfo` endpoint and view the company's phone numbers.
type AccountingPhoneNumberRequest struct {
	// The phone number.
	Number *string `json:"number,omitempty"`
	// The phone number's type.
	Type                *string                `json:"type,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountingPhoneNumberRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountingPhoneNumberRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountingPhoneNumberRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingPhoneNumberRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The Address Object
//
// ### Description
//
// The `Address` object is used to represent a contact's or company's address.
//
// ### Usage Example
//
// Fetch from the `GET CompanyInfo` endpoint and view the company's addresses.
type Address struct {
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The address type.
	//
	// - `BILLING` - BILLING
	// - `SHIPPING` - SHIPPING
	Type *AddressType `json:"type,omitempty"`
	// Line 1 of the address's street.
	Street1 *string `json:"street_1,omitempty"`
	// Line 2 of the address's street.
	Street2 *string `json:"street_2,omitempty"`
	// The address's city.
	City  *string     `json:"city,omitempty"`
	State interface{} `json:"state,omitempty"`
	// The address's state or region.
	CountrySubdivision *string `json:"country_subdivision,omitempty"`
	// The address's country.
	//
	// - `AF` - Afghanistan
	// - `AX` - Åland Islands
	// - `AL` - Albania
	// - `DZ` - Algeria
	// - `AS` - American Samoa
	// - `AD` - Andorra
	// - `AO` - Angola
	// - `AI` - Anguilla
	// - `AQ` - Antarctica
	// - `AG` - Antigua and Barbuda
	// - `AR` - Argentina
	// - `AM` - Armenia
	// - `AW` - Aruba
	// - `AU` - Australia
	// - `AT` - Austria
	// - `AZ` - Azerbaijan
	// - `BS` - Bahamas
	// - `BH` - Bahrain
	// - `BD` - Bangladesh
	// - `BB` - Barbados
	// - `BY` - Belarus
	// - `BE` - Belgium
	// - `BZ` - Belize
	// - `BJ` - Benin
	// - `BM` - Bermuda
	// - `BT` - Bhutan
	// - `BO` - Bolivia
	// - `BQ` - Bonaire, Sint Eustatius and Saba
	// - `BA` - Bosnia and Herzegovina
	// - `BW` - Botswana
	// - `BV` - Bouvet Island
	// - `BR` - Brazil
	// - `IO` - British Indian Ocean Territory
	// - `BN` - Brunei
	// - `BG` - Bulgaria
	// - `BF` - Burkina Faso
	// - `BI` - Burundi
	// - `CV` - Cabo Verde
	// - `KH` - Cambodia
	// - `CM` - Cameroon
	// - `CA` - Canada
	// - `KY` - Cayman Islands
	// - `CF` - Central African Republic
	// - `TD` - Chad
	// - `CL` - Chile
	// - `CN` - China
	// - `CX` - Christmas Island
	// - `CC` - Cocos (Keeling) Islands
	// - `CO` - Colombia
	// - `KM` - Comoros
	// - `CG` - Congo
	// - `CD` - Congo (the Democratic Republic of the)
	// - `CK` - Cook Islands
	// - `CR` - Costa Rica
	// - `CI` - Côte d'Ivoire
	// - `HR` - Croatia
	// - `CU` - Cuba
	// - `CW` - Curaçao
	// - `CY` - Cyprus
	// - `CZ` - Czechia
	// - `DK` - Denmark
	// - `DJ` - Djibouti
	// - `DM` - Dominica
	// - `DO` - Dominican Republic
	// - `EC` - Ecuador
	// - `EG` - Egypt
	// - `SV` - El Salvador
	// - `GQ` - Equatorial Guinea
	// - `ER` - Eritrea
	// - `EE` - Estonia
	// - `SZ` - Eswatini
	// - `ET` - Ethiopia
	// - `FK` - Falkland Islands (Malvinas)
	// - `FO` - Faroe Islands
	// - `FJ` - Fiji
	// - `FI` - Finland
	// - `FR` - France
	// - `GF` - French Guiana
	// - `PF` - French Polynesia
	// - `TF` - French Southern Territories
	// - `GA` - Gabon
	// - `GM` - Gambia
	// - `GE` - Georgia
	// - `DE` - Germany
	// - `GH` - Ghana
	// - `GI` - Gibraltar
	// - `GR` - Greece
	// - `GL` - Greenland
	// - `GD` - Grenada
	// - `GP` - Guadeloupe
	// - `GU` - Guam
	// - `GT` - Guatemala
	// - `GG` - Guernsey
	// - `GN` - Guinea
	// - `GW` - Guinea-Bissau
	// - `GY` - Guyana
	// - `HT` - Haiti
	// - `HM` - Heard Island and McDonald Islands
	// - `VA` - Holy See
	// - `HN` - Honduras
	// - `HK` - Hong Kong
	// - `HU` - Hungary
	// - `IS` - Iceland
	// - `IN` - India
	// - `ID` - Indonesia
	// - `IR` - Iran
	// - `IQ` - Iraq
	// - `IE` - Ireland
	// - `IM` - Isle of Man
	// - `IL` - Israel
	// - `IT` - Italy
	// - `JM` - Jamaica
	// - `JP` - Japan
	// - `JE` - Jersey
	// - `JO` - Jordan
	// - `KZ` - Kazakhstan
	// - `KE` - Kenya
	// - `KI` - Kiribati
	// - `KW` - Kuwait
	// - `KG` - Kyrgyzstan
	// - `LA` - Laos
	// - `LV` - Latvia
	// - `LB` - Lebanon
	// - `LS` - Lesotho
	// - `LR` - Liberia
	// - `LY` - Libya
	// - `LI` - Liechtenstein
	// - `LT` - Lithuania
	// - `LU` - Luxembourg
	// - `MO` - Macao
	// - `MG` - Madagascar
	// - `MW` - Malawi
	// - `MY` - Malaysia
	// - `MV` - Maldives
	// - `ML` - Mali
	// - `MT` - Malta
	// - `MH` - Marshall Islands
	// - `MQ` - Martinique
	// - `MR` - Mauritania
	// - `MU` - Mauritius
	// - `YT` - Mayotte
	// - `MX` - Mexico
	// - `FM` - Micronesia (Federated States of)
	// - `MD` - Moldova
	// - `MC` - Monaco
	// - `MN` - Mongolia
	// - `ME` - Montenegro
	// - `MS` - Montserrat
	// - `MA` - Morocco
	// - `MZ` - Mozambique
	// - `MM` - Myanmar
	// - `NA` - Namibia
	// - `NR` - Nauru
	// - `NP` - Nepal
	// - `NL` - Netherlands
	// - `NC` - New Caledonia
	// - `NZ` - New Zealand
	// - `NI` - Nicaragua
	// - `NE` - Niger
	// - `NG` - Nigeria
	// - `NU` - Niue
	// - `NF` - Norfolk Island
	// - `KP` - North Korea
	// - `MK` - North Macedonia
	// - `MP` - Northern Mariana Islands
	// - `NO` - Norway
	// - `OM` - Oman
	// - `PK` - Pakistan
	// - `PW` - Palau
	// - `PS` - Palestine, State of
	// - `PA` - Panama
	// - `PG` - Papua New Guinea
	// - `PY` - Paraguay
	// - `PE` - Peru
	// - `PH` - Philippines
	// - `PN` - Pitcairn
	// - `PL` - Poland
	// - `PT` - Portugal
	// - `PR` - Puerto Rico
	// - `QA` - Qatar
	// - `RE` - Réunion
	// - `RO` - Romania
	// - `RU` - Russia
	// - `RW` - Rwanda
	// - `BL` - Saint Barthélemy
	// - `SH` - Saint Helena, Ascension and Tristan da Cunha
	// - `KN` - Saint Kitts and Nevis
	// - `LC` - Saint Lucia
	// - `MF` - Saint Martin (French part)
	// - `PM` - Saint Pierre and Miquelon
	// - `VC` - Saint Vincent and the Grenadines
	// - `WS` - Samoa
	// - `SM` - San Marino
	// - `ST` - Sao Tome and Principe
	// - `SA` - Saudi Arabia
	// - `SN` - Senegal
	// - `RS` - Serbia
	// - `SC` - Seychelles
	// - `SL` - Sierra Leone
	// - `SG` - Singapore
	// - `SX` - Sint Maarten (Dutch part)
	// - `SK` - Slovakia
	// - `SI` - Slovenia
	// - `SB` - Solomon Islands
	// - `SO` - Somalia
	// - `ZA` - South Africa
	// - `GS` - South Georgia and the South Sandwich Islands
	// - `KR` - South Korea
	// - `SS` - South Sudan
	// - `ES` - Spain
	// - `LK` - Sri Lanka
	// - `SD` - Sudan
	// - `SR` - Suriname
	// - `SJ` - Svalbard and Jan Mayen
	// - `SE` - Sweden
	// - `CH` - Switzerland
	// - `SY` - Syria
	// - `TW` - Taiwan
	// - `TJ` - Tajikistan
	// - `TZ` - Tanzania
	// - `TH` - Thailand
	// - `TL` - Timor-Leste
	// - `TG` - Togo
	// - `TK` - Tokelau
	// - `TO` - Tonga
	// - `TT` - Trinidad and Tobago
	// - `TN` - Tunisia
	// - `TR` - Turkey
	// - `TM` - Turkmenistan
	// - `TC` - Turks and Caicos Islands
	// - `TV` - Tuvalu
	// - `UG` - Uganda
	// - `UA` - Ukraine
	// - `AE` - United Arab Emirates
	// - `GB` - United Kingdom
	// - `UM` - United States Minor Outlying Islands
	// - `US` - United States of America
	// - `UY` - Uruguay
	// - `UZ` - Uzbekistan
	// - `VU` - Vanuatu
	// - `VE` - Venezuela
	// - `VN` - Vietnam
	// - `VG` - Virgin Islands (British)
	// - `VI` - Virgin Islands (U.S.)
	// - `WF` - Wallis and Futuna
	// - `EH` - Western Sahara
	// - `YE` - Yemen
	// - `ZM` - Zambia
	// - `ZW` - Zimbabwe
	Country *AddressCountry `json:"country,omitempty"`
	// The address's zip code.
	ZipCode *string `json:"zip_code,omitempty"`

	_rawJSON json.RawMessage
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The address's country.
//
// - `AF` - Afghanistan
// - `AX` - Åland Islands
// - `AL` - Albania
// - `DZ` - Algeria
// - `AS` - American Samoa
// - `AD` - Andorra
// - `AO` - Angola
// - `AI` - Anguilla
// - `AQ` - Antarctica
// - `AG` - Antigua and Barbuda
// - `AR` - Argentina
// - `AM` - Armenia
// - `AW` - Aruba
// - `AU` - Australia
// - `AT` - Austria
// - `AZ` - Azerbaijan
// - `BS` - Bahamas
// - `BH` - Bahrain
// - `BD` - Bangladesh
// - `BB` - Barbados
// - `BY` - Belarus
// - `BE` - Belgium
// - `BZ` - Belize
// - `BJ` - Benin
// - `BM` - Bermuda
// - `BT` - Bhutan
// - `BO` - Bolivia
// - `BQ` - Bonaire, Sint Eustatius and Saba
// - `BA` - Bosnia and Herzegovina
// - `BW` - Botswana
// - `BV` - Bouvet Island
// - `BR` - Brazil
// - `IO` - British Indian Ocean Territory
// - `BN` - Brunei
// - `BG` - Bulgaria
// - `BF` - Burkina Faso
// - `BI` - Burundi
// - `CV` - Cabo Verde
// - `KH` - Cambodia
// - `CM` - Cameroon
// - `CA` - Canada
// - `KY` - Cayman Islands
// - `CF` - Central African Republic
// - `TD` - Chad
// - `CL` - Chile
// - `CN` - China
// - `CX` - Christmas Island
// - `CC` - Cocos (Keeling) Islands
// - `CO` - Colombia
// - `KM` - Comoros
// - `CG` - Congo
// - `CD` - Congo (the Democratic Republic of the)
// - `CK` - Cook Islands
// - `CR` - Costa Rica
// - `CI` - Côte d'Ivoire
// - `HR` - Croatia
// - `CU` - Cuba
// - `CW` - Curaçao
// - `CY` - Cyprus
// - `CZ` - Czechia
// - `DK` - Denmark
// - `DJ` - Djibouti
// - `DM` - Dominica
// - `DO` - Dominican Republic
// - `EC` - Ecuador
// - `EG` - Egypt
// - `SV` - El Salvador
// - `GQ` - Equatorial Guinea
// - `ER` - Eritrea
// - `EE` - Estonia
// - `SZ` - Eswatini
// - `ET` - Ethiopia
// - `FK` - Falkland Islands (Malvinas)
// - `FO` - Faroe Islands
// - `FJ` - Fiji
// - `FI` - Finland
// - `FR` - France
// - `GF` - French Guiana
// - `PF` - French Polynesia
// - `TF` - French Southern Territories
// - `GA` - Gabon
// - `GM` - Gambia
// - `GE` - Georgia
// - `DE` - Germany
// - `GH` - Ghana
// - `GI` - Gibraltar
// - `GR` - Greece
// - `GL` - Greenland
// - `GD` - Grenada
// - `GP` - Guadeloupe
// - `GU` - Guam
// - `GT` - Guatemala
// - `GG` - Guernsey
// - `GN` - Guinea
// - `GW` - Guinea-Bissau
// - `GY` - Guyana
// - `HT` - Haiti
// - `HM` - Heard Island and McDonald Islands
// - `VA` - Holy See
// - `HN` - Honduras
// - `HK` - Hong Kong
// - `HU` - Hungary
// - `IS` - Iceland
// - `IN` - India
// - `ID` - Indonesia
// - `IR` - Iran
// - `IQ` - Iraq
// - `IE` - Ireland
// - `IM` - Isle of Man
// - `IL` - Israel
// - `IT` - Italy
// - `JM` - Jamaica
// - `JP` - Japan
// - `JE` - Jersey
// - `JO` - Jordan
// - `KZ` - Kazakhstan
// - `KE` - Kenya
// - `KI` - Kiribati
// - `KW` - Kuwait
// - `KG` - Kyrgyzstan
// - `LA` - Laos
// - `LV` - Latvia
// - `LB` - Lebanon
// - `LS` - Lesotho
// - `LR` - Liberia
// - `LY` - Libya
// - `LI` - Liechtenstein
// - `LT` - Lithuania
// - `LU` - Luxembourg
// - `MO` - Macao
// - `MG` - Madagascar
// - `MW` - Malawi
// - `MY` - Malaysia
// - `MV` - Maldives
// - `ML` - Mali
// - `MT` - Malta
// - `MH` - Marshall Islands
// - `MQ` - Martinique
// - `MR` - Mauritania
// - `MU` - Mauritius
// - `YT` - Mayotte
// - `MX` - Mexico
// - `FM` - Micronesia (Federated States of)
// - `MD` - Moldova
// - `MC` - Monaco
// - `MN` - Mongolia
// - `ME` - Montenegro
// - `MS` - Montserrat
// - `MA` - Morocco
// - `MZ` - Mozambique
// - `MM` - Myanmar
// - `NA` - Namibia
// - `NR` - Nauru
// - `NP` - Nepal
// - `NL` - Netherlands
// - `NC` - New Caledonia
// - `NZ` - New Zealand
// - `NI` - Nicaragua
// - `NE` - Niger
// - `NG` - Nigeria
// - `NU` - Niue
// - `NF` - Norfolk Island
// - `KP` - North Korea
// - `MK` - North Macedonia
// - `MP` - Northern Mariana Islands
// - `NO` - Norway
// - `OM` - Oman
// - `PK` - Pakistan
// - `PW` - Palau
// - `PS` - Palestine, State of
// - `PA` - Panama
// - `PG` - Papua New Guinea
// - `PY` - Paraguay
// - `PE` - Peru
// - `PH` - Philippines
// - `PN` - Pitcairn
// - `PL` - Poland
// - `PT` - Portugal
// - `PR` - Puerto Rico
// - `QA` - Qatar
// - `RE` - Réunion
// - `RO` - Romania
// - `RU` - Russia
// - `RW` - Rwanda
// - `BL` - Saint Barthélemy
// - `SH` - Saint Helena, Ascension and Tristan da Cunha
// - `KN` - Saint Kitts and Nevis
// - `LC` - Saint Lucia
// - `MF` - Saint Martin (French part)
// - `PM` - Saint Pierre and Miquelon
// - `VC` - Saint Vincent and the Grenadines
// - `WS` - Samoa
// - `SM` - San Marino
// - `ST` - Sao Tome and Principe
// - `SA` - Saudi Arabia
// - `SN` - Senegal
// - `RS` - Serbia
// - `SC` - Seychelles
// - `SL` - Sierra Leone
// - `SG` - Singapore
// - `SX` - Sint Maarten (Dutch part)
// - `SK` - Slovakia
// - `SI` - Slovenia
// - `SB` - Solomon Islands
// - `SO` - Somalia
// - `ZA` - South Africa
// - `GS` - South Georgia and the South Sandwich Islands
// - `KR` - South Korea
// - `SS` - South Sudan
// - `ES` - Spain
// - `LK` - Sri Lanka
// - `SD` - Sudan
// - `SR` - Suriname
// - `SJ` - Svalbard and Jan Mayen
// - `SE` - Sweden
// - `CH` - Switzerland
// - `SY` - Syria
// - `TW` - Taiwan
// - `TJ` - Tajikistan
// - `TZ` - Tanzania
// - `TH` - Thailand
// - `TL` - Timor-Leste
// - `TG` - Togo
// - `TK` - Tokelau
// - `TO` - Tonga
// - `TT` - Trinidad and Tobago
// - `TN` - Tunisia
// - `TR` - Turkey
// - `TM` - Turkmenistan
// - `TC` - Turks and Caicos Islands
// - `TV` - Tuvalu
// - `UG` - Uganda
// - `UA` - Ukraine
// - `AE` - United Arab Emirates
// - `GB` - United Kingdom
// - `UM` - United States Minor Outlying Islands
// - `US` - United States of America
// - `UY` - Uruguay
// - `UZ` - Uzbekistan
// - `VU` - Vanuatu
// - `VE` - Venezuela
// - `VN` - Vietnam
// - `VG` - Virgin Islands (British)
// - `VI` - Virgin Islands (U.S.)
// - `WF` - Wallis and Futuna
// - `EH` - Western Sahara
// - `YE` - Yemen
// - `ZM` - Zambia
// - `ZW` - Zimbabwe
type AddressCountry struct {
	typeName    string
	CountryEnum CountryEnum
	String      string
}

func NewAddressCountryFromCountryEnum(value CountryEnum) *AddressCountry {
	return &AddressCountry{typeName: "countryEnum", CountryEnum: value}
}

func NewAddressCountryFromString(value string) *AddressCountry {
	return &AddressCountry{typeName: "string", String: value}
}

func (a *AddressCountry) UnmarshalJSON(data []byte) error {
	var valueCountryEnum CountryEnum
	if err := json.Unmarshal(data, &valueCountryEnum); err == nil {
		a.typeName = "countryEnum"
		a.CountryEnum = valueCountryEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AddressCountry) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "countryEnum":
		return json.Marshal(a.CountryEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AddressCountryVisitor interface {
	VisitCountryEnum(CountryEnum) error
	VisitString(string) error
}

func (a *AddressCountry) Accept(visitor AddressCountryVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "countryEnum":
		return visitor.VisitCountryEnum(a.CountryEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The Address Object
//
// ### Description
//
// The `Address` object is used to represent a contact's or company's address.
//
// ### Usage Example
//
// Fetch from the `GET CompanyInfo` endpoint and view the company's addresses.
type AddressRequest struct {
	// The address type.
	//
	// - `BILLING` - BILLING
	// - `SHIPPING` - SHIPPING
	Type *AddressRequestType `json:"type,omitempty"`
	// Line 1 of the address's street.
	Street1 *string `json:"street_1,omitempty"`
	// Line 2 of the address's street.
	Street2 *string `json:"street_2,omitempty"`
	// The address's city.
	City *string `json:"city,omitempty"`
	// The address's state or region.
	CountrySubdivision *string `json:"country_subdivision,omitempty"`
	// The address's country.
	//
	// - `AF` - Afghanistan
	// - `AX` - Åland Islands
	// - `AL` - Albania
	// - `DZ` - Algeria
	// - `AS` - American Samoa
	// - `AD` - Andorra
	// - `AO` - Angola
	// - `AI` - Anguilla
	// - `AQ` - Antarctica
	// - `AG` - Antigua and Barbuda
	// - `AR` - Argentina
	// - `AM` - Armenia
	// - `AW` - Aruba
	// - `AU` - Australia
	// - `AT` - Austria
	// - `AZ` - Azerbaijan
	// - `BS` - Bahamas
	// - `BH` - Bahrain
	// - `BD` - Bangladesh
	// - `BB` - Barbados
	// - `BY` - Belarus
	// - `BE` - Belgium
	// - `BZ` - Belize
	// - `BJ` - Benin
	// - `BM` - Bermuda
	// - `BT` - Bhutan
	// - `BO` - Bolivia
	// - `BQ` - Bonaire, Sint Eustatius and Saba
	// - `BA` - Bosnia and Herzegovina
	// - `BW` - Botswana
	// - `BV` - Bouvet Island
	// - `BR` - Brazil
	// - `IO` - British Indian Ocean Territory
	// - `BN` - Brunei
	// - `BG` - Bulgaria
	// - `BF` - Burkina Faso
	// - `BI` - Burundi
	// - `CV` - Cabo Verde
	// - `KH` - Cambodia
	// - `CM` - Cameroon
	// - `CA` - Canada
	// - `KY` - Cayman Islands
	// - `CF` - Central African Republic
	// - `TD` - Chad
	// - `CL` - Chile
	// - `CN` - China
	// - `CX` - Christmas Island
	// - `CC` - Cocos (Keeling) Islands
	// - `CO` - Colombia
	// - `KM` - Comoros
	// - `CG` - Congo
	// - `CD` - Congo (the Democratic Republic of the)
	// - `CK` - Cook Islands
	// - `CR` - Costa Rica
	// - `CI` - Côte d'Ivoire
	// - `HR` - Croatia
	// - `CU` - Cuba
	// - `CW` - Curaçao
	// - `CY` - Cyprus
	// - `CZ` - Czechia
	// - `DK` - Denmark
	// - `DJ` - Djibouti
	// - `DM` - Dominica
	// - `DO` - Dominican Republic
	// - `EC` - Ecuador
	// - `EG` - Egypt
	// - `SV` - El Salvador
	// - `GQ` - Equatorial Guinea
	// - `ER` - Eritrea
	// - `EE` - Estonia
	// - `SZ` - Eswatini
	// - `ET` - Ethiopia
	// - `FK` - Falkland Islands (Malvinas)
	// - `FO` - Faroe Islands
	// - `FJ` - Fiji
	// - `FI` - Finland
	// - `FR` - France
	// - `GF` - French Guiana
	// - `PF` - French Polynesia
	// - `TF` - French Southern Territories
	// - `GA` - Gabon
	// - `GM` - Gambia
	// - `GE` - Georgia
	// - `DE` - Germany
	// - `GH` - Ghana
	// - `GI` - Gibraltar
	// - `GR` - Greece
	// - `GL` - Greenland
	// - `GD` - Grenada
	// - `GP` - Guadeloupe
	// - `GU` - Guam
	// - `GT` - Guatemala
	// - `GG` - Guernsey
	// - `GN` - Guinea
	// - `GW` - Guinea-Bissau
	// - `GY` - Guyana
	// - `HT` - Haiti
	// - `HM` - Heard Island and McDonald Islands
	// - `VA` - Holy See
	// - `HN` - Honduras
	// - `HK` - Hong Kong
	// - `HU` - Hungary
	// - `IS` - Iceland
	// - `IN` - India
	// - `ID` - Indonesia
	// - `IR` - Iran
	// - `IQ` - Iraq
	// - `IE` - Ireland
	// - `IM` - Isle of Man
	// - `IL` - Israel
	// - `IT` - Italy
	// - `JM` - Jamaica
	// - `JP` - Japan
	// - `JE` - Jersey
	// - `JO` - Jordan
	// - `KZ` - Kazakhstan
	// - `KE` - Kenya
	// - `KI` - Kiribati
	// - `KW` - Kuwait
	// - `KG` - Kyrgyzstan
	// - `LA` - Laos
	// - `LV` - Latvia
	// - `LB` - Lebanon
	// - `LS` - Lesotho
	// - `LR` - Liberia
	// - `LY` - Libya
	// - `LI` - Liechtenstein
	// - `LT` - Lithuania
	// - `LU` - Luxembourg
	// - `MO` - Macao
	// - `MG` - Madagascar
	// - `MW` - Malawi
	// - `MY` - Malaysia
	// - `MV` - Maldives
	// - `ML` - Mali
	// - `MT` - Malta
	// - `MH` - Marshall Islands
	// - `MQ` - Martinique
	// - `MR` - Mauritania
	// - `MU` - Mauritius
	// - `YT` - Mayotte
	// - `MX` - Mexico
	// - `FM` - Micronesia (Federated States of)
	// - `MD` - Moldova
	// - `MC` - Monaco
	// - `MN` - Mongolia
	// - `ME` - Montenegro
	// - `MS` - Montserrat
	// - `MA` - Morocco
	// - `MZ` - Mozambique
	// - `MM` - Myanmar
	// - `NA` - Namibia
	// - `NR` - Nauru
	// - `NP` - Nepal
	// - `NL` - Netherlands
	// - `NC` - New Caledonia
	// - `NZ` - New Zealand
	// - `NI` - Nicaragua
	// - `NE` - Niger
	// - `NG` - Nigeria
	// - `NU` - Niue
	// - `NF` - Norfolk Island
	// - `KP` - North Korea
	// - `MK` - North Macedonia
	// - `MP` - Northern Mariana Islands
	// - `NO` - Norway
	// - `OM` - Oman
	// - `PK` - Pakistan
	// - `PW` - Palau
	// - `PS` - Palestine, State of
	// - `PA` - Panama
	// - `PG` - Papua New Guinea
	// - `PY` - Paraguay
	// - `PE` - Peru
	// - `PH` - Philippines
	// - `PN` - Pitcairn
	// - `PL` - Poland
	// - `PT` - Portugal
	// - `PR` - Puerto Rico
	// - `QA` - Qatar
	// - `RE` - Réunion
	// - `RO` - Romania
	// - `RU` - Russia
	// - `RW` - Rwanda
	// - `BL` - Saint Barthélemy
	// - `SH` - Saint Helena, Ascension and Tristan da Cunha
	// - `KN` - Saint Kitts and Nevis
	// - `LC` - Saint Lucia
	// - `MF` - Saint Martin (French part)
	// - `PM` - Saint Pierre and Miquelon
	// - `VC` - Saint Vincent and the Grenadines
	// - `WS` - Samoa
	// - `SM` - San Marino
	// - `ST` - Sao Tome and Principe
	// - `SA` - Saudi Arabia
	// - `SN` - Senegal
	// - `RS` - Serbia
	// - `SC` - Seychelles
	// - `SL` - Sierra Leone
	// - `SG` - Singapore
	// - `SX` - Sint Maarten (Dutch part)
	// - `SK` - Slovakia
	// - `SI` - Slovenia
	// - `SB` - Solomon Islands
	// - `SO` - Somalia
	// - `ZA` - South Africa
	// - `GS` - South Georgia and the South Sandwich Islands
	// - `KR` - South Korea
	// - `SS` - South Sudan
	// - `ES` - Spain
	// - `LK` - Sri Lanka
	// - `SD` - Sudan
	// - `SR` - Suriname
	// - `SJ` - Svalbard and Jan Mayen
	// - `SE` - Sweden
	// - `CH` - Switzerland
	// - `SY` - Syria
	// - `TW` - Taiwan
	// - `TJ` - Tajikistan
	// - `TZ` - Tanzania
	// - `TH` - Thailand
	// - `TL` - Timor-Leste
	// - `TG` - Togo
	// - `TK` - Tokelau
	// - `TO` - Tonga
	// - `TT` - Trinidad and Tobago
	// - `TN` - Tunisia
	// - `TR` - Turkey
	// - `TM` - Turkmenistan
	// - `TC` - Turks and Caicos Islands
	// - `TV` - Tuvalu
	// - `UG` - Uganda
	// - `UA` - Ukraine
	// - `AE` - United Arab Emirates
	// - `GB` - United Kingdom
	// - `UM` - United States Minor Outlying Islands
	// - `US` - United States of America
	// - `UY` - Uruguay
	// - `UZ` - Uzbekistan
	// - `VU` - Vanuatu
	// - `VE` - Venezuela
	// - `VN` - Vietnam
	// - `VG` - Virgin Islands (British)
	// - `VI` - Virgin Islands (U.S.)
	// - `WF` - Wallis and Futuna
	// - `EH` - Western Sahara
	// - `YE` - Yemen
	// - `ZM` - Zambia
	// - `ZW` - Zimbabwe
	Country *AddressRequestCountry `json:"country,omitempty"`
	// The address's zip code.
	ZipCode             *string                `json:"zip_code,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AddressRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddressRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddressRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddressRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The address's country.
//
// - `AF` - Afghanistan
// - `AX` - Åland Islands
// - `AL` - Albania
// - `DZ` - Algeria
// - `AS` - American Samoa
// - `AD` - Andorra
// - `AO` - Angola
// - `AI` - Anguilla
// - `AQ` - Antarctica
// - `AG` - Antigua and Barbuda
// - `AR` - Argentina
// - `AM` - Armenia
// - `AW` - Aruba
// - `AU` - Australia
// - `AT` - Austria
// - `AZ` - Azerbaijan
// - `BS` - Bahamas
// - `BH` - Bahrain
// - `BD` - Bangladesh
// - `BB` - Barbados
// - `BY` - Belarus
// - `BE` - Belgium
// - `BZ` - Belize
// - `BJ` - Benin
// - `BM` - Bermuda
// - `BT` - Bhutan
// - `BO` - Bolivia
// - `BQ` - Bonaire, Sint Eustatius and Saba
// - `BA` - Bosnia and Herzegovina
// - `BW` - Botswana
// - `BV` - Bouvet Island
// - `BR` - Brazil
// - `IO` - British Indian Ocean Territory
// - `BN` - Brunei
// - `BG` - Bulgaria
// - `BF` - Burkina Faso
// - `BI` - Burundi
// - `CV` - Cabo Verde
// - `KH` - Cambodia
// - `CM` - Cameroon
// - `CA` - Canada
// - `KY` - Cayman Islands
// - `CF` - Central African Republic
// - `TD` - Chad
// - `CL` - Chile
// - `CN` - China
// - `CX` - Christmas Island
// - `CC` - Cocos (Keeling) Islands
// - `CO` - Colombia
// - `KM` - Comoros
// - `CG` - Congo
// - `CD` - Congo (the Democratic Republic of the)
// - `CK` - Cook Islands
// - `CR` - Costa Rica
// - `CI` - Côte d'Ivoire
// - `HR` - Croatia
// - `CU` - Cuba
// - `CW` - Curaçao
// - `CY` - Cyprus
// - `CZ` - Czechia
// - `DK` - Denmark
// - `DJ` - Djibouti
// - `DM` - Dominica
// - `DO` - Dominican Republic
// - `EC` - Ecuador
// - `EG` - Egypt
// - `SV` - El Salvador
// - `GQ` - Equatorial Guinea
// - `ER` - Eritrea
// - `EE` - Estonia
// - `SZ` - Eswatini
// - `ET` - Ethiopia
// - `FK` - Falkland Islands (Malvinas)
// - `FO` - Faroe Islands
// - `FJ` - Fiji
// - `FI` - Finland
// - `FR` - France
// - `GF` - French Guiana
// - `PF` - French Polynesia
// - `TF` - French Southern Territories
// - `GA` - Gabon
// - `GM` - Gambia
// - `GE` - Georgia
// - `DE` - Germany
// - `GH` - Ghana
// - `GI` - Gibraltar
// - `GR` - Greece
// - `GL` - Greenland
// - `GD` - Grenada
// - `GP` - Guadeloupe
// - `GU` - Guam
// - `GT` - Guatemala
// - `GG` - Guernsey
// - `GN` - Guinea
// - `GW` - Guinea-Bissau
// - `GY` - Guyana
// - `HT` - Haiti
// - `HM` - Heard Island and McDonald Islands
// - `VA` - Holy See
// - `HN` - Honduras
// - `HK` - Hong Kong
// - `HU` - Hungary
// - `IS` - Iceland
// - `IN` - India
// - `ID` - Indonesia
// - `IR` - Iran
// - `IQ` - Iraq
// - `IE` - Ireland
// - `IM` - Isle of Man
// - `IL` - Israel
// - `IT` - Italy
// - `JM` - Jamaica
// - `JP` - Japan
// - `JE` - Jersey
// - `JO` - Jordan
// - `KZ` - Kazakhstan
// - `KE` - Kenya
// - `KI` - Kiribati
// - `KW` - Kuwait
// - `KG` - Kyrgyzstan
// - `LA` - Laos
// - `LV` - Latvia
// - `LB` - Lebanon
// - `LS` - Lesotho
// - `LR` - Liberia
// - `LY` - Libya
// - `LI` - Liechtenstein
// - `LT` - Lithuania
// - `LU` - Luxembourg
// - `MO` - Macao
// - `MG` - Madagascar
// - `MW` - Malawi
// - `MY` - Malaysia
// - `MV` - Maldives
// - `ML` - Mali
// - `MT` - Malta
// - `MH` - Marshall Islands
// - `MQ` - Martinique
// - `MR` - Mauritania
// - `MU` - Mauritius
// - `YT` - Mayotte
// - `MX` - Mexico
// - `FM` - Micronesia (Federated States of)
// - `MD` - Moldova
// - `MC` - Monaco
// - `MN` - Mongolia
// - `ME` - Montenegro
// - `MS` - Montserrat
// - `MA` - Morocco
// - `MZ` - Mozambique
// - `MM` - Myanmar
// - `NA` - Namibia
// - `NR` - Nauru
// - `NP` - Nepal
// - `NL` - Netherlands
// - `NC` - New Caledonia
// - `NZ` - New Zealand
// - `NI` - Nicaragua
// - `NE` - Niger
// - `NG` - Nigeria
// - `NU` - Niue
// - `NF` - Norfolk Island
// - `KP` - North Korea
// - `MK` - North Macedonia
// - `MP` - Northern Mariana Islands
// - `NO` - Norway
// - `OM` - Oman
// - `PK` - Pakistan
// - `PW` - Palau
// - `PS` - Palestine, State of
// - `PA` - Panama
// - `PG` - Papua New Guinea
// - `PY` - Paraguay
// - `PE` - Peru
// - `PH` - Philippines
// - `PN` - Pitcairn
// - `PL` - Poland
// - `PT` - Portugal
// - `PR` - Puerto Rico
// - `QA` - Qatar
// - `RE` - Réunion
// - `RO` - Romania
// - `RU` - Russia
// - `RW` - Rwanda
// - `BL` - Saint Barthélemy
// - `SH` - Saint Helena, Ascension and Tristan da Cunha
// - `KN` - Saint Kitts and Nevis
// - `LC` - Saint Lucia
// - `MF` - Saint Martin (French part)
// - `PM` - Saint Pierre and Miquelon
// - `VC` - Saint Vincent and the Grenadines
// - `WS` - Samoa
// - `SM` - San Marino
// - `ST` - Sao Tome and Principe
// - `SA` - Saudi Arabia
// - `SN` - Senegal
// - `RS` - Serbia
// - `SC` - Seychelles
// - `SL` - Sierra Leone
// - `SG` - Singapore
// - `SX` - Sint Maarten (Dutch part)
// - `SK` - Slovakia
// - `SI` - Slovenia
// - `SB` - Solomon Islands
// - `SO` - Somalia
// - `ZA` - South Africa
// - `GS` - South Georgia and the South Sandwich Islands
// - `KR` - South Korea
// - `SS` - South Sudan
// - `ES` - Spain
// - `LK` - Sri Lanka
// - `SD` - Sudan
// - `SR` - Suriname
// - `SJ` - Svalbard and Jan Mayen
// - `SE` - Sweden
// - `CH` - Switzerland
// - `SY` - Syria
// - `TW` - Taiwan
// - `TJ` - Tajikistan
// - `TZ` - Tanzania
// - `TH` - Thailand
// - `TL` - Timor-Leste
// - `TG` - Togo
// - `TK` - Tokelau
// - `TO` - Tonga
// - `TT` - Trinidad and Tobago
// - `TN` - Tunisia
// - `TR` - Turkey
// - `TM` - Turkmenistan
// - `TC` - Turks and Caicos Islands
// - `TV` - Tuvalu
// - `UG` - Uganda
// - `UA` - Ukraine
// - `AE` - United Arab Emirates
// - `GB` - United Kingdom
// - `UM` - United States Minor Outlying Islands
// - `US` - United States of America
// - `UY` - Uruguay
// - `UZ` - Uzbekistan
// - `VU` - Vanuatu
// - `VE` - Venezuela
// - `VN` - Vietnam
// - `VG` - Virgin Islands (British)
// - `VI` - Virgin Islands (U.S.)
// - `WF` - Wallis and Futuna
// - `EH` - Western Sahara
// - `YE` - Yemen
// - `ZM` - Zambia
// - `ZW` - Zimbabwe
type AddressRequestCountry struct {
	typeName    string
	CountryEnum CountryEnum
	String      string
}

func NewAddressRequestCountryFromCountryEnum(value CountryEnum) *AddressRequestCountry {
	return &AddressRequestCountry{typeName: "countryEnum", CountryEnum: value}
}

func NewAddressRequestCountryFromString(value string) *AddressRequestCountry {
	return &AddressRequestCountry{typeName: "string", String: value}
}

func (a *AddressRequestCountry) UnmarshalJSON(data []byte) error {
	var valueCountryEnum CountryEnum
	if err := json.Unmarshal(data, &valueCountryEnum); err == nil {
		a.typeName = "countryEnum"
		a.CountryEnum = valueCountryEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AddressRequestCountry) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "countryEnum":
		return json.Marshal(a.CountryEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AddressRequestCountryVisitor interface {
	VisitCountryEnum(CountryEnum) error
	VisitString(string) error
}

func (a *AddressRequestCountry) Accept(visitor AddressRequestCountryVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "countryEnum":
		return visitor.VisitCountryEnum(a.CountryEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The address type.
//
// - `BILLING` - BILLING
// - `SHIPPING` - SHIPPING
type AddressRequestType struct {
	typeName        string
	AddressTypeEnum AddressTypeEnum
	String          string
}

func NewAddressRequestTypeFromAddressTypeEnum(value AddressTypeEnum) *AddressRequestType {
	return &AddressRequestType{typeName: "addressTypeEnum", AddressTypeEnum: value}
}

func NewAddressRequestTypeFromString(value string) *AddressRequestType {
	return &AddressRequestType{typeName: "string", String: value}
}

func (a *AddressRequestType) UnmarshalJSON(data []byte) error {
	var valueAddressTypeEnum AddressTypeEnum
	if err := json.Unmarshal(data, &valueAddressTypeEnum); err == nil {
		a.typeName = "addressTypeEnum"
		a.AddressTypeEnum = valueAddressTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AddressRequestType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "addressTypeEnum":
		return json.Marshal(a.AddressTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AddressRequestTypeVisitor interface {
	VisitAddressTypeEnum(AddressTypeEnum) error
	VisitString(string) error
}

func (a *AddressRequestType) Accept(visitor AddressRequestTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "addressTypeEnum":
		return visitor.VisitAddressTypeEnum(a.AddressTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The address type.
//
// - `BILLING` - BILLING
// - `SHIPPING` - SHIPPING
type AddressType struct {
	typeName        string
	AddressTypeEnum AddressTypeEnum
	String          string
}

func NewAddressTypeFromAddressTypeEnum(value AddressTypeEnum) *AddressType {
	return &AddressType{typeName: "addressTypeEnum", AddressTypeEnum: value}
}

func NewAddressTypeFromString(value string) *AddressType {
	return &AddressType{typeName: "string", String: value}
}

func (a *AddressType) UnmarshalJSON(data []byte) error {
	var valueAddressTypeEnum AddressTypeEnum
	if err := json.Unmarshal(data, &valueAddressTypeEnum); err == nil {
		a.typeName = "addressTypeEnum"
		a.AddressTypeEnum = valueAddressTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AddressType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "addressTypeEnum":
		return json.Marshal(a.AddressTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AddressTypeVisitor interface {
	VisitAddressTypeEnum(AddressTypeEnum) error
	VisitString(string) error
}

func (a *AddressType) Accept(visitor AddressTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "addressTypeEnum":
		return visitor.VisitAddressTypeEnum(a.AddressTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// - `BILLING` - BILLING
// - `SHIPPING` - SHIPPING
type AddressTypeEnum string

const (
	AddressTypeEnumBilling  AddressTypeEnum = "BILLING"
	AddressTypeEnumShipping AddressTypeEnum = "SHIPPING"
)

func NewAddressTypeEnumFromString(s string) (AddressTypeEnum, error) {
	switch s {
	case "BILLING":
		return AddressTypeEnumBilling, nil
	case "SHIPPING":
		return AddressTypeEnumShipping, nil
	}
	var t AddressTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AddressTypeEnum) Ptr() *AddressTypeEnum {
	return &a
}

type AdvancedMetadata struct {
	Id           string        `json:"id"`
	DisplayName  *string       `json:"display_name,omitempty"`
	Description  *string       `json:"description,omitempty"`
	IsRequired   *bool         `json:"is_required,omitempty"`
	IsCustom     *bool         `json:"is_custom,omitempty"`
	FieldChoices []interface{} `json:"field_choices,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AdvancedMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler AdvancedMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdvancedMetadata(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdvancedMetadata) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AsyncPassthroughReciept struct {
	AsyncPassthroughReceiptId string `json:"async_passthrough_receipt_id"`

	_rawJSON json.RawMessage
}

func (a *AsyncPassthroughReciept) UnmarshalJSON(data []byte) error {
	type unmarshaler AsyncPassthroughReciept
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AsyncPassthroughReciept(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AsyncPassthroughReciept) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AsyncPostTask struct {
	Status *AsyncPostTaskStatus `json:"status,omitempty"`
	Result *AsyncPostTaskResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AsyncPostTask) UnmarshalJSON(data []byte) error {
	type unmarshaler AsyncPostTask
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AsyncPostTask(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AsyncPostTask) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AsyncPostTaskResult struct {
	StatusCode *int                   `json:"status_code,omitempty"`
	Response   map[string]interface{} `json:"response,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AsyncPostTaskResult) UnmarshalJSON(data []byte) error {
	type unmarshaler AsyncPostTaskResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AsyncPostTaskResult(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AsyncPostTaskResult) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AsyncPostTaskStatus struct {
	typeName                string
	AsyncPostTaskStatusEnum AsyncPostTaskStatusEnum
	String                  string
}

func NewAsyncPostTaskStatusFromAsyncPostTaskStatusEnum(value AsyncPostTaskStatusEnum) *AsyncPostTaskStatus {
	return &AsyncPostTaskStatus{typeName: "asyncPostTaskStatusEnum", AsyncPostTaskStatusEnum: value}
}

func NewAsyncPostTaskStatusFromString(value string) *AsyncPostTaskStatus {
	return &AsyncPostTaskStatus{typeName: "string", String: value}
}

func (a *AsyncPostTaskStatus) UnmarshalJSON(data []byte) error {
	var valueAsyncPostTaskStatusEnum AsyncPostTaskStatusEnum
	if err := json.Unmarshal(data, &valueAsyncPostTaskStatusEnum); err == nil {
		a.typeName = "asyncPostTaskStatusEnum"
		a.AsyncPostTaskStatusEnum = valueAsyncPostTaskStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AsyncPostTaskStatus) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "asyncPostTaskStatusEnum":
		return json.Marshal(a.AsyncPostTaskStatusEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AsyncPostTaskStatusVisitor interface {
	VisitAsyncPostTaskStatusEnum(AsyncPostTaskStatusEnum) error
	VisitString(string) error
}

func (a *AsyncPostTaskStatus) Accept(visitor AsyncPostTaskStatusVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "asyncPostTaskStatusEnum":
		return visitor.VisitAsyncPostTaskStatusEnum(a.AsyncPostTaskStatusEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// - `QUEUED` - QUEUED
// - `IN_PROGRESS` - IN_PROGRESS
// - `COMPLETED` - COMPLETED
// - `FAILURE` - FAILURE
type AsyncPostTaskStatusEnum string

const (
	AsyncPostTaskStatusEnumQueued     AsyncPostTaskStatusEnum = "QUEUED"
	AsyncPostTaskStatusEnumInProgress AsyncPostTaskStatusEnum = "IN_PROGRESS"
	AsyncPostTaskStatusEnumCompleted  AsyncPostTaskStatusEnum = "COMPLETED"
	AsyncPostTaskStatusEnumFailure    AsyncPostTaskStatusEnum = "FAILURE"
)

func NewAsyncPostTaskStatusEnumFromString(s string) (AsyncPostTaskStatusEnum, error) {
	switch s {
	case "QUEUED":
		return AsyncPostTaskStatusEnumQueued, nil
	case "IN_PROGRESS":
		return AsyncPostTaskStatusEnumInProgress, nil
	case "COMPLETED":
		return AsyncPostTaskStatusEnumCompleted, nil
	case "FAILURE":
		return AsyncPostTaskStatusEnumFailure, nil
	}
	var t AsyncPostTaskStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AsyncPostTaskStatusEnum) Ptr() *AsyncPostTaskStatusEnum {
	return &a
}

type AuditLogEvent struct {
	Id *string `json:"id,omitempty"`
	// The User's full name at the time of this Event occurring.
	UserName *string `json:"user_name,omitempty"`
	// The User's email at the time of this Event occurring.
	UserEmail *string `json:"user_email,omitempty"`
	// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
	//
	// - `ADMIN` - ADMIN
	// - `DEVELOPER` - DEVELOPER
	// - `MEMBER` - MEMBER
	// - `API` - API
	// - `SYSTEM` - SYSTEM
	// - `MERGE_TEAM` - MERGE_TEAM
	Role      *AuditLogEventRole `json:"role,omitempty"`
	IpAddress string             `json:"ip_address"`
	// Designates the type of event that occurred.
	//
	// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
	// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
	// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
	// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
	// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
	// - `INVITED_USER` - INVITED_USER
	// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
	// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
	// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
	// - `CREATED_DESTINATION` - CREATED_DESTINATION
	// - `DELETED_DESTINATION` - DELETED_DESTINATION
	// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
	// - `CHANGED_SCOPES` - CHANGED_SCOPES
	// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
	// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
	// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
	// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
	// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
	// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
	// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
	// - `RESET_PASSWORD` - RESET_PASSWORD
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
	// - `CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
	// - `DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
	// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
	// - `MUTED_ISSUE` - MUTED_ISSUE
	// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
	// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
	// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
	// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
	// - `END_USER_CREDENTIALS_ACCESSED` - END_USER_CREDENTIALS_ACCESSED
	EventType        *AuditLogEventEventType `json:"event_type,omitempty"`
	EventDescription string                  `json:"event_description"`
	CreatedAt        *time.Time              `json:"created_at,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AuditLogEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AuditLogEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuditLogEvent(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuditLogEvent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Designates the type of event that occurred.
//
// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
// - `MUTED_ISSUE` - MUTED_ISSUE
// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
// - `END_USER_CREDENTIALS_ACCESSED` - END_USER_CREDENTIALS_ACCESSED
type AuditLogEventEventType struct {
	typeName      string
	EventTypeEnum EventTypeEnum
	String        string
}

func NewAuditLogEventEventTypeFromEventTypeEnum(value EventTypeEnum) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "eventTypeEnum", EventTypeEnum: value}
}

func NewAuditLogEventEventTypeFromString(value string) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "string", String: value}
}

func (a *AuditLogEventEventType) UnmarshalJSON(data []byte) error {
	var valueEventTypeEnum EventTypeEnum
	if err := json.Unmarshal(data, &valueEventTypeEnum); err == nil {
		a.typeName = "eventTypeEnum"
		a.EventTypeEnum = valueEventTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventEventType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return json.Marshal(a.EventTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventEventTypeVisitor interface {
	VisitEventTypeEnum(EventTypeEnum) error
	VisitString(string) error
}

func (a *AuditLogEventEventType) Accept(visitor AuditLogEventEventTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return visitor.VisitEventTypeEnum(a.EventTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
//
// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type AuditLogEventRole struct {
	typeName string
	RoleEnum RoleEnum
	String   string
}

func NewAuditLogEventRoleFromRoleEnum(value RoleEnum) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "roleEnum", RoleEnum: value}
}

func NewAuditLogEventRoleFromString(value string) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "string", String: value}
}

func (a *AuditLogEventRole) UnmarshalJSON(data []byte) error {
	var valueRoleEnum RoleEnum
	if err := json.Unmarshal(data, &valueRoleEnum); err == nil {
		a.typeName = "roleEnum"
		a.RoleEnum = valueRoleEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventRole) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return json.Marshal(a.RoleEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventRoleVisitor interface {
	VisitRoleEnum(RoleEnum) error
	VisitString(string) error
}

func (a *AuditLogEventRole) Accept(visitor AuditLogEventRoleVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return visitor.VisitRoleEnum(a.RoleEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The AvailableActions Object
//
// ### Description
//
// The `Activity` object is used to see all available model/operation combinations for an integration.
//
// ### Usage Example
//
// Fetch all the actions available for the `Zenefits` integration.
type AvailableActions struct {
	Integration              *AccountIntegration `json:"integration,omitempty"`
	PassthroughAvailable     bool                `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation   `json:"available_model_operations,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AvailableActions) UnmarshalJSON(data []byte) error {
	type unmarshaler AvailableActions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AvailableActions(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AvailableActions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The BalanceSheet Object
//
// ### Description
//
// The `BalanceSheet` object shows a company’s assets, liabilities, and equity. Assets should be equal to liability and equity combined. This shows the company’s financial health at a specific point in time.
//
// ### Usage Example
//
// Fetch from the `LIST BalanceSheets` endpoint and view a company's balance sheets.
type BalanceSheet struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The balance sheet's name.
	Name *string `json:"name,omitempty"`
	// The balance sheet's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *BalanceSheetCurrency `json:"currency,omitempty"`
	// `Company` object for the given `BalanceSheet` object.
	Company *BalanceSheetCompany `json:"company,omitempty"`
	// The balance sheet's date. The balance sheet data will reflect the company's financial position this point in time.
	Date *time.Time `json:"date,omitempty"`
	// The balance sheet's net assets.
	NetAssets   *float64      `json:"net_assets,omitempty"`
	Assets      []*ReportItem `json:"assets,omitempty"`
	Liabilities []*ReportItem `json:"liabilities,omitempty"`
	Equity      []*ReportItem `json:"equity,omitempty"`
	// The time that balance sheet was generated by the accounting system.
	RemoteGeneratedAt *time.Time `json:"remote_generated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BalanceSheet) UnmarshalJSON(data []byte) error {
	type unmarshaler BalanceSheet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BalanceSheet(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BalanceSheet) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// `Company` object for the given `BalanceSheet` object.
type BalanceSheetCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewBalanceSheetCompanyFromString(value string) *BalanceSheetCompany {
	return &BalanceSheetCompany{typeName: "string", String: value}
}

func NewBalanceSheetCompanyFromCompanyInfo(value *CompanyInfo) *BalanceSheetCompany {
	return &BalanceSheetCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (b *BalanceSheetCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		b.typeName = "companyInfo"
		b.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BalanceSheetCompany) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return json.Marshal(b.String)
	case "companyInfo":
		return json.Marshal(b.CompanyInfo)
	}
}

type BalanceSheetCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (b *BalanceSheetCompany) Accept(visitor BalanceSheetCompanyVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return visitor.VisitString(b.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(b.CompanyInfo)
	}
}

// The balance sheet's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type BalanceSheetCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewBalanceSheetCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *BalanceSheetCurrency {
	return &BalanceSheetCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewBalanceSheetCurrencyFromString(value string) *BalanceSheetCurrency {
	return &BalanceSheetCurrency{typeName: "string", String: value}
}

func (b *BalanceSheetCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		b.typeName = "transactionCurrencyEnum"
		b.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BalanceSheetCurrency) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "transactionCurrencyEnum":
		return json.Marshal(b.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BalanceSheetCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (b *BalanceSheetCurrency) Accept(visitor BalanceSheetCurrencyVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(b.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// # The BankFeedAccount Object
//
// ### Description
//
// The `BankFeedAccount` object represents a bank feed account, detailing various attributes including account identifiers, names, currency, and balance information. This object is central to managing and tracking bank feed accounts within the system.
//
// ### Usage Example
//
// Fetch from the `GET BankFeedAccount` endpoint to view details of a bank feed account.
type BankFeedAccount struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The unique identifier of the source account from our customer’s platform.
	SourceAccountId *string `json:"source_account_id,omitempty"`
	// The unique identifier of the target account from the third party software.
	TargetAccountId *string `json:"target_account_id,omitempty"`
	// The name of the source account as stored in our customer’s platform.
	SourceAccountName *string `json:"source_account_name,omitempty"`
	// The human-readable account number of the source account as stored in our customer’s platform.
	SourceAccountNumber *string `json:"source_account_number,omitempty"`
	// The name of the target account from the third party software.
	TargetAccountName *string `json:"target_account_name,omitempty"`
	// The currency code of the bank feed.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *BankFeedAccountCurrency `json:"currency,omitempty"`
	// The status of the bank feed.
	//
	// - `ACTIVE` - ACTIVE
	// - `INACTIVE` - INACTIVE
	FeedStatus *BankFeedAccountFeedStatus `json:"feed_status,omitempty"`
	// The start date of the bank feed’s transactions.
	FeedStartDate *time.Time `json:"feed_start_date,omitempty"`
	// The current balance of funds in the source account.
	SourceAccountBalance *float64 `json:"source_account_balance,omitempty"`
	// The type of the account.
	//
	// - `BANK` - BANK
	// - `CREDIT_CARD` - CREDIT_CARD
	AccountType *BankFeedAccountAccountType `json:"account_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                    `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{}   `json:"field_mappings,omitempty"`
	RemoteData       []map[string]interface{} `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankFeedAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler BankFeedAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankFeedAccount(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankFeedAccount) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The type of the account.
//
// - `BANK` - BANK
// - `CREDIT_CARD` - CREDIT_CARD
type BankFeedAccountAccountType struct {
	typeName                       string
	BankFeedAccountAccountTypeEnum BankFeedAccountAccountTypeEnum
	String                         string
}

func NewBankFeedAccountAccountTypeFromBankFeedAccountAccountTypeEnum(value BankFeedAccountAccountTypeEnum) *BankFeedAccountAccountType {
	return &BankFeedAccountAccountType{typeName: "bankFeedAccountAccountTypeEnum", BankFeedAccountAccountTypeEnum: value}
}

func NewBankFeedAccountAccountTypeFromString(value string) *BankFeedAccountAccountType {
	return &BankFeedAccountAccountType{typeName: "string", String: value}
}

func (b *BankFeedAccountAccountType) UnmarshalJSON(data []byte) error {
	var valueBankFeedAccountAccountTypeEnum BankFeedAccountAccountTypeEnum
	if err := json.Unmarshal(data, &valueBankFeedAccountAccountTypeEnum); err == nil {
		b.typeName = "bankFeedAccountAccountTypeEnum"
		b.BankFeedAccountAccountTypeEnum = valueBankFeedAccountAccountTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedAccountAccountType) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "bankFeedAccountAccountTypeEnum":
		return json.Marshal(b.BankFeedAccountAccountTypeEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankFeedAccountAccountTypeVisitor interface {
	VisitBankFeedAccountAccountTypeEnum(BankFeedAccountAccountTypeEnum) error
	VisitString(string) error
}

func (b *BankFeedAccountAccountType) Accept(visitor BankFeedAccountAccountTypeVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "bankFeedAccountAccountTypeEnum":
		return visitor.VisitBankFeedAccountAccountTypeEnum(b.BankFeedAccountAccountTypeEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// - `BANK` - BANK
// - `CREDIT_CARD` - CREDIT_CARD
type BankFeedAccountAccountTypeEnum string

const (
	BankFeedAccountAccountTypeEnumBank       BankFeedAccountAccountTypeEnum = "BANK"
	BankFeedAccountAccountTypeEnumCreditCard BankFeedAccountAccountTypeEnum = "CREDIT_CARD"
)

func NewBankFeedAccountAccountTypeEnumFromString(s string) (BankFeedAccountAccountTypeEnum, error) {
	switch s {
	case "BANK":
		return BankFeedAccountAccountTypeEnumBank, nil
	case "CREDIT_CARD":
		return BankFeedAccountAccountTypeEnumCreditCard, nil
	}
	var t BankFeedAccountAccountTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankFeedAccountAccountTypeEnum) Ptr() *BankFeedAccountAccountTypeEnum {
	return &b
}

// The currency code of the bank feed.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type BankFeedAccountCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewBankFeedAccountCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *BankFeedAccountCurrency {
	return &BankFeedAccountCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewBankFeedAccountCurrencyFromString(value string) *BankFeedAccountCurrency {
	return &BankFeedAccountCurrency{typeName: "string", String: value}
}

func (b *BankFeedAccountCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		b.typeName = "transactionCurrencyEnum"
		b.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedAccountCurrency) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "transactionCurrencyEnum":
		return json.Marshal(b.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankFeedAccountCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (b *BankFeedAccountCurrency) Accept(visitor BankFeedAccountCurrencyVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(b.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// The status of the bank feed.
//
// - `ACTIVE` - ACTIVE
// - `INACTIVE` - INACTIVE
type BankFeedAccountFeedStatus struct {
	typeName       string
	FeedStatusEnum FeedStatusEnum
	String         string
}

func NewBankFeedAccountFeedStatusFromFeedStatusEnum(value FeedStatusEnum) *BankFeedAccountFeedStatus {
	return &BankFeedAccountFeedStatus{typeName: "feedStatusEnum", FeedStatusEnum: value}
}

func NewBankFeedAccountFeedStatusFromString(value string) *BankFeedAccountFeedStatus {
	return &BankFeedAccountFeedStatus{typeName: "string", String: value}
}

func (b *BankFeedAccountFeedStatus) UnmarshalJSON(data []byte) error {
	var valueFeedStatusEnum FeedStatusEnum
	if err := json.Unmarshal(data, &valueFeedStatusEnum); err == nil {
		b.typeName = "feedStatusEnum"
		b.FeedStatusEnum = valueFeedStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedAccountFeedStatus) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "feedStatusEnum":
		return json.Marshal(b.FeedStatusEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankFeedAccountFeedStatusVisitor interface {
	VisitFeedStatusEnum(FeedStatusEnum) error
	VisitString(string) error
}

func (b *BankFeedAccountFeedStatus) Accept(visitor BankFeedAccountFeedStatusVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "feedStatusEnum":
		return visitor.VisitFeedStatusEnum(b.FeedStatusEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// # The BankFeedAccount Object
//
// ### Description
//
// The `BankFeedAccount` object represents a bank feed account, detailing various attributes including account identifiers, names, currency, and balance information. This object is central to managing and tracking bank feed accounts within the system.
//
// ### Usage Example
//
// Fetch from the `GET BankFeedAccount` endpoint to view details of a bank feed account.
type BankFeedAccountRequest struct {
	// The unique identifier of the source account from our customer’s platform.
	SourceAccountId *string `json:"source_account_id,omitempty"`
	// The unique identifier of the target account from the third party software.
	TargetAccountId *string `json:"target_account_id,omitempty"`
	// The name of the source account as stored in our customer’s platform.
	SourceAccountName *string `json:"source_account_name,omitempty"`
	// The human-readable account number of the source account as stored in our customer’s platform.
	SourceAccountNumber *string `json:"source_account_number,omitempty"`
	// The name of the target account from the third party software.
	TargetAccountName *string `json:"target_account_name,omitempty"`
	// The currency code of the bank feed.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *BankFeedAccountRequestCurrency `json:"currency,omitempty"`
	// The status of the bank feed.
	//
	// - `ACTIVE` - ACTIVE
	// - `INACTIVE` - INACTIVE
	FeedStatus *BankFeedAccountRequestFeedStatus `json:"feed_status,omitempty"`
	// The start date of the bank feed’s transactions.
	FeedStartDate *time.Time `json:"feed_start_date,omitempty"`
	// The current balance of funds in the source account.
	SourceAccountBalance *float64 `json:"source_account_balance,omitempty"`
	// The type of the account.
	//
	// - `BANK` - BANK
	// - `CREDIT_CARD` - CREDIT_CARD
	AccountType         *BankFeedAccountRequestAccountType `json:"account_type,omitempty"`
	IntegrationParams   map[string]interface{}             `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}             `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankFeedAccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankFeedAccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankFeedAccountRequest(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankFeedAccountRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The type of the account.
//
// - `BANK` - BANK
// - `CREDIT_CARD` - CREDIT_CARD
type BankFeedAccountRequestAccountType struct {
	typeName                       string
	BankFeedAccountAccountTypeEnum BankFeedAccountAccountTypeEnum
	String                         string
}

func NewBankFeedAccountRequestAccountTypeFromBankFeedAccountAccountTypeEnum(value BankFeedAccountAccountTypeEnum) *BankFeedAccountRequestAccountType {
	return &BankFeedAccountRequestAccountType{typeName: "bankFeedAccountAccountTypeEnum", BankFeedAccountAccountTypeEnum: value}
}

func NewBankFeedAccountRequestAccountTypeFromString(value string) *BankFeedAccountRequestAccountType {
	return &BankFeedAccountRequestAccountType{typeName: "string", String: value}
}

func (b *BankFeedAccountRequestAccountType) UnmarshalJSON(data []byte) error {
	var valueBankFeedAccountAccountTypeEnum BankFeedAccountAccountTypeEnum
	if err := json.Unmarshal(data, &valueBankFeedAccountAccountTypeEnum); err == nil {
		b.typeName = "bankFeedAccountAccountTypeEnum"
		b.BankFeedAccountAccountTypeEnum = valueBankFeedAccountAccountTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedAccountRequestAccountType) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "bankFeedAccountAccountTypeEnum":
		return json.Marshal(b.BankFeedAccountAccountTypeEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankFeedAccountRequestAccountTypeVisitor interface {
	VisitBankFeedAccountAccountTypeEnum(BankFeedAccountAccountTypeEnum) error
	VisitString(string) error
}

func (b *BankFeedAccountRequestAccountType) Accept(visitor BankFeedAccountRequestAccountTypeVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "bankFeedAccountAccountTypeEnum":
		return visitor.VisitBankFeedAccountAccountTypeEnum(b.BankFeedAccountAccountTypeEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// The currency code of the bank feed.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type BankFeedAccountRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewBankFeedAccountRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *BankFeedAccountRequestCurrency {
	return &BankFeedAccountRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewBankFeedAccountRequestCurrencyFromString(value string) *BankFeedAccountRequestCurrency {
	return &BankFeedAccountRequestCurrency{typeName: "string", String: value}
}

func (b *BankFeedAccountRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		b.typeName = "transactionCurrencyEnum"
		b.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedAccountRequestCurrency) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "transactionCurrencyEnum":
		return json.Marshal(b.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankFeedAccountRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (b *BankFeedAccountRequestCurrency) Accept(visitor BankFeedAccountRequestCurrencyVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(b.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// The status of the bank feed.
//
// - `ACTIVE` - ACTIVE
// - `INACTIVE` - INACTIVE
type BankFeedAccountRequestFeedStatus struct {
	typeName       string
	FeedStatusEnum FeedStatusEnum
	String         string
}

func NewBankFeedAccountRequestFeedStatusFromFeedStatusEnum(value FeedStatusEnum) *BankFeedAccountRequestFeedStatus {
	return &BankFeedAccountRequestFeedStatus{typeName: "feedStatusEnum", FeedStatusEnum: value}
}

func NewBankFeedAccountRequestFeedStatusFromString(value string) *BankFeedAccountRequestFeedStatus {
	return &BankFeedAccountRequestFeedStatus{typeName: "string", String: value}
}

func (b *BankFeedAccountRequestFeedStatus) UnmarshalJSON(data []byte) error {
	var valueFeedStatusEnum FeedStatusEnum
	if err := json.Unmarshal(data, &valueFeedStatusEnum); err == nil {
		b.typeName = "feedStatusEnum"
		b.FeedStatusEnum = valueFeedStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedAccountRequestFeedStatus) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "feedStatusEnum":
		return json.Marshal(b.FeedStatusEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankFeedAccountRequestFeedStatusVisitor interface {
	VisitFeedStatusEnum(FeedStatusEnum) error
	VisitString(string) error
}

func (b *BankFeedAccountRequestFeedStatus) Accept(visitor BankFeedAccountRequestFeedStatusVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "feedStatusEnum":
		return visitor.VisitFeedStatusEnum(b.FeedStatusEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

type BankFeedAccountResponse struct {
	Model    *BankFeedAccount            `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankFeedAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BankFeedAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankFeedAccountResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankFeedAccountResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// # The BankFeedTransaction Object
//
// ### Description
//
// The `BankFeedTransaction` object is used to represent transactions linked to a bank feed account. This includes details about the transaction such as the date, amount, description, and type.
//
// ### Usage Example
//
// Fetch from the `GET BankFeedTransaction` endpoint to view details of a transaction associated with a bank feed account.
type BankFeedTransaction struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The bank feed account associated with the transaction.
	BankFeedAccount *BankFeedTransactionBankFeedAccount `json:"bank_feed_account,omitempty"`
	// The date that the transaction occurred.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The date the transaction was posted to the bank account.
	PostedDate *time.Time `json:"posted_date,omitempty"`
	// The amount of the transaction.
	Amount *float64 `json:"amount,omitempty"`
	// The description of the transaction.
	Description *string `json:"description,omitempty"`
	// The underlying type of the transaction.
	TransactionType *string `json:"transaction_type,omitempty"`
	// The person or merchant who initiated the transaction, or alternatively, to whom the transaction was paid.
	Payee *string `json:"payee,omitempty"`
	// If the transaction is of type debit or credit.
	//
	// - `CREDIT` - CREDIT
	// - `DEBIT` - DEBIT
	CreditOrDebit *BankFeedTransactionCreditOrDebit `json:"credit_or_debit,omitempty"`
	// The customer’s identifier for the transaction.
	SourceTransactionId *string `json:"source_transaction_id,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// Whether or not this transaction has been processed by the external system. For example, NetSuite writes this field as True when the SuiteApp has processed the transaction.
	IsProcessed *bool `json:"is_processed,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankFeedTransaction) UnmarshalJSON(data []byte) error {
	type unmarshaler BankFeedTransaction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankFeedTransaction(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankFeedTransaction) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The bank feed account associated with the transaction.
type BankFeedTransactionBankFeedAccount struct {
	typeName        string
	String          string
	BankFeedAccount *BankFeedAccount
}

func NewBankFeedTransactionBankFeedAccountFromString(value string) *BankFeedTransactionBankFeedAccount {
	return &BankFeedTransactionBankFeedAccount{typeName: "string", String: value}
}

func NewBankFeedTransactionBankFeedAccountFromBankFeedAccount(value *BankFeedAccount) *BankFeedTransactionBankFeedAccount {
	return &BankFeedTransactionBankFeedAccount{typeName: "bankFeedAccount", BankFeedAccount: value}
}

func (b *BankFeedTransactionBankFeedAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	valueBankFeedAccount := new(BankFeedAccount)
	if err := json.Unmarshal(data, &valueBankFeedAccount); err == nil {
		b.typeName = "bankFeedAccount"
		b.BankFeedAccount = valueBankFeedAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedTransactionBankFeedAccount) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return json.Marshal(b.String)
	case "bankFeedAccount":
		return json.Marshal(b.BankFeedAccount)
	}
}

type BankFeedTransactionBankFeedAccountVisitor interface {
	VisitString(string) error
	VisitBankFeedAccount(*BankFeedAccount) error
}

func (b *BankFeedTransactionBankFeedAccount) Accept(visitor BankFeedTransactionBankFeedAccountVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return visitor.VisitString(b.String)
	case "bankFeedAccount":
		return visitor.VisitBankFeedAccount(b.BankFeedAccount)
	}
}

// If the transaction is of type debit or credit.
//
// - `CREDIT` - CREDIT
// - `DEBIT` - DEBIT
type BankFeedTransactionCreditOrDebit struct {
	typeName          string
	CreditOrDebitEnum CreditOrDebitEnum
	String            string
}

func NewBankFeedTransactionCreditOrDebitFromCreditOrDebitEnum(value CreditOrDebitEnum) *BankFeedTransactionCreditOrDebit {
	return &BankFeedTransactionCreditOrDebit{typeName: "creditOrDebitEnum", CreditOrDebitEnum: value}
}

func NewBankFeedTransactionCreditOrDebitFromString(value string) *BankFeedTransactionCreditOrDebit {
	return &BankFeedTransactionCreditOrDebit{typeName: "string", String: value}
}

func (b *BankFeedTransactionCreditOrDebit) UnmarshalJSON(data []byte) error {
	var valueCreditOrDebitEnum CreditOrDebitEnum
	if err := json.Unmarshal(data, &valueCreditOrDebitEnum); err == nil {
		b.typeName = "creditOrDebitEnum"
		b.CreditOrDebitEnum = valueCreditOrDebitEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedTransactionCreditOrDebit) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "creditOrDebitEnum":
		return json.Marshal(b.CreditOrDebitEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankFeedTransactionCreditOrDebitVisitor interface {
	VisitCreditOrDebitEnum(CreditOrDebitEnum) error
	VisitString(string) error
}

func (b *BankFeedTransactionCreditOrDebit) Accept(visitor BankFeedTransactionCreditOrDebitVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "creditOrDebitEnum":
		return visitor.VisitCreditOrDebitEnum(b.CreditOrDebitEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

// # The BankFeedTransaction Object
//
// ### Description
//
// The `BankFeedTransaction` object is used to represent transactions linked to a bank feed account. This includes details about the transaction such as the date, amount, description, and type.
//
// ### Usage Example
//
// Fetch from the `GET BankFeedTransaction` endpoint to view details of a transaction associated with a bank feed account.
type BankFeedTransactionRequestRequest struct {
	// The bank feed account associated with the transaction.
	BankFeedAccount *BankFeedTransactionRequestRequestBankFeedAccount `json:"bank_feed_account,omitempty"`
	// The date that the transaction occurred.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The date the transaction was posted to the bank account.
	PostedDate *time.Time `json:"posted_date,omitempty"`
	// The amount of the transaction.
	Amount *float64 `json:"amount,omitempty"`
	// The description of the transaction.
	Description *string `json:"description,omitempty"`
	// The underlying type of the transaction.
	TransactionType *string `json:"transaction_type,omitempty"`
	// The person or merchant who initiated the transaction, or alternatively, to whom the transaction was paid.
	Payee *string `json:"payee,omitempty"`
	// If the transaction is of type debit or credit.
	//
	// - `CREDIT` - CREDIT
	// - `DEBIT` - DEBIT
	CreditOrDebit *BankFeedTransactionRequestRequestCreditOrDebit `json:"credit_or_debit,omitempty"`
	// The customer’s identifier for the transaction.
	SourceTransactionId *string                `json:"source_transaction_id,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankFeedTransactionRequestRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankFeedTransactionRequestRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankFeedTransactionRequestRequest(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankFeedTransactionRequestRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The bank feed account associated with the transaction.
type BankFeedTransactionRequestRequestBankFeedAccount struct {
	typeName        string
	String          string
	BankFeedAccount *BankFeedAccount
}

func NewBankFeedTransactionRequestRequestBankFeedAccountFromString(value string) *BankFeedTransactionRequestRequestBankFeedAccount {
	return &BankFeedTransactionRequestRequestBankFeedAccount{typeName: "string", String: value}
}

func NewBankFeedTransactionRequestRequestBankFeedAccountFromBankFeedAccount(value *BankFeedAccount) *BankFeedTransactionRequestRequestBankFeedAccount {
	return &BankFeedTransactionRequestRequestBankFeedAccount{typeName: "bankFeedAccount", BankFeedAccount: value}
}

func (b *BankFeedTransactionRequestRequestBankFeedAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	valueBankFeedAccount := new(BankFeedAccount)
	if err := json.Unmarshal(data, &valueBankFeedAccount); err == nil {
		b.typeName = "bankFeedAccount"
		b.BankFeedAccount = valueBankFeedAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedTransactionRequestRequestBankFeedAccount) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return json.Marshal(b.String)
	case "bankFeedAccount":
		return json.Marshal(b.BankFeedAccount)
	}
}

type BankFeedTransactionRequestRequestBankFeedAccountVisitor interface {
	VisitString(string) error
	VisitBankFeedAccount(*BankFeedAccount) error
}

func (b *BankFeedTransactionRequestRequestBankFeedAccount) Accept(visitor BankFeedTransactionRequestRequestBankFeedAccountVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "string":
		return visitor.VisitString(b.String)
	case "bankFeedAccount":
		return visitor.VisitBankFeedAccount(b.BankFeedAccount)
	}
}

// If the transaction is of type debit or credit.
//
// - `CREDIT` - CREDIT
// - `DEBIT` - DEBIT
type BankFeedTransactionRequestRequestCreditOrDebit struct {
	typeName          string
	CreditOrDebitEnum CreditOrDebitEnum
	String            string
}

func NewBankFeedTransactionRequestRequestCreditOrDebitFromCreditOrDebitEnum(value CreditOrDebitEnum) *BankFeedTransactionRequestRequestCreditOrDebit {
	return &BankFeedTransactionRequestRequestCreditOrDebit{typeName: "creditOrDebitEnum", CreditOrDebitEnum: value}
}

func NewBankFeedTransactionRequestRequestCreditOrDebitFromString(value string) *BankFeedTransactionRequestRequestCreditOrDebit {
	return &BankFeedTransactionRequestRequestCreditOrDebit{typeName: "string", String: value}
}

func (b *BankFeedTransactionRequestRequestCreditOrDebit) UnmarshalJSON(data []byte) error {
	var valueCreditOrDebitEnum CreditOrDebitEnum
	if err := json.Unmarshal(data, &valueCreditOrDebitEnum); err == nil {
		b.typeName = "creditOrDebitEnum"
		b.CreditOrDebitEnum = valueCreditOrDebitEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		b.typeName = "string"
		b.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BankFeedTransactionRequestRequestCreditOrDebit) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "creditOrDebitEnum":
		return json.Marshal(b.CreditOrDebitEnum)
	case "string":
		return json.Marshal(b.String)
	}
}

type BankFeedTransactionRequestRequestCreditOrDebitVisitor interface {
	VisitCreditOrDebitEnum(CreditOrDebitEnum) error
	VisitString(string) error
}

func (b *BankFeedTransactionRequestRequestCreditOrDebit) Accept(visitor BankFeedTransactionRequestRequestCreditOrDebitVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "creditOrDebitEnum":
		return visitor.VisitCreditOrDebitEnum(b.CreditOrDebitEnum)
	case "string":
		return visitor.VisitString(b.String)
	}
}

type BankFeedTransactionResponse struct {
	Model    *BankFeedTransaction        `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankFeedTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BankFeedTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankFeedTransactionResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankFeedTransactionResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// # The CashFlowStatement Object
//
// ### Description
//
// The `CashFlowStatement` object shows operating activities, investing activities, and financing activities over a period of time (month, quarter, or year).
//
// ### Usage Example
//
// Fetch from the `LIST CashFlowStatements` endpoint and view a company's cash flow statements.
type CashFlowStatement struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The cash flow statement's name.
	Name *string `json:"name,omitempty"`
	// The cash flow statement's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *CashFlowStatementCurrency `json:"currency,omitempty"`
	// The company the cash flow statement belongs to.
	Company *CashFlowStatementCompany `json:"company,omitempty"`
	// The cash flow statement's start period.
	StartPeriod *time.Time `json:"start_period,omitempty"`
	// The cash flow statement's end period.
	EndPeriod *time.Time `json:"end_period,omitempty"`
	// Cash and cash equivalents at the beginning of the cash flow statement's period.
	CashAtBeginningOfPeriod *float64 `json:"cash_at_beginning_of_period,omitempty"`
	// Cash and cash equivalents at the beginning of the cash flow statement's period.
	CashAtEndOfPeriod   *float64      `json:"cash_at_end_of_period,omitempty"`
	OperatingActivities []*ReportItem `json:"operating_activities,omitempty"`
	InvestingActivities []*ReportItem `json:"investing_activities,omitempty"`
	FinancingActivities []*ReportItem `json:"financing_activities,omitempty"`
	// The time that cash flow statement was generated by the accounting system.
	RemoteGeneratedAt *time.Time `json:"remote_generated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CashFlowStatement) UnmarshalJSON(data []byte) error {
	type unmarshaler CashFlowStatement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashFlowStatement(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashFlowStatement) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The company the cash flow statement belongs to.
type CashFlowStatementCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewCashFlowStatementCompanyFromString(value string) *CashFlowStatementCompany {
	return &CashFlowStatementCompany{typeName: "string", String: value}
}

func NewCashFlowStatementCompanyFromCompanyInfo(value *CompanyInfo) *CashFlowStatementCompany {
	return &CashFlowStatementCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (c *CashFlowStatementCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		c.typeName = "companyInfo"
		c.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CashFlowStatementCompany) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "companyInfo":
		return json.Marshal(c.CompanyInfo)
	}
}

type CashFlowStatementCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (c *CashFlowStatementCompany) Accept(visitor CashFlowStatementCompanyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(c.CompanyInfo)
	}
}

// The cash flow statement's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type CashFlowStatementCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewCashFlowStatementCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *CashFlowStatementCurrency {
	return &CashFlowStatementCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewCashFlowStatementCurrencyFromString(value string) *CashFlowStatementCurrency {
	return &CashFlowStatementCurrency{typeName: "string", String: value}
}

func (c *CashFlowStatementCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		c.typeName = "transactionCurrencyEnum"
		c.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CashFlowStatementCurrency) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "transactionCurrencyEnum":
		return json.Marshal(c.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type CashFlowStatementCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (c *CashFlowStatementCurrency) Accept(visitor CashFlowStatementCurrencyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(c.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoriesEnum string

const (
	CategoriesEnumHris        CategoriesEnum = "hris"
	CategoriesEnumAts         CategoriesEnum = "ats"
	CategoriesEnumAccounting  CategoriesEnum = "accounting"
	CategoriesEnumTicketing   CategoriesEnum = "ticketing"
	CategoriesEnumCrm         CategoriesEnum = "crm"
	CategoriesEnumMktg        CategoriesEnum = "mktg"
	CategoriesEnumFilestorage CategoriesEnum = "filestorage"
)

func NewCategoriesEnumFromString(s string) (CategoriesEnum, error) {
	switch s {
	case "hris":
		return CategoriesEnumHris, nil
	case "ats":
		return CategoriesEnumAts, nil
	case "accounting":
		return CategoriesEnumAccounting, nil
	case "ticketing":
		return CategoriesEnumTicketing, nil
	case "crm":
		return CategoriesEnumCrm, nil
	case "mktg":
		return CategoriesEnumMktg, nil
	case "filestorage":
		return CategoriesEnumFilestorage, nil
	}
	var t CategoriesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoriesEnum) Ptr() *CategoriesEnum {
	return &c
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoryEnum string

const (
	CategoryEnumHris        CategoryEnum = "hris"
	CategoryEnumAts         CategoryEnum = "ats"
	CategoryEnumAccounting  CategoryEnum = "accounting"
	CategoryEnumTicketing   CategoryEnum = "ticketing"
	CategoryEnumCrm         CategoryEnum = "crm"
	CategoryEnumMktg        CategoryEnum = "mktg"
	CategoryEnumFilestorage CategoryEnum = "filestorage"
)

func NewCategoryEnumFromString(s string) (CategoryEnum, error) {
	switch s {
	case "hris":
		return CategoryEnumHris, nil
	case "ats":
		return CategoryEnumAts, nil
	case "accounting":
		return CategoryEnumAccounting, nil
	case "ticketing":
		return CategoryEnumTicketing, nil
	case "crm":
		return CategoryEnumCrm, nil
	case "mktg":
		return CategoryEnumMktg, nil
	case "filestorage":
		return CategoryEnumFilestorage, nil
	}
	var t CategoryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryEnum) Ptr() *CategoryEnum {
	return &c
}

// - `CLASS` - CLASS
// - `DEPARTMENT` - DEPARTMENT
type CategoryTypeEnum string

const (
	CategoryTypeEnumClass      CategoryTypeEnum = "CLASS"
	CategoryTypeEnumDepartment CategoryTypeEnum = "DEPARTMENT"
)

func NewCategoryTypeEnumFromString(s string) (CategoryTypeEnum, error) {
	switch s {
	case "CLASS":
		return CategoryTypeEnumClass, nil
	case "DEPARTMENT":
		return CategoryTypeEnumDepartment, nil
	}
	var t CategoryTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryTypeEnum) Ptr() *CategoryTypeEnum {
	return &c
}

// - `ASSET` - ASSET
// - `EQUITY` - EQUITY
// - `EXPENSE` - EXPENSE
// - `LIABILITY` - LIABILITY
// - `REVENUE` - REVENUE
type ClassificationEnum string

const (
	ClassificationEnumAsset     ClassificationEnum = "ASSET"
	ClassificationEnumEquity    ClassificationEnum = "EQUITY"
	ClassificationEnumExpense   ClassificationEnum = "EXPENSE"
	ClassificationEnumLiability ClassificationEnum = "LIABILITY"
	ClassificationEnumRevenue   ClassificationEnum = "REVENUE"
)

func NewClassificationEnumFromString(s string) (ClassificationEnum, error) {
	switch s {
	case "ASSET":
		return ClassificationEnumAsset, nil
	case "EQUITY":
		return ClassificationEnumEquity, nil
	case "EXPENSE":
		return ClassificationEnumExpense, nil
	case "LIABILITY":
		return ClassificationEnumLiability, nil
	case "REVENUE":
		return ClassificationEnumRevenue, nil
	}
	var t ClassificationEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassificationEnum) Ptr() *ClassificationEnum {
	return &c
}

type CommonModelScopeApi struct {
	// The common models you want to update the scopes for
	CommonModels []*IndividualCommonModelScopeDeserializer `json:"common_models,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommonModelScopeApi) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonModelScopeApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonModelScopeApi(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonModelScopeApi) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommonModelScopesBodyRequest struct {
	ModelId        string               `json:"model_id"`
	EnabledActions []EnabledActionsEnum `json:"enabled_actions,omitempty"`
	DisabledFields []string             `json:"disabled_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommonModelScopesBodyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonModelScopesBodyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonModelScopesBodyRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonModelScopesBodyRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// # The CompanyInfo Object
//
// ### Description
//
// The `CompanyInfo` object contains information about the company of the linked account. If the company has multiple entities (also known as subsidiaries), each entity may show up as a single `CompanyInfo` record.
//
// ### Usage Example
//
// Fetch from the `GET CompanyInfo` endpoint and view a company's information.
type CompanyInfo struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The company's name.
	Name *string `json:"name,omitempty"`
	// The company's legal name.
	LegalName *string `json:"legal_name,omitempty"`
	// The company's tax number.
	TaxNumber *string `json:"tax_number,omitempty"`
	// The company's fiscal year end month.
	FiscalYearEndMonth *int `json:"fiscal_year_end_month,omitempty"`
	// The company's fiscal year end day.
	FiscalYearEndDay *int `json:"fiscal_year_end_day,omitempty"`
	// The currency set in the company's accounting platform.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *CompanyInfoCurrency `json:"currency,omitempty"`
	// When the third party's company was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The company's urls.
	Urls         []*string                `json:"urls,omitempty"`
	Addresses    []*Address               `json:"addresses,omitempty"`
	PhoneNumbers []*AccountingPhoneNumber `json:"phone_numbers,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CompanyInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CompanyInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompanyInfo(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The currency set in the company's accounting platform.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type CompanyInfoCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewCompanyInfoCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *CompanyInfoCurrency {
	return &CompanyInfoCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewCompanyInfoCurrencyFromString(value string) *CompanyInfoCurrency {
	return &CompanyInfoCurrency{typeName: "string", String: value}
}

func (c *CompanyInfoCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		c.typeName = "transactionCurrencyEnum"
		c.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CompanyInfoCurrency) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "transactionCurrencyEnum":
		return json.Marshal(c.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type CompanyInfoCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (c *CompanyInfoCurrency) Accept(visitor CompanyInfoCurrencyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(c.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// - `SALES` - SALES
// - `PURCHASE` - PURCHASE
type ComponentTypeEnum string

const (
	ComponentTypeEnumSales    ComponentTypeEnum = "SALES"
	ComponentTypeEnumPurchase ComponentTypeEnum = "PURCHASE"
)

func NewComponentTypeEnumFromString(s string) (ComponentTypeEnum, error) {
	switch s {
	case "SALES":
		return ComponentTypeEnumSales, nil
	case "PURCHASE":
		return ComponentTypeEnumPurchase, nil
	}
	var t ComponentTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComponentTypeEnum) Ptr() *ComponentTypeEnum {
	return &c
}

// # The Contact Object
//
// ### Description
//
// A `Contact` is an individual or business entity to which products and services are sold to or purchased from. The `Contact` model contains both Customers, in which products and services are sold to, and Vendors (or Suppliers), in which products and services are purchased from.
//
// - A `Contact` is a Vendor/Supplier if the `is_supplier` property is true.
// - A `Contact` is a customer if the `is_customer` property is true.
//
// ### Usage Example
//
// Fetch from the `LIST Contacts` endpoint and view a company's contacts.
type Contact struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The contact's name.
	Name *string `json:"name,omitempty"`
	// Whether the contact is a supplier.
	IsSupplier *bool `json:"is_supplier,omitempty"`
	// Whether the contact is a customer.
	IsCustomer *bool `json:"is_customer,omitempty"`
	// The contact's email address.
	EmailAddress *string `json:"email_address,omitempty"`
	// The contact's tax number.
	TaxNumber *string `json:"tax_number,omitempty"`
	// The contact's status
	//
	// - `ACTIVE` - ACTIVE
	// - `ARCHIVED` - ARCHIVED
	Status *ContactStatus `json:"status,omitempty"`
	// The currency the contact's transactions are in.
	Currency *string `json:"currency,omitempty"`
	// When the third party's contact was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// The company the contact belongs to.
	Company *string `json:"company,omitempty"`
	// `Address` object IDs for the given `Contacts` object.
	Addresses []*ContactAddressesItem `json:"addresses,omitempty"`
	// `AccountingPhoneNumber` object for the given `Contacts` object.
	PhoneNumbers []*AccountingPhoneNumber `json:"phone_numbers,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Contact) UnmarshalJSON(data []byte) error {
	type unmarshaler Contact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Contact(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Contact) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContactAddressesItem struct {
	typeName string
	String   string
	Address  *Address
}

func NewContactAddressesItemFromString(value string) *ContactAddressesItem {
	return &ContactAddressesItem{typeName: "string", String: value}
}

func NewContactAddressesItemFromAddress(value *Address) *ContactAddressesItem {
	return &ContactAddressesItem{typeName: "address", Address: value}
}

func (c *ContactAddressesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueAddress := new(Address)
	if err := json.Unmarshal(data, &valueAddress); err == nil {
		c.typeName = "address"
		c.Address = valueAddress
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ContactAddressesItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "address":
		return json.Marshal(c.Address)
	}
}

type ContactAddressesItemVisitor interface {
	VisitString(string) error
	VisitAddress(*Address) error
}

func (c *ContactAddressesItem) Accept(visitor ContactAddressesItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "address":
		return visitor.VisitAddress(c.Address)
	}
}

// # The Contact Object
//
// ### Description
//
// A `Contact` is an individual or business entity to which products and services are sold to or purchased from. The `Contact` model contains both Customers, in which products and services are sold to, and Vendors (or Suppliers), in which products and services are purchased from.
//
// - A `Contact` is a Vendor/Supplier if the `is_supplier` property is true.
// - A `Contact` is a customer if the `is_customer` property is true.
//
// ### Usage Example
//
// Fetch from the `LIST Contacts` endpoint and view a company's contacts.
type ContactRequest struct {
	// The contact's name.
	Name *string `json:"name,omitempty"`
	// Whether the contact is a supplier.
	IsSupplier *bool `json:"is_supplier,omitempty"`
	// Whether the contact is a customer.
	IsCustomer *bool `json:"is_customer,omitempty"`
	// The contact's email address.
	EmailAddress *string `json:"email_address,omitempty"`
	// The contact's tax number.
	TaxNumber *string `json:"tax_number,omitempty"`
	// The contact's status
	//
	// - `ACTIVE` - ACTIVE
	// - `ARCHIVED` - ARCHIVED
	Status *ContactRequestStatus `json:"status,omitempty"`
	// The currency the contact's transactions are in.
	Currency *string `json:"currency,omitempty"`
	// The company the contact belongs to.
	Company *string `json:"company,omitempty"`
	// `Address` object IDs for the given `Contacts` object.
	Addresses []*ContactRequestAddressesItem `json:"addresses,omitempty"`
	// `AccountingPhoneNumber` object for the given `Contacts` object.
	PhoneNumbers        []*AccountingPhoneNumberRequest `json:"phone_numbers,omitempty"`
	IntegrationParams   map[string]interface{}          `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}          `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest           `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ContactRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContactRequestAddressesItem struct {
	typeName string
	String   string
	Address  *Address
}

func NewContactRequestAddressesItemFromString(value string) *ContactRequestAddressesItem {
	return &ContactRequestAddressesItem{typeName: "string", String: value}
}

func NewContactRequestAddressesItemFromAddress(value *Address) *ContactRequestAddressesItem {
	return &ContactRequestAddressesItem{typeName: "address", Address: value}
}

func (c *ContactRequestAddressesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueAddress := new(Address)
	if err := json.Unmarshal(data, &valueAddress); err == nil {
		c.typeName = "address"
		c.Address = valueAddress
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ContactRequestAddressesItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "address":
		return json.Marshal(c.Address)
	}
}

type ContactRequestAddressesItemVisitor interface {
	VisitString(string) error
	VisitAddress(*Address) error
}

func (c *ContactRequestAddressesItem) Accept(visitor ContactRequestAddressesItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "address":
		return visitor.VisitAddress(c.Address)
	}
}

// The contact's status
//
// - `ACTIVE` - ACTIVE
// - `ARCHIVED` - ARCHIVED
type ContactRequestStatus struct {
	typeName      string
	Status7D1Enum Status7D1Enum
	String        string
}

func NewContactRequestStatusFromStatus7D1Enum(value Status7D1Enum) *ContactRequestStatus {
	return &ContactRequestStatus{typeName: "status7D1Enum", Status7D1Enum: value}
}

func NewContactRequestStatusFromString(value string) *ContactRequestStatus {
	return &ContactRequestStatus{typeName: "string", String: value}
}

func (c *ContactRequestStatus) UnmarshalJSON(data []byte) error {
	var valueStatus7D1Enum Status7D1Enum
	if err := json.Unmarshal(data, &valueStatus7D1Enum); err == nil {
		c.typeName = "status7D1Enum"
		c.Status7D1Enum = valueStatus7D1Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ContactRequestStatus) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "status7D1Enum":
		return json.Marshal(c.Status7D1Enum)
	case "string":
		return json.Marshal(c.String)
	}
}

type ContactRequestStatusVisitor interface {
	VisitStatus7D1Enum(Status7D1Enum) error
	VisitString(string) error
}

func (c *ContactRequestStatus) Accept(visitor ContactRequestStatusVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "status7D1Enum":
		return visitor.VisitStatus7D1Enum(c.Status7D1Enum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

type ContactResponse struct {
	Model    *Contact                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ContactResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The contact's status
//
// - `ACTIVE` - ACTIVE
// - `ARCHIVED` - ARCHIVED
type ContactStatus struct {
	typeName      string
	Status7D1Enum Status7D1Enum
	String        string
}

func NewContactStatusFromStatus7D1Enum(value Status7D1Enum) *ContactStatus {
	return &ContactStatus{typeName: "status7D1Enum", Status7D1Enum: value}
}

func NewContactStatusFromString(value string) *ContactStatus {
	return &ContactStatus{typeName: "string", String: value}
}

func (c *ContactStatus) UnmarshalJSON(data []byte) error {
	var valueStatus7D1Enum Status7D1Enum
	if err := json.Unmarshal(data, &valueStatus7D1Enum); err == nil {
		c.typeName = "status7D1Enum"
		c.Status7D1Enum = valueStatus7D1Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ContactStatus) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "status7D1Enum":
		return json.Marshal(c.Status7D1Enum)
	case "string":
		return json.Marshal(c.String)
	}
}

type ContactStatusVisitor interface {
	VisitStatus7D1Enum(Status7D1Enum) error
	VisitString(string) error
}

func (c *ContactStatus) Accept(visitor ContactStatusVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "status7D1Enum":
		return visitor.VisitStatus7D1Enum(c.Status7D1Enum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// - `AF` - Afghanistan
// - `AX` - Åland Islands
// - `AL` - Albania
// - `DZ` - Algeria
// - `AS` - American Samoa
// - `AD` - Andorra
// - `AO` - Angola
// - `AI` - Anguilla
// - `AQ` - Antarctica
// - `AG` - Antigua and Barbuda
// - `AR` - Argentina
// - `AM` - Armenia
// - `AW` - Aruba
// - `AU` - Australia
// - `AT` - Austria
// - `AZ` - Azerbaijan
// - `BS` - Bahamas
// - `BH` - Bahrain
// - `BD` - Bangladesh
// - `BB` - Barbados
// - `BY` - Belarus
// - `BE` - Belgium
// - `BZ` - Belize
// - `BJ` - Benin
// - `BM` - Bermuda
// - `BT` - Bhutan
// - `BO` - Bolivia
// - `BQ` - Bonaire, Sint Eustatius and Saba
// - `BA` - Bosnia and Herzegovina
// - `BW` - Botswana
// - `BV` - Bouvet Island
// - `BR` - Brazil
// - `IO` - British Indian Ocean Territory
// - `BN` - Brunei
// - `BG` - Bulgaria
// - `BF` - Burkina Faso
// - `BI` - Burundi
// - `CV` - Cabo Verde
// - `KH` - Cambodia
// - `CM` - Cameroon
// - `CA` - Canada
// - `KY` - Cayman Islands
// - `CF` - Central African Republic
// - `TD` - Chad
// - `CL` - Chile
// - `CN` - China
// - `CX` - Christmas Island
// - `CC` - Cocos (Keeling) Islands
// - `CO` - Colombia
// - `KM` - Comoros
// - `CG` - Congo
// - `CD` - Congo (the Democratic Republic of the)
// - `CK` - Cook Islands
// - `CR` - Costa Rica
// - `CI` - Côte d'Ivoire
// - `HR` - Croatia
// - `CU` - Cuba
// - `CW` - Curaçao
// - `CY` - Cyprus
// - `CZ` - Czechia
// - `DK` - Denmark
// - `DJ` - Djibouti
// - `DM` - Dominica
// - `DO` - Dominican Republic
// - `EC` - Ecuador
// - `EG` - Egypt
// - `SV` - El Salvador
// - `GQ` - Equatorial Guinea
// - `ER` - Eritrea
// - `EE` - Estonia
// - `SZ` - Eswatini
// - `ET` - Ethiopia
// - `FK` - Falkland Islands (Malvinas)
// - `FO` - Faroe Islands
// - `FJ` - Fiji
// - `FI` - Finland
// - `FR` - France
// - `GF` - French Guiana
// - `PF` - French Polynesia
// - `TF` - French Southern Territories
// - `GA` - Gabon
// - `GM` - Gambia
// - `GE` - Georgia
// - `DE` - Germany
// - `GH` - Ghana
// - `GI` - Gibraltar
// - `GR` - Greece
// - `GL` - Greenland
// - `GD` - Grenada
// - `GP` - Guadeloupe
// - `GU` - Guam
// - `GT` - Guatemala
// - `GG` - Guernsey
// - `GN` - Guinea
// - `GW` - Guinea-Bissau
// - `GY` - Guyana
// - `HT` - Haiti
// - `HM` - Heard Island and McDonald Islands
// - `VA` - Holy See
// - `HN` - Honduras
// - `HK` - Hong Kong
// - `HU` - Hungary
// - `IS` - Iceland
// - `IN` - India
// - `ID` - Indonesia
// - `IR` - Iran
// - `IQ` - Iraq
// - `IE` - Ireland
// - `IM` - Isle of Man
// - `IL` - Israel
// - `IT` - Italy
// - `JM` - Jamaica
// - `JP` - Japan
// - `JE` - Jersey
// - `JO` - Jordan
// - `KZ` - Kazakhstan
// - `KE` - Kenya
// - `KI` - Kiribati
// - `KW` - Kuwait
// - `KG` - Kyrgyzstan
// - `LA` - Laos
// - `LV` - Latvia
// - `LB` - Lebanon
// - `LS` - Lesotho
// - `LR` - Liberia
// - `LY` - Libya
// - `LI` - Liechtenstein
// - `LT` - Lithuania
// - `LU` - Luxembourg
// - `MO` - Macao
// - `MG` - Madagascar
// - `MW` - Malawi
// - `MY` - Malaysia
// - `MV` - Maldives
// - `ML` - Mali
// - `MT` - Malta
// - `MH` - Marshall Islands
// - `MQ` - Martinique
// - `MR` - Mauritania
// - `MU` - Mauritius
// - `YT` - Mayotte
// - `MX` - Mexico
// - `FM` - Micronesia (Federated States of)
// - `MD` - Moldova
// - `MC` - Monaco
// - `MN` - Mongolia
// - `ME` - Montenegro
// - `MS` - Montserrat
// - `MA` - Morocco
// - `MZ` - Mozambique
// - `MM` - Myanmar
// - `NA` - Namibia
// - `NR` - Nauru
// - `NP` - Nepal
// - `NL` - Netherlands
// - `NC` - New Caledonia
// - `NZ` - New Zealand
// - `NI` - Nicaragua
// - `NE` - Niger
// - `NG` - Nigeria
// - `NU` - Niue
// - `NF` - Norfolk Island
// - `KP` - North Korea
// - `MK` - North Macedonia
// - `MP` - Northern Mariana Islands
// - `NO` - Norway
// - `OM` - Oman
// - `PK` - Pakistan
// - `PW` - Palau
// - `PS` - Palestine, State of
// - `PA` - Panama
// - `PG` - Papua New Guinea
// - `PY` - Paraguay
// - `PE` - Peru
// - `PH` - Philippines
// - `PN` - Pitcairn
// - `PL` - Poland
// - `PT` - Portugal
// - `PR` - Puerto Rico
// - `QA` - Qatar
// - `RE` - Réunion
// - `RO` - Romania
// - `RU` - Russia
// - `RW` - Rwanda
// - `BL` - Saint Barthélemy
// - `SH` - Saint Helena, Ascension and Tristan da Cunha
// - `KN` - Saint Kitts and Nevis
// - `LC` - Saint Lucia
// - `MF` - Saint Martin (French part)
// - `PM` - Saint Pierre and Miquelon
// - `VC` - Saint Vincent and the Grenadines
// - `WS` - Samoa
// - `SM` - San Marino
// - `ST` - Sao Tome and Principe
// - `SA` - Saudi Arabia
// - `SN` - Senegal
// - `RS` - Serbia
// - `SC` - Seychelles
// - `SL` - Sierra Leone
// - `SG` - Singapore
// - `SX` - Sint Maarten (Dutch part)
// - `SK` - Slovakia
// - `SI` - Slovenia
// - `SB` - Solomon Islands
// - `SO` - Somalia
// - `ZA` - South Africa
// - `GS` - South Georgia and the South Sandwich Islands
// - `KR` - South Korea
// - `SS` - South Sudan
// - `ES` - Spain
// - `LK` - Sri Lanka
// - `SD` - Sudan
// - `SR` - Suriname
// - `SJ` - Svalbard and Jan Mayen
// - `SE` - Sweden
// - `CH` - Switzerland
// - `SY` - Syria
// - `TW` - Taiwan
// - `TJ` - Tajikistan
// - `TZ` - Tanzania
// - `TH` - Thailand
// - `TL` - Timor-Leste
// - `TG` - Togo
// - `TK` - Tokelau
// - `TO` - Tonga
// - `TT` - Trinidad and Tobago
// - `TN` - Tunisia
// - `TR` - Turkey
// - `TM` - Turkmenistan
// - `TC` - Turks and Caicos Islands
// - `TV` - Tuvalu
// - `UG` - Uganda
// - `UA` - Ukraine
// - `AE` - United Arab Emirates
// - `GB` - United Kingdom
// - `UM` - United States Minor Outlying Islands
// - `US` - United States of America
// - `UY` - Uruguay
// - `UZ` - Uzbekistan
// - `VU` - Vanuatu
// - `VE` - Venezuela
// - `VN` - Vietnam
// - `VG` - Virgin Islands (British)
// - `VI` - Virgin Islands (U.S.)
// - `WF` - Wallis and Futuna
// - `EH` - Western Sahara
// - `YE` - Yemen
// - `ZM` - Zambia
// - `ZW` - Zimbabwe
type CountryEnum string

const (
	CountryEnumAf CountryEnum = "AF"
	CountryEnumAx CountryEnum = "AX"
	CountryEnumAl CountryEnum = "AL"
	CountryEnumDz CountryEnum = "DZ"
	CountryEnumAs CountryEnum = "AS"
	CountryEnumAd CountryEnum = "AD"
	CountryEnumAo CountryEnum = "AO"
	CountryEnumAi CountryEnum = "AI"
	CountryEnumAq CountryEnum = "AQ"
	CountryEnumAg CountryEnum = "AG"
	CountryEnumAr CountryEnum = "AR"
	CountryEnumAm CountryEnum = "AM"
	CountryEnumAw CountryEnum = "AW"
	CountryEnumAu CountryEnum = "AU"
	CountryEnumAt CountryEnum = "AT"
	CountryEnumAz CountryEnum = "AZ"
	CountryEnumBs CountryEnum = "BS"
	CountryEnumBh CountryEnum = "BH"
	CountryEnumBd CountryEnum = "BD"
	CountryEnumBb CountryEnum = "BB"
	CountryEnumBy CountryEnum = "BY"
	CountryEnumBe CountryEnum = "BE"
	CountryEnumBz CountryEnum = "BZ"
	CountryEnumBj CountryEnum = "BJ"
	CountryEnumBm CountryEnum = "BM"
	CountryEnumBt CountryEnum = "BT"
	CountryEnumBo CountryEnum = "BO"
	CountryEnumBq CountryEnum = "BQ"
	CountryEnumBa CountryEnum = "BA"
	CountryEnumBw CountryEnum = "BW"
	CountryEnumBv CountryEnum = "BV"
	CountryEnumBr CountryEnum = "BR"
	CountryEnumIo CountryEnum = "IO"
	CountryEnumBn CountryEnum = "BN"
	CountryEnumBg CountryEnum = "BG"
	CountryEnumBf CountryEnum = "BF"
	CountryEnumBi CountryEnum = "BI"
	CountryEnumCv CountryEnum = "CV"
	CountryEnumKh CountryEnum = "KH"
	CountryEnumCm CountryEnum = "CM"
	CountryEnumCa CountryEnum = "CA"
	CountryEnumKy CountryEnum = "KY"
	CountryEnumCf CountryEnum = "CF"
	CountryEnumTd CountryEnum = "TD"
	CountryEnumCl CountryEnum = "CL"
	CountryEnumCn CountryEnum = "CN"
	CountryEnumCx CountryEnum = "CX"
	CountryEnumCc CountryEnum = "CC"
	CountryEnumCo CountryEnum = "CO"
	CountryEnumKm CountryEnum = "KM"
	CountryEnumCg CountryEnum = "CG"
	CountryEnumCd CountryEnum = "CD"
	CountryEnumCk CountryEnum = "CK"
	CountryEnumCr CountryEnum = "CR"
	CountryEnumCi CountryEnum = "CI"
	CountryEnumHr CountryEnum = "HR"
	CountryEnumCu CountryEnum = "CU"
	CountryEnumCw CountryEnum = "CW"
	CountryEnumCy CountryEnum = "CY"
	CountryEnumCz CountryEnum = "CZ"
	CountryEnumDk CountryEnum = "DK"
	CountryEnumDj CountryEnum = "DJ"
	CountryEnumDm CountryEnum = "DM"
	CountryEnumDo CountryEnum = "DO"
	CountryEnumEc CountryEnum = "EC"
	CountryEnumEg CountryEnum = "EG"
	CountryEnumSv CountryEnum = "SV"
	CountryEnumGq CountryEnum = "GQ"
	CountryEnumEr CountryEnum = "ER"
	CountryEnumEe CountryEnum = "EE"
	CountryEnumSz CountryEnum = "SZ"
	CountryEnumEt CountryEnum = "ET"
	CountryEnumFk CountryEnum = "FK"
	CountryEnumFo CountryEnum = "FO"
	CountryEnumFj CountryEnum = "FJ"
	CountryEnumFi CountryEnum = "FI"
	CountryEnumFr CountryEnum = "FR"
	CountryEnumGf CountryEnum = "GF"
	CountryEnumPf CountryEnum = "PF"
	CountryEnumTf CountryEnum = "TF"
	CountryEnumGa CountryEnum = "GA"
	CountryEnumGm CountryEnum = "GM"
	CountryEnumGe CountryEnum = "GE"
	CountryEnumDe CountryEnum = "DE"
	CountryEnumGh CountryEnum = "GH"
	CountryEnumGi CountryEnum = "GI"
	CountryEnumGr CountryEnum = "GR"
	CountryEnumGl CountryEnum = "GL"
	CountryEnumGd CountryEnum = "GD"
	CountryEnumGp CountryEnum = "GP"
	CountryEnumGu CountryEnum = "GU"
	CountryEnumGt CountryEnum = "GT"
	CountryEnumGg CountryEnum = "GG"
	CountryEnumGn CountryEnum = "GN"
	CountryEnumGw CountryEnum = "GW"
	CountryEnumGy CountryEnum = "GY"
	CountryEnumHt CountryEnum = "HT"
	CountryEnumHm CountryEnum = "HM"
	CountryEnumVa CountryEnum = "VA"
	CountryEnumHn CountryEnum = "HN"
	CountryEnumHk CountryEnum = "HK"
	CountryEnumHu CountryEnum = "HU"
	CountryEnumIs CountryEnum = "IS"
	CountryEnumIn CountryEnum = "IN"
	CountryEnumId CountryEnum = "ID"
	CountryEnumIr CountryEnum = "IR"
	CountryEnumIq CountryEnum = "IQ"
	CountryEnumIe CountryEnum = "IE"
	CountryEnumIm CountryEnum = "IM"
	CountryEnumIl CountryEnum = "IL"
	CountryEnumIt CountryEnum = "IT"
	CountryEnumJm CountryEnum = "JM"
	CountryEnumJp CountryEnum = "JP"
	CountryEnumJe CountryEnum = "JE"
	CountryEnumJo CountryEnum = "JO"
	CountryEnumKz CountryEnum = "KZ"
	CountryEnumKe CountryEnum = "KE"
	CountryEnumKi CountryEnum = "KI"
	CountryEnumKw CountryEnum = "KW"
	CountryEnumKg CountryEnum = "KG"
	CountryEnumLa CountryEnum = "LA"
	CountryEnumLv CountryEnum = "LV"
	CountryEnumLb CountryEnum = "LB"
	CountryEnumLs CountryEnum = "LS"
	CountryEnumLr CountryEnum = "LR"
	CountryEnumLy CountryEnum = "LY"
	CountryEnumLi CountryEnum = "LI"
	CountryEnumLt CountryEnum = "LT"
	CountryEnumLu CountryEnum = "LU"
	CountryEnumMo CountryEnum = "MO"
	CountryEnumMg CountryEnum = "MG"
	CountryEnumMw CountryEnum = "MW"
	CountryEnumMy CountryEnum = "MY"
	CountryEnumMv CountryEnum = "MV"
	CountryEnumMl CountryEnum = "ML"
	CountryEnumMt CountryEnum = "MT"
	CountryEnumMh CountryEnum = "MH"
	CountryEnumMq CountryEnum = "MQ"
	CountryEnumMr CountryEnum = "MR"
	CountryEnumMu CountryEnum = "MU"
	CountryEnumYt CountryEnum = "YT"
	CountryEnumMx CountryEnum = "MX"
	CountryEnumFm CountryEnum = "FM"
	CountryEnumMd CountryEnum = "MD"
	CountryEnumMc CountryEnum = "MC"
	CountryEnumMn CountryEnum = "MN"
	CountryEnumMe CountryEnum = "ME"
	CountryEnumMs CountryEnum = "MS"
	CountryEnumMa CountryEnum = "MA"
	CountryEnumMz CountryEnum = "MZ"
	CountryEnumMm CountryEnum = "MM"
	CountryEnumNa CountryEnum = "NA"
	CountryEnumNr CountryEnum = "NR"
	CountryEnumNp CountryEnum = "NP"
	CountryEnumNl CountryEnum = "NL"
	CountryEnumNc CountryEnum = "NC"
	CountryEnumNz CountryEnum = "NZ"
	CountryEnumNi CountryEnum = "NI"
	CountryEnumNe CountryEnum = "NE"
	CountryEnumNg CountryEnum = "NG"
	CountryEnumNu CountryEnum = "NU"
	CountryEnumNf CountryEnum = "NF"
	CountryEnumKp CountryEnum = "KP"
	CountryEnumMk CountryEnum = "MK"
	CountryEnumMp CountryEnum = "MP"
	CountryEnumNo CountryEnum = "NO"
	CountryEnumOm CountryEnum = "OM"
	CountryEnumPk CountryEnum = "PK"
	CountryEnumPw CountryEnum = "PW"
	CountryEnumPs CountryEnum = "PS"
	CountryEnumPa CountryEnum = "PA"
	CountryEnumPg CountryEnum = "PG"
	CountryEnumPy CountryEnum = "PY"
	CountryEnumPe CountryEnum = "PE"
	CountryEnumPh CountryEnum = "PH"
	CountryEnumPn CountryEnum = "PN"
	CountryEnumPl CountryEnum = "PL"
	CountryEnumPt CountryEnum = "PT"
	CountryEnumPr CountryEnum = "PR"
	CountryEnumQa CountryEnum = "QA"
	CountryEnumRe CountryEnum = "RE"
	CountryEnumRo CountryEnum = "RO"
	CountryEnumRu CountryEnum = "RU"
	CountryEnumRw CountryEnum = "RW"
	CountryEnumBl CountryEnum = "BL"
	CountryEnumSh CountryEnum = "SH"
	CountryEnumKn CountryEnum = "KN"
	CountryEnumLc CountryEnum = "LC"
	CountryEnumMf CountryEnum = "MF"
	CountryEnumPm CountryEnum = "PM"
	CountryEnumVc CountryEnum = "VC"
	CountryEnumWs CountryEnum = "WS"
	CountryEnumSm CountryEnum = "SM"
	CountryEnumSt CountryEnum = "ST"
	CountryEnumSa CountryEnum = "SA"
	CountryEnumSn CountryEnum = "SN"
	CountryEnumRs CountryEnum = "RS"
	CountryEnumSc CountryEnum = "SC"
	CountryEnumSl CountryEnum = "SL"
	CountryEnumSg CountryEnum = "SG"
	CountryEnumSx CountryEnum = "SX"
	CountryEnumSk CountryEnum = "SK"
	CountryEnumSi CountryEnum = "SI"
	CountryEnumSb CountryEnum = "SB"
	CountryEnumSo CountryEnum = "SO"
	CountryEnumZa CountryEnum = "ZA"
	CountryEnumGs CountryEnum = "GS"
	CountryEnumKr CountryEnum = "KR"
	CountryEnumSs CountryEnum = "SS"
	CountryEnumEs CountryEnum = "ES"
	CountryEnumLk CountryEnum = "LK"
	CountryEnumSd CountryEnum = "SD"
	CountryEnumSr CountryEnum = "SR"
	CountryEnumSj CountryEnum = "SJ"
	CountryEnumSe CountryEnum = "SE"
	CountryEnumCh CountryEnum = "CH"
	CountryEnumSy CountryEnum = "SY"
	CountryEnumTw CountryEnum = "TW"
	CountryEnumTj CountryEnum = "TJ"
	CountryEnumTz CountryEnum = "TZ"
	CountryEnumTh CountryEnum = "TH"
	CountryEnumTl CountryEnum = "TL"
	CountryEnumTg CountryEnum = "TG"
	CountryEnumTk CountryEnum = "TK"
	CountryEnumTo CountryEnum = "TO"
	CountryEnumTt CountryEnum = "TT"
	CountryEnumTn CountryEnum = "TN"
	CountryEnumTr CountryEnum = "TR"
	CountryEnumTm CountryEnum = "TM"
	CountryEnumTc CountryEnum = "TC"
	CountryEnumTv CountryEnum = "TV"
	CountryEnumUg CountryEnum = "UG"
	CountryEnumUa CountryEnum = "UA"
	CountryEnumAe CountryEnum = "AE"
	CountryEnumGb CountryEnum = "GB"
	CountryEnumUm CountryEnum = "UM"
	CountryEnumUs CountryEnum = "US"
	CountryEnumUy CountryEnum = "UY"
	CountryEnumUz CountryEnum = "UZ"
	CountryEnumVu CountryEnum = "VU"
	CountryEnumVe CountryEnum = "VE"
	CountryEnumVn CountryEnum = "VN"
	CountryEnumVg CountryEnum = "VG"
	CountryEnumVi CountryEnum = "VI"
	CountryEnumWf CountryEnum = "WF"
	CountryEnumEh CountryEnum = "EH"
	CountryEnumYe CountryEnum = "YE"
	CountryEnumZm CountryEnum = "ZM"
	CountryEnumZw CountryEnum = "ZW"
)

func NewCountryEnumFromString(s string) (CountryEnum, error) {
	switch s {
	case "AF":
		return CountryEnumAf, nil
	case "AX":
		return CountryEnumAx, nil
	case "AL":
		return CountryEnumAl, nil
	case "DZ":
		return CountryEnumDz, nil
	case "AS":
		return CountryEnumAs, nil
	case "AD":
		return CountryEnumAd, nil
	case "AO":
		return CountryEnumAo, nil
	case "AI":
		return CountryEnumAi, nil
	case "AQ":
		return CountryEnumAq, nil
	case "AG":
		return CountryEnumAg, nil
	case "AR":
		return CountryEnumAr, nil
	case "AM":
		return CountryEnumAm, nil
	case "AW":
		return CountryEnumAw, nil
	case "AU":
		return CountryEnumAu, nil
	case "AT":
		return CountryEnumAt, nil
	case "AZ":
		return CountryEnumAz, nil
	case "BS":
		return CountryEnumBs, nil
	case "BH":
		return CountryEnumBh, nil
	case "BD":
		return CountryEnumBd, nil
	case "BB":
		return CountryEnumBb, nil
	case "BY":
		return CountryEnumBy, nil
	case "BE":
		return CountryEnumBe, nil
	case "BZ":
		return CountryEnumBz, nil
	case "BJ":
		return CountryEnumBj, nil
	case "BM":
		return CountryEnumBm, nil
	case "BT":
		return CountryEnumBt, nil
	case "BO":
		return CountryEnumBo, nil
	case "BQ":
		return CountryEnumBq, nil
	case "BA":
		return CountryEnumBa, nil
	case "BW":
		return CountryEnumBw, nil
	case "BV":
		return CountryEnumBv, nil
	case "BR":
		return CountryEnumBr, nil
	case "IO":
		return CountryEnumIo, nil
	case "BN":
		return CountryEnumBn, nil
	case "BG":
		return CountryEnumBg, nil
	case "BF":
		return CountryEnumBf, nil
	case "BI":
		return CountryEnumBi, nil
	case "CV":
		return CountryEnumCv, nil
	case "KH":
		return CountryEnumKh, nil
	case "CM":
		return CountryEnumCm, nil
	case "CA":
		return CountryEnumCa, nil
	case "KY":
		return CountryEnumKy, nil
	case "CF":
		return CountryEnumCf, nil
	case "TD":
		return CountryEnumTd, nil
	case "CL":
		return CountryEnumCl, nil
	case "CN":
		return CountryEnumCn, nil
	case "CX":
		return CountryEnumCx, nil
	case "CC":
		return CountryEnumCc, nil
	case "CO":
		return CountryEnumCo, nil
	case "KM":
		return CountryEnumKm, nil
	case "CG":
		return CountryEnumCg, nil
	case "CD":
		return CountryEnumCd, nil
	case "CK":
		return CountryEnumCk, nil
	case "CR":
		return CountryEnumCr, nil
	case "CI":
		return CountryEnumCi, nil
	case "HR":
		return CountryEnumHr, nil
	case "CU":
		return CountryEnumCu, nil
	case "CW":
		return CountryEnumCw, nil
	case "CY":
		return CountryEnumCy, nil
	case "CZ":
		return CountryEnumCz, nil
	case "DK":
		return CountryEnumDk, nil
	case "DJ":
		return CountryEnumDj, nil
	case "DM":
		return CountryEnumDm, nil
	case "DO":
		return CountryEnumDo, nil
	case "EC":
		return CountryEnumEc, nil
	case "EG":
		return CountryEnumEg, nil
	case "SV":
		return CountryEnumSv, nil
	case "GQ":
		return CountryEnumGq, nil
	case "ER":
		return CountryEnumEr, nil
	case "EE":
		return CountryEnumEe, nil
	case "SZ":
		return CountryEnumSz, nil
	case "ET":
		return CountryEnumEt, nil
	case "FK":
		return CountryEnumFk, nil
	case "FO":
		return CountryEnumFo, nil
	case "FJ":
		return CountryEnumFj, nil
	case "FI":
		return CountryEnumFi, nil
	case "FR":
		return CountryEnumFr, nil
	case "GF":
		return CountryEnumGf, nil
	case "PF":
		return CountryEnumPf, nil
	case "TF":
		return CountryEnumTf, nil
	case "GA":
		return CountryEnumGa, nil
	case "GM":
		return CountryEnumGm, nil
	case "GE":
		return CountryEnumGe, nil
	case "DE":
		return CountryEnumDe, nil
	case "GH":
		return CountryEnumGh, nil
	case "GI":
		return CountryEnumGi, nil
	case "GR":
		return CountryEnumGr, nil
	case "GL":
		return CountryEnumGl, nil
	case "GD":
		return CountryEnumGd, nil
	case "GP":
		return CountryEnumGp, nil
	case "GU":
		return CountryEnumGu, nil
	case "GT":
		return CountryEnumGt, nil
	case "GG":
		return CountryEnumGg, nil
	case "GN":
		return CountryEnumGn, nil
	case "GW":
		return CountryEnumGw, nil
	case "GY":
		return CountryEnumGy, nil
	case "HT":
		return CountryEnumHt, nil
	case "HM":
		return CountryEnumHm, nil
	case "VA":
		return CountryEnumVa, nil
	case "HN":
		return CountryEnumHn, nil
	case "HK":
		return CountryEnumHk, nil
	case "HU":
		return CountryEnumHu, nil
	case "IS":
		return CountryEnumIs, nil
	case "IN":
		return CountryEnumIn, nil
	case "ID":
		return CountryEnumId, nil
	case "IR":
		return CountryEnumIr, nil
	case "IQ":
		return CountryEnumIq, nil
	case "IE":
		return CountryEnumIe, nil
	case "IM":
		return CountryEnumIm, nil
	case "IL":
		return CountryEnumIl, nil
	case "IT":
		return CountryEnumIt, nil
	case "JM":
		return CountryEnumJm, nil
	case "JP":
		return CountryEnumJp, nil
	case "JE":
		return CountryEnumJe, nil
	case "JO":
		return CountryEnumJo, nil
	case "KZ":
		return CountryEnumKz, nil
	case "KE":
		return CountryEnumKe, nil
	case "KI":
		return CountryEnumKi, nil
	case "KW":
		return CountryEnumKw, nil
	case "KG":
		return CountryEnumKg, nil
	case "LA":
		return CountryEnumLa, nil
	case "LV":
		return CountryEnumLv, nil
	case "LB":
		return CountryEnumLb, nil
	case "LS":
		return CountryEnumLs, nil
	case "LR":
		return CountryEnumLr, nil
	case "LY":
		return CountryEnumLy, nil
	case "LI":
		return CountryEnumLi, nil
	case "LT":
		return CountryEnumLt, nil
	case "LU":
		return CountryEnumLu, nil
	case "MO":
		return CountryEnumMo, nil
	case "MG":
		return CountryEnumMg, nil
	case "MW":
		return CountryEnumMw, nil
	case "MY":
		return CountryEnumMy, nil
	case "MV":
		return CountryEnumMv, nil
	case "ML":
		return CountryEnumMl, nil
	case "MT":
		return CountryEnumMt, nil
	case "MH":
		return CountryEnumMh, nil
	case "MQ":
		return CountryEnumMq, nil
	case "MR":
		return CountryEnumMr, nil
	case "MU":
		return CountryEnumMu, nil
	case "YT":
		return CountryEnumYt, nil
	case "MX":
		return CountryEnumMx, nil
	case "FM":
		return CountryEnumFm, nil
	case "MD":
		return CountryEnumMd, nil
	case "MC":
		return CountryEnumMc, nil
	case "MN":
		return CountryEnumMn, nil
	case "ME":
		return CountryEnumMe, nil
	case "MS":
		return CountryEnumMs, nil
	case "MA":
		return CountryEnumMa, nil
	case "MZ":
		return CountryEnumMz, nil
	case "MM":
		return CountryEnumMm, nil
	case "NA":
		return CountryEnumNa, nil
	case "NR":
		return CountryEnumNr, nil
	case "NP":
		return CountryEnumNp, nil
	case "NL":
		return CountryEnumNl, nil
	case "NC":
		return CountryEnumNc, nil
	case "NZ":
		return CountryEnumNz, nil
	case "NI":
		return CountryEnumNi, nil
	case "NE":
		return CountryEnumNe, nil
	case "NG":
		return CountryEnumNg, nil
	case "NU":
		return CountryEnumNu, nil
	case "NF":
		return CountryEnumNf, nil
	case "KP":
		return CountryEnumKp, nil
	case "MK":
		return CountryEnumMk, nil
	case "MP":
		return CountryEnumMp, nil
	case "NO":
		return CountryEnumNo, nil
	case "OM":
		return CountryEnumOm, nil
	case "PK":
		return CountryEnumPk, nil
	case "PW":
		return CountryEnumPw, nil
	case "PS":
		return CountryEnumPs, nil
	case "PA":
		return CountryEnumPa, nil
	case "PG":
		return CountryEnumPg, nil
	case "PY":
		return CountryEnumPy, nil
	case "PE":
		return CountryEnumPe, nil
	case "PH":
		return CountryEnumPh, nil
	case "PN":
		return CountryEnumPn, nil
	case "PL":
		return CountryEnumPl, nil
	case "PT":
		return CountryEnumPt, nil
	case "PR":
		return CountryEnumPr, nil
	case "QA":
		return CountryEnumQa, nil
	case "RE":
		return CountryEnumRe, nil
	case "RO":
		return CountryEnumRo, nil
	case "RU":
		return CountryEnumRu, nil
	case "RW":
		return CountryEnumRw, nil
	case "BL":
		return CountryEnumBl, nil
	case "SH":
		return CountryEnumSh, nil
	case "KN":
		return CountryEnumKn, nil
	case "LC":
		return CountryEnumLc, nil
	case "MF":
		return CountryEnumMf, nil
	case "PM":
		return CountryEnumPm, nil
	case "VC":
		return CountryEnumVc, nil
	case "WS":
		return CountryEnumWs, nil
	case "SM":
		return CountryEnumSm, nil
	case "ST":
		return CountryEnumSt, nil
	case "SA":
		return CountryEnumSa, nil
	case "SN":
		return CountryEnumSn, nil
	case "RS":
		return CountryEnumRs, nil
	case "SC":
		return CountryEnumSc, nil
	case "SL":
		return CountryEnumSl, nil
	case "SG":
		return CountryEnumSg, nil
	case "SX":
		return CountryEnumSx, nil
	case "SK":
		return CountryEnumSk, nil
	case "SI":
		return CountryEnumSi, nil
	case "SB":
		return CountryEnumSb, nil
	case "SO":
		return CountryEnumSo, nil
	case "ZA":
		return CountryEnumZa, nil
	case "GS":
		return CountryEnumGs, nil
	case "KR":
		return CountryEnumKr, nil
	case "SS":
		return CountryEnumSs, nil
	case "ES":
		return CountryEnumEs, nil
	case "LK":
		return CountryEnumLk, nil
	case "SD":
		return CountryEnumSd, nil
	case "SR":
		return CountryEnumSr, nil
	case "SJ":
		return CountryEnumSj, nil
	case "SE":
		return CountryEnumSe, nil
	case "CH":
		return CountryEnumCh, nil
	case "SY":
		return CountryEnumSy, nil
	case "TW":
		return CountryEnumTw, nil
	case "TJ":
		return CountryEnumTj, nil
	case "TZ":
		return CountryEnumTz, nil
	case "TH":
		return CountryEnumTh, nil
	case "TL":
		return CountryEnumTl, nil
	case "TG":
		return CountryEnumTg, nil
	case "TK":
		return CountryEnumTk, nil
	case "TO":
		return CountryEnumTo, nil
	case "TT":
		return CountryEnumTt, nil
	case "TN":
		return CountryEnumTn, nil
	case "TR":
		return CountryEnumTr, nil
	case "TM":
		return CountryEnumTm, nil
	case "TC":
		return CountryEnumTc, nil
	case "TV":
		return CountryEnumTv, nil
	case "UG":
		return CountryEnumUg, nil
	case "UA":
		return CountryEnumUa, nil
	case "AE":
		return CountryEnumAe, nil
	case "GB":
		return CountryEnumGb, nil
	case "UM":
		return CountryEnumUm, nil
	case "US":
		return CountryEnumUs, nil
	case "UY":
		return CountryEnumUy, nil
	case "UZ":
		return CountryEnumUz, nil
	case "VU":
		return CountryEnumVu, nil
	case "VE":
		return CountryEnumVe, nil
	case "VN":
		return CountryEnumVn, nil
	case "VG":
		return CountryEnumVg, nil
	case "VI":
		return CountryEnumVi, nil
	case "WF":
		return CountryEnumWf, nil
	case "EH":
		return CountryEnumEh, nil
	case "YE":
		return CountryEnumYe, nil
	case "ZM":
		return CountryEnumZm, nil
	case "ZW":
		return CountryEnumZw, nil
	}
	var t CountryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountryEnum) Ptr() *CountryEnum {
	return &c
}

// # The CreditNote Object
//
// ### Description
//
// A `CreditNote` is transaction issued to a customer, indicating a reduction or cancellation of the amount owed by the customer. It is most generally used as an adjustment note used to rectify errors, returns, or overpayments related to a sales transaction. A `CreditNote` can be applied to _Accounts Receivable_ Invoices to decrease the overall amount of the Invoice.
//
// ### Usage Example
//
// Fetch from the `LIST CreditNotes` endpoint and view a company's credit notes.
type CreditNote struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The credit note's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The credit note's status.
	//
	// - `SUBMITTED` - SUBMITTED
	// - `AUTHORIZED` - AUTHORIZED
	// - `PAID` - PAID
	Status *CreditNoteStatus `json:"status,omitempty"`
	// The credit note's number.
	Number *string `json:"number,omitempty"`
	// The credit note's contact.
	Contact *CreditNoteContact `json:"contact,omitempty"`
	// The company the credit note belongs to.
	Company *CreditNoteCompany `json:"company,omitempty"`
	// The credit note's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The credit note's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The amount of value remaining in the credit note that the customer can use.
	RemainingCredit *float64 `json:"remaining_credit,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax     *bool                               `json:"inclusive_of_tax,omitempty"`
	LineItems          []*CreditNoteLineItem               `json:"line_items,omitempty"`
	TrackingCategories []*CreditNoteTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The credit note's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *CreditNoteCurrency `json:"currency,omitempty"`
	// When the third party's credit note was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's credit note was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Array of `Payment` object IDs
	Payments []*CreditNotePaymentsItem `json:"payments,omitempty"`
	// A list of the Payment Applied to Lines common models related to a given Invoice, Credit Note, or Journal Entry.
	AppliedPayments []*CreditNoteAppliedPaymentsItem `json:"applied_payments,omitempty"`
	// The accounting period that the CreditNote was generated in.
	AccountingPeriod *CreditNoteAccountingPeriod `json:"accounting_period,omitempty"`
	// A list of the CreditNote Applied to Lines common models related to a given Credit Note
	AppliedToLines []*CreditNoteApplyLineForCreditNote `json:"applied_to_lines,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreditNote) UnmarshalJSON(data []byte) error {
	type unmarshaler CreditNote
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreditNote(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNote) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The accounting period that the CreditNote was generated in.
type CreditNoteAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewCreditNoteAccountingPeriodFromString(value string) *CreditNoteAccountingPeriod {
	return &CreditNoteAccountingPeriod{typeName: "string", String: value}
}

func NewCreditNoteAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *CreditNoteAccountingPeriod {
	return &CreditNoteAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (c *CreditNoteAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		c.typeName = "accountingPeriod"
		c.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "accountingPeriod":
		return json.Marshal(c.AccountingPeriod)
	}
}

type CreditNoteAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (c *CreditNoteAccountingPeriod) Accept(visitor CreditNoteAccountingPeriodVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(c.AccountingPeriod)
	}
}

type CreditNoteAppliedPaymentsItem struct {
	typeName        string
	String          string
	PaymentLineItem *PaymentLineItem
}

func NewCreditNoteAppliedPaymentsItemFromString(value string) *CreditNoteAppliedPaymentsItem {
	return &CreditNoteAppliedPaymentsItem{typeName: "string", String: value}
}

func NewCreditNoteAppliedPaymentsItemFromPaymentLineItem(value *PaymentLineItem) *CreditNoteAppliedPaymentsItem {
	return &CreditNoteAppliedPaymentsItem{typeName: "paymentLineItem", PaymentLineItem: value}
}

func (c *CreditNoteAppliedPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		c.typeName = "paymentLineItem"
		c.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteAppliedPaymentsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "paymentLineItem":
		return json.Marshal(c.PaymentLineItem)
	}
}

type CreditNoteAppliedPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (c *CreditNoteAppliedPaymentsItem) Accept(visitor CreditNoteAppliedPaymentsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "paymentLineItem":
		return visitor.VisitPaymentLineItem(c.PaymentLineItem)
	}
}

// # The CreditNoteApplyLine Object
//
// ### Description
//
// The `CreditNoteApplyLine` is attached to the CreditNote model.
//
// ### Usage Example
//
// Fetch from the `GET CreditNote` endpoint and view the invoice's applied to lines.
type CreditNoteApplyLineForCreditNote struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time                               `json:"modified_at,omitempty"`
	Invoice    *CreditNoteApplyLineForCreditNoteInvoice `json:"invoice,omitempty"`
	// Date that the credit note is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty"`
	// The amount of the Credit Note applied to the invoice.
	AppliedAmount *string `json:"applied_amount,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreditNoteApplyLineForCreditNote) UnmarshalJSON(data []byte) error {
	type unmarshaler CreditNoteApplyLineForCreditNote
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreditNoteApplyLineForCreditNote(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteApplyLineForCreditNote) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreditNoteApplyLineForCreditNoteInvoice struct {
	typeName string
	String   string
	Invoice  *Invoice
}

func NewCreditNoteApplyLineForCreditNoteInvoiceFromString(value string) *CreditNoteApplyLineForCreditNoteInvoice {
	return &CreditNoteApplyLineForCreditNoteInvoice{typeName: "string", String: value}
}

func NewCreditNoteApplyLineForCreditNoteInvoiceFromInvoice(value *Invoice) *CreditNoteApplyLineForCreditNoteInvoice {
	return &CreditNoteApplyLineForCreditNoteInvoice{typeName: "invoice", Invoice: value}
}

func (c *CreditNoteApplyLineForCreditNoteInvoice) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueInvoice := new(Invoice)
	if err := json.Unmarshal(data, &valueInvoice); err == nil {
		c.typeName = "invoice"
		c.Invoice = valueInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteApplyLineForCreditNoteInvoice) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "invoice":
		return json.Marshal(c.Invoice)
	}
}

type CreditNoteApplyLineForCreditNoteInvoiceVisitor interface {
	VisitString(string) error
	VisitInvoice(*Invoice) error
}

func (c *CreditNoteApplyLineForCreditNoteInvoice) Accept(visitor CreditNoteApplyLineForCreditNoteInvoiceVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "invoice":
		return visitor.VisitInvoice(c.Invoice)
	}
}

// # The CreditNoteApplyLine Object
//
// ### Description
//
// The `CreditNoteApplyLine` is attached to the CreditNote model.
//
// ### Usage Example
//
// Fetch from the `GET CreditNote` endpoint and view the invoice's applied to lines.
type CreditNoteApplyLineForCreditNoteRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string                                         `json:"remote_id,omitempty"`
	Invoice  *CreditNoteApplyLineForCreditNoteRequestInvoice `json:"invoice,omitempty"`
	// Date that the credit note is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty"`
	// The amount of the Credit Note applied to the invoice.
	AppliedAmount       *string                `json:"applied_amount,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreditNoteApplyLineForCreditNoteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreditNoteApplyLineForCreditNoteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreditNoteApplyLineForCreditNoteRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteApplyLineForCreditNoteRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreditNoteApplyLineForCreditNoteRequestInvoice struct {
	typeName string
	String   string
	Invoice  *Invoice
}

func NewCreditNoteApplyLineForCreditNoteRequestInvoiceFromString(value string) *CreditNoteApplyLineForCreditNoteRequestInvoice {
	return &CreditNoteApplyLineForCreditNoteRequestInvoice{typeName: "string", String: value}
}

func NewCreditNoteApplyLineForCreditNoteRequestInvoiceFromInvoice(value *Invoice) *CreditNoteApplyLineForCreditNoteRequestInvoice {
	return &CreditNoteApplyLineForCreditNoteRequestInvoice{typeName: "invoice", Invoice: value}
}

func (c *CreditNoteApplyLineForCreditNoteRequestInvoice) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueInvoice := new(Invoice)
	if err := json.Unmarshal(data, &valueInvoice); err == nil {
		c.typeName = "invoice"
		c.Invoice = valueInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteApplyLineForCreditNoteRequestInvoice) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "invoice":
		return json.Marshal(c.Invoice)
	}
}

type CreditNoteApplyLineForCreditNoteRequestInvoiceVisitor interface {
	VisitString(string) error
	VisitInvoice(*Invoice) error
}

func (c *CreditNoteApplyLineForCreditNoteRequestInvoice) Accept(visitor CreditNoteApplyLineForCreditNoteRequestInvoiceVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "invoice":
		return visitor.VisitInvoice(c.Invoice)
	}
}

// # The CreditNoteApplyLine Object
//
// ### Description
//
// The `CreditNoteApplyLine` is attached to the CreditNote model.
//
// ### Usage Example
//
// Fetch from the `GET CreditNote` endpoint and view the invoice's applied to lines.
type CreditNoteApplyLineForInvoice struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time                               `json:"modified_at,omitempty"`
	CreditNote *CreditNoteApplyLineForInvoiceCreditNote `json:"credit_note,omitempty"`
	// Date that the credit note is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty"`
	// The amount of the Credit Note applied to the invoice.
	AppliedAmount *string `json:"applied_amount,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreditNoteApplyLineForInvoice) UnmarshalJSON(data []byte) error {
	type unmarshaler CreditNoteApplyLineForInvoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreditNoteApplyLineForInvoice(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteApplyLineForInvoice) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreditNoteApplyLineForInvoiceCreditNote struct {
	typeName   string
	String     string
	CreditNote *CreditNote
}

func NewCreditNoteApplyLineForInvoiceCreditNoteFromString(value string) *CreditNoteApplyLineForInvoiceCreditNote {
	return &CreditNoteApplyLineForInvoiceCreditNote{typeName: "string", String: value}
}

func NewCreditNoteApplyLineForInvoiceCreditNoteFromCreditNote(value *CreditNote) *CreditNoteApplyLineForInvoiceCreditNote {
	return &CreditNoteApplyLineForInvoiceCreditNote{typeName: "creditNote", CreditNote: value}
}

func (c *CreditNoteApplyLineForInvoiceCreditNote) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreditNote := new(CreditNote)
	if err := json.Unmarshal(data, &valueCreditNote); err == nil {
		c.typeName = "creditNote"
		c.CreditNote = valueCreditNote
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteApplyLineForInvoiceCreditNote) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "creditNote":
		return json.Marshal(c.CreditNote)
	}
}

type CreditNoteApplyLineForInvoiceCreditNoteVisitor interface {
	VisitString(string) error
	VisitCreditNote(*CreditNote) error
}

func (c *CreditNoteApplyLineForInvoiceCreditNote) Accept(visitor CreditNoteApplyLineForInvoiceCreditNoteVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "creditNote":
		return visitor.VisitCreditNote(c.CreditNote)
	}
}

// The company the credit note belongs to.
type CreditNoteCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewCreditNoteCompanyFromString(value string) *CreditNoteCompany {
	return &CreditNoteCompany{typeName: "string", String: value}
}

func NewCreditNoteCompanyFromCompanyInfo(value *CompanyInfo) *CreditNoteCompany {
	return &CreditNoteCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (c *CreditNoteCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		c.typeName = "companyInfo"
		c.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteCompany) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "companyInfo":
		return json.Marshal(c.CompanyInfo)
	}
}

type CreditNoteCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (c *CreditNoteCompany) Accept(visitor CreditNoteCompanyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(c.CompanyInfo)
	}
}

// The credit note's contact.
type CreditNoteContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewCreditNoteContactFromString(value string) *CreditNoteContact {
	return &CreditNoteContact{typeName: "string", String: value}
}

func NewCreditNoteContactFromContact(value *Contact) *CreditNoteContact {
	return &CreditNoteContact{typeName: "contact", Contact: value}
}

func (c *CreditNoteContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		c.typeName = "contact"
		c.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteContact) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "contact":
		return json.Marshal(c.Contact)
	}
}

type CreditNoteContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (c *CreditNoteContact) Accept(visitor CreditNoteContactVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "contact":
		return visitor.VisitContact(c.Contact)
	}
}

// The credit note's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type CreditNoteCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewCreditNoteCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *CreditNoteCurrency {
	return &CreditNoteCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewCreditNoteCurrencyFromString(value string) *CreditNoteCurrency {
	return &CreditNoteCurrency{typeName: "string", String: value}
}

func (c *CreditNoteCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		c.typeName = "transactionCurrencyEnum"
		c.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteCurrency) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "transactionCurrencyEnum":
		return json.Marshal(c.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type CreditNoteCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (c *CreditNoteCurrency) Accept(visitor CreditNoteCurrencyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(c.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// # The CreditNoteLineItem Object
//
// ### Description
//
// The `CreditNoteLineItem` object is used to represent a credit note's line items.
//
// ### Usage Example
//
// Fetch from the `GET CreditNote` endpoint and view the credit note's line items.
type CreditNoteLineItem struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time              `json:"modified_at,omitempty"`
	Item       *CreditNoteLineItemItem `json:"item,omitempty"`
	// The credit note line item's name.
	Name *string `json:"name,omitempty"`
	// The description of the item that is owed.
	Description *string `json:"description,omitempty"`
	// The credit note line item's quantity.
	Quantity *string `json:"quantity,omitempty"`
	// The credit note line item's memo.
	Memo *string `json:"memo,omitempty"`
	// The credit note line item's unit price.
	UnitPrice *string `json:"unit_price,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The credit note line item's total.
	TotalLineAmount *string `json:"total_line_amount,omitempty"`
	// The credit note line item's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty"`
	// The credit note line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty"`
	// The credit note line item's account.
	Account *string `json:"account,omitempty"`
	// The company the credit note belongs to.
	Company *CreditNoteLineItemCompany `json:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreditNoteLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CreditNoteLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreditNoteLineItem(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteLineItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The company the credit note belongs to.
type CreditNoteLineItemCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewCreditNoteLineItemCompanyFromString(value string) *CreditNoteLineItemCompany {
	return &CreditNoteLineItemCompany{typeName: "string", String: value}
}

func NewCreditNoteLineItemCompanyFromCompanyInfo(value *CompanyInfo) *CreditNoteLineItemCompany {
	return &CreditNoteLineItemCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (c *CreditNoteLineItemCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		c.typeName = "companyInfo"
		c.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteLineItemCompany) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "companyInfo":
		return json.Marshal(c.CompanyInfo)
	}
}

type CreditNoteLineItemCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (c *CreditNoteLineItemCompany) Accept(visitor CreditNoteLineItemCompanyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(c.CompanyInfo)
	}
}

type CreditNoteLineItemItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewCreditNoteLineItemItemFromString(value string) *CreditNoteLineItemItem {
	return &CreditNoteLineItemItem{typeName: "string", String: value}
}

func NewCreditNoteLineItemItemFromItem(value *Item) *CreditNoteLineItemItem {
	return &CreditNoteLineItemItem{typeName: "item", Item: value}
}

func (c *CreditNoteLineItemItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		c.typeName = "item"
		c.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteLineItemItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "item":
		return json.Marshal(c.Item)
	}
}

type CreditNoteLineItemItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (c *CreditNoteLineItemItem) Accept(visitor CreditNoteLineItemItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "item":
		return visitor.VisitItem(c.Item)
	}
}

// # The CreditNoteLineItem Object
//
// ### Description
//
// The `CreditNoteLineItem` object is used to represent a credit note's line items.
//
// ### Usage Example
//
// Fetch from the `GET CreditNote` endpoint and view the credit note's line items.
type CreditNoteLineItemRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string                        `json:"remote_id,omitempty"`
	Item     *CreditNoteLineItemRequestItem `json:"item,omitempty"`
	// The credit note line item's name.
	Name *string `json:"name,omitempty"`
	// The description of the item that is owed.
	Description *string `json:"description,omitempty"`
	// The credit note line item's quantity.
	Quantity *string `json:"quantity,omitempty"`
	// The credit note line item's memo.
	Memo *string `json:"memo,omitempty"`
	// The credit note line item's unit price.
	UnitPrice *string `json:"unit_price,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The credit note line item's total.
	TotalLineAmount *string `json:"total_line_amount,omitempty"`
	// The credit note line item's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty"`
	// The credit note line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty"`
	// The credit note line item's account.
	Account *string `json:"account,omitempty"`
	// The company the credit note belongs to.
	Company             *CreditNoteLineItemRequestCompany `json:"company,omitempty"`
	IntegrationParams   map[string]interface{}            `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}            `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreditNoteLineItemRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreditNoteLineItemRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreditNoteLineItemRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteLineItemRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The company the credit note belongs to.
type CreditNoteLineItemRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewCreditNoteLineItemRequestCompanyFromString(value string) *CreditNoteLineItemRequestCompany {
	return &CreditNoteLineItemRequestCompany{typeName: "string", String: value}
}

func NewCreditNoteLineItemRequestCompanyFromCompanyInfo(value *CompanyInfo) *CreditNoteLineItemRequestCompany {
	return &CreditNoteLineItemRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (c *CreditNoteLineItemRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		c.typeName = "companyInfo"
		c.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteLineItemRequestCompany) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "companyInfo":
		return json.Marshal(c.CompanyInfo)
	}
}

type CreditNoteLineItemRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (c *CreditNoteLineItemRequestCompany) Accept(visitor CreditNoteLineItemRequestCompanyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(c.CompanyInfo)
	}
}

type CreditNoteLineItemRequestItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewCreditNoteLineItemRequestItemFromString(value string) *CreditNoteLineItemRequestItem {
	return &CreditNoteLineItemRequestItem{typeName: "string", String: value}
}

func NewCreditNoteLineItemRequestItemFromItem(value *Item) *CreditNoteLineItemRequestItem {
	return &CreditNoteLineItemRequestItem{typeName: "item", Item: value}
}

func (c *CreditNoteLineItemRequestItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		c.typeName = "item"
		c.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteLineItemRequestItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "item":
		return json.Marshal(c.Item)
	}
}

type CreditNoteLineItemRequestItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (c *CreditNoteLineItemRequestItem) Accept(visitor CreditNoteLineItemRequestItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "item":
		return visitor.VisitItem(c.Item)
	}
}

type CreditNotePaymentsItem struct {
	typeName string
	String   string
	Payment  *Payment
}

func NewCreditNotePaymentsItemFromString(value string) *CreditNotePaymentsItem {
	return &CreditNotePaymentsItem{typeName: "string", String: value}
}

func NewCreditNotePaymentsItemFromPayment(value *Payment) *CreditNotePaymentsItem {
	return &CreditNotePaymentsItem{typeName: "payment", Payment: value}
}

func (c *CreditNotePaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		c.typeName = "payment"
		c.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNotePaymentsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "payment":
		return json.Marshal(c.Payment)
	}
}

type CreditNotePaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (c *CreditNotePaymentsItem) Accept(visitor CreditNotePaymentsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "payment":
		return visitor.VisitPayment(c.Payment)
	}
}

// # The CreditNote Object
//
// ### Description
//
// A `CreditNote` is transaction issued to a customer, indicating a reduction or cancellation of the amount owed by the customer. It is most generally used as an adjustment note used to rectify errors, returns, or overpayments related to a sales transaction. A `CreditNote` can be applied to _Accounts Receivable_ Invoices to decrease the overall amount of the Invoice.
//
// ### Usage Example
//
// Fetch from the `LIST CreditNotes` endpoint and view a company's credit notes.
type CreditNoteRequest struct {
	// The credit note's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The credit note's status.
	//
	// - `SUBMITTED` - SUBMITTED
	// - `AUTHORIZED` - AUTHORIZED
	// - `PAID` - PAID
	Status *CreditNoteRequestStatus `json:"status,omitempty"`
	// The credit note's number.
	Number *string `json:"number,omitempty"`
	// The credit note's contact.
	Contact *CreditNoteRequestContact `json:"contact,omitempty"`
	// The company the credit note belongs to.
	Company *CreditNoteRequestCompany `json:"company,omitempty"`
	// The credit note's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The credit note's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The amount of value remaining in the credit note that the customer can use.
	RemainingCredit *float64 `json:"remaining_credit,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax     *bool                                      `json:"inclusive_of_tax,omitempty"`
	LineItems          []*CreditNoteRequestLineItemsItem          `json:"line_items,omitempty"`
	TrackingCategories []*CreditNoteRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The credit note's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *CreditNoteRequestCurrency `json:"currency,omitempty"`
	// Array of `Payment` object IDs
	Payments []*CreditNoteRequestPaymentsItem `json:"payments,omitempty"`
	// A list of the Payment Applied to Lines common models related to a given Invoice, Credit Note, or Journal Entry.
	AppliedPayments []*CreditNoteRequestAppliedPaymentsItem `json:"applied_payments,omitempty"`
	// The accounting period that the CreditNote was generated in.
	AccountingPeriod *CreditNoteRequestAccountingPeriod `json:"accounting_period,omitempty"`
	// A list of the CreditNote Applied to Lines common models related to a given Credit Note
	AppliedToLines      []*CreditNoteApplyLineForCreditNoteRequest `json:"applied_to_lines,omitempty"`
	IntegrationParams   map[string]interface{}                     `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}                     `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreditNoteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreditNoteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreditNoteRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The accounting period that the CreditNote was generated in.
type CreditNoteRequestAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewCreditNoteRequestAccountingPeriodFromString(value string) *CreditNoteRequestAccountingPeriod {
	return &CreditNoteRequestAccountingPeriod{typeName: "string", String: value}
}

func NewCreditNoteRequestAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *CreditNoteRequestAccountingPeriod {
	return &CreditNoteRequestAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (c *CreditNoteRequestAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		c.typeName = "accountingPeriod"
		c.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "accountingPeriod":
		return json.Marshal(c.AccountingPeriod)
	}
}

type CreditNoteRequestAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (c *CreditNoteRequestAccountingPeriod) Accept(visitor CreditNoteRequestAccountingPeriodVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(c.AccountingPeriod)
	}
}

type CreditNoteRequestAppliedPaymentsItem struct {
	typeName        string
	String          string
	PaymentLineItem *PaymentLineItem
}

func NewCreditNoteRequestAppliedPaymentsItemFromString(value string) *CreditNoteRequestAppliedPaymentsItem {
	return &CreditNoteRequestAppliedPaymentsItem{typeName: "string", String: value}
}

func NewCreditNoteRequestAppliedPaymentsItemFromPaymentLineItem(value *PaymentLineItem) *CreditNoteRequestAppliedPaymentsItem {
	return &CreditNoteRequestAppliedPaymentsItem{typeName: "paymentLineItem", PaymentLineItem: value}
}

func (c *CreditNoteRequestAppliedPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		c.typeName = "paymentLineItem"
		c.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestAppliedPaymentsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "paymentLineItem":
		return json.Marshal(c.PaymentLineItem)
	}
}

type CreditNoteRequestAppliedPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (c *CreditNoteRequestAppliedPaymentsItem) Accept(visitor CreditNoteRequestAppliedPaymentsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "paymentLineItem":
		return visitor.VisitPaymentLineItem(c.PaymentLineItem)
	}
}

// The company the credit note belongs to.
type CreditNoteRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewCreditNoteRequestCompanyFromString(value string) *CreditNoteRequestCompany {
	return &CreditNoteRequestCompany{typeName: "string", String: value}
}

func NewCreditNoteRequestCompanyFromCompanyInfo(value *CompanyInfo) *CreditNoteRequestCompany {
	return &CreditNoteRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (c *CreditNoteRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		c.typeName = "companyInfo"
		c.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestCompany) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "companyInfo":
		return json.Marshal(c.CompanyInfo)
	}
}

type CreditNoteRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (c *CreditNoteRequestCompany) Accept(visitor CreditNoteRequestCompanyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(c.CompanyInfo)
	}
}

// The credit note's contact.
type CreditNoteRequestContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewCreditNoteRequestContactFromString(value string) *CreditNoteRequestContact {
	return &CreditNoteRequestContact{typeName: "string", String: value}
}

func NewCreditNoteRequestContactFromContact(value *Contact) *CreditNoteRequestContact {
	return &CreditNoteRequestContact{typeName: "contact", Contact: value}
}

func (c *CreditNoteRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		c.typeName = "contact"
		c.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestContact) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "contact":
		return json.Marshal(c.Contact)
	}
}

type CreditNoteRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (c *CreditNoteRequestContact) Accept(visitor CreditNoteRequestContactVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "contact":
		return visitor.VisitContact(c.Contact)
	}
}

// The credit note's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type CreditNoteRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewCreditNoteRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *CreditNoteRequestCurrency {
	return &CreditNoteRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewCreditNoteRequestCurrencyFromString(value string) *CreditNoteRequestCurrency {
	return &CreditNoteRequestCurrency{typeName: "string", String: value}
}

func (c *CreditNoteRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		c.typeName = "transactionCurrencyEnum"
		c.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestCurrency) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "transactionCurrencyEnum":
		return json.Marshal(c.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type CreditNoteRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (c *CreditNoteRequestCurrency) Accept(visitor CreditNoteRequestCurrencyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(c.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

type CreditNoteRequestLineItemsItem struct {
	typeName                  string
	String                    string
	CreditNoteLineItemRequest *CreditNoteLineItemRequest
}

func NewCreditNoteRequestLineItemsItemFromString(value string) *CreditNoteRequestLineItemsItem {
	return &CreditNoteRequestLineItemsItem{typeName: "string", String: value}
}

func NewCreditNoteRequestLineItemsItemFromCreditNoteLineItemRequest(value *CreditNoteLineItemRequest) *CreditNoteRequestLineItemsItem {
	return &CreditNoteRequestLineItemsItem{typeName: "creditNoteLineItemRequest", CreditNoteLineItemRequest: value}
}

func (c *CreditNoteRequestLineItemsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreditNoteLineItemRequest := new(CreditNoteLineItemRequest)
	if err := json.Unmarshal(data, &valueCreditNoteLineItemRequest); err == nil {
		c.typeName = "creditNoteLineItemRequest"
		c.CreditNoteLineItemRequest = valueCreditNoteLineItemRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestLineItemsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "creditNoteLineItemRequest":
		return json.Marshal(c.CreditNoteLineItemRequest)
	}
}

type CreditNoteRequestLineItemsItemVisitor interface {
	VisitString(string) error
	VisitCreditNoteLineItemRequest(*CreditNoteLineItemRequest) error
}

func (c *CreditNoteRequestLineItemsItem) Accept(visitor CreditNoteRequestLineItemsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "creditNoteLineItemRequest":
		return visitor.VisitCreditNoteLineItemRequest(c.CreditNoteLineItemRequest)
	}
}

type CreditNoteRequestPaymentsItem struct {
	typeName string
	String   string
	Payment  *Payment
}

func NewCreditNoteRequestPaymentsItemFromString(value string) *CreditNoteRequestPaymentsItem {
	return &CreditNoteRequestPaymentsItem{typeName: "string", String: value}
}

func NewCreditNoteRequestPaymentsItemFromPayment(value *Payment) *CreditNoteRequestPaymentsItem {
	return &CreditNoteRequestPaymentsItem{typeName: "payment", Payment: value}
}

func (c *CreditNoteRequestPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		c.typeName = "payment"
		c.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestPaymentsItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "payment":
		return json.Marshal(c.Payment)
	}
}

type CreditNoteRequestPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (c *CreditNoteRequestPaymentsItem) Accept(visitor CreditNoteRequestPaymentsItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "payment":
		return visitor.VisitPayment(c.Payment)
	}
}

// The credit note's status.
//
// - `SUBMITTED` - SUBMITTED
// - `AUTHORIZED` - AUTHORIZED
// - `PAID` - PAID
type CreditNoteRequestStatus struct {
	typeName             string
	CreditNoteStatusEnum CreditNoteStatusEnum
	String               string
}

func NewCreditNoteRequestStatusFromCreditNoteStatusEnum(value CreditNoteStatusEnum) *CreditNoteRequestStatus {
	return &CreditNoteRequestStatus{typeName: "creditNoteStatusEnum", CreditNoteStatusEnum: value}
}

func NewCreditNoteRequestStatusFromString(value string) *CreditNoteRequestStatus {
	return &CreditNoteRequestStatus{typeName: "string", String: value}
}

func (c *CreditNoteRequestStatus) UnmarshalJSON(data []byte) error {
	var valueCreditNoteStatusEnum CreditNoteStatusEnum
	if err := json.Unmarshal(data, &valueCreditNoteStatusEnum); err == nil {
		c.typeName = "creditNoteStatusEnum"
		c.CreditNoteStatusEnum = valueCreditNoteStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestStatus) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "creditNoteStatusEnum":
		return json.Marshal(c.CreditNoteStatusEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type CreditNoteRequestStatusVisitor interface {
	VisitCreditNoteStatusEnum(CreditNoteStatusEnum) error
	VisitString(string) error
}

func (c *CreditNoteRequestStatus) Accept(visitor CreditNoteRequestStatusVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "creditNoteStatusEnum":
		return visitor.VisitCreditNoteStatusEnum(c.CreditNoteStatusEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

type CreditNoteRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewCreditNoteRequestTrackingCategoriesItemFromString(value string) *CreditNoteRequestTrackingCategoriesItem {
	return &CreditNoteRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewCreditNoteRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *CreditNoteRequestTrackingCategoriesItem {
	return &CreditNoteRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (c *CreditNoteRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		c.typeName = "trackingCategory"
		c.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "trackingCategory":
		return json.Marshal(c.TrackingCategory)
	}
}

type CreditNoteRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (c *CreditNoteRequestTrackingCategoriesItem) Accept(visitor CreditNoteRequestTrackingCategoriesItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(c.TrackingCategory)
	}
}

type CreditNoteResponse struct {
	Model    *CreditNote                 `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreditNoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreditNoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreditNoteResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The credit note's status.
//
// - `SUBMITTED` - SUBMITTED
// - `AUTHORIZED` - AUTHORIZED
// - `PAID` - PAID
type CreditNoteStatus struct {
	typeName             string
	CreditNoteStatusEnum CreditNoteStatusEnum
	String               string
}

func NewCreditNoteStatusFromCreditNoteStatusEnum(value CreditNoteStatusEnum) *CreditNoteStatus {
	return &CreditNoteStatus{typeName: "creditNoteStatusEnum", CreditNoteStatusEnum: value}
}

func NewCreditNoteStatusFromString(value string) *CreditNoteStatus {
	return &CreditNoteStatus{typeName: "string", String: value}
}

func (c *CreditNoteStatus) UnmarshalJSON(data []byte) error {
	var valueCreditNoteStatusEnum CreditNoteStatusEnum
	if err := json.Unmarshal(data, &valueCreditNoteStatusEnum); err == nil {
		c.typeName = "creditNoteStatusEnum"
		c.CreditNoteStatusEnum = valueCreditNoteStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteStatus) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "creditNoteStatusEnum":
		return json.Marshal(c.CreditNoteStatusEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type CreditNoteStatusVisitor interface {
	VisitCreditNoteStatusEnum(CreditNoteStatusEnum) error
	VisitString(string) error
}

func (c *CreditNoteStatus) Accept(visitor CreditNoteStatusVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "creditNoteStatusEnum":
		return visitor.VisitCreditNoteStatusEnum(c.CreditNoteStatusEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// - `SUBMITTED` - SUBMITTED
// - `AUTHORIZED` - AUTHORIZED
// - `PAID` - PAID
type CreditNoteStatusEnum string

const (
	CreditNoteStatusEnumSubmitted  CreditNoteStatusEnum = "SUBMITTED"
	CreditNoteStatusEnumAuthorized CreditNoteStatusEnum = "AUTHORIZED"
	CreditNoteStatusEnumPaid       CreditNoteStatusEnum = "PAID"
)

func NewCreditNoteStatusEnumFromString(s string) (CreditNoteStatusEnum, error) {
	switch s {
	case "SUBMITTED":
		return CreditNoteStatusEnumSubmitted, nil
	case "AUTHORIZED":
		return CreditNoteStatusEnumAuthorized, nil
	case "PAID":
		return CreditNoteStatusEnumPaid, nil
	}
	var t CreditNoteStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreditNoteStatusEnum) Ptr() *CreditNoteStatusEnum {
	return &c
}

type CreditNoteTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewCreditNoteTrackingCategoriesItemFromString(value string) *CreditNoteTrackingCategoriesItem {
	return &CreditNoteTrackingCategoriesItem{typeName: "string", String: value}
}

func NewCreditNoteTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *CreditNoteTrackingCategoriesItem {
	return &CreditNoteTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (c *CreditNoteTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		c.typeName = "trackingCategory"
		c.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "trackingCategory":
		return json.Marshal(c.TrackingCategory)
	}
}

type CreditNoteTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (c *CreditNoteTrackingCategoriesItem) Accept(visitor CreditNoteTrackingCategoriesItemVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(c.TrackingCategory)
	}
}

// - `CREDIT` - CREDIT
// - `DEBIT` - DEBIT
type CreditOrDebitEnum string

const (
	CreditOrDebitEnumCredit CreditOrDebitEnum = "CREDIT"
	CreditOrDebitEnumDebit  CreditOrDebitEnum = "DEBIT"
)

func NewCreditOrDebitEnumFromString(s string) (CreditOrDebitEnum, error) {
	switch s {
	case "CREDIT":
		return CreditOrDebitEnumCredit, nil
	case "DEBIT":
		return CreditOrDebitEnumDebit, nil
	}
	var t CreditOrDebitEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreditOrDebitEnum) Ptr() *CreditOrDebitEnum {
	return &c
}

// # The DataPassthrough Object
//
// ### Description
//
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
//
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method,omitempty"`
	// The path of the request in the third party's platform.
	Path string `json:"path"`
	// An optional override of the third party's base url for the request.
	BaseUrlOverride *string `json:"base_url_override,omitempty"`
	// The data with the request. You must include a `request_format` parameter matching the data's format
	Data *string `json:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]interface{} `json:"headers,omitempty"`
	RequestFormat *RequestFormatEnum     `json:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DataPassthroughRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DataPassthroughRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataPassthroughRequest(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataPassthroughRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModeLog struct {
	LogId         string                `json:"log_id"`
	DashboardView string                `json:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DebugModeLog) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModeLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModeLog(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModeLog) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModelLogSummary struct {
	Url        string `json:"url"`
	Method     string `json:"method"`
	StatusCode int    `json:"status_code"`

	_rawJSON json.RawMessage
}

func (d *DebugModelLogSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModelLogSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModelLogSummary(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModelLogSummary) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The Employee Object
//
// ### Description
//
// An `Employee` is an individual who works for the company of the linked account. The `Employee` model contains both contractors and full time employees.
//
// - An `Employee` is a contractor if `is_contractor` property is `True`
// - An `Employee` is a full time employee if `is_contractor` property is `False`
//
// ### Usage Example
//
// Fetch from the `LIST Employees` endpoint and view a company's employees.
type Employee struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty"`
	// `True` if the employee is a contractor, `False` if not.
	IsContractor *bool `json:"is_contractor,omitempty"`
	// The employee's internal identification number.
	EmployeeNumber *string `json:"employee_number,omitempty"`
	// The employee's email address.
	EmailAddress *string `json:"email_address,omitempty"`
	// The subsidiary that the employee belongs to.
	Company *EmployeeCompany `json:"company,omitempty"`
	// The employee's status in the accounting system.
	//
	// - `ACTIVE` - ACTIVE
	// - `INACTIVE` - INACTIVE
	Status *EmployeeStatus `json:"status,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Employee) UnmarshalJSON(data []byte) error {
	type unmarshaler Employee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Employee(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Employee) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The subsidiary that the employee belongs to.
type EmployeeCompany struct {
	typeName string
	String   string
	Unknown  interface{}
}

func NewEmployeeCompanyFromString(value string) *EmployeeCompany {
	return &EmployeeCompany{typeName: "string", String: value}
}

func NewEmployeeCompanyFromUnknown(value interface{}) *EmployeeCompany {
	return &EmployeeCompany{typeName: "unknown", Unknown: value}
}

func (e *EmployeeCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		e.typeName = "unknown"
		e.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeCompany) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "unknown":
		return json.Marshal(e.Unknown)
	}
}

type EmployeeCompanyVisitor interface {
	VisitString(string) error
	VisitUnknown(interface{}) error
}

func (e *EmployeeCompany) Accept(visitor EmployeeCompanyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "unknown":
		return visitor.VisitUnknown(e.Unknown)
	}
}

// The employee's status in the accounting system.
//
// - `ACTIVE` - ACTIVE
// - `INACTIVE` - INACTIVE
type EmployeeStatus struct {
	typeName      string
	Status895Enum Status895Enum
	String        string
}

func NewEmployeeStatusFromStatus895Enum(value Status895Enum) *EmployeeStatus {
	return &EmployeeStatus{typeName: "status895Enum", Status895Enum: value}
}

func NewEmployeeStatusFromString(value string) *EmployeeStatus {
	return &EmployeeStatus{typeName: "string", String: value}
}

func (e *EmployeeStatus) UnmarshalJSON(data []byte) error {
	var valueStatus895Enum Status895Enum
	if err := json.Unmarshal(data, &valueStatus895Enum); err == nil {
		e.typeName = "status895Enum"
		e.Status895Enum = valueStatus895Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "status895Enum":
		return json.Marshal(e.Status895Enum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EmployeeStatusVisitor interface {
	VisitStatus895Enum(Status895Enum) error
	VisitString(string) error
}

func (e *EmployeeStatus) Accept(visitor EmployeeStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "status895Enum":
		return visitor.VisitStatus895Enum(e.Status895Enum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// - `READ` - READ
// - `WRITE` - WRITE
type EnabledActionsEnum string

const (
	EnabledActionsEnumRead  EnabledActionsEnum = "READ"
	EnabledActionsEnumWrite EnabledActionsEnum = "WRITE"
)

func NewEnabledActionsEnumFromString(s string) (EnabledActionsEnum, error) {
	switch s {
	case "READ":
		return EnabledActionsEnumRead, nil
	case "WRITE":
		return EnabledActionsEnumWrite, nil
	}
	var t EnabledActionsEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnabledActionsEnum) Ptr() *EnabledActionsEnum {
	return &e
}

// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum string

const (
	EncodingEnumRaw        EncodingEnum = "RAW"
	EncodingEnumBase64     EncodingEnum = "BASE64"
	EncodingEnumGzipBase64 EncodingEnum = "GZIP_BASE64"
)

func NewEncodingEnumFromString(s string) (EncodingEnum, error) {
	switch s {
	case "RAW":
		return EncodingEnumRaw, nil
	case "BASE64":
		return EncodingEnumBase64, nil
	case "GZIP_BASE64":
		return EncodingEnumGzipBase64, nil
	}
	var t EncodingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncodingEnum) Ptr() *EncodingEnum {
	return &e
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`

	_rawJSON json.RawMessage
}

func (e *ErrorValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorValidationProblem(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorValidationProblem) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE` - DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE
// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
// - `MUTED_ISSUE` - MUTED_ISSUE
// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
// - `END_USER_CREDENTIALS_ACCESSED` - END_USER_CREDENTIALS_ACCESSED
type EventTypeEnum string

const (
	EventTypeEnumCreatedRemoteProductionApiKey              EventTypeEnum = "CREATED_REMOTE_PRODUCTION_API_KEY"
	EventTypeEnumDeletedRemoteProductionApiKey              EventTypeEnum = "DELETED_REMOTE_PRODUCTION_API_KEY"
	EventTypeEnumCreatedTestApiKey                          EventTypeEnum = "CREATED_TEST_API_KEY"
	EventTypeEnumDeletedTestApiKey                          EventTypeEnum = "DELETED_TEST_API_KEY"
	EventTypeEnumRegeneratedProductionApiKey                EventTypeEnum = "REGENERATED_PRODUCTION_API_KEY"
	EventTypeEnumInvitedUser                                EventTypeEnum = "INVITED_USER"
	EventTypeEnumTwoFactorAuthEnabled                       EventTypeEnum = "TWO_FACTOR_AUTH_ENABLED"
	EventTypeEnumTwoFactorAuthDisabled                      EventTypeEnum = "TWO_FACTOR_AUTH_DISABLED"
	EventTypeEnumDeletedLinkedAccount                       EventTypeEnum = "DELETED_LINKED_ACCOUNT"
	EventTypeEnumCreatedDestination                         EventTypeEnum = "CREATED_DESTINATION"
	EventTypeEnumDeletedDestination                         EventTypeEnum = "DELETED_DESTINATION"
	EventTypeEnumChangedDestination                         EventTypeEnum = "CHANGED_DESTINATION"
	EventTypeEnumChangedScopes                              EventTypeEnum = "CHANGED_SCOPES"
	EventTypeEnumChangedPersonalInformation                 EventTypeEnum = "CHANGED_PERSONAL_INFORMATION"
	EventTypeEnumChangedOrganizationSettings                EventTypeEnum = "CHANGED_ORGANIZATION_SETTINGS"
	EventTypeEnumEnabledIntegration                         EventTypeEnum = "ENABLED_INTEGRATION"
	EventTypeEnumDisabledIntegration                        EventTypeEnum = "DISABLED_INTEGRATION"
	EventTypeEnumEnabledCategory                            EventTypeEnum = "ENABLED_CATEGORY"
	EventTypeEnumDisabledCategory                           EventTypeEnum = "DISABLED_CATEGORY"
	EventTypeEnumChangedPassword                            EventTypeEnum = "CHANGED_PASSWORD"
	EventTypeEnumResetPassword                              EventTypeEnum = "RESET_PASSWORD"
	EventTypeEnumEnabledRedactUnmappedDataForOrganization   EventTypeEnum = "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount  EventTypeEnum = "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	EventTypeEnumDisabledRedactUnmappedDataForOrganization  EventTypeEnum = "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount EventTypeEnum = "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	EventTypeEnumCreatedIntegrationWideFieldMapping         EventTypeEnum = "CREATED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumCreatedLinkedAccountFieldMapping           EventTypeEnum = "CREATED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumChangedIntegrationWideFieldMapping         EventTypeEnum = "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumChangedLinkedAccountFieldMapping           EventTypeEnum = "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumDeletedIntegrationWideFieldMapping         EventTypeEnum = "DELETED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumDeletedLinkedAccountFieldMapping           EventTypeEnum = "DELETED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumCreatedLinkedAccountCommonModelOverride    EventTypeEnum = "CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE"
	EventTypeEnumChangedLinkedAccountCommonModelOverride    EventTypeEnum = "CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE"
	EventTypeEnumDeletedLinkedAccountCommonModelOverride    EventTypeEnum = "DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE"
	EventTypeEnumForcedLinkedAccountResync                  EventTypeEnum = "FORCED_LINKED_ACCOUNT_RESYNC"
	EventTypeEnumMutedIssue                                 EventTypeEnum = "MUTED_ISSUE"
	EventTypeEnumGeneratedMagicLink                         EventTypeEnum = "GENERATED_MAGIC_LINK"
	EventTypeEnumEnabledMergeWebhook                        EventTypeEnum = "ENABLED_MERGE_WEBHOOK"
	EventTypeEnumDisabledMergeWebhook                       EventTypeEnum = "DISABLED_MERGE_WEBHOOK"
	EventTypeEnumMergeWebhookTargetChanged                  EventTypeEnum = "MERGE_WEBHOOK_TARGET_CHANGED"
	EventTypeEnumEndUserCredentialsAccessed                 EventTypeEnum = "END_USER_CREDENTIALS_ACCESSED"
)

func NewEventTypeEnumFromString(s string) (EventTypeEnum, error) {
	switch s {
	case "CREATED_REMOTE_PRODUCTION_API_KEY":
		return EventTypeEnumCreatedRemoteProductionApiKey, nil
	case "DELETED_REMOTE_PRODUCTION_API_KEY":
		return EventTypeEnumDeletedRemoteProductionApiKey, nil
	case "CREATED_TEST_API_KEY":
		return EventTypeEnumCreatedTestApiKey, nil
	case "DELETED_TEST_API_KEY":
		return EventTypeEnumDeletedTestApiKey, nil
	case "REGENERATED_PRODUCTION_API_KEY":
		return EventTypeEnumRegeneratedProductionApiKey, nil
	case "INVITED_USER":
		return EventTypeEnumInvitedUser, nil
	case "TWO_FACTOR_AUTH_ENABLED":
		return EventTypeEnumTwoFactorAuthEnabled, nil
	case "TWO_FACTOR_AUTH_DISABLED":
		return EventTypeEnumTwoFactorAuthDisabled, nil
	case "DELETED_LINKED_ACCOUNT":
		return EventTypeEnumDeletedLinkedAccount, nil
	case "CREATED_DESTINATION":
		return EventTypeEnumCreatedDestination, nil
	case "DELETED_DESTINATION":
		return EventTypeEnumDeletedDestination, nil
	case "CHANGED_DESTINATION":
		return EventTypeEnumChangedDestination, nil
	case "CHANGED_SCOPES":
		return EventTypeEnumChangedScopes, nil
	case "CHANGED_PERSONAL_INFORMATION":
		return EventTypeEnumChangedPersonalInformation, nil
	case "CHANGED_ORGANIZATION_SETTINGS":
		return EventTypeEnumChangedOrganizationSettings, nil
	case "ENABLED_INTEGRATION":
		return EventTypeEnumEnabledIntegration, nil
	case "DISABLED_INTEGRATION":
		return EventTypeEnumDisabledIntegration, nil
	case "ENABLED_CATEGORY":
		return EventTypeEnumEnabledCategory, nil
	case "DISABLED_CATEGORY":
		return EventTypeEnumDisabledCategory, nil
	case "CHANGED_PASSWORD":
		return EventTypeEnumChangedPassword, nil
	case "RESET_PASSWORD":
		return EventTypeEnumResetPassword, nil
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		return EventTypeEnumEnabledRedactUnmappedDataForOrganization, nil
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		return EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount, nil
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		return EventTypeEnumDisabledRedactUnmappedDataForOrganization, nil
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		return EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount, nil
	case "CREATED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumCreatedIntegrationWideFieldMapping, nil
	case "CREATED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumCreatedLinkedAccountFieldMapping, nil
	case "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumChangedIntegrationWideFieldMapping, nil
	case "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumChangedLinkedAccountFieldMapping, nil
	case "DELETED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumDeletedIntegrationWideFieldMapping, nil
	case "DELETED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumDeletedLinkedAccountFieldMapping, nil
	case "CREATED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE":
		return EventTypeEnumCreatedLinkedAccountCommonModelOverride, nil
	case "CHANGED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE":
		return EventTypeEnumChangedLinkedAccountCommonModelOverride, nil
	case "DELETED_LINKED_ACCOUNT_COMMON_MODEL_OVERRIDE":
		return EventTypeEnumDeletedLinkedAccountCommonModelOverride, nil
	case "FORCED_LINKED_ACCOUNT_RESYNC":
		return EventTypeEnumForcedLinkedAccountResync, nil
	case "MUTED_ISSUE":
		return EventTypeEnumMutedIssue, nil
	case "GENERATED_MAGIC_LINK":
		return EventTypeEnumGeneratedMagicLink, nil
	case "ENABLED_MERGE_WEBHOOK":
		return EventTypeEnumEnabledMergeWebhook, nil
	case "DISABLED_MERGE_WEBHOOK":
		return EventTypeEnumDisabledMergeWebhook, nil
	case "MERGE_WEBHOOK_TARGET_CHANGED":
		return EventTypeEnumMergeWebhookTargetChanged, nil
	case "END_USER_CREDENTIALS_ACCESSED":
		return EventTypeEnumEndUserCredentialsAccessed, nil
	}
	var t EventTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventTypeEnum) Ptr() *EventTypeEnum {
	return &e
}

// # The Expense Object
//
// ### Description
//
// The `Expense` object is used to represent a direct purchase by a business, typically made with a check, credit card, or cash. Each `Expense` object is dedicated to a grouping of expenses, with each expense recorded in the lines object.
//
// The `Expense` object is used also used to represent refunds to direct purchases. Refunds can be distinguished from purchases by the amount sign of the records. Expense objects with a negative amount are purchases and `Expense` objects with a positive amount are refunds to those purchases.
//
// ### Usage Example
//
// Fetch from the `GET Expense` endpoint and view a company's expense.
type Expense struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// When the transaction occurred.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// When the expense was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The expense's payment account.
	Account *ExpenseAccount `json:"account,omitempty"`
	// The expense's contact.
	Contact *ExpenseContact `json:"contact,omitempty"`
	// The expense's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The expense's total amount before tax.
	SubTotal *float64 `json:"sub_total,omitempty"`
	// The expense's total tax amount.
	TotalTaxAmount *float64 `json:"total_tax_amount,omitempty"`
	// The expense's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *ExpenseCurrency `json:"currency,omitempty"`
	// The expense's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty"`
	// The company the expense belongs to.
	Company *ExpenseCompany `json:"company,omitempty"`
	// The employee this overall transaction relates to.
	Employee *ExpenseEmployee `json:"employee,omitempty"`
	// The expense's private note.
	Memo               *string                          `json:"memo,omitempty"`
	Lines              []*ExpenseLine                   `json:"lines,omitempty"`
	TrackingCategories []*ExpenseTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// The accounting period that the Expense was generated in.
	AccountingPeriod *ExpenseAccountingPeriod `json:"accounting_period,omitempty"`
	FieldMappings    map[string]interface{}   `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData            `json:"remote_data,omitempty"`
	RemoteFields     []*RemoteField           `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Expense) UnmarshalJSON(data []byte) error {
	type unmarshaler Expense
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Expense(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Expense) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The expense's payment account.
type ExpenseAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewExpenseAccountFromString(value string) *ExpenseAccount {
	return &ExpenseAccount{typeName: "string", String: value}
}

func NewExpenseAccountFromAccount(value *Account) *ExpenseAccount {
	return &ExpenseAccount{typeName: "account", Account: value}
}

func (e *ExpenseAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		e.typeName = "account"
		e.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseAccount) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "account":
		return json.Marshal(e.Account)
	}
}

type ExpenseAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (e *ExpenseAccount) Accept(visitor ExpenseAccountVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "account":
		return visitor.VisitAccount(e.Account)
	}
}

// The accounting period that the Expense was generated in.
type ExpenseAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewExpenseAccountingPeriodFromString(value string) *ExpenseAccountingPeriod {
	return &ExpenseAccountingPeriod{typeName: "string", String: value}
}

func NewExpenseAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *ExpenseAccountingPeriod {
	return &ExpenseAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (e *ExpenseAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		e.typeName = "accountingPeriod"
		e.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "accountingPeriod":
		return json.Marshal(e.AccountingPeriod)
	}
}

type ExpenseAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (e *ExpenseAccountingPeriod) Accept(visitor ExpenseAccountingPeriodVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(e.AccountingPeriod)
	}
}

// The company the expense belongs to.
type ExpenseCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewExpenseCompanyFromString(value string) *ExpenseCompany {
	return &ExpenseCompany{typeName: "string", String: value}
}

func NewExpenseCompanyFromCompanyInfo(value *CompanyInfo) *ExpenseCompany {
	return &ExpenseCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (e *ExpenseCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		e.typeName = "companyInfo"
		e.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseCompany) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "companyInfo":
		return json.Marshal(e.CompanyInfo)
	}
}

type ExpenseCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (e *ExpenseCompany) Accept(visitor ExpenseCompanyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(e.CompanyInfo)
	}
}

// The expense's contact.
type ExpenseContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewExpenseContactFromString(value string) *ExpenseContact {
	return &ExpenseContact{typeName: "string", String: value}
}

func NewExpenseContactFromContact(value *Contact) *ExpenseContact {
	return &ExpenseContact{typeName: "contact", Contact: value}
}

func (e *ExpenseContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		e.typeName = "contact"
		e.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseContact) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "contact":
		return json.Marshal(e.Contact)
	}
}

type ExpenseContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (e *ExpenseContact) Accept(visitor ExpenseContactVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "contact":
		return visitor.VisitContact(e.Contact)
	}
}

// The expense's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type ExpenseCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewExpenseCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *ExpenseCurrency {
	return &ExpenseCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewExpenseCurrencyFromString(value string) *ExpenseCurrency {
	return &ExpenseCurrency{typeName: "string", String: value}
}

func (e *ExpenseCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		e.typeName = "transactionCurrencyEnum"
		e.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseCurrency) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "transactionCurrencyEnum":
		return json.Marshal(e.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type ExpenseCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (e *ExpenseCurrency) Accept(visitor ExpenseCurrencyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(e.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee this overall transaction relates to.
type ExpenseEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewExpenseEmployeeFromString(value string) *ExpenseEmployee {
	return &ExpenseEmployee{typeName: "string", String: value}
}

func NewExpenseEmployeeFromEmployee(value *Employee) *ExpenseEmployee {
	return &ExpenseEmployee{typeName: "employee", Employee: value}
}

func (e *ExpenseEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseEmployee) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type ExpenseEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *ExpenseEmployee) Accept(visitor ExpenseEmployeeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// # The ExpenseLine Object
//
// ### Description
//
// The `ExpenseLine` object is used to represent an expense's line items.
//
// ### Usage Example
//
// Fetch from the `GET Expense` endpoint and view the expense's line items.
type ExpenseLine struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The line's item.
	Item *ExpenseLineItem `json:"item,omitempty"`
	// The line's net amount.
	NetAmount        *float64                     `json:"net_amount,omitempty"`
	TrackingCategory *ExpenseLineTrackingCategory `json:"tracking_category,omitempty"`
	// The expense line item's associated tracking categories.
	TrackingCategories []*ExpenseLineTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The company the expense belongs to.
	Company *string `json:"company,omitempty"`
	// The employee this overall transaction relates to.
	Employee *ExpenseLineEmployee `json:"employee,omitempty"`
	// The expense line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *ExpenseLineCurrency `json:"currency,omitempty"`
	// The expense's payment account.
	Account *ExpenseLineAccount `json:"account,omitempty"`
	// The expense's contact.
	Contact *ExpenseLineContact `json:"contact,omitempty"`
	// The description of the item that was purchased by the company.
	Description *string `json:"description,omitempty"`
	// The expense line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExpenseLine) UnmarshalJSON(data []byte) error {
	type unmarshaler ExpenseLine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExpenseLine(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExpenseLine) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The expense's payment account.
type ExpenseLineAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewExpenseLineAccountFromString(value string) *ExpenseLineAccount {
	return &ExpenseLineAccount{typeName: "string", String: value}
}

func NewExpenseLineAccountFromAccount(value *Account) *ExpenseLineAccount {
	return &ExpenseLineAccount{typeName: "account", Account: value}
}

func (e *ExpenseLineAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		e.typeName = "account"
		e.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineAccount) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "account":
		return json.Marshal(e.Account)
	}
}

type ExpenseLineAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (e *ExpenseLineAccount) Accept(visitor ExpenseLineAccountVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "account":
		return visitor.VisitAccount(e.Account)
	}
}

// The expense's contact.
type ExpenseLineContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewExpenseLineContactFromString(value string) *ExpenseLineContact {
	return &ExpenseLineContact{typeName: "string", String: value}
}

func NewExpenseLineContactFromContact(value *Contact) *ExpenseLineContact {
	return &ExpenseLineContact{typeName: "contact", Contact: value}
}

func (e *ExpenseLineContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		e.typeName = "contact"
		e.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineContact) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "contact":
		return json.Marshal(e.Contact)
	}
}

type ExpenseLineContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (e *ExpenseLineContact) Accept(visitor ExpenseLineContactVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "contact":
		return visitor.VisitContact(e.Contact)
	}
}

// The expense line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type ExpenseLineCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewExpenseLineCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *ExpenseLineCurrency {
	return &ExpenseLineCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewExpenseLineCurrencyFromString(value string) *ExpenseLineCurrency {
	return &ExpenseLineCurrency{typeName: "string", String: value}
}

func (e *ExpenseLineCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		e.typeName = "transactionCurrencyEnum"
		e.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineCurrency) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "transactionCurrencyEnum":
		return json.Marshal(e.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type ExpenseLineCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (e *ExpenseLineCurrency) Accept(visitor ExpenseLineCurrencyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(e.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee this overall transaction relates to.
type ExpenseLineEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewExpenseLineEmployeeFromString(value string) *ExpenseLineEmployee {
	return &ExpenseLineEmployee{typeName: "string", String: value}
}

func NewExpenseLineEmployeeFromEmployee(value *Employee) *ExpenseLineEmployee {
	return &ExpenseLineEmployee{typeName: "employee", Employee: value}
}

func (e *ExpenseLineEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineEmployee) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type ExpenseLineEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *ExpenseLineEmployee) Accept(visitor ExpenseLineEmployeeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The line's item.
type ExpenseLineItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewExpenseLineItemFromString(value string) *ExpenseLineItem {
	return &ExpenseLineItem{typeName: "string", String: value}
}

func NewExpenseLineItemFromItem(value *Item) *ExpenseLineItem {
	return &ExpenseLineItem{typeName: "item", Item: value}
}

func (e *ExpenseLineItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		e.typeName = "item"
		e.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "item":
		return json.Marshal(e.Item)
	}
}

type ExpenseLineItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (e *ExpenseLineItem) Accept(visitor ExpenseLineItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "item":
		return visitor.VisitItem(e.Item)
	}
}

// # The ExpenseLine Object
//
// ### Description
//
// The `ExpenseLine` object is used to represent an expense's line items.
//
// ### Usage Example
//
// Fetch from the `GET Expense` endpoint and view the expense's line items.
type ExpenseLineRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The line's item.
	Item *ExpenseLineRequestItem `json:"item,omitempty"`
	// The line's net amount.
	NetAmount        *float64                            `json:"net_amount,omitempty"`
	TrackingCategory *ExpenseLineRequestTrackingCategory `json:"tracking_category,omitempty"`
	// The expense line item's associated tracking categories.
	TrackingCategories []*ExpenseLineRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The company the expense belongs to.
	Company *string `json:"company,omitempty"`
	// The employee this overall transaction relates to.
	Employee *ExpenseLineRequestEmployee `json:"employee,omitempty"`
	// The expense line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *ExpenseLineRequestCurrency `json:"currency,omitempty"`
	// The expense's payment account.
	Account *ExpenseLineRequestAccount `json:"account,omitempty"`
	// The expense's contact.
	Contact *ExpenseLineRequestContact `json:"contact,omitempty"`
	// The description of the item that was purchased by the company.
	Description *string `json:"description,omitempty"`
	// The expense line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate             *string                `json:"tax_rate,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExpenseLineRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ExpenseLineRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExpenseLineRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExpenseLineRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The expense's payment account.
type ExpenseLineRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewExpenseLineRequestAccountFromString(value string) *ExpenseLineRequestAccount {
	return &ExpenseLineRequestAccount{typeName: "string", String: value}
}

func NewExpenseLineRequestAccountFromAccount(value *Account) *ExpenseLineRequestAccount {
	return &ExpenseLineRequestAccount{typeName: "account", Account: value}
}

func (e *ExpenseLineRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		e.typeName = "account"
		e.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineRequestAccount) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "account":
		return json.Marshal(e.Account)
	}
}

type ExpenseLineRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (e *ExpenseLineRequestAccount) Accept(visitor ExpenseLineRequestAccountVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "account":
		return visitor.VisitAccount(e.Account)
	}
}

// The expense's contact.
type ExpenseLineRequestContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewExpenseLineRequestContactFromString(value string) *ExpenseLineRequestContact {
	return &ExpenseLineRequestContact{typeName: "string", String: value}
}

func NewExpenseLineRequestContactFromContact(value *Contact) *ExpenseLineRequestContact {
	return &ExpenseLineRequestContact{typeName: "contact", Contact: value}
}

func (e *ExpenseLineRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		e.typeName = "contact"
		e.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineRequestContact) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "contact":
		return json.Marshal(e.Contact)
	}
}

type ExpenseLineRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (e *ExpenseLineRequestContact) Accept(visitor ExpenseLineRequestContactVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "contact":
		return visitor.VisitContact(e.Contact)
	}
}

// The expense line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type ExpenseLineRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewExpenseLineRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *ExpenseLineRequestCurrency {
	return &ExpenseLineRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewExpenseLineRequestCurrencyFromString(value string) *ExpenseLineRequestCurrency {
	return &ExpenseLineRequestCurrency{typeName: "string", String: value}
}

func (e *ExpenseLineRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		e.typeName = "transactionCurrencyEnum"
		e.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineRequestCurrency) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "transactionCurrencyEnum":
		return json.Marshal(e.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type ExpenseLineRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (e *ExpenseLineRequestCurrency) Accept(visitor ExpenseLineRequestCurrencyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(e.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee this overall transaction relates to.
type ExpenseLineRequestEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewExpenseLineRequestEmployeeFromString(value string) *ExpenseLineRequestEmployee {
	return &ExpenseLineRequestEmployee{typeName: "string", String: value}
}

func NewExpenseLineRequestEmployeeFromEmployee(value *Employee) *ExpenseLineRequestEmployee {
	return &ExpenseLineRequestEmployee{typeName: "employee", Employee: value}
}

func (e *ExpenseLineRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineRequestEmployee) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type ExpenseLineRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *ExpenseLineRequestEmployee) Accept(visitor ExpenseLineRequestEmployeeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

// The line's item.
type ExpenseLineRequestItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewExpenseLineRequestItemFromString(value string) *ExpenseLineRequestItem {
	return &ExpenseLineRequestItem{typeName: "string", String: value}
}

func NewExpenseLineRequestItemFromItem(value *Item) *ExpenseLineRequestItem {
	return &ExpenseLineRequestItem{typeName: "item", Item: value}
}

func (e *ExpenseLineRequestItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		e.typeName = "item"
		e.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineRequestItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "item":
		return json.Marshal(e.Item)
	}
}

type ExpenseLineRequestItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (e *ExpenseLineRequestItem) Accept(visitor ExpenseLineRequestItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "item":
		return visitor.VisitItem(e.Item)
	}
}

type ExpenseLineRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewExpenseLineRequestTrackingCategoriesItemFromString(value string) *ExpenseLineRequestTrackingCategoriesItem {
	return &ExpenseLineRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewExpenseLineRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *ExpenseLineRequestTrackingCategoriesItem {
	return &ExpenseLineRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (e *ExpenseLineRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		e.typeName = "trackingCategory"
		e.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "trackingCategory":
		return json.Marshal(e.TrackingCategory)
	}
}

type ExpenseLineRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (e *ExpenseLineRequestTrackingCategoriesItem) Accept(visitor ExpenseLineRequestTrackingCategoriesItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(e.TrackingCategory)
	}
}

type ExpenseLineRequestTrackingCategory struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewExpenseLineRequestTrackingCategoryFromString(value string) *ExpenseLineRequestTrackingCategory {
	return &ExpenseLineRequestTrackingCategory{typeName: "string", String: value}
}

func NewExpenseLineRequestTrackingCategoryFromTrackingCategory(value *TrackingCategory) *ExpenseLineRequestTrackingCategory {
	return &ExpenseLineRequestTrackingCategory{typeName: "trackingCategory", TrackingCategory: value}
}

func (e *ExpenseLineRequestTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		e.typeName = "trackingCategory"
		e.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineRequestTrackingCategory) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "trackingCategory":
		return json.Marshal(e.TrackingCategory)
	}
}

type ExpenseLineRequestTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (e *ExpenseLineRequestTrackingCategory) Accept(visitor ExpenseLineRequestTrackingCategoryVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(e.TrackingCategory)
	}
}

type ExpenseLineTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewExpenseLineTrackingCategoriesItemFromString(value string) *ExpenseLineTrackingCategoriesItem {
	return &ExpenseLineTrackingCategoriesItem{typeName: "string", String: value}
}

func NewExpenseLineTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *ExpenseLineTrackingCategoriesItem {
	return &ExpenseLineTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (e *ExpenseLineTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		e.typeName = "trackingCategory"
		e.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "trackingCategory":
		return json.Marshal(e.TrackingCategory)
	}
}

type ExpenseLineTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (e *ExpenseLineTrackingCategoriesItem) Accept(visitor ExpenseLineTrackingCategoriesItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(e.TrackingCategory)
	}
}

type ExpenseLineTrackingCategory struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewExpenseLineTrackingCategoryFromString(value string) *ExpenseLineTrackingCategory {
	return &ExpenseLineTrackingCategory{typeName: "string", String: value}
}

func NewExpenseLineTrackingCategoryFromTrackingCategory(value *TrackingCategory) *ExpenseLineTrackingCategory {
	return &ExpenseLineTrackingCategory{typeName: "trackingCategory", TrackingCategory: value}
}

func (e *ExpenseLineTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		e.typeName = "trackingCategory"
		e.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseLineTrackingCategory) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "trackingCategory":
		return json.Marshal(e.TrackingCategory)
	}
}

type ExpenseLineTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (e *ExpenseLineTrackingCategory) Accept(visitor ExpenseLineTrackingCategoryVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(e.TrackingCategory)
	}
}

// # The Expense Object
//
// ### Description
//
// The `Expense` object is used to represent a direct purchase by a business, typically made with a check, credit card, or cash. Each `Expense` object is dedicated to a grouping of expenses, with each expense recorded in the lines object.
//
// The `Expense` object is used also used to represent refunds to direct purchases. Refunds can be distinguished from purchases by the amount sign of the records. Expense objects with a negative amount are purchases and `Expense` objects with a positive amount are refunds to those purchases.
//
// ### Usage Example
//
// Fetch from the `GET Expense` endpoint and view a company's expense.
type ExpenseRequest struct {
	// When the transaction occurred.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The expense's payment account.
	Account *ExpenseRequestAccount `json:"account,omitempty"`
	// The expense's contact.
	Contact *ExpenseRequestContact `json:"contact,omitempty"`
	// The expense's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The expense's total amount before tax.
	SubTotal *float64 `json:"sub_total,omitempty"`
	// The expense's total tax amount.
	TotalTaxAmount *float64 `json:"total_tax_amount,omitempty"`
	// The expense's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *ExpenseRequestCurrency `json:"currency,omitempty"`
	// The expense's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty"`
	// The company the expense belongs to.
	Company *ExpenseRequestCompany `json:"company,omitempty"`
	// The employee this overall transaction relates to.
	Employee *ExpenseRequestEmployee `json:"employee,omitempty"`
	// The expense's private note.
	Memo               *string                                 `json:"memo,omitempty"`
	Lines              []*ExpenseLineRequest                   `json:"lines,omitempty"`
	TrackingCategories []*ExpenseRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The accounting period that the Expense was generated in.
	AccountingPeriod    *ExpenseRequestAccountingPeriod `json:"accounting_period,omitempty"`
	IntegrationParams   map[string]interface{}          `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}          `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest           `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExpenseRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ExpenseRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExpenseRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExpenseRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The expense's payment account.
type ExpenseRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewExpenseRequestAccountFromString(value string) *ExpenseRequestAccount {
	return &ExpenseRequestAccount{typeName: "string", String: value}
}

func NewExpenseRequestAccountFromAccount(value *Account) *ExpenseRequestAccount {
	return &ExpenseRequestAccount{typeName: "account", Account: value}
}

func (e *ExpenseRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		e.typeName = "account"
		e.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseRequestAccount) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "account":
		return json.Marshal(e.Account)
	}
}

type ExpenseRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (e *ExpenseRequestAccount) Accept(visitor ExpenseRequestAccountVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "account":
		return visitor.VisitAccount(e.Account)
	}
}

// The accounting period that the Expense was generated in.
type ExpenseRequestAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewExpenseRequestAccountingPeriodFromString(value string) *ExpenseRequestAccountingPeriod {
	return &ExpenseRequestAccountingPeriod{typeName: "string", String: value}
}

func NewExpenseRequestAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *ExpenseRequestAccountingPeriod {
	return &ExpenseRequestAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (e *ExpenseRequestAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		e.typeName = "accountingPeriod"
		e.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseRequestAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "accountingPeriod":
		return json.Marshal(e.AccountingPeriod)
	}
}

type ExpenseRequestAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (e *ExpenseRequestAccountingPeriod) Accept(visitor ExpenseRequestAccountingPeriodVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(e.AccountingPeriod)
	}
}

// The company the expense belongs to.
type ExpenseRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewExpenseRequestCompanyFromString(value string) *ExpenseRequestCompany {
	return &ExpenseRequestCompany{typeName: "string", String: value}
}

func NewExpenseRequestCompanyFromCompanyInfo(value *CompanyInfo) *ExpenseRequestCompany {
	return &ExpenseRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (e *ExpenseRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		e.typeName = "companyInfo"
		e.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseRequestCompany) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "companyInfo":
		return json.Marshal(e.CompanyInfo)
	}
}

type ExpenseRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (e *ExpenseRequestCompany) Accept(visitor ExpenseRequestCompanyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(e.CompanyInfo)
	}
}

// The expense's contact.
type ExpenseRequestContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewExpenseRequestContactFromString(value string) *ExpenseRequestContact {
	return &ExpenseRequestContact{typeName: "string", String: value}
}

func NewExpenseRequestContactFromContact(value *Contact) *ExpenseRequestContact {
	return &ExpenseRequestContact{typeName: "contact", Contact: value}
}

func (e *ExpenseRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		e.typeName = "contact"
		e.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseRequestContact) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "contact":
		return json.Marshal(e.Contact)
	}
}

type ExpenseRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (e *ExpenseRequestContact) Accept(visitor ExpenseRequestContactVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "contact":
		return visitor.VisitContact(e.Contact)
	}
}

// The expense's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type ExpenseRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewExpenseRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *ExpenseRequestCurrency {
	return &ExpenseRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewExpenseRequestCurrencyFromString(value string) *ExpenseRequestCurrency {
	return &ExpenseRequestCurrency{typeName: "string", String: value}
}

func (e *ExpenseRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		e.typeName = "transactionCurrencyEnum"
		e.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseRequestCurrency) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "transactionCurrencyEnum":
		return json.Marshal(e.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type ExpenseRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (e *ExpenseRequestCurrency) Accept(visitor ExpenseRequestCurrencyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(e.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The employee this overall transaction relates to.
type ExpenseRequestEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewExpenseRequestEmployeeFromString(value string) *ExpenseRequestEmployee {
	return &ExpenseRequestEmployee{typeName: "string", String: value}
}

func NewExpenseRequestEmployeeFromEmployee(value *Employee) *ExpenseRequestEmployee {
	return &ExpenseRequestEmployee{typeName: "employee", Employee: value}
}

func (e *ExpenseRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		e.typeName = "employee"
		e.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseRequestEmployee) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "employee":
		return json.Marshal(e.Employee)
	}
}

type ExpenseRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (e *ExpenseRequestEmployee) Accept(visitor ExpenseRequestEmployeeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "employee":
		return visitor.VisitEmployee(e.Employee)
	}
}

type ExpenseRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewExpenseRequestTrackingCategoriesItemFromString(value string) *ExpenseRequestTrackingCategoriesItem {
	return &ExpenseRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewExpenseRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *ExpenseRequestTrackingCategoriesItem {
	return &ExpenseRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (e *ExpenseRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		e.typeName = "trackingCategory"
		e.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "trackingCategory":
		return json.Marshal(e.TrackingCategory)
	}
}

type ExpenseRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (e *ExpenseRequestTrackingCategoriesItem) Accept(visitor ExpenseRequestTrackingCategoriesItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(e.TrackingCategory)
	}
}

type ExpenseResponse struct {
	Model    *Expense                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExpenseResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ExpenseResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExpenseResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExpenseResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExpenseTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewExpenseTrackingCategoriesItemFromString(value string) *ExpenseTrackingCategoriesItem {
	return &ExpenseTrackingCategoriesItem{typeName: "string", String: value}
}

func NewExpenseTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *ExpenseTrackingCategoriesItem {
	return &ExpenseTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (e *ExpenseTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		e.typeName = "trackingCategory"
		e.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ExpenseTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "trackingCategory":
		return json.Marshal(e.TrackingCategory)
	}
}

type ExpenseTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (e *ExpenseTrackingCategoriesItem) Accept(visitor ExpenseTrackingCategoriesItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(e.TrackingCategory)
	}
}

type ExternalTargetFieldApi struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	IsMapped    *string `json:"is_mapped,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExternalTargetFieldApi) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalTargetFieldApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalTargetFieldApi(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalTargetFieldApi) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalTargetFieldApiResponse struct {
	Account                  []*ExternalTargetFieldApi `json:"Account,omitempty"`
	AccountingAttachment     []*ExternalTargetFieldApi `json:"AccountingAttachment,omitempty"`
	BalanceSheet             []*ExternalTargetFieldApi `json:"BalanceSheet,omitempty"`
	CashFlowStatement        []*ExternalTargetFieldApi `json:"CashFlowStatement,omitempty"`
	CompanyInfo              []*ExternalTargetFieldApi `json:"CompanyInfo,omitempty"`
	Contact                  []*ExternalTargetFieldApi `json:"Contact,omitempty"`
	IncomeStatement          []*ExternalTargetFieldApi `json:"IncomeStatement,omitempty"`
	CreditNote               []*ExternalTargetFieldApi `json:"CreditNote,omitempty"`
	Item                     []*ExternalTargetFieldApi `json:"Item,omitempty"`
	PurchaseOrder            []*ExternalTargetFieldApi `json:"PurchaseOrder,omitempty"`
	TrackingCategory         []*ExternalTargetFieldApi `json:"TrackingCategory,omitempty"`
	JournalEntry             []*ExternalTargetFieldApi `json:"JournalEntry,omitempty"`
	TaxRate                  []*ExternalTargetFieldApi `json:"TaxRate,omitempty"`
	Invoice                  []*ExternalTargetFieldApi `json:"Invoice,omitempty"`
	Payment                  []*ExternalTargetFieldApi `json:"Payment,omitempty"`
	Expense                  []*ExternalTargetFieldApi `json:"Expense,omitempty"`
	VendorCredit             []*ExternalTargetFieldApi `json:"VendorCredit,omitempty"`
	Transaction              []*ExternalTargetFieldApi `json:"Transaction,omitempty"`
	AccountingPeriod         []*ExternalTargetFieldApi `json:"AccountingPeriod,omitempty"`
	GeneralLedgerTransaction []*ExternalTargetFieldApi `json:"GeneralLedgerTransaction,omitempty"`
	BankFeedAccount          []*ExternalTargetFieldApi `json:"BankFeedAccount,omitempty"`
	Employee                 []*ExternalTargetFieldApi `json:"Employee,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExternalTargetFieldApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalTargetFieldApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalTargetFieldApiResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalTargetFieldApiResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// - `ACTIVE` - ACTIVE
// - `INACTIVE` - INACTIVE
type FeedStatusEnum string

const (
	FeedStatusEnumActive   FeedStatusEnum = "ACTIVE"
	FeedStatusEnumInactive FeedStatusEnum = "INACTIVE"
)

func NewFeedStatusEnumFromString(s string) (FeedStatusEnum, error) {
	switch s {
	case "ACTIVE":
		return FeedStatusEnumActive, nil
	case "INACTIVE":
		return FeedStatusEnumInactive, nil
	}
	var t FeedStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FeedStatusEnum) Ptr() *FeedStatusEnum {
	return &f
}

// - `string` - string
// - `number` - number
// - `date` - date
// - `datetime` - datetime
// - `bool` - bool
// - `list` - list
type FieldFormatEnum string

const (
	FieldFormatEnumString   FieldFormatEnum = "string"
	FieldFormatEnumNumber   FieldFormatEnum = "number"
	FieldFormatEnumDate     FieldFormatEnum = "date"
	FieldFormatEnumDatetime FieldFormatEnum = "datetime"
	FieldFormatEnumBool     FieldFormatEnum = "bool"
	FieldFormatEnumList     FieldFormatEnum = "list"
)

func NewFieldFormatEnumFromString(s string) (FieldFormatEnum, error) {
	switch s {
	case "string":
		return FieldFormatEnumString, nil
	case "number":
		return FieldFormatEnumNumber, nil
	case "date":
		return FieldFormatEnumDate, nil
	case "datetime":
		return FieldFormatEnumDatetime, nil
	case "bool":
		return FieldFormatEnumBool, nil
	case "list":
		return FieldFormatEnumList, nil
	}
	var t FieldFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldFormatEnum) Ptr() *FieldFormatEnum {
	return &f
}

type FieldMappingApiInstance struct {
	Id                *string                             `json:"id,omitempty"`
	IsIntegrationWide *bool                               `json:"is_integration_wide,omitempty"`
	TargetField       *FieldMappingApiInstanceTargetField `json:"target_field,omitempty"`
	RemoteField       *FieldMappingApiInstanceRemoteField `json:"remote_field,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstance) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstance(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstance) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceRemoteField struct {
	RemoteKeyName      *string                                               `json:"remote_key_name,omitempty"`
	Schema             map[string]interface{}                                `json:"schema,omitempty"`
	RemoteEndpointInfo *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo `json:"remote_endpoint_info,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceRemoteField) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceRemoteField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceRemoteField(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceRemoteField) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo struct {
	Method             *string  `json:"method,omitempty"`
	UrlPath            *string  `json:"url_path,omitempty"`
	FieldTraversalPath []string `json:"field_traversal_path,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceResponse struct {
	Account                  []*FieldMappingApiInstance `json:"Account,omitempty"`
	AccountingAttachment     []*FieldMappingApiInstance `json:"AccountingAttachment,omitempty"`
	BalanceSheet             []*FieldMappingApiInstance `json:"BalanceSheet,omitempty"`
	CashFlowStatement        []*FieldMappingApiInstance `json:"CashFlowStatement,omitempty"`
	CompanyInfo              []*FieldMappingApiInstance `json:"CompanyInfo,omitempty"`
	Contact                  []*FieldMappingApiInstance `json:"Contact,omitempty"`
	IncomeStatement          []*FieldMappingApiInstance `json:"IncomeStatement,omitempty"`
	CreditNote               []*FieldMappingApiInstance `json:"CreditNote,omitempty"`
	Item                     []*FieldMappingApiInstance `json:"Item,omitempty"`
	PurchaseOrder            []*FieldMappingApiInstance `json:"PurchaseOrder,omitempty"`
	TrackingCategory         []*FieldMappingApiInstance `json:"TrackingCategory,omitempty"`
	JournalEntry             []*FieldMappingApiInstance `json:"JournalEntry,omitempty"`
	TaxRate                  []*FieldMappingApiInstance `json:"TaxRate,omitempty"`
	Invoice                  []*FieldMappingApiInstance `json:"Invoice,omitempty"`
	Payment                  []*FieldMappingApiInstance `json:"Payment,omitempty"`
	Expense                  []*FieldMappingApiInstance `json:"Expense,omitempty"`
	VendorCredit             []*FieldMappingApiInstance `json:"VendorCredit,omitempty"`
	Transaction              []*FieldMappingApiInstance `json:"Transaction,omitempty"`
	AccountingPeriod         []*FieldMappingApiInstance `json:"AccountingPeriod,omitempty"`
	GeneralLedgerTransaction []*FieldMappingApiInstance `json:"GeneralLedgerTransaction,omitempty"`
	BankFeedAccount          []*FieldMappingApiInstance `json:"BankFeedAccount,omitempty"`
	Employee                 []*FieldMappingApiInstance `json:"Employee,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceTargetField struct {
	Name               string `json:"name"`
	Description        string `json:"description"`
	IsOrganizationWide bool   `json:"is_organization_wide"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceTargetField) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceTargetField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceTargetField(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceTargetField) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingInstanceResponse struct {
	Model    *FieldMappingApiInstance    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingInstanceResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingInstanceResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldPermissionDeserializer struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldPermissionDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializer(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializer) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldPermissionDeserializerRequest struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializerRequest(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializerRequest) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// - `string` - string
// - `number` - number
// - `date` - date
// - `datetime` - datetime
// - `bool` - bool
// - `list` - list
type FieldTypeEnum string

const (
	FieldTypeEnumString   FieldTypeEnum = "string"
	FieldTypeEnumNumber   FieldTypeEnum = "number"
	FieldTypeEnumDate     FieldTypeEnum = "date"
	FieldTypeEnumDatetime FieldTypeEnum = "datetime"
	FieldTypeEnumBool     FieldTypeEnum = "bool"
	FieldTypeEnumList     FieldTypeEnum = "list"
)

func NewFieldTypeEnumFromString(s string) (FieldTypeEnum, error) {
	switch s {
	case "string":
		return FieldTypeEnumString, nil
	case "number":
		return FieldTypeEnumNumber, nil
	case "date":
		return FieldTypeEnumDate, nil
	case "datetime":
		return FieldTypeEnumDatetime, nil
	case "bool":
		return FieldTypeEnumBool, nil
	case "list":
		return FieldTypeEnumList, nil
	}
	var t FieldTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldTypeEnum) Ptr() *FieldTypeEnum {
	return &f
}

// # The GeneralLedgerTransaction Object
//
// ### Description
//
// A General Ledger Entry is a record of a financial transaction that is posted to the general ledger, the central repository of a company’s financial data.
//
// The `GeneralLedgerTransaction` object is a singular endpoint to pull all transactions posted to a company’s general ledger. The transaction that generated the `GeneralLedgerTransaction` can be found by referencing the `underlying_transaction_type` and `underlying_transaction_remote_id` fields.
//
// The lines of a `GeneralLedgerTransaction` object will always have equal amounts of debits and credits.
//
// ### Usage Example
//
// Fetch from the `GET GeneralLedgerTransaction` endpoint and view a general ledger transaction.
type GeneralLedgerTransaction struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The third party remote ID of the underlying transaction.
	UnderlyingTransactionRemoteId *string `json:"underlying_transaction_remote_id,omitempty"`
	// The type of the underlying transaction.
	//
	// - `INVOICE` - INVOICE
	// - `EXPENSE` - EXPENSE
	// - `TRANSACTION` - TRANSACTION
	// - `JOURNAL_ENTRY` - JOURNAL_ENTRY
	// - `PAYMENT` - PAYMENT
	// - `VENDOR_CREDIT` - VENDOR_CREDIT
	// - `CREDIT_NOTE` - CREDIT_NOTE
	UnderlyingTransactionType *GeneralLedgerTransactionUnderlyingTransactionType `json:"underlying_transaction_type,omitempty"`
	// The accounting period that the GeneralLedgerTransaction was generated in.
	AccountingPeriod *GeneralLedgerTransactionAccountingPeriod `json:"accounting_period,omitempty"`
	// The company the GeneralLedgerTransaction belongs to.
	Company *GeneralLedgerTransactionCompany `json:"company,omitempty"`
	// When the third party's GeneralLedgerTransaction entry was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// When the third party's GeneralLedgerTransaction entry was created.
	RemoteCreatedAt    *time.Time                                        `json:"remote_created_at,omitempty"`
	TrackingCategories []*GeneralLedgerTransactionTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The date that the transaction was posted to the general ledger.
	PostingDate *time.Time `json:"posting_date,omitempty"`
	// A list of “General Ledger Transaction Applied to Lines” objects.
	GeneralLedgerTransactionLines []*GeneralLedgerTransactionGeneralLedgerTransactionLinesItem `json:"general_ledger_transaction_lines,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GeneralLedgerTransaction) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneralLedgerTransaction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneralLedgerTransaction(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeneralLedgerTransaction) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The accounting period that the GeneralLedgerTransaction was generated in.
type GeneralLedgerTransactionAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewGeneralLedgerTransactionAccountingPeriodFromString(value string) *GeneralLedgerTransactionAccountingPeriod {
	return &GeneralLedgerTransactionAccountingPeriod{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *GeneralLedgerTransactionAccountingPeriod {
	return &GeneralLedgerTransactionAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (g *GeneralLedgerTransactionAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		g.typeName = "accountingPeriod"
		g.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "accountingPeriod":
		return json.Marshal(g.AccountingPeriod)
	}
}

type GeneralLedgerTransactionAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (g *GeneralLedgerTransactionAccountingPeriod) Accept(visitor GeneralLedgerTransactionAccountingPeriodVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(g.AccountingPeriod)
	}
}

// The company the GeneralLedgerTransaction belongs to.
type GeneralLedgerTransactionCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewGeneralLedgerTransactionCompanyFromString(value string) *GeneralLedgerTransactionCompany {
	return &GeneralLedgerTransactionCompany{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionCompanyFromCompanyInfo(value *CompanyInfo) *GeneralLedgerTransactionCompany {
	return &GeneralLedgerTransactionCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (g *GeneralLedgerTransactionCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		g.typeName = "companyInfo"
		g.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionCompany) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "companyInfo":
		return json.Marshal(g.CompanyInfo)
	}
}

type GeneralLedgerTransactionCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (g *GeneralLedgerTransactionCompany) Accept(visitor GeneralLedgerTransactionCompanyVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(g.CompanyInfo)
	}
}

type GeneralLedgerTransactionGeneralLedgerTransactionLinesItem struct {
	typeName                     string
	String                       string
	GeneralLedgerTransactionLine *GeneralLedgerTransactionLine
}

func NewGeneralLedgerTransactionGeneralLedgerTransactionLinesItemFromString(value string) *GeneralLedgerTransactionGeneralLedgerTransactionLinesItem {
	return &GeneralLedgerTransactionGeneralLedgerTransactionLinesItem{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionGeneralLedgerTransactionLinesItemFromGeneralLedgerTransactionLine(value *GeneralLedgerTransactionLine) *GeneralLedgerTransactionGeneralLedgerTransactionLinesItem {
	return &GeneralLedgerTransactionGeneralLedgerTransactionLinesItem{typeName: "generalLedgerTransactionLine", GeneralLedgerTransactionLine: value}
}

func (g *GeneralLedgerTransactionGeneralLedgerTransactionLinesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueGeneralLedgerTransactionLine := new(GeneralLedgerTransactionLine)
	if err := json.Unmarshal(data, &valueGeneralLedgerTransactionLine); err == nil {
		g.typeName = "generalLedgerTransactionLine"
		g.GeneralLedgerTransactionLine = valueGeneralLedgerTransactionLine
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionGeneralLedgerTransactionLinesItem) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "generalLedgerTransactionLine":
		return json.Marshal(g.GeneralLedgerTransactionLine)
	}
}

type GeneralLedgerTransactionGeneralLedgerTransactionLinesItemVisitor interface {
	VisitString(string) error
	VisitGeneralLedgerTransactionLine(*GeneralLedgerTransactionLine) error
}

func (g *GeneralLedgerTransactionGeneralLedgerTransactionLinesItem) Accept(visitor GeneralLedgerTransactionGeneralLedgerTransactionLinesItemVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "generalLedgerTransactionLine":
		return visitor.VisitGeneralLedgerTransactionLine(g.GeneralLedgerTransactionLine)
	}
}

// # The GeneralLedgerTransactionLineSerializer Object
//
// ### Description
//
// The `GeneralLedgerTransactionLineSerializer` object represents general ledger transaction line item.
//
// ### Usage Example Fetch from the `GET GeneralLedgerTransactionLineSerializer` endpoint and view an
//
// `GeneralLedgerTransaction` line item.
type GeneralLedgerTransactionLine struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time                           `json:"modified_at,omitempty"`
	Account    *GeneralLedgerTransactionLineAccount `json:"account,omitempty"`
	// The company the GeneralLedgerTransaction belongs to.
	Company  *GeneralLedgerTransactionLineCompany  `json:"company,omitempty"`
	Employee *GeneralLedgerTransactionLineEmployee `json:"employee,omitempty"`
	Contact  *GeneralLedgerTransactionLineContact  `json:"contact,omitempty"`
	// The base currency of the transaction
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	BaseCurrency *GeneralLedgerTransactionLineBaseCurrency `json:"base_currency,omitempty"`
	// The transaction currency that the transaction is made in.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	TransactionCurrency *GeneralLedgerTransactionLineTransactionCurrency `json:"transaction_currency,omitempty"`
	// The exchange rate between the base currency and the transaction currency.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// A description of the line item.
	Description         *string                           `json:"description,omitempty"`
	TrackingCategories  []*TrackingCategory               `json:"tracking_categories,omitempty"`
	DebitAmount         string                            `json:"debit_amount"`
	CreditAmount        string                            `json:"credit_amount"`
	Item                *GeneralLedgerTransactionLineItem `json:"item,omitempty"`
	ForeignDebitAmount  string                            `json:"foreign_debit_amount"`
	ForeignCreditAmount string                            `json:"foreign_credit_amount"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GeneralLedgerTransactionLine) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneralLedgerTransactionLine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneralLedgerTransactionLine(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeneralLedgerTransactionLine) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneralLedgerTransactionLineAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewGeneralLedgerTransactionLineAccountFromString(value string) *GeneralLedgerTransactionLineAccount {
	return &GeneralLedgerTransactionLineAccount{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionLineAccountFromAccount(value *Account) *GeneralLedgerTransactionLineAccount {
	return &GeneralLedgerTransactionLineAccount{typeName: "account", Account: value}
}

func (g *GeneralLedgerTransactionLineAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		g.typeName = "account"
		g.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionLineAccount) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "account":
		return json.Marshal(g.Account)
	}
}

type GeneralLedgerTransactionLineAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (g *GeneralLedgerTransactionLineAccount) Accept(visitor GeneralLedgerTransactionLineAccountVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "account":
		return visitor.VisitAccount(g.Account)
	}
}

// The base currency of the transaction
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type GeneralLedgerTransactionLineBaseCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewGeneralLedgerTransactionLineBaseCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *GeneralLedgerTransactionLineBaseCurrency {
	return &GeneralLedgerTransactionLineBaseCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewGeneralLedgerTransactionLineBaseCurrencyFromString(value string) *GeneralLedgerTransactionLineBaseCurrency {
	return &GeneralLedgerTransactionLineBaseCurrency{typeName: "string", String: value}
}

func (g *GeneralLedgerTransactionLineBaseCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		g.typeName = "transactionCurrencyEnum"
		g.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionLineBaseCurrency) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "transactionCurrencyEnum":
		return json.Marshal(g.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(g.String)
	}
}

type GeneralLedgerTransactionLineBaseCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (g *GeneralLedgerTransactionLineBaseCurrency) Accept(visitor GeneralLedgerTransactionLineBaseCurrencyVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(g.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(g.String)
	}
}

// The company the GeneralLedgerTransaction belongs to.
type GeneralLedgerTransactionLineCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewGeneralLedgerTransactionLineCompanyFromString(value string) *GeneralLedgerTransactionLineCompany {
	return &GeneralLedgerTransactionLineCompany{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionLineCompanyFromCompanyInfo(value *CompanyInfo) *GeneralLedgerTransactionLineCompany {
	return &GeneralLedgerTransactionLineCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (g *GeneralLedgerTransactionLineCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		g.typeName = "companyInfo"
		g.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionLineCompany) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "companyInfo":
		return json.Marshal(g.CompanyInfo)
	}
}

type GeneralLedgerTransactionLineCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (g *GeneralLedgerTransactionLineCompany) Accept(visitor GeneralLedgerTransactionLineCompanyVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(g.CompanyInfo)
	}
}

type GeneralLedgerTransactionLineContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewGeneralLedgerTransactionLineContactFromString(value string) *GeneralLedgerTransactionLineContact {
	return &GeneralLedgerTransactionLineContact{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionLineContactFromContact(value *Contact) *GeneralLedgerTransactionLineContact {
	return &GeneralLedgerTransactionLineContact{typeName: "contact", Contact: value}
}

func (g *GeneralLedgerTransactionLineContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		g.typeName = "contact"
		g.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionLineContact) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "contact":
		return json.Marshal(g.Contact)
	}
}

type GeneralLedgerTransactionLineContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (g *GeneralLedgerTransactionLineContact) Accept(visitor GeneralLedgerTransactionLineContactVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "contact":
		return visitor.VisitContact(g.Contact)
	}
}

type GeneralLedgerTransactionLineEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewGeneralLedgerTransactionLineEmployeeFromString(value string) *GeneralLedgerTransactionLineEmployee {
	return &GeneralLedgerTransactionLineEmployee{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionLineEmployeeFromEmployee(value *Employee) *GeneralLedgerTransactionLineEmployee {
	return &GeneralLedgerTransactionLineEmployee{typeName: "employee", Employee: value}
}

func (g *GeneralLedgerTransactionLineEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		g.typeName = "employee"
		g.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionLineEmployee) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "employee":
		return json.Marshal(g.Employee)
	}
}

type GeneralLedgerTransactionLineEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (g *GeneralLedgerTransactionLineEmployee) Accept(visitor GeneralLedgerTransactionLineEmployeeVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "employee":
		return visitor.VisitEmployee(g.Employee)
	}
}

type GeneralLedgerTransactionLineItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewGeneralLedgerTransactionLineItemFromString(value string) *GeneralLedgerTransactionLineItem {
	return &GeneralLedgerTransactionLineItem{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionLineItemFromItem(value *Item) *GeneralLedgerTransactionLineItem {
	return &GeneralLedgerTransactionLineItem{typeName: "item", Item: value}
}

func (g *GeneralLedgerTransactionLineItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		g.typeName = "item"
		g.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionLineItem) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "item":
		return json.Marshal(g.Item)
	}
}

type GeneralLedgerTransactionLineItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (g *GeneralLedgerTransactionLineItem) Accept(visitor GeneralLedgerTransactionLineItemVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "item":
		return visitor.VisitItem(g.Item)
	}
}

// The transaction currency that the transaction is made in.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type GeneralLedgerTransactionLineTransactionCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewGeneralLedgerTransactionLineTransactionCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *GeneralLedgerTransactionLineTransactionCurrency {
	return &GeneralLedgerTransactionLineTransactionCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewGeneralLedgerTransactionLineTransactionCurrencyFromString(value string) *GeneralLedgerTransactionLineTransactionCurrency {
	return &GeneralLedgerTransactionLineTransactionCurrency{typeName: "string", String: value}
}

func (g *GeneralLedgerTransactionLineTransactionCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		g.typeName = "transactionCurrencyEnum"
		g.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionLineTransactionCurrency) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "transactionCurrencyEnum":
		return json.Marshal(g.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(g.String)
	}
}

type GeneralLedgerTransactionLineTransactionCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (g *GeneralLedgerTransactionLineTransactionCurrency) Accept(visitor GeneralLedgerTransactionLineTransactionCurrencyVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(g.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GeneralLedgerTransactionTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewGeneralLedgerTransactionTrackingCategoriesItemFromString(value string) *GeneralLedgerTransactionTrackingCategoriesItem {
	return &GeneralLedgerTransactionTrackingCategoriesItem{typeName: "string", String: value}
}

func NewGeneralLedgerTransactionTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *GeneralLedgerTransactionTrackingCategoriesItem {
	return &GeneralLedgerTransactionTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (g *GeneralLedgerTransactionTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		g.typeName = "trackingCategory"
		g.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return json.Marshal(g.String)
	case "trackingCategory":
		return json.Marshal(g.TrackingCategory)
	}
}

type GeneralLedgerTransactionTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (g *GeneralLedgerTransactionTrackingCategoriesItem) Accept(visitor GeneralLedgerTransactionTrackingCategoriesItemVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "string":
		return visitor.VisitString(g.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(g.TrackingCategory)
	}
}

// The type of the underlying transaction.
//
// - `INVOICE` - INVOICE
// - `EXPENSE` - EXPENSE
// - `TRANSACTION` - TRANSACTION
// - `JOURNAL_ENTRY` - JOURNAL_ENTRY
// - `PAYMENT` - PAYMENT
// - `VENDOR_CREDIT` - VENDOR_CREDIT
// - `CREDIT_NOTE` - CREDIT_NOTE
type GeneralLedgerTransactionUnderlyingTransactionType struct {
	typeName                      string
	UnderlyingTransactionTypeEnum UnderlyingTransactionTypeEnum
	String                        string
}

func NewGeneralLedgerTransactionUnderlyingTransactionTypeFromUnderlyingTransactionTypeEnum(value UnderlyingTransactionTypeEnum) *GeneralLedgerTransactionUnderlyingTransactionType {
	return &GeneralLedgerTransactionUnderlyingTransactionType{typeName: "underlyingTransactionTypeEnum", UnderlyingTransactionTypeEnum: value}
}

func NewGeneralLedgerTransactionUnderlyingTransactionTypeFromString(value string) *GeneralLedgerTransactionUnderlyingTransactionType {
	return &GeneralLedgerTransactionUnderlyingTransactionType{typeName: "string", String: value}
}

func (g *GeneralLedgerTransactionUnderlyingTransactionType) UnmarshalJSON(data []byte) error {
	var valueUnderlyingTransactionTypeEnum UnderlyingTransactionTypeEnum
	if err := json.Unmarshal(data, &valueUnderlyingTransactionTypeEnum); err == nil {
		g.typeName = "underlyingTransactionTypeEnum"
		g.UnderlyingTransactionTypeEnum = valueUnderlyingTransactionTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GeneralLedgerTransactionUnderlyingTransactionType) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "underlyingTransactionTypeEnum":
		return json.Marshal(g.UnderlyingTransactionTypeEnum)
	case "string":
		return json.Marshal(g.String)
	}
}

type GeneralLedgerTransactionUnderlyingTransactionTypeVisitor interface {
	VisitUnderlyingTransactionTypeEnum(UnderlyingTransactionTypeEnum) error
	VisitString(string) error
}

func (g *GeneralLedgerTransactionUnderlyingTransactionType) Accept(visitor GeneralLedgerTransactionUnderlyingTransactionTypeVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "underlyingTransactionTypeEnum":
		return visitor.VisitUnderlyingTransactionTypeEnum(g.UnderlyingTransactionTypeEnum)
	case "string":
		return visitor.VisitString(g.String)
	}
}

// # The IncomeStatement Object
//
// ### Description
//
// The `IncomeStatement` object is used to represent a company’s income, the cost of sales, operating expenses, and other non-operating expenses. The object also includes other important values like gross profit, gross operating profit, and net income. This represents a period of time (month, quarter, or year).
//
// ### Usage Example
//
// Fetch from the `GET IncomeStatement` endpoint and view a company's income statement for a given period.
type IncomeStatement struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The income statement's name.
	Name *string `json:"name,omitempty"`
	// The income statement's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *IncomeStatementCurrency `json:"currency,omitempty"`
	// The company the income statement belongs to.
	Company *IncomeStatementCompany `json:"company,omitempty"`
	// The income statement's start period.
	StartPeriod *time.Time `json:"start_period,omitempty"`
	// The income statement's end period.
	EndPeriod   *time.Time    `json:"end_period,omitempty"`
	Income      []*ReportItem `json:"income,omitempty"`
	CostOfSales []*ReportItem `json:"cost_of_sales,omitempty"`
	// The revenue minus the cost of sale.
	GrossProfit       *float64      `json:"gross_profit,omitempty"`
	OperatingExpenses []*ReportItem `json:"operating_expenses,omitempty"`
	// The revenue minus the operating expenses.
	NetOperatingIncome   *float64      `json:"net_operating_income,omitempty"`
	NonOperatingExpenses []*ReportItem `json:"non_operating_expenses,omitempty"`
	// The gross profit minus the total expenses.
	NetIncome *float64 `json:"net_income,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IncomeStatement) UnmarshalJSON(data []byte) error {
	type unmarshaler IncomeStatement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IncomeStatement(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IncomeStatement) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The company the income statement belongs to.
type IncomeStatementCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewIncomeStatementCompanyFromString(value string) *IncomeStatementCompany {
	return &IncomeStatementCompany{typeName: "string", String: value}
}

func NewIncomeStatementCompanyFromCompanyInfo(value *CompanyInfo) *IncomeStatementCompany {
	return &IncomeStatementCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (i *IncomeStatementCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		i.typeName = "companyInfo"
		i.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IncomeStatementCompany) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "companyInfo":
		return json.Marshal(i.CompanyInfo)
	}
}

type IncomeStatementCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (i *IncomeStatementCompany) Accept(visitor IncomeStatementCompanyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(i.CompanyInfo)
	}
}

// The income statement's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type IncomeStatementCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewIncomeStatementCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *IncomeStatementCurrency {
	return &IncomeStatementCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewIncomeStatementCurrencyFromString(value string) *IncomeStatementCurrency {
	return &IncomeStatementCurrency{typeName: "string", String: value}
}

func (i *IncomeStatementCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		i.typeName = "transactionCurrencyEnum"
		i.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IncomeStatementCurrency) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return json.Marshal(i.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IncomeStatementCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (i *IncomeStatementCurrency) Accept(visitor IncomeStatementCurrencyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(i.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

type IndividualCommonModelScopeDeserializer struct {
	ModelName        string                                  `json:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializer `json:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializer            `json:"field_permissions,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializer(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializer) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndividualCommonModelScopeDeserializerRequest struct {
	ModelName        string                                         `json:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializerRequest `json:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializerRequest            `json:"field_permissions,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializerRequest(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializerRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// # The Invoice Object
//
// ### Description
//
// The `Invoice` object represents an itemized record of goods and/or services sold to a customer or bought from a vendor.
//
// Represents a Bill when the `Invoice` type is `ACCOUNTS_PAYABLE`. References an Invoice when the `Invoice` type is `ACCOUNTS_RECEIVABLE`.
//
// ### Usage Example
//
// Fetch from the `LIST Invoices` endpoint and view a company's invoices.
type Invoice struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// Whether the invoice is an accounts receivable or accounts payable. If `type` is `ACCOUNTS_PAYABLE`, the invoice is a bill. If `type` is `ACCOUNTS_RECEIVABLE`, it is an invoice.
	//
	// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	Type *InvoiceType `json:"type,omitempty"`
	// The invoice's contact.
	Contact *InvoiceContact `json:"contact,omitempty"`
	// The invoice's number.
	Number *string `json:"number,omitempty"`
	// The invoice's issue date.
	IssueDate *time.Time `json:"issue_date,omitempty"`
	// The invoice's due date.
	DueDate *time.Time `json:"due_date,omitempty"`
	// The invoice's paid date.
	PaidOnDate *time.Time `json:"paid_on_date,omitempty"`
	// The invoice's private note.
	Memo *string `json:"memo,omitempty"`
	// The company the invoice belongs to.
	Company *InvoiceCompany `json:"company,omitempty"`
	// The employee this overall transaction relates to.
	Employee *InvoiceEmployee `json:"employee,omitempty"`
	// The invoice's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *InvoiceCurrency `json:"currency,omitempty"`
	// The invoice's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The total discounts applied to the total cost.
	TotalDiscount *float64 `json:"total_discount,omitempty"`
	// The total amount being paid before taxes.
	SubTotal *float64 `json:"sub_total,omitempty"`
	// The status of the invoice.
	//
	// - `PAID` - PAID
	// - `DRAFT` - DRAFT
	// - `SUBMITTED` - SUBMITTED
	// - `PARTIALLY_PAID` - PARTIALLY_PAID
	// - `OPEN` - OPEN
	// - `VOID` - VOID
	Status *InvoiceStatus `json:"status,omitempty"`
	// The total amount being paid in taxes.
	TotalTaxAmount *float64 `json:"total_tax_amount,omitempty"`
	// The invoice's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The invoice's remaining balance.
	Balance *float64 `json:"balance,omitempty"`
	// When the third party's invoice entry was updated.
	RemoteUpdatedAt    *time.Time                       `json:"remote_updated_at,omitempty"`
	TrackingCategories []*InvoiceTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The accounting period that the Invoice was generated in.
	AccountingPeriod *InvoiceAccountingPeriod     `json:"accounting_period,omitempty"`
	PurchaseOrders   []*InvoicePurchaseOrdersItem `json:"purchase_orders,omitempty"`
	// Array of `Payment` object IDs.
	Payments []*InvoicePaymentsItem `json:"payments,omitempty"`
	// A list of the Payment Applied to Lines common models related to a given Invoice, Credit Note, or Journal Entry.
	AppliedPayments []*InvoiceAppliedPaymentsItem `json:"applied_payments,omitempty"`
	LineItems       []*InvoiceLineItem            `json:"line_items,omitempty"`
	// `CreditNoteApplyLines` applied to the Invoice.
	AppliedCreditNotes []*InvoiceAppliedCreditNotesItem `json:"applied_credit_notes,omitempty"`
	// `VendorCreditApplyLines` applied to the Invoice.
	AppliedVendorCredits []*InvoiceAppliedVendorCreditsItem `json:"applied_vendor_credits,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Invoice) UnmarshalJSON(data []byte) error {
	type unmarshaler Invoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Invoice(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Invoice) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The accounting period that the Invoice was generated in.
type InvoiceAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewInvoiceAccountingPeriodFromString(value string) *InvoiceAccountingPeriod {
	return &InvoiceAccountingPeriod{typeName: "string", String: value}
}

func NewInvoiceAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *InvoiceAccountingPeriod {
	return &InvoiceAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (i *InvoiceAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		i.typeName = "accountingPeriod"
		i.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "accountingPeriod":
		return json.Marshal(i.AccountingPeriod)
	}
}

type InvoiceAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (i *InvoiceAccountingPeriod) Accept(visitor InvoiceAccountingPeriodVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(i.AccountingPeriod)
	}
}

type InvoiceAppliedCreditNotesItem struct {
	typeName                      string
	String                        string
	CreditNoteApplyLineForInvoice *CreditNoteApplyLineForInvoice
}

func NewInvoiceAppliedCreditNotesItemFromString(value string) *InvoiceAppliedCreditNotesItem {
	return &InvoiceAppliedCreditNotesItem{typeName: "string", String: value}
}

func NewInvoiceAppliedCreditNotesItemFromCreditNoteApplyLineForInvoice(value *CreditNoteApplyLineForInvoice) *InvoiceAppliedCreditNotesItem {
	return &InvoiceAppliedCreditNotesItem{typeName: "creditNoteApplyLineForInvoice", CreditNoteApplyLineForInvoice: value}
}

func (i *InvoiceAppliedCreditNotesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueCreditNoteApplyLineForInvoice := new(CreditNoteApplyLineForInvoice)
	if err := json.Unmarshal(data, &valueCreditNoteApplyLineForInvoice); err == nil {
		i.typeName = "creditNoteApplyLineForInvoice"
		i.CreditNoteApplyLineForInvoice = valueCreditNoteApplyLineForInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceAppliedCreditNotesItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "creditNoteApplyLineForInvoice":
		return json.Marshal(i.CreditNoteApplyLineForInvoice)
	}
}

type InvoiceAppliedCreditNotesItemVisitor interface {
	VisitString(string) error
	VisitCreditNoteApplyLineForInvoice(*CreditNoteApplyLineForInvoice) error
}

func (i *InvoiceAppliedCreditNotesItem) Accept(visitor InvoiceAppliedCreditNotesItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "creditNoteApplyLineForInvoice":
		return visitor.VisitCreditNoteApplyLineForInvoice(i.CreditNoteApplyLineForInvoice)
	}
}

type InvoiceAppliedPaymentsItem struct {
	typeName        string
	String          string
	PaymentLineItem *PaymentLineItem
}

func NewInvoiceAppliedPaymentsItemFromString(value string) *InvoiceAppliedPaymentsItem {
	return &InvoiceAppliedPaymentsItem{typeName: "string", String: value}
}

func NewInvoiceAppliedPaymentsItemFromPaymentLineItem(value *PaymentLineItem) *InvoiceAppliedPaymentsItem {
	return &InvoiceAppliedPaymentsItem{typeName: "paymentLineItem", PaymentLineItem: value}
}

func (i *InvoiceAppliedPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		i.typeName = "paymentLineItem"
		i.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceAppliedPaymentsItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "paymentLineItem":
		return json.Marshal(i.PaymentLineItem)
	}
}

type InvoiceAppliedPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (i *InvoiceAppliedPaymentsItem) Accept(visitor InvoiceAppliedPaymentsItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "paymentLineItem":
		return visitor.VisitPaymentLineItem(i.PaymentLineItem)
	}
}

type InvoiceAppliedVendorCreditsItem struct {
	typeName                        string
	String                          string
	VendorCreditApplyLineForInvoice *VendorCreditApplyLineForInvoice
}

func NewInvoiceAppliedVendorCreditsItemFromString(value string) *InvoiceAppliedVendorCreditsItem {
	return &InvoiceAppliedVendorCreditsItem{typeName: "string", String: value}
}

func NewInvoiceAppliedVendorCreditsItemFromVendorCreditApplyLineForInvoice(value *VendorCreditApplyLineForInvoice) *InvoiceAppliedVendorCreditsItem {
	return &InvoiceAppliedVendorCreditsItem{typeName: "vendorCreditApplyLineForInvoice", VendorCreditApplyLineForInvoice: value}
}

func (i *InvoiceAppliedVendorCreditsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueVendorCreditApplyLineForInvoice := new(VendorCreditApplyLineForInvoice)
	if err := json.Unmarshal(data, &valueVendorCreditApplyLineForInvoice); err == nil {
		i.typeName = "vendorCreditApplyLineForInvoice"
		i.VendorCreditApplyLineForInvoice = valueVendorCreditApplyLineForInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceAppliedVendorCreditsItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "vendorCreditApplyLineForInvoice":
		return json.Marshal(i.VendorCreditApplyLineForInvoice)
	}
}

type InvoiceAppliedVendorCreditsItemVisitor interface {
	VisitString(string) error
	VisitVendorCreditApplyLineForInvoice(*VendorCreditApplyLineForInvoice) error
}

func (i *InvoiceAppliedVendorCreditsItem) Accept(visitor InvoiceAppliedVendorCreditsItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "vendorCreditApplyLineForInvoice":
		return visitor.VisitVendorCreditApplyLineForInvoice(i.VendorCreditApplyLineForInvoice)
	}
}

// The company the invoice belongs to.
type InvoiceCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewInvoiceCompanyFromString(value string) *InvoiceCompany {
	return &InvoiceCompany{typeName: "string", String: value}
}

func NewInvoiceCompanyFromCompanyInfo(value *CompanyInfo) *InvoiceCompany {
	return &InvoiceCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (i *InvoiceCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		i.typeName = "companyInfo"
		i.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceCompany) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "companyInfo":
		return json.Marshal(i.CompanyInfo)
	}
}

type InvoiceCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (i *InvoiceCompany) Accept(visitor InvoiceCompanyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(i.CompanyInfo)
	}
}

// The invoice's contact.
type InvoiceContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewInvoiceContactFromString(value string) *InvoiceContact {
	return &InvoiceContact{typeName: "string", String: value}
}

func NewInvoiceContactFromContact(value *Contact) *InvoiceContact {
	return &InvoiceContact{typeName: "contact", Contact: value}
}

func (i *InvoiceContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		i.typeName = "contact"
		i.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceContact) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "contact":
		return json.Marshal(i.Contact)
	}
}

type InvoiceContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (i *InvoiceContact) Accept(visitor InvoiceContactVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "contact":
		return visitor.VisitContact(i.Contact)
	}
}

// The invoice's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type InvoiceCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewInvoiceCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *InvoiceCurrency {
	return &InvoiceCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewInvoiceCurrencyFromString(value string) *InvoiceCurrency {
	return &InvoiceCurrency{typeName: "string", String: value}
}

func (i *InvoiceCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		i.typeName = "transactionCurrencyEnum"
		i.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceCurrency) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return json.Marshal(i.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type InvoiceCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (i *InvoiceCurrency) Accept(visitor InvoiceCurrencyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(i.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// The employee this overall transaction relates to.
type InvoiceEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewInvoiceEmployeeFromString(value string) *InvoiceEmployee {
	return &InvoiceEmployee{typeName: "string", String: value}
}

func NewInvoiceEmployeeFromEmployee(value *Employee) *InvoiceEmployee {
	return &InvoiceEmployee{typeName: "employee", Employee: value}
}

func (i *InvoiceEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		i.typeName = "employee"
		i.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceEmployee) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "employee":
		return json.Marshal(i.Employee)
	}
}

type InvoiceEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (i *InvoiceEmployee) Accept(visitor InvoiceEmployeeVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "employee":
		return visitor.VisitEmployee(i.Employee)
	}
}

// # The InvoiceLineItem Object
//
// ### Description
//
// The `InvoiceLineItem` object represents an itemized record of goods and/or services sold to a customer.
//
// ### Usage Example
//
// Fetch from the `GET Invoice` endpoint and view the invoice's line items.
type InvoiceLineItem struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The line item's description.
	Description *string `json:"description,omitempty"`
	// The line item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// The line item's quantity.
	Quantity *float64 `json:"quantity,omitempty"`
	// The line item's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The employee this overall transaction relates to.
	Employee *InvoiceLineItemEmployee `json:"employee,omitempty"`
	// The line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *InvoiceLineItemCurrency `json:"currency,omitempty"`
	// The line item's exchange rate.
	ExchangeRate *string                 `json:"exchange_rate,omitempty"`
	Item         *InvoiceLineItemItem    `json:"item,omitempty"`
	Account      *InvoiceLineItemAccount `json:"account,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate          *string                          `json:"tax_rate,omitempty"`
	TrackingCategory *InvoiceLineItemTrackingCategory `json:"tracking_category,omitempty"`
	// The invoice line item's associated tracking categories.
	TrackingCategories []*InvoiceLineItemTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The company the invoice belongs to.
	Company *string `json:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceLineItem(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItem) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewInvoiceLineItemAccountFromString(value string) *InvoiceLineItemAccount {
	return &InvoiceLineItemAccount{typeName: "string", String: value}
}

func NewInvoiceLineItemAccountFromAccount(value *Account) *InvoiceLineItemAccount {
	return &InvoiceLineItemAccount{typeName: "account", Account: value}
}

func (i *InvoiceLineItemAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		i.typeName = "account"
		i.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemAccount) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "account":
		return json.Marshal(i.Account)
	}
}

type InvoiceLineItemAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (i *InvoiceLineItemAccount) Accept(visitor InvoiceLineItemAccountVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "account":
		return visitor.VisitAccount(i.Account)
	}
}

// The line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type InvoiceLineItemCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewInvoiceLineItemCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *InvoiceLineItemCurrency {
	return &InvoiceLineItemCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewInvoiceLineItemCurrencyFromString(value string) *InvoiceLineItemCurrency {
	return &InvoiceLineItemCurrency{typeName: "string", String: value}
}

func (i *InvoiceLineItemCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		i.typeName = "transactionCurrencyEnum"
		i.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemCurrency) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return json.Marshal(i.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type InvoiceLineItemCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (i *InvoiceLineItemCurrency) Accept(visitor InvoiceLineItemCurrencyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(i.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// The employee this overall transaction relates to.
type InvoiceLineItemEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewInvoiceLineItemEmployeeFromString(value string) *InvoiceLineItemEmployee {
	return &InvoiceLineItemEmployee{typeName: "string", String: value}
}

func NewInvoiceLineItemEmployeeFromEmployee(value *Employee) *InvoiceLineItemEmployee {
	return &InvoiceLineItemEmployee{typeName: "employee", Employee: value}
}

func (i *InvoiceLineItemEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		i.typeName = "employee"
		i.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemEmployee) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "employee":
		return json.Marshal(i.Employee)
	}
}

type InvoiceLineItemEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (i *InvoiceLineItemEmployee) Accept(visitor InvoiceLineItemEmployeeVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "employee":
		return visitor.VisitEmployee(i.Employee)
	}
}

type InvoiceLineItemItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewInvoiceLineItemItemFromString(value string) *InvoiceLineItemItem {
	return &InvoiceLineItemItem{typeName: "string", String: value}
}

func NewInvoiceLineItemItemFromItem(value *Item) *InvoiceLineItemItem {
	return &InvoiceLineItemItem{typeName: "item", Item: value}
}

func (i *InvoiceLineItemItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		i.typeName = "item"
		i.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "item":
		return json.Marshal(i.Item)
	}
}

type InvoiceLineItemItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (i *InvoiceLineItemItem) Accept(visitor InvoiceLineItemItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "item":
		return visitor.VisitItem(i.Item)
	}
}

// # The InvoiceLineItem Object
//
// ### Description
//
// The `InvoiceLineItem` object represents an itemized record of goods and/or services sold to a customer.
//
// ### Usage Example
//
// Fetch from the `GET Invoice` endpoint and view the invoice's line items.
type InvoiceLineItemRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The line item's description.
	Description *string `json:"description,omitempty"`
	// The line item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// The line item's quantity.
	Quantity *float64 `json:"quantity,omitempty"`
	// The line item's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The employee this overall transaction relates to.
	Employee *InvoiceLineItemRequestEmployee `json:"employee,omitempty"`
	// The line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *InvoiceLineItemRequestCurrency `json:"currency,omitempty"`
	// The line item's exchange rate.
	ExchangeRate *string                        `json:"exchange_rate,omitempty"`
	Item         *InvoiceLineItemRequestItem    `json:"item,omitempty"`
	Account      *InvoiceLineItemRequestAccount `json:"account,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate          *string                                 `json:"tax_rate,omitempty"`
	TrackingCategory *InvoiceLineItemRequestTrackingCategory `json:"tracking_category,omitempty"`
	// The invoice line item's associated tracking categories.
	TrackingCategories []*InvoiceLineItemRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The company the invoice belongs to.
	Company             *string                `json:"company,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceLineItemRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceLineItemRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceLineItemRequest(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewInvoiceLineItemRequestAccountFromString(value string) *InvoiceLineItemRequestAccount {
	return &InvoiceLineItemRequestAccount{typeName: "string", String: value}
}

func NewInvoiceLineItemRequestAccountFromAccount(value *Account) *InvoiceLineItemRequestAccount {
	return &InvoiceLineItemRequestAccount{typeName: "account", Account: value}
}

func (i *InvoiceLineItemRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		i.typeName = "account"
		i.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestAccount) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "account":
		return json.Marshal(i.Account)
	}
}

type InvoiceLineItemRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (i *InvoiceLineItemRequestAccount) Accept(visitor InvoiceLineItemRequestAccountVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "account":
		return visitor.VisitAccount(i.Account)
	}
}

// The line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type InvoiceLineItemRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewInvoiceLineItemRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *InvoiceLineItemRequestCurrency {
	return &InvoiceLineItemRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewInvoiceLineItemRequestCurrencyFromString(value string) *InvoiceLineItemRequestCurrency {
	return &InvoiceLineItemRequestCurrency{typeName: "string", String: value}
}

func (i *InvoiceLineItemRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		i.typeName = "transactionCurrencyEnum"
		i.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestCurrency) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return json.Marshal(i.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type InvoiceLineItemRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (i *InvoiceLineItemRequestCurrency) Accept(visitor InvoiceLineItemRequestCurrencyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(i.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// The employee this overall transaction relates to.
type InvoiceLineItemRequestEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewInvoiceLineItemRequestEmployeeFromString(value string) *InvoiceLineItemRequestEmployee {
	return &InvoiceLineItemRequestEmployee{typeName: "string", String: value}
}

func NewInvoiceLineItemRequestEmployeeFromEmployee(value *Employee) *InvoiceLineItemRequestEmployee {
	return &InvoiceLineItemRequestEmployee{typeName: "employee", Employee: value}
}

func (i *InvoiceLineItemRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		i.typeName = "employee"
		i.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestEmployee) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "employee":
		return json.Marshal(i.Employee)
	}
}

type InvoiceLineItemRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (i *InvoiceLineItemRequestEmployee) Accept(visitor InvoiceLineItemRequestEmployeeVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "employee":
		return visitor.VisitEmployee(i.Employee)
	}
}

type InvoiceLineItemRequestItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewInvoiceLineItemRequestItemFromString(value string) *InvoiceLineItemRequestItem {
	return &InvoiceLineItemRequestItem{typeName: "string", String: value}
}

func NewInvoiceLineItemRequestItemFromItem(value *Item) *InvoiceLineItemRequestItem {
	return &InvoiceLineItemRequestItem{typeName: "item", Item: value}
}

func (i *InvoiceLineItemRequestItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		i.typeName = "item"
		i.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "item":
		return json.Marshal(i.Item)
	}
}

type InvoiceLineItemRequestItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (i *InvoiceLineItemRequestItem) Accept(visitor InvoiceLineItemRequestItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "item":
		return visitor.VisitItem(i.Item)
	}
}

type InvoiceLineItemRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewInvoiceLineItemRequestTrackingCategoriesItemFromString(value string) *InvoiceLineItemRequestTrackingCategoriesItem {
	return &InvoiceLineItemRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewInvoiceLineItemRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *InvoiceLineItemRequestTrackingCategoriesItem {
	return &InvoiceLineItemRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (i *InvoiceLineItemRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typeName = "trackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "trackingCategory":
		return json.Marshal(i.TrackingCategory)
	}
}

type InvoiceLineItemRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceLineItemRequestTrackingCategoriesItem) Accept(visitor InvoiceLineItemRequestTrackingCategoriesItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
}

type InvoiceLineItemRequestTrackingCategory struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewInvoiceLineItemRequestTrackingCategoryFromString(value string) *InvoiceLineItemRequestTrackingCategory {
	return &InvoiceLineItemRequestTrackingCategory{typeName: "string", String: value}
}

func NewInvoiceLineItemRequestTrackingCategoryFromTrackingCategory(value *TrackingCategory) *InvoiceLineItemRequestTrackingCategory {
	return &InvoiceLineItemRequestTrackingCategory{typeName: "trackingCategory", TrackingCategory: value}
}

func (i *InvoiceLineItemRequestTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typeName = "trackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestTrackingCategory) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "trackingCategory":
		return json.Marshal(i.TrackingCategory)
	}
}

type InvoiceLineItemRequestTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceLineItemRequestTrackingCategory) Accept(visitor InvoiceLineItemRequestTrackingCategoryVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
}

type InvoiceLineItemTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewInvoiceLineItemTrackingCategoriesItemFromString(value string) *InvoiceLineItemTrackingCategoriesItem {
	return &InvoiceLineItemTrackingCategoriesItem{typeName: "string", String: value}
}

func NewInvoiceLineItemTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *InvoiceLineItemTrackingCategoriesItem {
	return &InvoiceLineItemTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (i *InvoiceLineItemTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typeName = "trackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "trackingCategory":
		return json.Marshal(i.TrackingCategory)
	}
}

type InvoiceLineItemTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceLineItemTrackingCategoriesItem) Accept(visitor InvoiceLineItemTrackingCategoriesItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
}

type InvoiceLineItemTrackingCategory struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewInvoiceLineItemTrackingCategoryFromString(value string) *InvoiceLineItemTrackingCategory {
	return &InvoiceLineItemTrackingCategory{typeName: "string", String: value}
}

func NewInvoiceLineItemTrackingCategoryFromTrackingCategory(value *TrackingCategory) *InvoiceLineItemTrackingCategory {
	return &InvoiceLineItemTrackingCategory{typeName: "trackingCategory", TrackingCategory: value}
}

func (i *InvoiceLineItemTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typeName = "trackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemTrackingCategory) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "trackingCategory":
		return json.Marshal(i.TrackingCategory)
	}
}

type InvoiceLineItemTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceLineItemTrackingCategory) Accept(visitor InvoiceLineItemTrackingCategoryVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
}

type InvoicePaymentsItem struct {
	typeName string
	String   string
	Payment  *Payment
}

func NewInvoicePaymentsItemFromString(value string) *InvoicePaymentsItem {
	return &InvoicePaymentsItem{typeName: "string", String: value}
}

func NewInvoicePaymentsItemFromPayment(value *Payment) *InvoicePaymentsItem {
	return &InvoicePaymentsItem{typeName: "payment", Payment: value}
}

func (i *InvoicePaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		i.typeName = "payment"
		i.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoicePaymentsItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "payment":
		return json.Marshal(i.Payment)
	}
}

type InvoicePaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (i *InvoicePaymentsItem) Accept(visitor InvoicePaymentsItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "payment":
		return visitor.VisitPayment(i.Payment)
	}
}

type InvoicePurchaseOrdersItem struct {
	typeName      string
	String        string
	PurchaseOrder *PurchaseOrder
}

func NewInvoicePurchaseOrdersItemFromString(value string) *InvoicePurchaseOrdersItem {
	return &InvoicePurchaseOrdersItem{typeName: "string", String: value}
}

func NewInvoicePurchaseOrdersItemFromPurchaseOrder(value *PurchaseOrder) *InvoicePurchaseOrdersItem {
	return &InvoicePurchaseOrdersItem{typeName: "purchaseOrder", PurchaseOrder: value}
}

func (i *InvoicePurchaseOrdersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valuePurchaseOrder := new(PurchaseOrder)
	if err := json.Unmarshal(data, &valuePurchaseOrder); err == nil {
		i.typeName = "purchaseOrder"
		i.PurchaseOrder = valuePurchaseOrder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoicePurchaseOrdersItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "purchaseOrder":
		return json.Marshal(i.PurchaseOrder)
	}
}

type InvoicePurchaseOrdersItemVisitor interface {
	VisitString(string) error
	VisitPurchaseOrder(*PurchaseOrder) error
}

func (i *InvoicePurchaseOrdersItem) Accept(visitor InvoicePurchaseOrdersItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "purchaseOrder":
		return visitor.VisitPurchaseOrder(i.PurchaseOrder)
	}
}

// # The Invoice Object
//
// ### Description
//
// The `Invoice` object represents an itemized record of goods and/or services sold to a customer or bought from a vendor.
//
// Represents a Bill when the `Invoice` type is `ACCOUNTS_PAYABLE`. References an Invoice when the `Invoice` type is `ACCOUNTS_RECEIVABLE`.
//
// ### Usage Example
//
// Fetch from the `LIST Invoices` endpoint and view a company's invoices.
type InvoiceRequest struct {
	// Whether the invoice is an accounts receivable or accounts payable. If `type` is `ACCOUNTS_PAYABLE`, the invoice is a bill. If `type` is `ACCOUNTS_RECEIVABLE`, it is an invoice.
	//
	// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	Type *InvoiceRequestType `json:"type,omitempty"`
	// The invoice's contact.
	Contact *InvoiceRequestContact `json:"contact,omitempty"`
	// The invoice's number.
	Number *string `json:"number,omitempty"`
	// The invoice's issue date.
	IssueDate *time.Time `json:"issue_date,omitempty"`
	// The invoice's due date.
	DueDate *time.Time `json:"due_date,omitempty"`
	// The invoice's paid date.
	PaidOnDate *time.Time `json:"paid_on_date,omitempty"`
	// The employee this overall transaction relates to.
	Employee *InvoiceRequestEmployee `json:"employee,omitempty"`
	// The invoice's private note.
	Memo *string `json:"memo,omitempty"`
	// The status of the invoice.
	//
	// - `PAID` - PAID
	// - `DRAFT` - DRAFT
	// - `SUBMITTED` - SUBMITTED
	// - `PARTIALLY_PAID` - PARTIALLY_PAID
	// - `OPEN` - OPEN
	// - `VOID` - VOID
	Status *InvoiceRequestStatus `json:"status,omitempty"`
	// The company the invoice belongs to.
	Company *InvoiceRequestCompany `json:"company,omitempty"`
	// The invoice's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *InvoiceRequestCurrency `json:"currency,omitempty"`
	// The invoice's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The total discounts applied to the total cost.
	TotalDiscount *float64 `json:"total_discount,omitempty"`
	// The total amount being paid before taxes.
	SubTotal *float64 `json:"sub_total,omitempty"`
	// The total amount being paid in taxes.
	TotalTaxAmount *float64 `json:"total_tax_amount,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty"`
	// The invoice's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The invoice's remaining balance.
	Balance *float64 `json:"balance,omitempty"`
	// Array of `Payment` object IDs.
	Payments            []*InvoiceRequestPaymentsItem           `json:"payments,omitempty"`
	TrackingCategories  []*InvoiceRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	LineItems           []*InvoiceLineItemRequest               `json:"line_items,omitempty"`
	PurchaseOrders      []*InvoiceRequestPurchaseOrdersItem     `json:"purchase_orders,omitempty"`
	IntegrationParams   map[string]interface{}                  `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}                  `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest                   `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRequest(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The company the invoice belongs to.
type InvoiceRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewInvoiceRequestCompanyFromString(value string) *InvoiceRequestCompany {
	return &InvoiceRequestCompany{typeName: "string", String: value}
}

func NewInvoiceRequestCompanyFromCompanyInfo(value *CompanyInfo) *InvoiceRequestCompany {
	return &InvoiceRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (i *InvoiceRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		i.typeName = "companyInfo"
		i.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestCompany) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "companyInfo":
		return json.Marshal(i.CompanyInfo)
	}
}

type InvoiceRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (i *InvoiceRequestCompany) Accept(visitor InvoiceRequestCompanyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(i.CompanyInfo)
	}
}

// The invoice's contact.
type InvoiceRequestContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewInvoiceRequestContactFromString(value string) *InvoiceRequestContact {
	return &InvoiceRequestContact{typeName: "string", String: value}
}

func NewInvoiceRequestContactFromContact(value *Contact) *InvoiceRequestContact {
	return &InvoiceRequestContact{typeName: "contact", Contact: value}
}

func (i *InvoiceRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		i.typeName = "contact"
		i.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestContact) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "contact":
		return json.Marshal(i.Contact)
	}
}

type InvoiceRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (i *InvoiceRequestContact) Accept(visitor InvoiceRequestContactVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "contact":
		return visitor.VisitContact(i.Contact)
	}
}

// The invoice's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type InvoiceRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewInvoiceRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *InvoiceRequestCurrency {
	return &InvoiceRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewInvoiceRequestCurrencyFromString(value string) *InvoiceRequestCurrency {
	return &InvoiceRequestCurrency{typeName: "string", String: value}
}

func (i *InvoiceRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		i.typeName = "transactionCurrencyEnum"
		i.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestCurrency) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return json.Marshal(i.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type InvoiceRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (i *InvoiceRequestCurrency) Accept(visitor InvoiceRequestCurrencyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(i.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// The employee this overall transaction relates to.
type InvoiceRequestEmployee struct {
	typeName string
	String   string
	Employee *Employee
}

func NewInvoiceRequestEmployeeFromString(value string) *InvoiceRequestEmployee {
	return &InvoiceRequestEmployee{typeName: "string", String: value}
}

func NewInvoiceRequestEmployeeFromEmployee(value *Employee) *InvoiceRequestEmployee {
	return &InvoiceRequestEmployee{typeName: "employee", Employee: value}
}

func (i *InvoiceRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		i.typeName = "employee"
		i.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestEmployee) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "employee":
		return json.Marshal(i.Employee)
	}
}

type InvoiceRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (i *InvoiceRequestEmployee) Accept(visitor InvoiceRequestEmployeeVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "employee":
		return visitor.VisitEmployee(i.Employee)
	}
}

type InvoiceRequestPaymentsItem struct {
	typeName string
	String   string
	Payment  *Payment
}

func NewInvoiceRequestPaymentsItemFromString(value string) *InvoiceRequestPaymentsItem {
	return &InvoiceRequestPaymentsItem{typeName: "string", String: value}
}

func NewInvoiceRequestPaymentsItemFromPayment(value *Payment) *InvoiceRequestPaymentsItem {
	return &InvoiceRequestPaymentsItem{typeName: "payment", Payment: value}
}

func (i *InvoiceRequestPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		i.typeName = "payment"
		i.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestPaymentsItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "payment":
		return json.Marshal(i.Payment)
	}
}

type InvoiceRequestPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (i *InvoiceRequestPaymentsItem) Accept(visitor InvoiceRequestPaymentsItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "payment":
		return visitor.VisitPayment(i.Payment)
	}
}

type InvoiceRequestPurchaseOrdersItem struct {
	typeName      string
	String        string
	PurchaseOrder *PurchaseOrder
}

func NewInvoiceRequestPurchaseOrdersItemFromString(value string) *InvoiceRequestPurchaseOrdersItem {
	return &InvoiceRequestPurchaseOrdersItem{typeName: "string", String: value}
}

func NewInvoiceRequestPurchaseOrdersItemFromPurchaseOrder(value *PurchaseOrder) *InvoiceRequestPurchaseOrdersItem {
	return &InvoiceRequestPurchaseOrdersItem{typeName: "purchaseOrder", PurchaseOrder: value}
}

func (i *InvoiceRequestPurchaseOrdersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valuePurchaseOrder := new(PurchaseOrder)
	if err := json.Unmarshal(data, &valuePurchaseOrder); err == nil {
		i.typeName = "purchaseOrder"
		i.PurchaseOrder = valuePurchaseOrder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestPurchaseOrdersItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "purchaseOrder":
		return json.Marshal(i.PurchaseOrder)
	}
}

type InvoiceRequestPurchaseOrdersItemVisitor interface {
	VisitString(string) error
	VisitPurchaseOrder(*PurchaseOrder) error
}

func (i *InvoiceRequestPurchaseOrdersItem) Accept(visitor InvoiceRequestPurchaseOrdersItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "purchaseOrder":
		return visitor.VisitPurchaseOrder(i.PurchaseOrder)
	}
}

// The status of the invoice.
//
// - `PAID` - PAID
// - `DRAFT` - DRAFT
// - `SUBMITTED` - SUBMITTED
// - `PARTIALLY_PAID` - PARTIALLY_PAID
// - `OPEN` - OPEN
// - `VOID` - VOID
type InvoiceRequestStatus struct {
	typeName          string
	InvoiceStatusEnum InvoiceStatusEnum
	String            string
}

func NewInvoiceRequestStatusFromInvoiceStatusEnum(value InvoiceStatusEnum) *InvoiceRequestStatus {
	return &InvoiceRequestStatus{typeName: "invoiceStatusEnum", InvoiceStatusEnum: value}
}

func NewInvoiceRequestStatusFromString(value string) *InvoiceRequestStatus {
	return &InvoiceRequestStatus{typeName: "string", String: value}
}

func (i *InvoiceRequestStatus) UnmarshalJSON(data []byte) error {
	var valueInvoiceStatusEnum InvoiceStatusEnum
	if err := json.Unmarshal(data, &valueInvoiceStatusEnum); err == nil {
		i.typeName = "invoiceStatusEnum"
		i.InvoiceStatusEnum = valueInvoiceStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "invoiceStatusEnum":
		return json.Marshal(i.InvoiceStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type InvoiceRequestStatusVisitor interface {
	VisitInvoiceStatusEnum(InvoiceStatusEnum) error
	VisitString(string) error
}

func (i *InvoiceRequestStatus) Accept(visitor InvoiceRequestStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "invoiceStatusEnum":
		return visitor.VisitInvoiceStatusEnum(i.InvoiceStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

type InvoiceRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewInvoiceRequestTrackingCategoriesItemFromString(value string) *InvoiceRequestTrackingCategoriesItem {
	return &InvoiceRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewInvoiceRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *InvoiceRequestTrackingCategoriesItem {
	return &InvoiceRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (i *InvoiceRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typeName = "trackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "trackingCategory":
		return json.Marshal(i.TrackingCategory)
	}
}

type InvoiceRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceRequestTrackingCategoriesItem) Accept(visitor InvoiceRequestTrackingCategoriesItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
}

// Whether the invoice is an accounts receivable or accounts payable. If `type` is `ACCOUNTS_PAYABLE`, the invoice is a bill. If `type` is `ACCOUNTS_RECEIVABLE`, it is an invoice.
//
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
type InvoiceRequestType struct {
	typeName        string
	InvoiceTypeEnum InvoiceTypeEnum
	String          string
}

func NewInvoiceRequestTypeFromInvoiceTypeEnum(value InvoiceTypeEnum) *InvoiceRequestType {
	return &InvoiceRequestType{typeName: "invoiceTypeEnum", InvoiceTypeEnum: value}
}

func NewInvoiceRequestTypeFromString(value string) *InvoiceRequestType {
	return &InvoiceRequestType{typeName: "string", String: value}
}

func (i *InvoiceRequestType) UnmarshalJSON(data []byte) error {
	var valueInvoiceTypeEnum InvoiceTypeEnum
	if err := json.Unmarshal(data, &valueInvoiceTypeEnum); err == nil {
		i.typeName = "invoiceTypeEnum"
		i.InvoiceTypeEnum = valueInvoiceTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestType) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "invoiceTypeEnum":
		return json.Marshal(i.InvoiceTypeEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type InvoiceRequestTypeVisitor interface {
	VisitInvoiceTypeEnum(InvoiceTypeEnum) error
	VisitString(string) error
}

func (i *InvoiceRequestType) Accept(visitor InvoiceRequestTypeVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "invoiceTypeEnum":
		return visitor.VisitInvoiceTypeEnum(i.InvoiceTypeEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

type InvoiceResponse struct {
	Model    *Invoice                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceResponse(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The status of the invoice.
//
// - `PAID` - PAID
// - `DRAFT` - DRAFT
// - `SUBMITTED` - SUBMITTED
// - `PARTIALLY_PAID` - PARTIALLY_PAID
// - `OPEN` - OPEN
// - `VOID` - VOID
type InvoiceStatus struct {
	typeName          string
	InvoiceStatusEnum InvoiceStatusEnum
	String            string
}

func NewInvoiceStatusFromInvoiceStatusEnum(value InvoiceStatusEnum) *InvoiceStatus {
	return &InvoiceStatus{typeName: "invoiceStatusEnum", InvoiceStatusEnum: value}
}

func NewInvoiceStatusFromString(value string) *InvoiceStatus {
	return &InvoiceStatus{typeName: "string", String: value}
}

func (i *InvoiceStatus) UnmarshalJSON(data []byte) error {
	var valueInvoiceStatusEnum InvoiceStatusEnum
	if err := json.Unmarshal(data, &valueInvoiceStatusEnum); err == nil {
		i.typeName = "invoiceStatusEnum"
		i.InvoiceStatusEnum = valueInvoiceStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "invoiceStatusEnum":
		return json.Marshal(i.InvoiceStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type InvoiceStatusVisitor interface {
	VisitInvoiceStatusEnum(InvoiceStatusEnum) error
	VisitString(string) error
}

func (i *InvoiceStatus) Accept(visitor InvoiceStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "invoiceStatusEnum":
		return visitor.VisitInvoiceStatusEnum(i.InvoiceStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `PAID` - PAID
// - `DRAFT` - DRAFT
// - `SUBMITTED` - SUBMITTED
// - `PARTIALLY_PAID` - PARTIALLY_PAID
// - `OPEN` - OPEN
// - `VOID` - VOID
type InvoiceStatusEnum string

const (
	InvoiceStatusEnumPaid          InvoiceStatusEnum = "PAID"
	InvoiceStatusEnumDraft         InvoiceStatusEnum = "DRAFT"
	InvoiceStatusEnumSubmitted     InvoiceStatusEnum = "SUBMITTED"
	InvoiceStatusEnumPartiallyPaid InvoiceStatusEnum = "PARTIALLY_PAID"
	InvoiceStatusEnumOpen          InvoiceStatusEnum = "OPEN"
	InvoiceStatusEnumVoid          InvoiceStatusEnum = "VOID"
)

func NewInvoiceStatusEnumFromString(s string) (InvoiceStatusEnum, error) {
	switch s {
	case "PAID":
		return InvoiceStatusEnumPaid, nil
	case "DRAFT":
		return InvoiceStatusEnumDraft, nil
	case "SUBMITTED":
		return InvoiceStatusEnumSubmitted, nil
	case "PARTIALLY_PAID":
		return InvoiceStatusEnumPartiallyPaid, nil
	case "OPEN":
		return InvoiceStatusEnumOpen, nil
	case "VOID":
		return InvoiceStatusEnumVoid, nil
	}
	var t InvoiceStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceStatusEnum) Ptr() *InvoiceStatusEnum {
	return &i
}

type InvoiceTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewInvoiceTrackingCategoriesItemFromString(value string) *InvoiceTrackingCategoriesItem {
	return &InvoiceTrackingCategoriesItem{typeName: "string", String: value}
}

func NewInvoiceTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *InvoiceTrackingCategoriesItem {
	return &InvoiceTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (i *InvoiceTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typeName = "trackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "trackingCategory":
		return json.Marshal(i.TrackingCategory)
	}
}

type InvoiceTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceTrackingCategoriesItem) Accept(visitor InvoiceTrackingCategoriesItemVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
}

// Whether the invoice is an accounts receivable or accounts payable. If `type` is `ACCOUNTS_PAYABLE`, the invoice is a bill. If `type` is `ACCOUNTS_RECEIVABLE`, it is an invoice.
//
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
type InvoiceType struct {
	typeName        string
	InvoiceTypeEnum InvoiceTypeEnum
	String          string
}

func NewInvoiceTypeFromInvoiceTypeEnum(value InvoiceTypeEnum) *InvoiceType {
	return &InvoiceType{typeName: "invoiceTypeEnum", InvoiceTypeEnum: value}
}

func NewInvoiceTypeFromString(value string) *InvoiceType {
	return &InvoiceType{typeName: "string", String: value}
}

func (i *InvoiceType) UnmarshalJSON(data []byte) error {
	var valueInvoiceTypeEnum InvoiceTypeEnum
	if err := json.Unmarshal(data, &valueInvoiceTypeEnum); err == nil {
		i.typeName = "invoiceTypeEnum"
		i.InvoiceTypeEnum = valueInvoiceTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceType) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "invoiceTypeEnum":
		return json.Marshal(i.InvoiceTypeEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type InvoiceTypeVisitor interface {
	VisitInvoiceTypeEnum(InvoiceTypeEnum) error
	VisitString(string) error
}

func (i *InvoiceType) Accept(visitor InvoiceTypeVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "invoiceTypeEnum":
		return visitor.VisitInvoiceTypeEnum(i.InvoiceTypeEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
type InvoiceTypeEnum string

const (
	InvoiceTypeEnumAccountsReceivable InvoiceTypeEnum = "ACCOUNTS_RECEIVABLE"
	InvoiceTypeEnumAccountsPayable    InvoiceTypeEnum = "ACCOUNTS_PAYABLE"
)

func NewInvoiceTypeEnumFromString(s string) (InvoiceTypeEnum, error) {
	switch s {
	case "ACCOUNTS_RECEIVABLE":
		return InvoiceTypeEnumAccountsReceivable, nil
	case "ACCOUNTS_PAYABLE":
		return InvoiceTypeEnumAccountsPayable, nil
	}
	var t InvoiceTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceTypeEnum) Ptr() *InvoiceTypeEnum {
	return &i
}

type Issue struct {
	Id *string `json:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// - `ONGOING` - ONGOING
	// - `RESOLVED` - RESOLVED
	Status            *IssueStatus           `json:"status,omitempty"`
	ErrorDescription  string                 `json:"error_description"`
	EndUser           map[string]interface{} `json:"end_user,omitempty"`
	FirstIncidentTime *time.Time             `json:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time             `json:"last_incident_time,omitempty"`
	IsMuted           *bool                  `json:"is_muted,omitempty"`
	ErrorDetails      []string               `json:"error_details,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	type unmarshaler Issue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Issue(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Issue) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatus struct {
	typeName        string
	IssueStatusEnum IssueStatusEnum
	String          string
}

func NewIssueStatusFromIssueStatusEnum(value IssueStatusEnum) *IssueStatus {
	return &IssueStatus{typeName: "issueStatusEnum", IssueStatusEnum: value}
}

func NewIssueStatusFromString(value string) *IssueStatus {
	return &IssueStatus{typeName: "string", String: value}
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typeName = "issueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return json.Marshal(i.IssueStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatusEnum string

const (
	IssueStatusEnumOngoing  IssueStatusEnum = "ONGOING"
	IssueStatusEnumResolved IssueStatusEnum = "RESOLVED"
)

func NewIssueStatusEnumFromString(s string) (IssueStatusEnum, error) {
	switch s {
	case "ONGOING":
		return IssueStatusEnumOngoing, nil
	case "RESOLVED":
		return IssueStatusEnumResolved, nil
	}
	var t IssueStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatusEnum) Ptr() *IssueStatusEnum {
	return &i
}

// # The Item Object
//
// ### Description
//
// The `Item` object refers to the goods involved in a transaction.
//
// ### Usage Example
//
// Fetch from the `LIST Items` endpoint and view a company's items.
type Item struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The item's name.
	Name *string `json:"name,omitempty"`
	// The item's status.
	//
	// - `ACTIVE` - ACTIVE
	// - `ARCHIVED` - ARCHIVED
	Status *ItemStatus `json:"status,omitempty"`
	// The item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// The price at which the item is purchased from a vendor.
	PurchasePrice *float64 `json:"purchase_price,omitempty"`
	// References the default account used to record a purchase of the item.
	PurchaseAccount *ItemPurchaseAccount `json:"purchase_account,omitempty"`
	// References the default account used to record a sale.
	SalesAccount *ItemSalesAccount `json:"sales_account,omitempty"`
	// The company the item belongs to.
	Company *ItemCompany `json:"company,omitempty"`
	// The default purchase tax rate for this item.
	PurchaseTaxRate *ItemPurchaseTaxRate `json:"purchase_tax_rate,omitempty"`
	// The default sales tax rate for this item.
	SalesTaxRate *ItemSalesTaxRate `json:"sales_tax_rate,omitempty"`
	// When the third party's item note was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Item) UnmarshalJSON(data []byte) error {
	type unmarshaler Item
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Item(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Item) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The company the item belongs to.
type ItemCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewItemCompanyFromString(value string) *ItemCompany {
	return &ItemCompany{typeName: "string", String: value}
}

func NewItemCompanyFromCompanyInfo(value *CompanyInfo) *ItemCompany {
	return &ItemCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (i *ItemCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		i.typeName = "companyInfo"
		i.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemCompany) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "companyInfo":
		return json.Marshal(i.CompanyInfo)
	}
}

type ItemCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (i *ItemCompany) Accept(visitor ItemCompanyVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(i.CompanyInfo)
	}
}

// - `string` - uuid
// - `number` - url
// - `date` - email
// - `datetime` - phone
// - `bool` - currency
// - `list` - decimal
type ItemFormatEnum string

const (
	ItemFormatEnumString   ItemFormatEnum = "string"
	ItemFormatEnumNumber   ItemFormatEnum = "number"
	ItemFormatEnumDate     ItemFormatEnum = "date"
	ItemFormatEnumDatetime ItemFormatEnum = "datetime"
	ItemFormatEnumBool     ItemFormatEnum = "bool"
	ItemFormatEnumList     ItemFormatEnum = "list"
)

func NewItemFormatEnumFromString(s string) (ItemFormatEnum, error) {
	switch s {
	case "string":
		return ItemFormatEnumString, nil
	case "number":
		return ItemFormatEnumNumber, nil
	case "date":
		return ItemFormatEnumDate, nil
	case "datetime":
		return ItemFormatEnumDatetime, nil
	case "bool":
		return ItemFormatEnumBool, nil
	case "list":
		return ItemFormatEnumList, nil
	}
	var t ItemFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ItemFormatEnum) Ptr() *ItemFormatEnum {
	return &i
}

// References the default account used to record a purchase of the item.
type ItemPurchaseAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewItemPurchaseAccountFromString(value string) *ItemPurchaseAccount {
	return &ItemPurchaseAccount{typeName: "string", String: value}
}

func NewItemPurchaseAccountFromAccount(value *Account) *ItemPurchaseAccount {
	return &ItemPurchaseAccount{typeName: "account", Account: value}
}

func (i *ItemPurchaseAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		i.typeName = "account"
		i.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemPurchaseAccount) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "account":
		return json.Marshal(i.Account)
	}
}

type ItemPurchaseAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (i *ItemPurchaseAccount) Accept(visitor ItemPurchaseAccountVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "account":
		return visitor.VisitAccount(i.Account)
	}
}

// The default purchase tax rate for this item.
type ItemPurchaseTaxRate struct {
	typeName string
	String   string
	TaxRate  *TaxRate
}

func NewItemPurchaseTaxRateFromString(value string) *ItemPurchaseTaxRate {
	return &ItemPurchaseTaxRate{typeName: "string", String: value}
}

func NewItemPurchaseTaxRateFromTaxRate(value *TaxRate) *ItemPurchaseTaxRate {
	return &ItemPurchaseTaxRate{typeName: "taxRate", TaxRate: value}
}

func (i *ItemPurchaseTaxRate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueTaxRate := new(TaxRate)
	if err := json.Unmarshal(data, &valueTaxRate); err == nil {
		i.typeName = "taxRate"
		i.TaxRate = valueTaxRate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemPurchaseTaxRate) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "taxRate":
		return json.Marshal(i.TaxRate)
	}
}

type ItemPurchaseTaxRateVisitor interface {
	VisitString(string) error
	VisitTaxRate(*TaxRate) error
}

func (i *ItemPurchaseTaxRate) Accept(visitor ItemPurchaseTaxRateVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "taxRate":
		return visitor.VisitTaxRate(i.TaxRate)
	}
}

// References the default account used to record a sale.
type ItemSalesAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewItemSalesAccountFromString(value string) *ItemSalesAccount {
	return &ItemSalesAccount{typeName: "string", String: value}
}

func NewItemSalesAccountFromAccount(value *Account) *ItemSalesAccount {
	return &ItemSalesAccount{typeName: "account", Account: value}
}

func (i *ItemSalesAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		i.typeName = "account"
		i.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemSalesAccount) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "account":
		return json.Marshal(i.Account)
	}
}

type ItemSalesAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (i *ItemSalesAccount) Accept(visitor ItemSalesAccountVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "account":
		return visitor.VisitAccount(i.Account)
	}
}

// The default sales tax rate for this item.
type ItemSalesTaxRate struct {
	typeName string
	String   string
	TaxRate  *TaxRate
}

func NewItemSalesTaxRateFromString(value string) *ItemSalesTaxRate {
	return &ItemSalesTaxRate{typeName: "string", String: value}
}

func NewItemSalesTaxRateFromTaxRate(value *TaxRate) *ItemSalesTaxRate {
	return &ItemSalesTaxRate{typeName: "taxRate", TaxRate: value}
}

func (i *ItemSalesTaxRate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	valueTaxRate := new(TaxRate)
	if err := json.Unmarshal(data, &valueTaxRate); err == nil {
		i.typeName = "taxRate"
		i.TaxRate = valueTaxRate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemSalesTaxRate) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "taxRate":
		return json.Marshal(i.TaxRate)
	}
}

type ItemSalesTaxRateVisitor interface {
	VisitString(string) error
	VisitTaxRate(*TaxRate) error
}

func (i *ItemSalesTaxRate) Accept(visitor ItemSalesTaxRateVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "taxRate":
		return visitor.VisitTaxRate(i.TaxRate)
	}
}

type ItemSchema struct {
	ItemType    *ItemTypeEnum   `json:"item_type,omitempty"`
	ItemFormat  *ItemFormatEnum `json:"item_format,omitempty"`
	ItemChoices []string        `json:"item_choices,omitempty"`

	_rawJSON json.RawMessage
}

func (i *ItemSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemSchema(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemSchema) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The item's status.
//
// - `ACTIVE` - ACTIVE
// - `ARCHIVED` - ARCHIVED
type ItemStatus struct {
	typeName      string
	Status7D1Enum Status7D1Enum
	String        string
}

func NewItemStatusFromStatus7D1Enum(value Status7D1Enum) *ItemStatus {
	return &ItemStatus{typeName: "status7D1Enum", Status7D1Enum: value}
}

func NewItemStatusFromString(value string) *ItemStatus {
	return &ItemStatus{typeName: "string", String: value}
}

func (i *ItemStatus) UnmarshalJSON(data []byte) error {
	var valueStatus7D1Enum Status7D1Enum
	if err := json.Unmarshal(data, &valueStatus7D1Enum); err == nil {
		i.typeName = "status7D1Enum"
		i.Status7D1Enum = valueStatus7D1Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "status7D1Enum":
		return json.Marshal(i.Status7D1Enum)
	case "string":
		return json.Marshal(i.String)
	}
}

type ItemStatusVisitor interface {
	VisitStatus7D1Enum(Status7D1Enum) error
	VisitString(string) error
}

func (i *ItemStatus) Accept(visitor ItemStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "status7D1Enum":
		return visitor.VisitStatus7D1Enum(i.Status7D1Enum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `string` - string
// - `number` - number
// - `date` - date
// - `datetime` - datetime
// - `bool` - bool
// - `list` - list
type ItemTypeEnum string

const (
	ItemTypeEnumString   ItemTypeEnum = "string"
	ItemTypeEnumNumber   ItemTypeEnum = "number"
	ItemTypeEnumDate     ItemTypeEnum = "date"
	ItemTypeEnumDatetime ItemTypeEnum = "datetime"
	ItemTypeEnumBool     ItemTypeEnum = "bool"
	ItemTypeEnumList     ItemTypeEnum = "list"
)

func NewItemTypeEnumFromString(s string) (ItemTypeEnum, error) {
	switch s {
	case "string":
		return ItemTypeEnumString, nil
	case "number":
		return ItemTypeEnumNumber, nil
	case "date":
		return ItemTypeEnumDate, nil
	case "datetime":
		return ItemTypeEnumDatetime, nil
	case "bool":
		return ItemTypeEnumBool, nil
	case "list":
		return ItemTypeEnumList, nil
	}
	var t ItemTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ItemTypeEnum) Ptr() *ItemTypeEnum {
	return &i
}

// # The JournalEntry Object
//
// ### Description
//
// A `JournalEntry` is a record of a transaction or event that is entered into a company's accounting system.
//
// The `JournalEntry` common model contains records that are automatically created as a result of a certain type of transaction, like an Invoice, and records that are manually created against a company’s ledger.
//
// The lines of a given `JournalEntry` object should always sum to 0. A positive `net_amount` means the line represents a debit and a negative net_amount represents a credit.
//
// ### Usage Example
//
// Fetch from the `GET JournalEntry` endpoint and view a company's journey entry.
type JournalEntry struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The journal entry's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// Array of `Payment` object IDs.
	Payments []*JournalEntryPaymentsItem `json:"payments,omitempty"`
	// A list of the Payment Applied to Lines common models related to a given Invoice, Credit Note, or Journal Entry.
	AppliedPayments []*JournalEntryAppliedPaymentsItem `json:"applied_payments,omitempty"`
	// The journal entry's private note.
	Memo *string `json:"memo,omitempty"`
	// The journal's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *JournalEntryCurrency `json:"currency,omitempty"`
	// The journal entry's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the journal entry belongs to.
	Company *JournalEntryCompany `json:"company,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool          `json:"inclusive_of_tax,omitempty"`
	Lines          []*JournalLine `json:"lines,omitempty"`
	// Reference number for identifying journal entries.
	JournalNumber      *string                               `json:"journal_number,omitempty"`
	TrackingCategories []*JournalEntryTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// The journal's posting status.
	//
	// - `UNPOSTED` - UNPOSTED
	// - `POSTED` - POSTED
	PostingStatus *JournalEntryPostingStatus `json:"posting_status,omitempty"`
	// The accounting period that the JournalEntry was generated in.
	AccountingPeriod *JournalEntryAccountingPeriod `json:"accounting_period,omitempty"`
	// When the third party's journal entry was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's journal entry was updated.
	RemoteUpdatedAt *time.Time             `json:"remote_updated_at,omitempty"`
	FieldMappings   map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData      []*RemoteData          `json:"remote_data,omitempty"`
	RemoteFields    []*RemoteField         `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JournalEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler JournalEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JournalEntry(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalEntry) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The accounting period that the JournalEntry was generated in.
type JournalEntryAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewJournalEntryAccountingPeriodFromString(value string) *JournalEntryAccountingPeriod {
	return &JournalEntryAccountingPeriod{typeName: "string", String: value}
}

func NewJournalEntryAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *JournalEntryAccountingPeriod {
	return &JournalEntryAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (j *JournalEntryAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		j.typeName = "accountingPeriod"
		j.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "accountingPeriod":
		return json.Marshal(j.AccountingPeriod)
	}
}

type JournalEntryAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (j *JournalEntryAccountingPeriod) Accept(visitor JournalEntryAccountingPeriodVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(j.AccountingPeriod)
	}
}

type JournalEntryAppliedPaymentsItem struct {
	typeName        string
	String          string
	PaymentLineItem *PaymentLineItem
}

func NewJournalEntryAppliedPaymentsItemFromString(value string) *JournalEntryAppliedPaymentsItem {
	return &JournalEntryAppliedPaymentsItem{typeName: "string", String: value}
}

func NewJournalEntryAppliedPaymentsItemFromPaymentLineItem(value *PaymentLineItem) *JournalEntryAppliedPaymentsItem {
	return &JournalEntryAppliedPaymentsItem{typeName: "paymentLineItem", PaymentLineItem: value}
}

func (j *JournalEntryAppliedPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		j.typeName = "paymentLineItem"
		j.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryAppliedPaymentsItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "paymentLineItem":
		return json.Marshal(j.PaymentLineItem)
	}
}

type JournalEntryAppliedPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (j *JournalEntryAppliedPaymentsItem) Accept(visitor JournalEntryAppliedPaymentsItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "paymentLineItem":
		return visitor.VisitPaymentLineItem(j.PaymentLineItem)
	}
}

// The company the journal entry belongs to.
type JournalEntryCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewJournalEntryCompanyFromString(value string) *JournalEntryCompany {
	return &JournalEntryCompany{typeName: "string", String: value}
}

func NewJournalEntryCompanyFromCompanyInfo(value *CompanyInfo) *JournalEntryCompany {
	return &JournalEntryCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (j *JournalEntryCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		j.typeName = "companyInfo"
		j.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryCompany) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "companyInfo":
		return json.Marshal(j.CompanyInfo)
	}
}

type JournalEntryCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (j *JournalEntryCompany) Accept(visitor JournalEntryCompanyVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(j.CompanyInfo)
	}
}

// The journal's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type JournalEntryCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewJournalEntryCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *JournalEntryCurrency {
	return &JournalEntryCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewJournalEntryCurrencyFromString(value string) *JournalEntryCurrency {
	return &JournalEntryCurrency{typeName: "string", String: value}
}

func (j *JournalEntryCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		j.typeName = "transactionCurrencyEnum"
		j.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryCurrency) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "transactionCurrencyEnum":
		return json.Marshal(j.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(j.String)
	}
}

type JournalEntryCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (j *JournalEntryCurrency) Accept(visitor JournalEntryCurrencyVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(j.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(j.String)
	}
}

type JournalEntryPaymentsItem struct {
	typeName string
	String   string
	Payment  *Payment
}

func NewJournalEntryPaymentsItemFromString(value string) *JournalEntryPaymentsItem {
	return &JournalEntryPaymentsItem{typeName: "string", String: value}
}

func NewJournalEntryPaymentsItemFromPayment(value *Payment) *JournalEntryPaymentsItem {
	return &JournalEntryPaymentsItem{typeName: "payment", Payment: value}
}

func (j *JournalEntryPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		j.typeName = "payment"
		j.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryPaymentsItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "payment":
		return json.Marshal(j.Payment)
	}
}

type JournalEntryPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (j *JournalEntryPaymentsItem) Accept(visitor JournalEntryPaymentsItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "payment":
		return visitor.VisitPayment(j.Payment)
	}
}

// The journal's posting status.
//
// - `UNPOSTED` - UNPOSTED
// - `POSTED` - POSTED
type JournalEntryPostingStatus struct {
	typeName          string
	PostingStatusEnum PostingStatusEnum
	String            string
}

func NewJournalEntryPostingStatusFromPostingStatusEnum(value PostingStatusEnum) *JournalEntryPostingStatus {
	return &JournalEntryPostingStatus{typeName: "postingStatusEnum", PostingStatusEnum: value}
}

func NewJournalEntryPostingStatusFromString(value string) *JournalEntryPostingStatus {
	return &JournalEntryPostingStatus{typeName: "string", String: value}
}

func (j *JournalEntryPostingStatus) UnmarshalJSON(data []byte) error {
	var valuePostingStatusEnum PostingStatusEnum
	if err := json.Unmarshal(data, &valuePostingStatusEnum); err == nil {
		j.typeName = "postingStatusEnum"
		j.PostingStatusEnum = valuePostingStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryPostingStatus) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "postingStatusEnum":
		return json.Marshal(j.PostingStatusEnum)
	case "string":
		return json.Marshal(j.String)
	}
}

type JournalEntryPostingStatusVisitor interface {
	VisitPostingStatusEnum(PostingStatusEnum) error
	VisitString(string) error
}

func (j *JournalEntryPostingStatus) Accept(visitor JournalEntryPostingStatusVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "postingStatusEnum":
		return visitor.VisitPostingStatusEnum(j.PostingStatusEnum)
	case "string":
		return visitor.VisitString(j.String)
	}
}

// # The JournalEntry Object
//
// ### Description
//
// The `JournalEntry` object is used to get a record of all manually created entries made in a company’s general ledger. The journal line items for each journal entry should sum to zero.
//
// ### Usage Example
//
// Fetch from the `GET JournalEntry` endpoint and view a company's journey entry.
type JournalEntryRequest struct {
	// The journal entry's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// Array of `Payment` object IDs.
	Payments []*JournalEntryRequestPaymentsItem `json:"payments,omitempty"`
	// The journal entry's private note.
	Memo *string `json:"memo,omitempty"`
	// The journal's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *JournalEntryRequestCurrency `json:"currency,omitempty"`
	// The journal entry's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the journal entry belongs to.
	Company            *JournalEntryRequestCompany                  `json:"company,omitempty"`
	TrackingCategories []*JournalEntryRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool                 `json:"inclusive_of_tax,omitempty"`
	Lines          []*JournalLineRequest `json:"lines,omitempty"`
	// Reference number for identifying journal entries.
	JournalNumber *string `json:"journal_number,omitempty"`
	// The journal's posting status.
	//
	// - `UNPOSTED` - UNPOSTED
	// - `POSTED` - POSTED
	PostingStatus       *JournalEntryRequestPostingStatus `json:"posting_status,omitempty"`
	IntegrationParams   map[string]interface{}            `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}            `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest             `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JournalEntryRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler JournalEntryRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JournalEntryRequest(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalEntryRequest) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The company the journal entry belongs to.
type JournalEntryRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewJournalEntryRequestCompanyFromString(value string) *JournalEntryRequestCompany {
	return &JournalEntryRequestCompany{typeName: "string", String: value}
}

func NewJournalEntryRequestCompanyFromCompanyInfo(value *CompanyInfo) *JournalEntryRequestCompany {
	return &JournalEntryRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (j *JournalEntryRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		j.typeName = "companyInfo"
		j.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestCompany) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "companyInfo":
		return json.Marshal(j.CompanyInfo)
	}
}

type JournalEntryRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (j *JournalEntryRequestCompany) Accept(visitor JournalEntryRequestCompanyVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(j.CompanyInfo)
	}
}

// The journal's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type JournalEntryRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewJournalEntryRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *JournalEntryRequestCurrency {
	return &JournalEntryRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewJournalEntryRequestCurrencyFromString(value string) *JournalEntryRequestCurrency {
	return &JournalEntryRequestCurrency{typeName: "string", String: value}
}

func (j *JournalEntryRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		j.typeName = "transactionCurrencyEnum"
		j.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestCurrency) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "transactionCurrencyEnum":
		return json.Marshal(j.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(j.String)
	}
}

type JournalEntryRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (j *JournalEntryRequestCurrency) Accept(visitor JournalEntryRequestCurrencyVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(j.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(j.String)
	}
}

type JournalEntryRequestPaymentsItem struct {
	typeName string
	String   string
	Payment  *Payment
}

func NewJournalEntryRequestPaymentsItemFromString(value string) *JournalEntryRequestPaymentsItem {
	return &JournalEntryRequestPaymentsItem{typeName: "string", String: value}
}

func NewJournalEntryRequestPaymentsItemFromPayment(value *Payment) *JournalEntryRequestPaymentsItem {
	return &JournalEntryRequestPaymentsItem{typeName: "payment", Payment: value}
}

func (j *JournalEntryRequestPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		j.typeName = "payment"
		j.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestPaymentsItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "payment":
		return json.Marshal(j.Payment)
	}
}

type JournalEntryRequestPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (j *JournalEntryRequestPaymentsItem) Accept(visitor JournalEntryRequestPaymentsItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "payment":
		return visitor.VisitPayment(j.Payment)
	}
}

// The journal's posting status.
//
// - `UNPOSTED` - UNPOSTED
// - `POSTED` - POSTED
type JournalEntryRequestPostingStatus struct {
	typeName          string
	PostingStatusEnum PostingStatusEnum
	String            string
}

func NewJournalEntryRequestPostingStatusFromPostingStatusEnum(value PostingStatusEnum) *JournalEntryRequestPostingStatus {
	return &JournalEntryRequestPostingStatus{typeName: "postingStatusEnum", PostingStatusEnum: value}
}

func NewJournalEntryRequestPostingStatusFromString(value string) *JournalEntryRequestPostingStatus {
	return &JournalEntryRequestPostingStatus{typeName: "string", String: value}
}

func (j *JournalEntryRequestPostingStatus) UnmarshalJSON(data []byte) error {
	var valuePostingStatusEnum PostingStatusEnum
	if err := json.Unmarshal(data, &valuePostingStatusEnum); err == nil {
		j.typeName = "postingStatusEnum"
		j.PostingStatusEnum = valuePostingStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestPostingStatus) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "postingStatusEnum":
		return json.Marshal(j.PostingStatusEnum)
	case "string":
		return json.Marshal(j.String)
	}
}

type JournalEntryRequestPostingStatusVisitor interface {
	VisitPostingStatusEnum(PostingStatusEnum) error
	VisitString(string) error
}

func (j *JournalEntryRequestPostingStatus) Accept(visitor JournalEntryRequestPostingStatusVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "postingStatusEnum":
		return visitor.VisitPostingStatusEnum(j.PostingStatusEnum)
	case "string":
		return visitor.VisitString(j.String)
	}
}

type JournalEntryRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewJournalEntryRequestTrackingCategoriesItemFromString(value string) *JournalEntryRequestTrackingCategoriesItem {
	return &JournalEntryRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewJournalEntryRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *JournalEntryRequestTrackingCategoriesItem {
	return &JournalEntryRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (j *JournalEntryRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typeName = "trackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "trackingCategory":
		return json.Marshal(j.TrackingCategory)
	}
}

type JournalEntryRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalEntryRequestTrackingCategoriesItem) Accept(visitor JournalEntryRequestTrackingCategoriesItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
}

type JournalEntryResponse struct {
	Model    *JournalEntry               `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JournalEntryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler JournalEntryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JournalEntryResponse(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalEntryResponse) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JournalEntryTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewJournalEntryTrackingCategoriesItemFromString(value string) *JournalEntryTrackingCategoriesItem {
	return &JournalEntryTrackingCategoriesItem{typeName: "string", String: value}
}

func NewJournalEntryTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *JournalEntryTrackingCategoriesItem {
	return &JournalEntryTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (j *JournalEntryTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typeName = "trackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "trackingCategory":
		return json.Marshal(j.TrackingCategory)
	}
}

type JournalEntryTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalEntryTrackingCategoriesItem) Accept(visitor JournalEntryTrackingCategoriesItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
}

// # The JournalLine Object
//
// ### Description
//
// The `JournalLine` object is used to represent a journal entry's line items.
//
// ### Usage Example
//
// Fetch from the `GET JournalEntry` endpoint and view the journal entry's line items.
type JournalLine struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time          `json:"modified_at,omitempty"`
	Account    *JournalLineAccount `json:"account,omitempty"`
	// The value of the line item including taxes and other fees.
	NetAmount        *float64                     `json:"net_amount,omitempty"`
	TrackingCategory *JournalLineTrackingCategory `json:"tracking_category,omitempty"`
	// The journal line item's associated tracking categories.
	TrackingCategories []*JournalLineTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The journal line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *JournalLineCurrency `json:"currency,omitempty"`
	// The company the journal entry belongs to.
	Company  *string `json:"company,omitempty"`
	Employee *string `json:"employee,omitempty"`
	Contact  *string `json:"contact,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The line's description.
	Description *string `json:"description,omitempty"`
	// The journal line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool          `json:"remote_was_deleted,omitempty"`
	RemoteFields     []*RemoteField `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JournalLine) UnmarshalJSON(data []byte) error {
	type unmarshaler JournalLine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JournalLine(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalLine) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JournalLineAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewJournalLineAccountFromString(value string) *JournalLineAccount {
	return &JournalLineAccount{typeName: "string", String: value}
}

func NewJournalLineAccountFromAccount(value *Account) *JournalLineAccount {
	return &JournalLineAccount{typeName: "account", Account: value}
}

func (j *JournalLineAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		j.typeName = "account"
		j.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineAccount) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "account":
		return json.Marshal(j.Account)
	}
}

type JournalLineAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (j *JournalLineAccount) Accept(visitor JournalLineAccountVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "account":
		return visitor.VisitAccount(j.Account)
	}
}

// The journal line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type JournalLineCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewJournalLineCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *JournalLineCurrency {
	return &JournalLineCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewJournalLineCurrencyFromString(value string) *JournalLineCurrency {
	return &JournalLineCurrency{typeName: "string", String: value}
}

func (j *JournalLineCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		j.typeName = "transactionCurrencyEnum"
		j.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineCurrency) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "transactionCurrencyEnum":
		return json.Marshal(j.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(j.String)
	}
}

type JournalLineCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (j *JournalLineCurrency) Accept(visitor JournalLineCurrencyVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(j.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(j.String)
	}
}

// # The JournalLine Object
//
// ### Description
//
// The `JournalLine` object is used to represent a journal entry's line items.
//
// ### Usage Example
//
// Fetch from the `GET JournalEntry` endpoint and view the journal entry's line items.
type JournalLineRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string                    `json:"remote_id,omitempty"`
	Account  *JournalLineRequestAccount `json:"account,omitempty"`
	// The value of the line item including taxes and other fees.
	NetAmount        *float64                            `json:"net_amount,omitempty"`
	TrackingCategory *JournalLineRequestTrackingCategory `json:"tracking_category,omitempty"`
	// The journal line item's associated tracking categories.
	TrackingCategories []*JournalLineRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The journal line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *JournalLineRequestCurrency `json:"currency,omitempty"`
	// The company the journal entry belongs to.
	Company  *string `json:"company,omitempty"`
	Employee *string `json:"employee,omitempty"`
	Contact  *string `json:"contact,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The line's description.
	Description *string `json:"description,omitempty"`
	// The journal line item's exchange rate.
	ExchangeRate        *string                `json:"exchange_rate,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JournalLineRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler JournalLineRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JournalLineRequest(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalLineRequest) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JournalLineRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewJournalLineRequestAccountFromString(value string) *JournalLineRequestAccount {
	return &JournalLineRequestAccount{typeName: "string", String: value}
}

func NewJournalLineRequestAccountFromAccount(value *Account) *JournalLineRequestAccount {
	return &JournalLineRequestAccount{typeName: "account", Account: value}
}

func (j *JournalLineRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		j.typeName = "account"
		j.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestAccount) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "account":
		return json.Marshal(j.Account)
	}
}

type JournalLineRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (j *JournalLineRequestAccount) Accept(visitor JournalLineRequestAccountVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "account":
		return visitor.VisitAccount(j.Account)
	}
}

// The journal line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type JournalLineRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewJournalLineRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *JournalLineRequestCurrency {
	return &JournalLineRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewJournalLineRequestCurrencyFromString(value string) *JournalLineRequestCurrency {
	return &JournalLineRequestCurrency{typeName: "string", String: value}
}

func (j *JournalLineRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		j.typeName = "transactionCurrencyEnum"
		j.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestCurrency) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "transactionCurrencyEnum":
		return json.Marshal(j.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(j.String)
	}
}

type JournalLineRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (j *JournalLineRequestCurrency) Accept(visitor JournalLineRequestCurrencyVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(j.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(j.String)
	}
}

type JournalLineRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewJournalLineRequestTrackingCategoriesItemFromString(value string) *JournalLineRequestTrackingCategoriesItem {
	return &JournalLineRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewJournalLineRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *JournalLineRequestTrackingCategoriesItem {
	return &JournalLineRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (j *JournalLineRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typeName = "trackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "trackingCategory":
		return json.Marshal(j.TrackingCategory)
	}
}

type JournalLineRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalLineRequestTrackingCategoriesItem) Accept(visitor JournalLineRequestTrackingCategoriesItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
}

type JournalLineRequestTrackingCategory struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewJournalLineRequestTrackingCategoryFromString(value string) *JournalLineRequestTrackingCategory {
	return &JournalLineRequestTrackingCategory{typeName: "string", String: value}
}

func NewJournalLineRequestTrackingCategoryFromTrackingCategory(value *TrackingCategory) *JournalLineRequestTrackingCategory {
	return &JournalLineRequestTrackingCategory{typeName: "trackingCategory", TrackingCategory: value}
}

func (j *JournalLineRequestTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typeName = "trackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestTrackingCategory) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "trackingCategory":
		return json.Marshal(j.TrackingCategory)
	}
}

type JournalLineRequestTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalLineRequestTrackingCategory) Accept(visitor JournalLineRequestTrackingCategoryVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
}

type JournalLineTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewJournalLineTrackingCategoriesItemFromString(value string) *JournalLineTrackingCategoriesItem {
	return &JournalLineTrackingCategoriesItem{typeName: "string", String: value}
}

func NewJournalLineTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *JournalLineTrackingCategoriesItem {
	return &JournalLineTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (j *JournalLineTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typeName = "trackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "trackingCategory":
		return json.Marshal(j.TrackingCategory)
	}
}

type JournalLineTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalLineTrackingCategoriesItem) Accept(visitor JournalLineTrackingCategoriesItemVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
}

type JournalLineTrackingCategory struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewJournalLineTrackingCategoryFromString(value string) *JournalLineTrackingCategory {
	return &JournalLineTrackingCategory{typeName: "string", String: value}
}

func NewJournalLineTrackingCategoryFromTrackingCategory(value *TrackingCategory) *JournalLineTrackingCategory {
	return &JournalLineTrackingCategory{typeName: "trackingCategory", TrackingCategory: value}
}

func (j *JournalLineTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typeName = "string"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typeName = "trackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineTrackingCategory) MarshalJSON() ([]byte, error) {
	switch j.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return json.Marshal(j.String)
	case "trackingCategory":
		return json.Marshal(j.TrackingCategory)
	}
}

type JournalLineTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalLineTrackingCategory) Accept(visitor JournalLineTrackingCategoryVisitor) error {
	switch j.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", j.typeName, j)
	case "string":
		return visitor.VisitString(j.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
}

// - `en` - en
// - `de` - de
type LanguageEnum string

const (
	LanguageEnumEn LanguageEnum = "en"
	LanguageEnumDe LanguageEnum = "de"
)

func NewLanguageEnumFromString(s string) (LanguageEnum, error) {
	switch s {
	case "en":
		return LanguageEnumEn, nil
	case "de":
		return LanguageEnumDe, nil
	}
	var t LanguageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LanguageEnum) Ptr() *LanguageEnum {
	return &l
}

type LinkToken struct {
	LinkToken       string  `json:"link_token"`
	IntegrationName *string `json:"integration_name,omitempty"`
	MagicLinkUrl    *string `json:"magic_link_url,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LinkToken) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkToken(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkToken) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request"`

	_rawJSON json.RawMessage
}

func (l *LinkedAccountStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedAccountStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedAccountStatus(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedAccountStatus) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MetaResponse struct {
	RequestSchema                  map[string]interface{} `json:"request_schema,omitempty"`
	RemoteFieldClasses             map[string]interface{} `json:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus   `json:"status,omitempty"`
	HasConditionalParams           bool                   `json:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                   `json:"has_required_linked_account_params"`

	_rawJSON json.RawMessage
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetaResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// - `GET` - GET
// - `OPTIONS` - OPTIONS
// - `HEAD` - HEAD
// - `POST` - POST
// - `PUT` - PUT
// - `PATCH` - PATCH
// - `DELETE` - DELETE
type MethodEnum string

const (
	MethodEnumGet     MethodEnum = "GET"
	MethodEnumOptions MethodEnum = "OPTIONS"
	MethodEnumHead    MethodEnum = "HEAD"
	MethodEnumPost    MethodEnum = "POST"
	MethodEnumPut     MethodEnum = "PUT"
	MethodEnumPatch   MethodEnum = "PATCH"
	MethodEnumDelete  MethodEnum = "DELETE"
)

func NewMethodEnumFromString(s string) (MethodEnum, error) {
	switch s {
	case "GET":
		return MethodEnumGet, nil
	case "OPTIONS":
		return MethodEnumOptions, nil
	case "HEAD":
		return MethodEnumHead, nil
	case "POST":
		return MethodEnumPost, nil
	case "PUT":
		return MethodEnumPut, nil
	case "PATCH":
		return MethodEnumPatch, nil
	case "DELETE":
		return MethodEnumDelete, nil
	}
	var t MethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodEnum) Ptr() *MethodEnum {
	return &m
}

// # The ModelOperation Object
//
// ### Description
//
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
//
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name"`
	AvailableOperations    []string `json:"available_operations,omitempty"`
	RequiredPostParameters []string `json:"required_post_parameters,omitempty"`
	SupportedFields        []string `json:"supported_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelOperation(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelOperation) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializer struct {
	IsEnabled *bool `json:"is_enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelPermissionDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializer(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializer) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializerRequest struct {
	IsEnabled *bool `json:"is_enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializerRequest(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializerRequest) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The MultipartFormField Object
//
// ### Description
//
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
//
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name"`
	// The data for the form field.
	Data string `json:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// - `RAW` - RAW
	// - `BASE64` - BASE64
	// - `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MultipartFormFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipartFormFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipartFormFieldRequest(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipartFormFieldRequest) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	typeName     string
	EncodingEnum EncodingEnum
	String       string
}

func NewMultipartFormFieldRequestEncodingFromEncodingEnum(value EncodingEnum) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "encodingEnum", EncodingEnum: value}
}

func NewMultipartFormFieldRequestEncodingFromString(value string) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "string", String: value}
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typeName = "encodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return json.Marshal(m.EncodingEnum)
	case "string":
		return json.Marshal(m.String)
	}
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	case "string":
		return visitor.VisitString(m.String)
	}
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAccountDetailsAndActionsList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAccountDetailsAndActionsList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAccountDetailsAndActionsList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAccountDetailsAndActionsList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedAccountList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Account `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAccountList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAccountList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAccountList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAccountList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedAccountingAttachmentList struct {
	Next     *string                 `json:"next,omitempty"`
	Previous *string                 `json:"previous,omitempty"`
	Results  []*AccountingAttachment `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAccountingAttachmentList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAccountingAttachmentList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAccountingAttachmentList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAccountingAttachmentList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedAccountingPeriodList struct {
	Next     *string             `json:"next,omitempty"`
	Previous *string             `json:"previous,omitempty"`
	Results  []*AccountingPeriod `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAccountingPeriodList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAccountingPeriodList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAccountingPeriodList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAccountingPeriodList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedAuditLogEventList struct {
	Next     *string          `json:"next,omitempty"`
	Previous *string          `json:"previous,omitempty"`
	Results  []*AuditLogEvent `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAuditLogEventList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAuditLogEventList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAuditLogEventList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAuditLogEventList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedBalanceSheetList struct {
	Next     *string         `json:"next,omitempty"`
	Previous *string         `json:"previous,omitempty"`
	Results  []*BalanceSheet `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedBalanceSheetList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedBalanceSheetList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedBalanceSheetList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedBalanceSheetList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedBankFeedAccountList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*BankFeedAccount `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedBankFeedAccountList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedBankFeedAccountList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedBankFeedAccountList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedBankFeedAccountList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedBankFeedTransactionList struct {
	Next     *string                `json:"next,omitempty"`
	Previous *string                `json:"previous,omitempty"`
	Results  []*BankFeedTransaction `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedBankFeedTransactionList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedBankFeedTransactionList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedBankFeedTransactionList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedBankFeedTransactionList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedCashFlowStatementList struct {
	Next     *string              `json:"next,omitempty"`
	Previous *string              `json:"previous,omitempty"`
	Results  []*CashFlowStatement `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedCashFlowStatementList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedCashFlowStatementList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedCashFlowStatementList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedCashFlowStatementList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedCompanyInfoList struct {
	Next     *string        `json:"next,omitempty"`
	Previous *string        `json:"previous,omitempty"`
	Results  []*CompanyInfo `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedCompanyInfoList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedCompanyInfoList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedCompanyInfoList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedCompanyInfoList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedContactList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Contact `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedContactList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedContactList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedContactList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedContactList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedCreditNoteList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*CreditNote `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedCreditNoteList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedCreditNoteList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedCreditNoteList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedCreditNoteList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedEmployeeList struct {
	Next     *string     `json:"next,omitempty"`
	Previous *string     `json:"previous,omitempty"`
	Results  []*Employee `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedEmployeeList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedEmployeeList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedEmployeeList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedEmployeeList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedExpenseList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Expense `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedExpenseList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedExpenseList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedExpenseList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedExpenseList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedGeneralLedgerTransactionList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*GeneralLedgerTransaction `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedGeneralLedgerTransactionList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedGeneralLedgerTransactionList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedGeneralLedgerTransactionList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedGeneralLedgerTransactionList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedIncomeStatementList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*IncomeStatement `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedIncomeStatementList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedIncomeStatementList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedIncomeStatementList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedIncomeStatementList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedInvoiceList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Invoice `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedInvoiceList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedInvoiceList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedInvoiceList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedInvoiceList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedIssueList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedIssueList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedIssueList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedIssueList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedItemList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Item `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedItemList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedItemList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedItemList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedItemList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedJournalEntryList struct {
	Next     *string         `json:"next,omitempty"`
	Previous *string         `json:"previous,omitempty"`
	Results  []*JournalEntry `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedJournalEntryList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedJournalEntryList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedJournalEntryList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedJournalEntryList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedPaymentList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Payment `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedPaymentList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedPaymentList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedPaymentList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedPaymentList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedPurchaseOrderList struct {
	Next     *string          `json:"next,omitempty"`
	Previous *string          `json:"previous,omitempty"`
	Results  []*PurchaseOrder `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedPurchaseOrderList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedPurchaseOrderList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedPurchaseOrderList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedPurchaseOrderList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedRemoteFieldClassList struct {
	Next     *string             `json:"next,omitempty"`
	Previous *string             `json:"previous,omitempty"`
	Results  []*RemoteFieldClass `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedRemoteFieldClassList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedRemoteFieldClassList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedRemoteFieldClassList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedRemoteFieldClassList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedSyncStatusList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*SyncStatus `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedSyncStatusList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedSyncStatusList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedSyncStatusList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedSyncStatusList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedTaxRateList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*TaxRate `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedTaxRateList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedTaxRateList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedTaxRateList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedTaxRateList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedTrackingCategoryList struct {
	Next     *string             `json:"next,omitempty"`
	Previous *string             `json:"previous,omitempty"`
	Results  []*TrackingCategory `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedTrackingCategoryList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedTrackingCategoryList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedTrackingCategoryList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedTrackingCategoryList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedTransactionList struct {
	Next     *string        `json:"next,omitempty"`
	Previous *string        `json:"previous,omitempty"`
	Results  []*Transaction `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedTransactionList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedTransactionList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedTransactionList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedTransactionList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedVendorCreditList struct {
	Next     *string         `json:"next,omitempty"`
	Previous *string         `json:"previous,omitempty"`
	Results  []*VendorCredit `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedVendorCreditList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedVendorCreditList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedVendorCreditList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedVendorCreditList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The Payment Object
//
// ### Description
//
// The `Payment` object represents general payments made towards a specific transaction.
//
// ### Usage Example
//
// Fetch from the `GET Payment` endpoint and view an invoice's payment.
type PatchedPaymentRequest struct {
	// The payment's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The supplier, or customer involved in the payment.
	Contact *PatchedPaymentRequestContact `json:"contact,omitempty"`
	// The supplier’s or customer’s account in which the payment is made.
	Account *PatchedPaymentRequestAccount `json:"account,omitempty"`
	// The payment's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *PatchedPaymentRequestCurrency `json:"currency,omitempty"`
	// The payment's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the payment belongs to.
	Company *PatchedPaymentRequestCompany `json:"company,omitempty"`
	// The total amount of money being paid to the supplier, or customer, after taxes.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The type of the invoice.
	//
	// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	Type               *PatchedPaymentRequestType                     `json:"type,omitempty"`
	TrackingCategories []*PatchedPaymentRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The accounting period that the Payment was generated in.
	AccountingPeriod *PatchedPaymentRequestAccountingPeriod `json:"accounting_period,omitempty"`
	// A list of “Payment Applied to Lines” objects.
	AppliedToLines      []*PatchedPaymentRequestAppliedToLinesItem `json:"applied_to_lines,omitempty"`
	IntegrationParams   map[string]interface{}                     `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}                     `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest                      `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchedPaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchedPaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchedPaymentRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchedPaymentRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The supplier’s or customer’s account in which the payment is made.
type PatchedPaymentRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewPatchedPaymentRequestAccountFromString(value string) *PatchedPaymentRequestAccount {
	return &PatchedPaymentRequestAccount{typeName: "string", String: value}
}

func NewPatchedPaymentRequestAccountFromAccount(value *Account) *PatchedPaymentRequestAccount {
	return &PatchedPaymentRequestAccount{typeName: "account", Account: value}
}

func (p *PatchedPaymentRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		p.typeName = "account"
		p.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestAccount) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "account":
		return json.Marshal(p.Account)
	}
}

type PatchedPaymentRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (p *PatchedPaymentRequestAccount) Accept(visitor PatchedPaymentRequestAccountVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "account":
		return visitor.VisitAccount(p.Account)
	}
}

// The accounting period that the Payment was generated in.
type PatchedPaymentRequestAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewPatchedPaymentRequestAccountingPeriodFromString(value string) *PatchedPaymentRequestAccountingPeriod {
	return &PatchedPaymentRequestAccountingPeriod{typeName: "string", String: value}
}

func NewPatchedPaymentRequestAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *PatchedPaymentRequestAccountingPeriod {
	return &PatchedPaymentRequestAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (p *PatchedPaymentRequestAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		p.typeName = "accountingPeriod"
		p.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "accountingPeriod":
		return json.Marshal(p.AccountingPeriod)
	}
}

type PatchedPaymentRequestAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (p *PatchedPaymentRequestAccountingPeriod) Accept(visitor PatchedPaymentRequestAccountingPeriodVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(p.AccountingPeriod)
	}
}

type PatchedPaymentRequestAppliedToLinesItem struct {
	typeName               string
	String                 string
	PaymentLineItemRequest *PaymentLineItemRequest
}

func NewPatchedPaymentRequestAppliedToLinesItemFromString(value string) *PatchedPaymentRequestAppliedToLinesItem {
	return &PatchedPaymentRequestAppliedToLinesItem{typeName: "string", String: value}
}

func NewPatchedPaymentRequestAppliedToLinesItemFromPaymentLineItemRequest(value *PaymentLineItemRequest) *PatchedPaymentRequestAppliedToLinesItem {
	return &PatchedPaymentRequestAppliedToLinesItem{typeName: "paymentLineItemRequest", PaymentLineItemRequest: value}
}

func (p *PatchedPaymentRequestAppliedToLinesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valuePaymentLineItemRequest := new(PaymentLineItemRequest)
	if err := json.Unmarshal(data, &valuePaymentLineItemRequest); err == nil {
		p.typeName = "paymentLineItemRequest"
		p.PaymentLineItemRequest = valuePaymentLineItemRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestAppliedToLinesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "paymentLineItemRequest":
		return json.Marshal(p.PaymentLineItemRequest)
	}
}

type PatchedPaymentRequestAppliedToLinesItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItemRequest(*PaymentLineItemRequest) error
}

func (p *PatchedPaymentRequestAppliedToLinesItem) Accept(visitor PatchedPaymentRequestAppliedToLinesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "paymentLineItemRequest":
		return visitor.VisitPaymentLineItemRequest(p.PaymentLineItemRequest)
	}
}

// The company the payment belongs to.
type PatchedPaymentRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewPatchedPaymentRequestCompanyFromString(value string) *PatchedPaymentRequestCompany {
	return &PatchedPaymentRequestCompany{typeName: "string", String: value}
}

func NewPatchedPaymentRequestCompanyFromCompanyInfo(value *CompanyInfo) *PatchedPaymentRequestCompany {
	return &PatchedPaymentRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (p *PatchedPaymentRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typeName = "companyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestCompany) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "companyInfo":
		return json.Marshal(p.CompanyInfo)
	}
}

type PatchedPaymentRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PatchedPaymentRequestCompany) Accept(visitor PatchedPaymentRequestCompanyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
}

// The supplier, or customer involved in the payment.
type PatchedPaymentRequestContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewPatchedPaymentRequestContactFromString(value string) *PatchedPaymentRequestContact {
	return &PatchedPaymentRequestContact{typeName: "string", String: value}
}

func NewPatchedPaymentRequestContactFromContact(value *Contact) *PatchedPaymentRequestContact {
	return &PatchedPaymentRequestContact{typeName: "contact", Contact: value}
}

func (p *PatchedPaymentRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typeName = "contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestContact) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "contact":
		return json.Marshal(p.Contact)
	}
}

type PatchedPaymentRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PatchedPaymentRequestContact) Accept(visitor PatchedPaymentRequestContactVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "contact":
		return visitor.VisitContact(p.Contact)
	}
}

// The payment's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PatchedPaymentRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewPatchedPaymentRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *PatchedPaymentRequestCurrency {
	return &PatchedPaymentRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewPatchedPaymentRequestCurrencyFromString(value string) *PatchedPaymentRequestCurrency {
	return &PatchedPaymentRequestCurrency{typeName: "string", String: value}
}

func (p *PatchedPaymentRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typeName = "transactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestCurrency) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return json.Marshal(p.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PatchedPaymentRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PatchedPaymentRequestCurrency) Accept(visitor PatchedPaymentRequestCurrencyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

type PatchedPaymentRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewPatchedPaymentRequestTrackingCategoriesItemFromString(value string) *PatchedPaymentRequestTrackingCategoriesItem {
	return &PatchedPaymentRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewPatchedPaymentRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *PatchedPaymentRequestTrackingCategoriesItem {
	return &PatchedPaymentRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (p *PatchedPaymentRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typeName = "trackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "trackingCategory":
		return json.Marshal(p.TrackingCategory)
	}
}

type PatchedPaymentRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PatchedPaymentRequestTrackingCategoriesItem) Accept(visitor PatchedPaymentRequestTrackingCategoriesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
}

// The type of the invoice.
//
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
type PatchedPaymentRequestType struct {
	typeName        string
	PaymentTypeEnum PaymentTypeEnum
	String          string
}

func NewPatchedPaymentRequestTypeFromPaymentTypeEnum(value PaymentTypeEnum) *PatchedPaymentRequestType {
	return &PatchedPaymentRequestType{typeName: "paymentTypeEnum", PaymentTypeEnum: value}
}

func NewPatchedPaymentRequestTypeFromString(value string) *PatchedPaymentRequestType {
	return &PatchedPaymentRequestType{typeName: "string", String: value}
}

func (p *PatchedPaymentRequestType) UnmarshalJSON(data []byte) error {
	var valuePaymentTypeEnum PaymentTypeEnum
	if err := json.Unmarshal(data, &valuePaymentTypeEnum); err == nil {
		p.typeName = "paymentTypeEnum"
		p.PaymentTypeEnum = valuePaymentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "paymentTypeEnum":
		return json.Marshal(p.PaymentTypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PatchedPaymentRequestTypeVisitor interface {
	VisitPaymentTypeEnum(PaymentTypeEnum) error
	VisitString(string) error
}

func (p *PatchedPaymentRequestType) Accept(visitor PatchedPaymentRequestTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "paymentTypeEnum":
		return visitor.VisitPaymentTypeEnum(p.PaymentTypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// # The Payment Object
//
// ### Description
//
// The `Payment` object represents general payments made towards a specific transaction.
//
// ### Usage Example
//
// Fetch from the `GET Payment` endpoint and view an invoice's payment.
type Payment struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The payment's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The supplier, or customer involved in the payment.
	Contact *PaymentContact `json:"contact,omitempty"`
	// The supplier’s or customer’s account in which the payment is made.
	Account *PaymentAccount `json:"account,omitempty"`
	// The payment's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *PaymentCurrency `json:"currency,omitempty"`
	// The payment's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the payment belongs to.
	Company *PaymentCompany `json:"company,omitempty"`
	// The total amount of money being paid to the supplier, or customer, after taxes.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The type of the invoice.
	//
	// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	Type               *PaymentType                     `json:"type,omitempty"`
	TrackingCategories []*PaymentTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The accounting period that the Payment was generated in.
	AccountingPeriod *PaymentAccountingPeriod `json:"accounting_period,omitempty"`
	// A list of “Payment Applied to Lines” objects.
	AppliedToLines []*PaymentAppliedToLinesItem `json:"applied_to_lines,omitempty"`
	// When the third party's payment entry was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Payment) UnmarshalJSON(data []byte) error {
	type unmarshaler Payment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payment(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payment) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The supplier’s or customer’s account in which the payment is made.
type PaymentAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewPaymentAccountFromString(value string) *PaymentAccount {
	return &PaymentAccount{typeName: "string", String: value}
}

func NewPaymentAccountFromAccount(value *Account) *PaymentAccount {
	return &PaymentAccount{typeName: "account", Account: value}
}

func (p *PaymentAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		p.typeName = "account"
		p.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentAccount) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "account":
		return json.Marshal(p.Account)
	}
}

type PaymentAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (p *PaymentAccount) Accept(visitor PaymentAccountVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "account":
		return visitor.VisitAccount(p.Account)
	}
}

// The accounting period that the Payment was generated in.
type PaymentAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewPaymentAccountingPeriodFromString(value string) *PaymentAccountingPeriod {
	return &PaymentAccountingPeriod{typeName: "string", String: value}
}

func NewPaymentAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *PaymentAccountingPeriod {
	return &PaymentAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (p *PaymentAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		p.typeName = "accountingPeriod"
		p.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "accountingPeriod":
		return json.Marshal(p.AccountingPeriod)
	}
}

type PaymentAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (p *PaymentAccountingPeriod) Accept(visitor PaymentAccountingPeriodVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(p.AccountingPeriod)
	}
}

type PaymentAppliedToLinesItem struct {
	typeName        string
	String          string
	PaymentLineItem *PaymentLineItem
}

func NewPaymentAppliedToLinesItemFromString(value string) *PaymentAppliedToLinesItem {
	return &PaymentAppliedToLinesItem{typeName: "string", String: value}
}

func NewPaymentAppliedToLinesItemFromPaymentLineItem(value *PaymentLineItem) *PaymentAppliedToLinesItem {
	return &PaymentAppliedToLinesItem{typeName: "paymentLineItem", PaymentLineItem: value}
}

func (p *PaymentAppliedToLinesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		p.typeName = "paymentLineItem"
		p.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentAppliedToLinesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "paymentLineItem":
		return json.Marshal(p.PaymentLineItem)
	}
}

type PaymentAppliedToLinesItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (p *PaymentAppliedToLinesItem) Accept(visitor PaymentAppliedToLinesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "paymentLineItem":
		return visitor.VisitPaymentLineItem(p.PaymentLineItem)
	}
}

// The company the payment belongs to.
type PaymentCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewPaymentCompanyFromString(value string) *PaymentCompany {
	return &PaymentCompany{typeName: "string", String: value}
}

func NewPaymentCompanyFromCompanyInfo(value *CompanyInfo) *PaymentCompany {
	return &PaymentCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (p *PaymentCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typeName = "companyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentCompany) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "companyInfo":
		return json.Marshal(p.CompanyInfo)
	}
}

type PaymentCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PaymentCompany) Accept(visitor PaymentCompanyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
}

// The supplier, or customer involved in the payment.
type PaymentContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewPaymentContactFromString(value string) *PaymentContact {
	return &PaymentContact{typeName: "string", String: value}
}

func NewPaymentContactFromContact(value *Contact) *PaymentContact {
	return &PaymentContact{typeName: "contact", Contact: value}
}

func (p *PaymentContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typeName = "contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentContact) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "contact":
		return json.Marshal(p.Contact)
	}
}

type PaymentContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PaymentContact) Accept(visitor PaymentContactVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "contact":
		return visitor.VisitContact(p.Contact)
	}
}

// The payment's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PaymentCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewPaymentCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *PaymentCurrency {
	return &PaymentCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewPaymentCurrencyFromString(value string) *PaymentCurrency {
	return &PaymentCurrency{typeName: "string", String: value}
}

func (p *PaymentCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typeName = "transactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentCurrency) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return json.Marshal(p.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PaymentCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PaymentCurrency) Accept(visitor PaymentCurrencyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// # The PaymentLineItem Object
//
// ### Description
//
// The `PaymentLineItem` object is an applied-to-line on a `Payment` that can either be a `Invoice`, `CreditNote`, or `JournalEntry`.
//
// ### Usage Example
//
// `Payment` will have a field called `applied-to-lines` which will be an array of `PaymentLineItemInternalMappingSerializer` objects that can either be a `Invoice`, `CreditNote`, or `JournalEntry`.
type PaymentLineItem struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The amount being applied to the transaction.
	AppliedAmount *string `json:"applied_amount,omitempty"`
	// The date the payment portion is applied.
	AppliedDate *time.Time `json:"applied_date,omitempty"`
	// The Merge ID of the transaction the payment portion is being applied to.
	RelatedObjectId *string `json:"related_object_id,omitempty"`
	// The type of transaction the payment portion is being applied to. Possible values include: INVOICE, JOURNAL_ENTRY, or CREDIT_NOTE.
	RelatedObjectType *string `json:"related_object_type,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaymentLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLineItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLineItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The PaymentLineItem Object
//
// ### Description
//
// The `PaymentLineItem` object is an applied-to-line on a `Payment` that can either be a `Invoice`, `CreditNote`, or `JournalEntry`.
//
// ### Usage Example
//
// `Payment` will have a field called `applied-to-lines` which will be an array of `PaymentLineItemInternalMappingSerializer` objects that can either be a `Invoice`, `CreditNote`, or `JournalEntry`.
type PaymentLineItemRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The amount being applied to the transaction.
	AppliedAmount *string `json:"applied_amount,omitempty"`
	// The date the payment portion is applied.
	AppliedDate *time.Time `json:"applied_date,omitempty"`
	// The Merge ID of the transaction the payment portion is being applied to.
	RelatedObjectId *string `json:"related_object_id,omitempty"`
	// The type of transaction the payment portion is being applied to. Possible values include: INVOICE, JOURNAL_ENTRY, or CREDIT_NOTE.
	RelatedObjectType   *string                `json:"related_object_type,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaymentLineItemRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLineItemRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLineItemRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLineItemRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The Payment Object
//
// ### Description
//
// The `Payment` object represents general payments made towards a specific transaction.
//
// ### Usage Example
//
// Fetch from the `GET Payment` endpoint and view an invoice's payment.
type PaymentRequest struct {
	// The payment's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The supplier, or customer involved in the payment.
	Contact *PaymentRequestContact `json:"contact,omitempty"`
	// The supplier’s or customer’s account in which the payment is made.
	Account *PaymentRequestAccount `json:"account,omitempty"`
	// The payment's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *PaymentRequestCurrency `json:"currency,omitempty"`
	// The payment's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the payment belongs to.
	Company *PaymentRequestCompany `json:"company,omitempty"`
	// The total amount of money being paid to the supplier, or customer, after taxes.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The type of the invoice.
	//
	// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	Type               *PaymentRequestType                     `json:"type,omitempty"`
	TrackingCategories []*PaymentRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The accounting period that the Payment was generated in.
	AccountingPeriod *PaymentRequestAccountingPeriod `json:"accounting_period,omitempty"`
	// A list of “Payment Applied to Lines” objects.
	AppliedToLines      []*PaymentRequestAppliedToLinesItem `json:"applied_to_lines,omitempty"`
	IntegrationParams   map[string]interface{}              `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}              `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest               `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The supplier’s or customer’s account in which the payment is made.
type PaymentRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewPaymentRequestAccountFromString(value string) *PaymentRequestAccount {
	return &PaymentRequestAccount{typeName: "string", String: value}
}

func NewPaymentRequestAccountFromAccount(value *Account) *PaymentRequestAccount {
	return &PaymentRequestAccount{typeName: "account", Account: value}
}

func (p *PaymentRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		p.typeName = "account"
		p.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestAccount) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "account":
		return json.Marshal(p.Account)
	}
}

type PaymentRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (p *PaymentRequestAccount) Accept(visitor PaymentRequestAccountVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "account":
		return visitor.VisitAccount(p.Account)
	}
}

// The accounting period that the Payment was generated in.
type PaymentRequestAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewPaymentRequestAccountingPeriodFromString(value string) *PaymentRequestAccountingPeriod {
	return &PaymentRequestAccountingPeriod{typeName: "string", String: value}
}

func NewPaymentRequestAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *PaymentRequestAccountingPeriod {
	return &PaymentRequestAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (p *PaymentRequestAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		p.typeName = "accountingPeriod"
		p.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "accountingPeriod":
		return json.Marshal(p.AccountingPeriod)
	}
}

type PaymentRequestAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (p *PaymentRequestAccountingPeriod) Accept(visitor PaymentRequestAccountingPeriodVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(p.AccountingPeriod)
	}
}

type PaymentRequestAppliedToLinesItem struct {
	typeName               string
	String                 string
	PaymentLineItemRequest *PaymentLineItemRequest
}

func NewPaymentRequestAppliedToLinesItemFromString(value string) *PaymentRequestAppliedToLinesItem {
	return &PaymentRequestAppliedToLinesItem{typeName: "string", String: value}
}

func NewPaymentRequestAppliedToLinesItemFromPaymentLineItemRequest(value *PaymentLineItemRequest) *PaymentRequestAppliedToLinesItem {
	return &PaymentRequestAppliedToLinesItem{typeName: "paymentLineItemRequest", PaymentLineItemRequest: value}
}

func (p *PaymentRequestAppliedToLinesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valuePaymentLineItemRequest := new(PaymentLineItemRequest)
	if err := json.Unmarshal(data, &valuePaymentLineItemRequest); err == nil {
		p.typeName = "paymentLineItemRequest"
		p.PaymentLineItemRequest = valuePaymentLineItemRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestAppliedToLinesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "paymentLineItemRequest":
		return json.Marshal(p.PaymentLineItemRequest)
	}
}

type PaymentRequestAppliedToLinesItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItemRequest(*PaymentLineItemRequest) error
}

func (p *PaymentRequestAppliedToLinesItem) Accept(visitor PaymentRequestAppliedToLinesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "paymentLineItemRequest":
		return visitor.VisitPaymentLineItemRequest(p.PaymentLineItemRequest)
	}
}

// The company the payment belongs to.
type PaymentRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewPaymentRequestCompanyFromString(value string) *PaymentRequestCompany {
	return &PaymentRequestCompany{typeName: "string", String: value}
}

func NewPaymentRequestCompanyFromCompanyInfo(value *CompanyInfo) *PaymentRequestCompany {
	return &PaymentRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (p *PaymentRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typeName = "companyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestCompany) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "companyInfo":
		return json.Marshal(p.CompanyInfo)
	}
}

type PaymentRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PaymentRequestCompany) Accept(visitor PaymentRequestCompanyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
}

// The supplier, or customer involved in the payment.
type PaymentRequestContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewPaymentRequestContactFromString(value string) *PaymentRequestContact {
	return &PaymentRequestContact{typeName: "string", String: value}
}

func NewPaymentRequestContactFromContact(value *Contact) *PaymentRequestContact {
	return &PaymentRequestContact{typeName: "contact", Contact: value}
}

func (p *PaymentRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typeName = "contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestContact) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "contact":
		return json.Marshal(p.Contact)
	}
}

type PaymentRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PaymentRequestContact) Accept(visitor PaymentRequestContactVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "contact":
		return visitor.VisitContact(p.Contact)
	}
}

// The payment's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PaymentRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewPaymentRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *PaymentRequestCurrency {
	return &PaymentRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewPaymentRequestCurrencyFromString(value string) *PaymentRequestCurrency {
	return &PaymentRequestCurrency{typeName: "string", String: value}
}

func (p *PaymentRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typeName = "transactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestCurrency) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return json.Marshal(p.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PaymentRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PaymentRequestCurrency) Accept(visitor PaymentRequestCurrencyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

type PaymentRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewPaymentRequestTrackingCategoriesItemFromString(value string) *PaymentRequestTrackingCategoriesItem {
	return &PaymentRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewPaymentRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *PaymentRequestTrackingCategoriesItem {
	return &PaymentRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (p *PaymentRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typeName = "trackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "trackingCategory":
		return json.Marshal(p.TrackingCategory)
	}
}

type PaymentRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PaymentRequestTrackingCategoriesItem) Accept(visitor PaymentRequestTrackingCategoriesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
}

// The type of the invoice.
//
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
type PaymentRequestType struct {
	typeName        string
	PaymentTypeEnum PaymentTypeEnum
	String          string
}

func NewPaymentRequestTypeFromPaymentTypeEnum(value PaymentTypeEnum) *PaymentRequestType {
	return &PaymentRequestType{typeName: "paymentTypeEnum", PaymentTypeEnum: value}
}

func NewPaymentRequestTypeFromString(value string) *PaymentRequestType {
	return &PaymentRequestType{typeName: "string", String: value}
}

func (p *PaymentRequestType) UnmarshalJSON(data []byte) error {
	var valuePaymentTypeEnum PaymentTypeEnum
	if err := json.Unmarshal(data, &valuePaymentTypeEnum); err == nil {
		p.typeName = "paymentTypeEnum"
		p.PaymentTypeEnum = valuePaymentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "paymentTypeEnum":
		return json.Marshal(p.PaymentTypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PaymentRequestTypeVisitor interface {
	VisitPaymentTypeEnum(PaymentTypeEnum) error
	VisitString(string) error
}

func (p *PaymentRequestType) Accept(visitor PaymentRequestTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "paymentTypeEnum":
		return visitor.VisitPaymentTypeEnum(p.PaymentTypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

type PaymentResponse struct {
	Model    *Payment                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewPaymentTrackingCategoriesItemFromString(value string) *PaymentTrackingCategoriesItem {
	return &PaymentTrackingCategoriesItem{typeName: "string", String: value}
}

func NewPaymentTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *PaymentTrackingCategoriesItem {
	return &PaymentTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (p *PaymentTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typeName = "trackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "trackingCategory":
		return json.Marshal(p.TrackingCategory)
	}
}

type PaymentTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PaymentTrackingCategoriesItem) Accept(visitor PaymentTrackingCategoriesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
}

// The type of the invoice.
//
// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
type PaymentType struct {
	typeName        string
	PaymentTypeEnum PaymentTypeEnum
	String          string
}

func NewPaymentTypeFromPaymentTypeEnum(value PaymentTypeEnum) *PaymentType {
	return &PaymentType{typeName: "paymentTypeEnum", PaymentTypeEnum: value}
}

func NewPaymentTypeFromString(value string) *PaymentType {
	return &PaymentType{typeName: "string", String: value}
}

func (p *PaymentType) UnmarshalJSON(data []byte) error {
	var valuePaymentTypeEnum PaymentTypeEnum
	if err := json.Unmarshal(data, &valuePaymentTypeEnum); err == nil {
		p.typeName = "paymentTypeEnum"
		p.PaymentTypeEnum = valuePaymentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "paymentTypeEnum":
		return json.Marshal(p.PaymentTypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PaymentTypeVisitor interface {
	VisitPaymentTypeEnum(PaymentTypeEnum) error
	VisitString(string) error
}

func (p *PaymentType) Accept(visitor PaymentTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "paymentTypeEnum":
		return visitor.VisitPaymentTypeEnum(p.PaymentTypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// - `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// - `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
type PaymentTypeEnum string

const (
	PaymentTypeEnumAccountsPayable    PaymentTypeEnum = "ACCOUNTS_PAYABLE"
	PaymentTypeEnumAccountsReceivable PaymentTypeEnum = "ACCOUNTS_RECEIVABLE"
)

func NewPaymentTypeEnumFromString(s string) (PaymentTypeEnum, error) {
	switch s {
	case "ACCOUNTS_PAYABLE":
		return PaymentTypeEnumAccountsPayable, nil
	case "ACCOUNTS_RECEIVABLE":
		return PaymentTypeEnumAccountsReceivable, nil
	}
	var t PaymentTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentTypeEnum) Ptr() *PaymentTypeEnum {
	return &p
}

// - `UNPOSTED` - UNPOSTED
// - `POSTED` - POSTED
type PostingStatusEnum string

const (
	PostingStatusEnumUnposted PostingStatusEnum = "UNPOSTED"
	PostingStatusEnumPosted   PostingStatusEnum = "POSTED"
)

func NewPostingStatusEnumFromString(s string) (PostingStatusEnum, error) {
	switch s {
	case "UNPOSTED":
		return PostingStatusEnumUnposted, nil
	case "POSTED":
		return PostingStatusEnumPosted, nil
	}
	var t PostingStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PostingStatusEnum) Ptr() *PostingStatusEnum {
	return &p
}

// # The PurchaseOrder Object
//
// ### Description
//
// A `PurchaseOrder` represents a request to purchase goods or services from a vendor. It outlines the details of the purchase, such as the items or services requested, quantities, prices, and delivery details.
//
// A `PurchaseOrder` is a crucial component of the procurement process, but does not typically result in any impact on the company’s general ledger. The general ledger is typically only affected when the `PurchaseOrder` is fulfilled as an _Accounts Payable_ `Invoice` object (also known as a Bill).
//
// ### Usage Example
//
// Fetch from the `LIST PurchaseOrders` endpoint and view a company's purchase orders.
type PurchaseOrder struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The purchase order's status.
	//
	// - `DRAFT` - DRAFT
	// - `SUBMITTED` - SUBMITTED
	// - `AUTHORIZED` - AUTHORIZED
	// - `BILLED` - BILLED
	// - `DELETED` - DELETED
	Status *PurchaseOrderStatus `json:"status,omitempty"`
	// The purchase order's issue date.
	IssueDate *time.Time `json:"issue_date,omitempty"`
	// The human-readable number of the purchase order.
	PurchaseOrderNumber *string `json:"purchase_order_number,omitempty"`
	// The purchase order's delivery date.
	DeliveryDate *time.Time `json:"delivery_date,omitempty"`
	// The purchase order's delivery address.
	DeliveryAddress *PurchaseOrderDeliveryAddress `json:"delivery_address,omitempty"`
	// The contact making the purchase order.
	Customer *string `json:"customer,omitempty"`
	// The party fulfilling the purchase order.
	Vendor *PurchaseOrderVendor `json:"vendor,omitempty"`
	// A memo attached to the purchase order.
	Memo *string `json:"memo,omitempty"`
	// The company the purchase order belongs to.
	Company *PurchaseOrderCompany `json:"company,omitempty"`
	// The purchase order's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The purchase order's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *PurchaseOrderCurrency `json:"currency,omitempty"`
	// The purchase order's exchange rate.
	ExchangeRate *string                  `json:"exchange_rate,omitempty"`
	LineItems    []*PurchaseOrderLineItem `json:"line_items,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax     *bool                                  `json:"inclusive_of_tax,omitempty"`
	TrackingCategories []*PurchaseOrderTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// The accounting period that the PurchaseOrder was generated in.
	AccountingPeriod *PurchaseOrderAccountingPeriod `json:"accounting_period,omitempty"`
	// When the third party's purchase order note was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's purchase order note was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PurchaseOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler PurchaseOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PurchaseOrder(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PurchaseOrder) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The accounting period that the PurchaseOrder was generated in.
type PurchaseOrderAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewPurchaseOrderAccountingPeriodFromString(value string) *PurchaseOrderAccountingPeriod {
	return &PurchaseOrderAccountingPeriod{typeName: "string", String: value}
}

func NewPurchaseOrderAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *PurchaseOrderAccountingPeriod {
	return &PurchaseOrderAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (p *PurchaseOrderAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		p.typeName = "accountingPeriod"
		p.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "accountingPeriod":
		return json.Marshal(p.AccountingPeriod)
	}
}

type PurchaseOrderAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (p *PurchaseOrderAccountingPeriod) Accept(visitor PurchaseOrderAccountingPeriodVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(p.AccountingPeriod)
	}
}

// The company the purchase order belongs to.
type PurchaseOrderCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewPurchaseOrderCompanyFromString(value string) *PurchaseOrderCompany {
	return &PurchaseOrderCompany{typeName: "string", String: value}
}

func NewPurchaseOrderCompanyFromCompanyInfo(value *CompanyInfo) *PurchaseOrderCompany {
	return &PurchaseOrderCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (p *PurchaseOrderCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typeName = "companyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderCompany) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "companyInfo":
		return json.Marshal(p.CompanyInfo)
	}
}

type PurchaseOrderCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PurchaseOrderCompany) Accept(visitor PurchaseOrderCompanyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
}

// The purchase order's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PurchaseOrderCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewPurchaseOrderCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *PurchaseOrderCurrency {
	return &PurchaseOrderCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewPurchaseOrderCurrencyFromString(value string) *PurchaseOrderCurrency {
	return &PurchaseOrderCurrency{typeName: "string", String: value}
}

func (p *PurchaseOrderCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typeName = "transactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderCurrency) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return json.Marshal(p.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PurchaseOrderCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PurchaseOrderCurrency) Accept(visitor PurchaseOrderCurrencyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// The purchase order's delivery address.
type PurchaseOrderDeliveryAddress struct {
	typeName string
	String   string
	Address  *Address
}

func NewPurchaseOrderDeliveryAddressFromString(value string) *PurchaseOrderDeliveryAddress {
	return &PurchaseOrderDeliveryAddress{typeName: "string", String: value}
}

func NewPurchaseOrderDeliveryAddressFromAddress(value *Address) *PurchaseOrderDeliveryAddress {
	return &PurchaseOrderDeliveryAddress{typeName: "address", Address: value}
}

func (p *PurchaseOrderDeliveryAddress) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAddress := new(Address)
	if err := json.Unmarshal(data, &valueAddress); err == nil {
		p.typeName = "address"
		p.Address = valueAddress
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderDeliveryAddress) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "address":
		return json.Marshal(p.Address)
	}
}

type PurchaseOrderDeliveryAddressVisitor interface {
	VisitString(string) error
	VisitAddress(*Address) error
}

func (p *PurchaseOrderDeliveryAddress) Accept(visitor PurchaseOrderDeliveryAddressVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "address":
		return visitor.VisitAddress(p.Address)
	}
}

// # The PurchaseOrderLineItem Object
//
// ### Description
//
// The `PurchaseOrderLineItem` object is used to represent a purchase order's line item.
//
// ### Usage Example
//
// Fetch from the `GET PurchaseOrder` endpoint and view a company's purchase orders.
type PurchaseOrderLineItem struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// A description of the good being purchased.
	Description *string `json:"description,omitempty"`
	// The line item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// The line item's quantity.
	Quantity *float64                   `json:"quantity,omitempty"`
	Item     *PurchaseOrderLineItemItem `json:"item,omitempty"`
	// The purchase order line item's account.
	Account *string `json:"account,omitempty"`
	// The purchase order line item's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty"`
	// The purchase order line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty"`
	// The purchase order line item's tax amount.
	TaxAmount *string `json:"tax_amount,omitempty"`
	// The purchase order line item's total amount.
	TotalLineAmount *string `json:"total_line_amount,omitempty"`
	// The purchase order line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *PurchaseOrderLineItemCurrency `json:"currency,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The purchase order line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the purchase order line item belongs to.
	Company *string `json:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool          `json:"remote_was_deleted,omitempty"`
	RemoteFields     []*RemoteField `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PurchaseOrderLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PurchaseOrderLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PurchaseOrderLineItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PurchaseOrderLineItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The purchase order line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PurchaseOrderLineItemCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewPurchaseOrderLineItemCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *PurchaseOrderLineItemCurrency {
	return &PurchaseOrderLineItemCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewPurchaseOrderLineItemCurrencyFromString(value string) *PurchaseOrderLineItemCurrency {
	return &PurchaseOrderLineItemCurrency{typeName: "string", String: value}
}

func (p *PurchaseOrderLineItemCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typeName = "transactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderLineItemCurrency) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return json.Marshal(p.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PurchaseOrderLineItemCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PurchaseOrderLineItemCurrency) Accept(visitor PurchaseOrderLineItemCurrencyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

type PurchaseOrderLineItemItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewPurchaseOrderLineItemItemFromString(value string) *PurchaseOrderLineItemItem {
	return &PurchaseOrderLineItemItem{typeName: "string", String: value}
}

func NewPurchaseOrderLineItemItemFromItem(value *Item) *PurchaseOrderLineItemItem {
	return &PurchaseOrderLineItemItem{typeName: "item", Item: value}
}

func (p *PurchaseOrderLineItemItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		p.typeName = "item"
		p.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderLineItemItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "item":
		return json.Marshal(p.Item)
	}
}

type PurchaseOrderLineItemItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (p *PurchaseOrderLineItemItem) Accept(visitor PurchaseOrderLineItemItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "item":
		return visitor.VisitItem(p.Item)
	}
}

// # The PurchaseOrderLineItem Object
//
// ### Description
//
// The `PurchaseOrderLineItem` object is used to represent a purchase order's line item.
//
// ### Usage Example
//
// Fetch from the `GET PurchaseOrder` endpoint and view a company's purchase orders.
type PurchaseOrderLineItemRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// A description of the good being purchased.
	Description *string `json:"description,omitempty"`
	// The line item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// The line item's quantity.
	Quantity *float64                          `json:"quantity,omitempty"`
	Item     *PurchaseOrderLineItemRequestItem `json:"item,omitempty"`
	// The purchase order line item's account.
	Account *string `json:"account,omitempty"`
	// The purchase order line item's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty"`
	// The purchase order line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty"`
	// The purchase order line item's tax amount.
	TaxAmount *string `json:"tax_amount,omitempty"`
	// The purchase order line item's total amount.
	TotalLineAmount *string `json:"total_line_amount,omitempty"`
	// The purchase order line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *PurchaseOrderLineItemRequestCurrency `json:"currency,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The purchase order line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the purchase order line item belongs to.
	Company             *string                `json:"company,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PurchaseOrderLineItemRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PurchaseOrderLineItemRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PurchaseOrderLineItemRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PurchaseOrderLineItemRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The purchase order line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PurchaseOrderLineItemRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewPurchaseOrderLineItemRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *PurchaseOrderLineItemRequestCurrency {
	return &PurchaseOrderLineItemRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewPurchaseOrderLineItemRequestCurrencyFromString(value string) *PurchaseOrderLineItemRequestCurrency {
	return &PurchaseOrderLineItemRequestCurrency{typeName: "string", String: value}
}

func (p *PurchaseOrderLineItemRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typeName = "transactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderLineItemRequestCurrency) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return json.Marshal(p.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PurchaseOrderLineItemRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PurchaseOrderLineItemRequestCurrency) Accept(visitor PurchaseOrderLineItemRequestCurrencyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

type PurchaseOrderLineItemRequestItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewPurchaseOrderLineItemRequestItemFromString(value string) *PurchaseOrderLineItemRequestItem {
	return &PurchaseOrderLineItemRequestItem{typeName: "string", String: value}
}

func NewPurchaseOrderLineItemRequestItemFromItem(value *Item) *PurchaseOrderLineItemRequestItem {
	return &PurchaseOrderLineItemRequestItem{typeName: "item", Item: value}
}

func (p *PurchaseOrderLineItemRequestItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		p.typeName = "item"
		p.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderLineItemRequestItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "item":
		return json.Marshal(p.Item)
	}
}

type PurchaseOrderLineItemRequestItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (p *PurchaseOrderLineItemRequestItem) Accept(visitor PurchaseOrderLineItemRequestItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "item":
		return visitor.VisitItem(p.Item)
	}
}

// # The PurchaseOrder Object
//
// ### Description
//
// The `PurchaseOrder` object is a record of request for a product or service between a buyer and seller.
//
// ### Usage Example
//
// Fetch from the `LIST PurchaseOrders` endpoint and view a company's purchase orders.
type PurchaseOrderRequest struct {
	// The purchase order's status.
	//
	// - `DRAFT` - DRAFT
	// - `SUBMITTED` - SUBMITTED
	// - `AUTHORIZED` - AUTHORIZED
	// - `BILLED` - BILLED
	// - `DELETED` - DELETED
	Status *PurchaseOrderRequestStatus `json:"status,omitempty"`
	// The purchase order's issue date.
	IssueDate *time.Time `json:"issue_date,omitempty"`
	// The purchase order's delivery date.
	DeliveryDate *time.Time `json:"delivery_date,omitempty"`
	// The purchase order's delivery address.
	DeliveryAddress *PurchaseOrderRequestDeliveryAddress `json:"delivery_address,omitempty"`
	// The contact making the purchase order.
	Customer *string `json:"customer,omitempty"`
	// The party fulfilling the purchase order.
	Vendor *PurchaseOrderRequestVendor `json:"vendor,omitempty"`
	// A memo attached to the purchase order.
	Memo *string `json:"memo,omitempty"`
	// The company the purchase order belongs to.
	Company *PurchaseOrderRequestCompany `json:"company,omitempty"`
	// The purchase order's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The purchase order's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *PurchaseOrderRequestCurrency `json:"currency,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty"`
	// The purchase order's exchange rate.
	ExchangeRate        *string                                       `json:"exchange_rate,omitempty"`
	TrackingCategories  []*PurchaseOrderRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	LineItems           []*PurchaseOrderLineItemRequest               `json:"line_items,omitempty"`
	IntegrationParams   map[string]interface{}                        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}                        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest                         `json:"remote_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PurchaseOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PurchaseOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PurchaseOrderRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PurchaseOrderRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The company the purchase order belongs to.
type PurchaseOrderRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewPurchaseOrderRequestCompanyFromString(value string) *PurchaseOrderRequestCompany {
	return &PurchaseOrderRequestCompany{typeName: "string", String: value}
}

func NewPurchaseOrderRequestCompanyFromCompanyInfo(value *CompanyInfo) *PurchaseOrderRequestCompany {
	return &PurchaseOrderRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (p *PurchaseOrderRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typeName = "companyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderRequestCompany) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "companyInfo":
		return json.Marshal(p.CompanyInfo)
	}
}

type PurchaseOrderRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PurchaseOrderRequestCompany) Accept(visitor PurchaseOrderRequestCompanyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
}

// The purchase order's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type PurchaseOrderRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewPurchaseOrderRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *PurchaseOrderRequestCurrency {
	return &PurchaseOrderRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewPurchaseOrderRequestCurrencyFromString(value string) *PurchaseOrderRequestCurrency {
	return &PurchaseOrderRequestCurrency{typeName: "string", String: value}
}

func (p *PurchaseOrderRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typeName = "transactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderRequestCurrency) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return json.Marshal(p.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PurchaseOrderRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PurchaseOrderRequestCurrency) Accept(visitor PurchaseOrderRequestCurrencyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// The purchase order's delivery address.
type PurchaseOrderRequestDeliveryAddress struct {
	typeName string
	String   string
	Address  *Address
}

func NewPurchaseOrderRequestDeliveryAddressFromString(value string) *PurchaseOrderRequestDeliveryAddress {
	return &PurchaseOrderRequestDeliveryAddress{typeName: "string", String: value}
}

func NewPurchaseOrderRequestDeliveryAddressFromAddress(value *Address) *PurchaseOrderRequestDeliveryAddress {
	return &PurchaseOrderRequestDeliveryAddress{typeName: "address", Address: value}
}

func (p *PurchaseOrderRequestDeliveryAddress) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueAddress := new(Address)
	if err := json.Unmarshal(data, &valueAddress); err == nil {
		p.typeName = "address"
		p.Address = valueAddress
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderRequestDeliveryAddress) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "address":
		return json.Marshal(p.Address)
	}
}

type PurchaseOrderRequestDeliveryAddressVisitor interface {
	VisitString(string) error
	VisitAddress(*Address) error
}

func (p *PurchaseOrderRequestDeliveryAddress) Accept(visitor PurchaseOrderRequestDeliveryAddressVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "address":
		return visitor.VisitAddress(p.Address)
	}
}

// The purchase order's status.
//
// - `DRAFT` - DRAFT
// - `SUBMITTED` - SUBMITTED
// - `AUTHORIZED` - AUTHORIZED
// - `BILLED` - BILLED
// - `DELETED` - DELETED
type PurchaseOrderRequestStatus struct {
	typeName                string
	PurchaseOrderStatusEnum PurchaseOrderStatusEnum
	String                  string
}

func NewPurchaseOrderRequestStatusFromPurchaseOrderStatusEnum(value PurchaseOrderStatusEnum) *PurchaseOrderRequestStatus {
	return &PurchaseOrderRequestStatus{typeName: "purchaseOrderStatusEnum", PurchaseOrderStatusEnum: value}
}

func NewPurchaseOrderRequestStatusFromString(value string) *PurchaseOrderRequestStatus {
	return &PurchaseOrderRequestStatus{typeName: "string", String: value}
}

func (p *PurchaseOrderRequestStatus) UnmarshalJSON(data []byte) error {
	var valuePurchaseOrderStatusEnum PurchaseOrderStatusEnum
	if err := json.Unmarshal(data, &valuePurchaseOrderStatusEnum); err == nil {
		p.typeName = "purchaseOrderStatusEnum"
		p.PurchaseOrderStatusEnum = valuePurchaseOrderStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderRequestStatus) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "purchaseOrderStatusEnum":
		return json.Marshal(p.PurchaseOrderStatusEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PurchaseOrderRequestStatusVisitor interface {
	VisitPurchaseOrderStatusEnum(PurchaseOrderStatusEnum) error
	VisitString(string) error
}

func (p *PurchaseOrderRequestStatus) Accept(visitor PurchaseOrderRequestStatusVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "purchaseOrderStatusEnum":
		return visitor.VisitPurchaseOrderStatusEnum(p.PurchaseOrderStatusEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

type PurchaseOrderRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewPurchaseOrderRequestTrackingCategoriesItemFromString(value string) *PurchaseOrderRequestTrackingCategoriesItem {
	return &PurchaseOrderRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewPurchaseOrderRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *PurchaseOrderRequestTrackingCategoriesItem {
	return &PurchaseOrderRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (p *PurchaseOrderRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typeName = "trackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "trackingCategory":
		return json.Marshal(p.TrackingCategory)
	}
}

type PurchaseOrderRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PurchaseOrderRequestTrackingCategoriesItem) Accept(visitor PurchaseOrderRequestTrackingCategoriesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
}

// The party fulfilling the purchase order.
type PurchaseOrderRequestVendor struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewPurchaseOrderRequestVendorFromString(value string) *PurchaseOrderRequestVendor {
	return &PurchaseOrderRequestVendor{typeName: "string", String: value}
}

func NewPurchaseOrderRequestVendorFromContact(value *Contact) *PurchaseOrderRequestVendor {
	return &PurchaseOrderRequestVendor{typeName: "contact", Contact: value}
}

func (p *PurchaseOrderRequestVendor) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typeName = "contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderRequestVendor) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "contact":
		return json.Marshal(p.Contact)
	}
}

type PurchaseOrderRequestVendorVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PurchaseOrderRequestVendor) Accept(visitor PurchaseOrderRequestVendorVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "contact":
		return visitor.VisitContact(p.Contact)
	}
}

type PurchaseOrderResponse struct {
	Model    *PurchaseOrder              `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PurchaseOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PurchaseOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PurchaseOrderResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PurchaseOrderResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The purchase order's status.
//
// - `DRAFT` - DRAFT
// - `SUBMITTED` - SUBMITTED
// - `AUTHORIZED` - AUTHORIZED
// - `BILLED` - BILLED
// - `DELETED` - DELETED
type PurchaseOrderStatus struct {
	typeName                string
	PurchaseOrderStatusEnum PurchaseOrderStatusEnum
	String                  string
}

func NewPurchaseOrderStatusFromPurchaseOrderStatusEnum(value PurchaseOrderStatusEnum) *PurchaseOrderStatus {
	return &PurchaseOrderStatus{typeName: "purchaseOrderStatusEnum", PurchaseOrderStatusEnum: value}
}

func NewPurchaseOrderStatusFromString(value string) *PurchaseOrderStatus {
	return &PurchaseOrderStatus{typeName: "string", String: value}
}

func (p *PurchaseOrderStatus) UnmarshalJSON(data []byte) error {
	var valuePurchaseOrderStatusEnum PurchaseOrderStatusEnum
	if err := json.Unmarshal(data, &valuePurchaseOrderStatusEnum); err == nil {
		p.typeName = "purchaseOrderStatusEnum"
		p.PurchaseOrderStatusEnum = valuePurchaseOrderStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderStatus) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "purchaseOrderStatusEnum":
		return json.Marshal(p.PurchaseOrderStatusEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PurchaseOrderStatusVisitor interface {
	VisitPurchaseOrderStatusEnum(PurchaseOrderStatusEnum) error
	VisitString(string) error
}

func (p *PurchaseOrderStatus) Accept(visitor PurchaseOrderStatusVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "purchaseOrderStatusEnum":
		return visitor.VisitPurchaseOrderStatusEnum(p.PurchaseOrderStatusEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// - `DRAFT` - DRAFT
// - `SUBMITTED` - SUBMITTED
// - `AUTHORIZED` - AUTHORIZED
// - `BILLED` - BILLED
// - `DELETED` - DELETED
type PurchaseOrderStatusEnum string

const (
	PurchaseOrderStatusEnumDraft      PurchaseOrderStatusEnum = "DRAFT"
	PurchaseOrderStatusEnumSubmitted  PurchaseOrderStatusEnum = "SUBMITTED"
	PurchaseOrderStatusEnumAuthorized PurchaseOrderStatusEnum = "AUTHORIZED"
	PurchaseOrderStatusEnumBilled     PurchaseOrderStatusEnum = "BILLED"
	PurchaseOrderStatusEnumDeleted    PurchaseOrderStatusEnum = "DELETED"
)

func NewPurchaseOrderStatusEnumFromString(s string) (PurchaseOrderStatusEnum, error) {
	switch s {
	case "DRAFT":
		return PurchaseOrderStatusEnumDraft, nil
	case "SUBMITTED":
		return PurchaseOrderStatusEnumSubmitted, nil
	case "AUTHORIZED":
		return PurchaseOrderStatusEnumAuthorized, nil
	case "BILLED":
		return PurchaseOrderStatusEnumBilled, nil
	case "DELETED":
		return PurchaseOrderStatusEnumDeleted, nil
	}
	var t PurchaseOrderStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PurchaseOrderStatusEnum) Ptr() *PurchaseOrderStatusEnum {
	return &p
}

type PurchaseOrderTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewPurchaseOrderTrackingCategoriesItemFromString(value string) *PurchaseOrderTrackingCategoriesItem {
	return &PurchaseOrderTrackingCategoriesItem{typeName: "string", String: value}
}

func NewPurchaseOrderTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *PurchaseOrderTrackingCategoriesItem {
	return &PurchaseOrderTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (p *PurchaseOrderTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typeName = "trackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "trackingCategory":
		return json.Marshal(p.TrackingCategory)
	}
}

type PurchaseOrderTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PurchaseOrderTrackingCategoriesItem) Accept(visitor PurchaseOrderTrackingCategoriesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
}

// The party fulfilling the purchase order.
type PurchaseOrderVendor struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewPurchaseOrderVendorFromString(value string) *PurchaseOrderVendor {
	return &PurchaseOrderVendor{typeName: "string", String: value}
}

func NewPurchaseOrderVendorFromContact(value *Contact) *PurchaseOrderVendor {
	return &PurchaseOrderVendor{typeName: "contact", Contact: value}
}

func (p *PurchaseOrderVendor) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typeName = "contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderVendor) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "contact":
		return json.Marshal(p.Contact)
	}
}

type PurchaseOrderVendorVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PurchaseOrderVendor) Accept(visitor PurchaseOrderVendorVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "contact":
		return visitor.VisitContact(p.Contact)
	}
}

// # The RemoteData Object
//
// ### Description
//
// The `RemoteData` object is used to represent the full data pulled from the third-party API for an object.
//
// ### Usage Example
//
// TODO
type RemoteData struct {
	// The third-party API path that is being called.
	Path string      `json:"path"`
	Data interface{} `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteData) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteData(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteData) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteEndpointInfo struct {
	Method             string        `json:"method"`
	UrlPath            string        `json:"url_path"`
	FieldTraversalPath []interface{} `json:"field_traversal_path,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteEndpointInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteEndpointInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteEndpointInfo(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteEndpointInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteField struct {
	RemoteFieldClass *RemoteFieldClass      `json:"remote_field_class,omitempty"`
	Value            map[string]interface{} `json:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteField) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteField(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteField) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldApi struct {
	Schema             map[string]interface{}  `json:"schema,omitempty"`
	RemoteKeyName      string                  `json:"remote_key_name"`
	RemoteEndpointInfo *RemoteEndpointInfo     `json:"remote_endpoint_info,omitempty"`
	ExampleValues      []interface{}           `json:"example_values,omitempty"`
	AdvancedMetadata   *AdvancedMetadata       `json:"advanced_metadata,omitempty"`
	Coverage           *RemoteFieldApiCoverage `json:"coverage,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteFieldApi) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldApi(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldApi) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldApiCoverage struct {
	typeName string
	Integer  int
	Double   float64
}

func NewRemoteFieldApiCoverageFromInteger(value int) *RemoteFieldApiCoverage {
	return &RemoteFieldApiCoverage{typeName: "integer", Integer: value}
}

func NewRemoteFieldApiCoverageFromDouble(value float64) *RemoteFieldApiCoverage {
	return &RemoteFieldApiCoverage{typeName: "double", Double: value}
}

func (r *RemoteFieldApiCoverage) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		r.typeName = "double"
		r.Double = valueDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldApiCoverage) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "double":
		return json.Marshal(r.Double)
	}
}

type RemoteFieldApiCoverageVisitor interface {
	VisitInteger(int) error
	VisitDouble(float64) error
}

func (r *RemoteFieldApiCoverage) Accept(visitor RemoteFieldApiCoverageVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "double":
		return visitor.VisitDouble(r.Double)
	}
}

type RemoteFieldApiResponse struct {
	Account                  []*RemoteFieldApi `json:"Account,omitempty"`
	AccountingAttachment     []*RemoteFieldApi `json:"AccountingAttachment,omitempty"`
	BalanceSheet             []*RemoteFieldApi `json:"BalanceSheet,omitempty"`
	CashFlowStatement        []*RemoteFieldApi `json:"CashFlowStatement,omitempty"`
	CompanyInfo              []*RemoteFieldApi `json:"CompanyInfo,omitempty"`
	Contact                  []*RemoteFieldApi `json:"Contact,omitempty"`
	IncomeStatement          []*RemoteFieldApi `json:"IncomeStatement,omitempty"`
	CreditNote               []*RemoteFieldApi `json:"CreditNote,omitempty"`
	Item                     []*RemoteFieldApi `json:"Item,omitempty"`
	PurchaseOrder            []*RemoteFieldApi `json:"PurchaseOrder,omitempty"`
	TrackingCategory         []*RemoteFieldApi `json:"TrackingCategory,omitempty"`
	JournalEntry             []*RemoteFieldApi `json:"JournalEntry,omitempty"`
	TaxRate                  []*RemoteFieldApi `json:"TaxRate,omitempty"`
	Invoice                  []*RemoteFieldApi `json:"Invoice,omitempty"`
	Payment                  []*RemoteFieldApi `json:"Payment,omitempty"`
	Expense                  []*RemoteFieldApi `json:"Expense,omitempty"`
	VendorCredit             []*RemoteFieldApi `json:"VendorCredit,omitempty"`
	Transaction              []*RemoteFieldApi `json:"Transaction,omitempty"`
	AccountingPeriod         []*RemoteFieldApi `json:"AccountingPeriod,omitempty"`
	GeneralLedgerTransaction []*RemoteFieldApi `json:"GeneralLedgerTransaction,omitempty"`
	BankFeedAccount          []*RemoteFieldApi `json:"BankFeedAccount,omitempty"`
	Employee                 []*RemoteFieldApi `json:"Employee,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteFieldApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldApiResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldApiResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldClass struct {
	Id            *string          `json:"id,omitempty"`
	DisplayName   *string          `json:"display_name,omitempty"`
	RemoteKeyName *string          `json:"remote_key_name,omitempty"`
	Description   *string          `json:"description,omitempty"`
	IsCustom      *bool            `json:"is_custom,omitempty"`
	IsRequired    *bool            `json:"is_required,omitempty"`
	FieldType     *FieldTypeEnum   `json:"field_type,omitempty"`
	FieldFormat   *FieldFormatEnum `json:"field_format,omitempty"`
	FieldChoices  []string         `json:"field_choices,omitempty"`
	ItemSchema    *ItemSchema      `json:"item_schema,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteFieldClass) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldClass
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldClass(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldClass) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldRequest struct {
	RemoteFieldClass *RemoteFieldRequestRemoteFieldClass `json:"remote_field_class,omitempty"`
	Value            interface{}                         `json:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldRequest(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldRequestRemoteFieldClass struct {
	typeName         string
	String           string
	RemoteFieldClass *RemoteFieldClass
}

func NewRemoteFieldRequestRemoteFieldClassFromString(value string) *RemoteFieldRequestRemoteFieldClass {
	return &RemoteFieldRequestRemoteFieldClass{typeName: "string", String: value}
}

func NewRemoteFieldRequestRemoteFieldClassFromRemoteFieldClass(value *RemoteFieldClass) *RemoteFieldRequestRemoteFieldClass {
	return &RemoteFieldRequestRemoteFieldClass{typeName: "remoteFieldClass", RemoteFieldClass: value}
}

func (r *RemoteFieldRequestRemoteFieldClass) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRemoteFieldClass := new(RemoteFieldClass)
	if err := json.Unmarshal(data, &valueRemoteFieldClass); err == nil {
		r.typeName = "remoteFieldClass"
		r.RemoteFieldClass = valueRemoteFieldClass
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldRequestRemoteFieldClass) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "remoteFieldClass":
		return json.Marshal(r.RemoteFieldClass)
	}
}

type RemoteFieldRequestRemoteFieldClassVisitor interface {
	VisitString(string) error
	VisitRemoteFieldClass(*RemoteFieldClass) error
}

func (r *RemoteFieldRequestRemoteFieldClass) Accept(visitor RemoteFieldRequestRemoteFieldClassVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "remoteFieldClass":
		return visitor.VisitRemoteFieldClass(r.RemoteFieldClass)
	}
}

// # The RemoteKey Object
//
// ### Description
//
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
//
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name"`
	Key  string `json:"key"`

	_rawJSON json.RawMessage
}

func (r *RemoteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteKey(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteKey) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteResponse Object
//
// ### Description
//
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
//
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                 `json:"method"`
	Path            string                 `json:"path"`
	Status          int                    `json:"status"`
	Response        interface{}            `json:"response,omitempty"`
	ResponseHeaders map[string]interface{} `json:"response_headers,omitempty"`
	ResponseType    *ResponseTypeEnum      `json:"response_type,omitempty"`
	Headers         map[string]interface{} `json:"headers,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The ReportItem Object
//
// ### Description
//
// The `ReportItem` object is used to represent a report item for a Balance Sheet, Cash Flow Statement or Profit and Loss Report.
//
// ### Usage Example
//
// Fetch from the `GET BalanceSheet` endpoint and view the balance sheet's report items.
type ReportItem struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The report item's name.
	Name *string `json:"name,omitempty"`
	// The report item's value.
	Value    *float64                 `json:"value,omitempty"`
	SubItems []map[string]interface{} `json:"sub_items,omitempty"`
	// The company the report item belongs to.
	Company *string `json:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (r *ReportItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ReportItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReportItem(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReportItem) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// - `JSON` - JSON
// - `XML` - XML
// - `MULTIPART` - MULTIPART
type RequestFormatEnum string

const (
	RequestFormatEnumJson      RequestFormatEnum = "JSON"
	RequestFormatEnumXml       RequestFormatEnum = "XML"
	RequestFormatEnumMultipart RequestFormatEnum = "MULTIPART"
)

func NewRequestFormatEnumFromString(s string) (RequestFormatEnum, error) {
	switch s {
	case "JSON":
		return RequestFormatEnumJson, nil
	case "XML":
		return RequestFormatEnumXml, nil
	case "MULTIPART":
		return RequestFormatEnumMultipart, nil
	}
	var t RequestFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestFormatEnum) Ptr() *RequestFormatEnum {
	return &r
}

// - `JSON` - JSON
// - `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum string

const (
	ResponseTypeEnumJson       ResponseTypeEnum = "JSON"
	ResponseTypeEnumBase64Gzip ResponseTypeEnum = "BASE64_GZIP"
)

func NewResponseTypeEnumFromString(s string) (ResponseTypeEnum, error) {
	switch s {
	case "JSON":
		return ResponseTypeEnumJson, nil
	case "BASE64_GZIP":
		return ResponseTypeEnumBase64Gzip, nil
	}
	var t ResponseTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTypeEnum) Ptr() *ResponseTypeEnum {
	return &r
}

// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type RoleEnum string

const (
	RoleEnumAdmin     RoleEnum = "ADMIN"
	RoleEnumDeveloper RoleEnum = "DEVELOPER"
	RoleEnumMember    RoleEnum = "MEMBER"
	RoleEnumApi       RoleEnum = "API"
	RoleEnumSystem    RoleEnum = "SYSTEM"
	RoleEnumMergeTeam RoleEnum = "MERGE_TEAM"
)

func NewRoleEnumFromString(s string) (RoleEnum, error) {
	switch s {
	case "ADMIN":
		return RoleEnumAdmin, nil
	case "DEVELOPER":
		return RoleEnumDeveloper, nil
	case "MEMBER":
		return RoleEnumMember, nil
	case "API":
		return RoleEnumApi, nil
	case "SYSTEM":
		return RoleEnumSystem, nil
	case "MERGE_TEAM":
		return RoleEnumMergeTeam, nil
	}
	var t RoleEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoleEnum) Ptr() *RoleEnum {
	return &r
}

// - `IN_NEXT_SYNC` - IN_NEXT_SYNC
// - `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum string

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = "IN_NEXT_SYNC"
	SelectiveSyncConfigurationsUsageEnumInLastSync SelectiveSyncConfigurationsUsageEnum = "IN_LAST_SYNC"
)

func NewSelectiveSyncConfigurationsUsageEnumFromString(s string) (SelectiveSyncConfigurationsUsageEnum, error) {
	switch s {
	case "IN_NEXT_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInNextSync, nil
	case "IN_LAST_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInLastSync, nil
	}
	var t SelectiveSyncConfigurationsUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SelectiveSyncConfigurationsUsageEnum) Ptr() *SelectiveSyncConfigurationsUsageEnum {
	return &s
}

// - `ACTIVE` - ACTIVE
// - `ARCHIVED` - ARCHIVED
type Status7D1Enum string

const (
	Status7D1EnumActive   Status7D1Enum = "ACTIVE"
	Status7D1EnumArchived Status7D1Enum = "ARCHIVED"
)

func NewStatus7D1EnumFromString(s string) (Status7D1Enum, error) {
	switch s {
	case "ACTIVE":
		return Status7D1EnumActive, nil
	case "ARCHIVED":
		return Status7D1EnumArchived, nil
	}
	var t Status7D1Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Status7D1Enum) Ptr() *Status7D1Enum {
	return &s
}

// - `ACTIVE` - ACTIVE
// - `INACTIVE` - INACTIVE
type Status895Enum string

const (
	Status895EnumActive   Status895Enum = "ACTIVE"
	Status895EnumInactive Status895Enum = "INACTIVE"
)

func NewStatus895EnumFromString(s string) (Status895Enum, error) {
	switch s {
	case "ACTIVE":
		return Status895EnumActive, nil
	case "INACTIVE":
		return Status895EnumInactive, nil
	}
	var t Status895Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Status895Enum) Ptr() *Status895Enum {
	return &s
}

// # The SyncStatus Object
//
// ### Description
//
// # The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
//
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name"`
	ModelId                          string                                `json:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty"`
	Status                           SyncStatusStatusEnum                  `json:"status,omitempty"`
	IsInitialSync                    bool                                  `json:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SyncStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncStatus(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatus) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// - `SYNCING` - SYNCING
// - `DONE` - DONE
// - `FAILED` - FAILED
// - `DISABLED` - DISABLED
// - `PAUSED` - PAUSED
// - `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type SyncStatusStatusEnum string

const (
	SyncStatusStatusEnumSyncing         SyncStatusStatusEnum = "SYNCING"
	SyncStatusStatusEnumDone            SyncStatusStatusEnum = "DONE"
	SyncStatusStatusEnumFailed          SyncStatusStatusEnum = "FAILED"
	SyncStatusStatusEnumDisabled        SyncStatusStatusEnum = "DISABLED"
	SyncStatusStatusEnumPaused          SyncStatusStatusEnum = "PAUSED"
	SyncStatusStatusEnumPartiallySynced SyncStatusStatusEnum = "PARTIALLY_SYNCED"
)

func NewSyncStatusStatusEnumFromString(s string) (SyncStatusStatusEnum, error) {
	switch s {
	case "SYNCING":
		return SyncStatusStatusEnumSyncing, nil
	case "DONE":
		return SyncStatusStatusEnumDone, nil
	case "FAILED":
		return SyncStatusStatusEnumFailed, nil
	case "DISABLED":
		return SyncStatusStatusEnumDisabled, nil
	case "PAUSED":
		return SyncStatusStatusEnumPaused, nil
	case "PARTIALLY_SYNCED":
		return SyncStatusStatusEnumPartiallySynced, nil
	}
	var t SyncStatusStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SyncStatusStatusEnum) Ptr() *SyncStatusStatusEnum {
	return &s
}

// # The TaxRate Object
//
// ### Description
//
// The `TaxComponent` object is used to represent any sub-taxes that make up the `TaxRate`.
//
// ### Usage Example
//
// Fetch from the `LIST TaxRates` endpoint and view tax components relevant to a tax rate.
type TaxComponent struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The tax rate’s name.
	Name *string `json:"name,omitempty"`
	// The tax component’s rate.
	Rate *string `json:"rate,omitempty"`
	// Returns True if the tax component is compound, False if not.
	IsCompound *bool `json:"is_compound,omitempty"`
	// Returns PURCHASE if the tax component corresponds to a purchase tax or SALES if the tax component corresponds to a sales tax.
	//
	// - `SALES` - SALES
	// - `PURCHASE` - PURCHASE
	ComponentType *TaxComponentComponentType `json:"component_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TaxComponent) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxComponent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxComponent(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxComponent) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Returns PURCHASE if the tax component corresponds to a purchase tax or SALES if the tax component corresponds to a sales tax.
//
// - `SALES` - SALES
// - `PURCHASE` - PURCHASE
type TaxComponentComponentType struct {
	typeName          string
	ComponentTypeEnum ComponentTypeEnum
	String            string
}

func NewTaxComponentComponentTypeFromComponentTypeEnum(value ComponentTypeEnum) *TaxComponentComponentType {
	return &TaxComponentComponentType{typeName: "componentTypeEnum", ComponentTypeEnum: value}
}

func NewTaxComponentComponentTypeFromString(value string) *TaxComponentComponentType {
	return &TaxComponentComponentType{typeName: "string", String: value}
}

func (t *TaxComponentComponentType) UnmarshalJSON(data []byte) error {
	var valueComponentTypeEnum ComponentTypeEnum
	if err := json.Unmarshal(data, &valueComponentTypeEnum); err == nil {
		t.typeName = "componentTypeEnum"
		t.ComponentTypeEnum = valueComponentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaxComponentComponentType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "componentTypeEnum":
		return json.Marshal(t.ComponentTypeEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TaxComponentComponentTypeVisitor interface {
	VisitComponentTypeEnum(ComponentTypeEnum) error
	VisitString(string) error
}

func (t *TaxComponentComponentType) Accept(visitor TaxComponentComponentTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "componentTypeEnum":
		return visitor.VisitComponentTypeEnum(t.ComponentTypeEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// # The TaxRate Object
//
// ### Description
//
// The `TaxRate` object is used to represent a tax rate.
//
// ### Usage Example
//
// Fetch from the `LIST TaxRates` endpoint and view tax rates relevant to a company.
type TaxRate struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The subsidiary that the tax rate belongs to (in the case of multi-entity systems).
	Company *TaxRateCompany `json:"company,omitempty"`
	// The tax code associated with this tax rate or group of tax rates from the third-party platform.
	Code *string `json:"code,omitempty"`
	// The tax rate’s name.
	Name *string `json:"name,omitempty"`
	// The tax rate's description.
	Description *string `json:"description,omitempty"`
	// The tax rate’s status - `ACTIVE` if an active tax rate, `ARCHIVED` if not active.
	//
	// - `ACTIVE` - ACTIVE
	// - `ARCHIVED` - ARCHIVED
	Status *TaxRateStatus `json:"status,omitempty"`
	// The country the tax rate is associated with.
	Country *string `json:"country,omitempty"`
	// The tax’s total tax rate - sum of the tax components (not compounded).
	TotalTaxRate *float64 `json:"total_tax_rate,omitempty"`
	// The tax rate’s effective tax rate - total amount of tax with compounding.
	EffectiveTaxRate *float64 `json:"effective_tax_rate,omitempty"`
	// The related tax components of the tax rate.
	TaxComponents []*TaxRateTaxComponentsItem `json:"tax_components,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TaxRate) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxRate(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxRate) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The subsidiary that the tax rate belongs to (in the case of multi-entity systems).
type TaxRateCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewTaxRateCompanyFromString(value string) *TaxRateCompany {
	return &TaxRateCompany{typeName: "string", String: value}
}

func NewTaxRateCompanyFromCompanyInfo(value *CompanyInfo) *TaxRateCompany {
	return &TaxRateCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (t *TaxRateCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		t.typeName = "companyInfo"
		t.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaxRateCompany) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "companyInfo":
		return json.Marshal(t.CompanyInfo)
	}
}

type TaxRateCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (t *TaxRateCompany) Accept(visitor TaxRateCompanyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(t.CompanyInfo)
	}
}

// The tax rate’s status - `ACTIVE` if an active tax rate, `ARCHIVED` if not active.
//
// - `ACTIVE` - ACTIVE
// - `ARCHIVED` - ARCHIVED
type TaxRateStatus struct {
	typeName      string
	Status7D1Enum Status7D1Enum
	String        string
}

func NewTaxRateStatusFromStatus7D1Enum(value Status7D1Enum) *TaxRateStatus {
	return &TaxRateStatus{typeName: "status7D1Enum", Status7D1Enum: value}
}

func NewTaxRateStatusFromString(value string) *TaxRateStatus {
	return &TaxRateStatus{typeName: "string", String: value}
}

func (t *TaxRateStatus) UnmarshalJSON(data []byte) error {
	var valueStatus7D1Enum Status7D1Enum
	if err := json.Unmarshal(data, &valueStatus7D1Enum); err == nil {
		t.typeName = "status7D1Enum"
		t.Status7D1Enum = valueStatus7D1Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaxRateStatus) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "status7D1Enum":
		return json.Marshal(t.Status7D1Enum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TaxRateStatusVisitor interface {
	VisitStatus7D1Enum(Status7D1Enum) error
	VisitString(string) error
}

func (t *TaxRateStatus) Accept(visitor TaxRateStatusVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "status7D1Enum":
		return visitor.VisitStatus7D1Enum(t.Status7D1Enum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TaxRateTaxComponentsItem struct {
	typeName     string
	String       string
	TaxComponent *TaxComponent
}

func NewTaxRateTaxComponentsItemFromString(value string) *TaxRateTaxComponentsItem {
	return &TaxRateTaxComponentsItem{typeName: "string", String: value}
}

func NewTaxRateTaxComponentsItemFromTaxComponent(value *TaxComponent) *TaxRateTaxComponentsItem {
	return &TaxRateTaxComponentsItem{typeName: "taxComponent", TaxComponent: value}
}

func (t *TaxRateTaxComponentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueTaxComponent := new(TaxComponent)
	if err := json.Unmarshal(data, &valueTaxComponent); err == nil {
		t.typeName = "taxComponent"
		t.TaxComponent = valueTaxComponent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaxRateTaxComponentsItem) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "taxComponent":
		return json.Marshal(t.TaxComponent)
	}
}

type TaxRateTaxComponentsItemVisitor interface {
	VisitString(string) error
	VisitTaxComponent(*TaxComponent) error
}

func (t *TaxRateTaxComponentsItem) Accept(visitor TaxRateTaxComponentsItemVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "taxComponent":
		return visitor.VisitTaxComponent(t.TaxComponent)
	}
}

// # The TrackingCategory Object
//
// ### Description
//
// A `TrackingCategory` object represents a categorization method used to classify transactions within an accounting platform. They are often used to group records for reporting and analysis purposes. The most common types of `TrackingCategories` are Classes and Departments.
//
// ### Usage Example
//
// Fetch from the `GET TrackingCategory` endpoint and view a company's tracking category.
type TrackingCategory struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The tracking category's name.
	Name *string `json:"name,omitempty"`
	// The tracking category's status.
	//
	// - `ACTIVE` - ACTIVE
	// - `ARCHIVED` - ARCHIVED
	Status *TrackingCategoryStatus `json:"status,omitempty"`
	// The tracking category’s type.
	//
	// - `CLASS` - CLASS
	// - `DEPARTMENT` - DEPARTMENT
	CategoryType   *TrackingCategoryCategoryType `json:"category_type,omitempty"`
	ParentCategory *string                       `json:"parent_category,omitempty"`
	// The company the GeneralLedgerTransaction belongs to.
	Company *TrackingCategoryCompany `json:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrackingCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler TrackingCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrackingCategory(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrackingCategory) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The tracking category’s type.
//
// - `CLASS` - CLASS
// - `DEPARTMENT` - DEPARTMENT
type TrackingCategoryCategoryType struct {
	typeName         string
	CategoryTypeEnum CategoryTypeEnum
	String           string
}

func NewTrackingCategoryCategoryTypeFromCategoryTypeEnum(value CategoryTypeEnum) *TrackingCategoryCategoryType {
	return &TrackingCategoryCategoryType{typeName: "categoryTypeEnum", CategoryTypeEnum: value}
}

func NewTrackingCategoryCategoryTypeFromString(value string) *TrackingCategoryCategoryType {
	return &TrackingCategoryCategoryType{typeName: "string", String: value}
}

func (t *TrackingCategoryCategoryType) UnmarshalJSON(data []byte) error {
	var valueCategoryTypeEnum CategoryTypeEnum
	if err := json.Unmarshal(data, &valueCategoryTypeEnum); err == nil {
		t.typeName = "categoryTypeEnum"
		t.CategoryTypeEnum = valueCategoryTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TrackingCategoryCategoryType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "categoryTypeEnum":
		return json.Marshal(t.CategoryTypeEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TrackingCategoryCategoryTypeVisitor interface {
	VisitCategoryTypeEnum(CategoryTypeEnum) error
	VisitString(string) error
}

func (t *TrackingCategoryCategoryType) Accept(visitor TrackingCategoryCategoryTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "categoryTypeEnum":
		return visitor.VisitCategoryTypeEnum(t.CategoryTypeEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// The company the GeneralLedgerTransaction belongs to.
type TrackingCategoryCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewTrackingCategoryCompanyFromString(value string) *TrackingCategoryCompany {
	return &TrackingCategoryCompany{typeName: "string", String: value}
}

func NewTrackingCategoryCompanyFromCompanyInfo(value *CompanyInfo) *TrackingCategoryCompany {
	return &TrackingCategoryCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (t *TrackingCategoryCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		t.typeName = "companyInfo"
		t.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TrackingCategoryCompany) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "companyInfo":
		return json.Marshal(t.CompanyInfo)
	}
}

type TrackingCategoryCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (t *TrackingCategoryCompany) Accept(visitor TrackingCategoryCompanyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(t.CompanyInfo)
	}
}

// The tracking category's status.
//
// - `ACTIVE` - ACTIVE
// - `ARCHIVED` - ARCHIVED
type TrackingCategoryStatus struct {
	typeName      string
	Status7D1Enum Status7D1Enum
	String        string
}

func NewTrackingCategoryStatusFromStatus7D1Enum(value Status7D1Enum) *TrackingCategoryStatus {
	return &TrackingCategoryStatus{typeName: "status7D1Enum", Status7D1Enum: value}
}

func NewTrackingCategoryStatusFromString(value string) *TrackingCategoryStatus {
	return &TrackingCategoryStatus{typeName: "string", String: value}
}

func (t *TrackingCategoryStatus) UnmarshalJSON(data []byte) error {
	var valueStatus7D1Enum Status7D1Enum
	if err := json.Unmarshal(data, &valueStatus7D1Enum); err == nil {
		t.typeName = "status7D1Enum"
		t.Status7D1Enum = valueStatus7D1Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TrackingCategoryStatus) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "status7D1Enum":
		return json.Marshal(t.Status7D1Enum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TrackingCategoryStatusVisitor interface {
	VisitStatus7D1Enum(Status7D1Enum) error
	VisitString(string) error
}

func (t *TrackingCategoryStatus) Accept(visitor TrackingCategoryStatusVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "status7D1Enum":
		return visitor.VisitStatus7D1Enum(t.Status7D1Enum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// # The Transaction Object
//
// ### Description
//
// The `Transaction` common model includes records of all types of transactions that do not appear in other common models. The type of transaction can be identified through the type field. More specifically, it will contain all types of transactions outside of:
//
// - **Credit Notes**
// - **Expenses**
// - **Invoices**
// - **Journal Entries**
// - **Payments**
// - **Purchase Orders**
// - **Vendor Credits**
//
// ### Usage Example
//
// Fetch from the `GET Transaction` endpoint and view a company's transactions.
type Transaction struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The type of transaction, which can by any transaction object not already included in Merge’s common model.
	TransactionType *string `json:"transaction_type,omitempty"`
	// The transaction's number used for identifying purposes.
	Number *string `json:"number,omitempty"`
	// The date upon which the transaction occurred.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The transaction's account.
	Account *TransactionAccount `json:"account,omitempty"`
	// The contact to whom the transaction relates to.
	Contact *TransactionContact `json:"contact,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty"`
	// The total amount being paid after taxes.
	TotalAmount *string `json:"total_amount,omitempty"`
	// The transaction's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrency `json:"currency,omitempty"`
	// The transaction's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the transaction belongs to.
	Company            *string                              `json:"company,omitempty"`
	TrackingCategories []*TransactionTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	LineItems          []*TransactionLineItem               `json:"line_items,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// The accounting period that the Transaction was generated in.
	AccountingPeriod *TransactionAccountingPeriod `json:"accounting_period,omitempty"`
	FieldMappings    map[string]interface{}       `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData                `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Transaction) UnmarshalJSON(data []byte) error {
	type unmarshaler Transaction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Transaction(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Transaction) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The transaction's account.
type TransactionAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewTransactionAccountFromString(value string) *TransactionAccount {
	return &TransactionAccount{typeName: "string", String: value}
}

func NewTransactionAccountFromAccount(value *Account) *TransactionAccount {
	return &TransactionAccount{typeName: "account", Account: value}
}

func (t *TransactionAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		t.typeName = "account"
		t.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransactionAccount) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "account":
		return json.Marshal(t.Account)
	}
}

type TransactionAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (t *TransactionAccount) Accept(visitor TransactionAccountVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "account":
		return visitor.VisitAccount(t.Account)
	}
}

// The accounting period that the Transaction was generated in.
type TransactionAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewTransactionAccountingPeriodFromString(value string) *TransactionAccountingPeriod {
	return &TransactionAccountingPeriod{typeName: "string", String: value}
}

func NewTransactionAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *TransactionAccountingPeriod {
	return &TransactionAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (t *TransactionAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		t.typeName = "accountingPeriod"
		t.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransactionAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "accountingPeriod":
		return json.Marshal(t.AccountingPeriod)
	}
}

type TransactionAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (t *TransactionAccountingPeriod) Accept(visitor TransactionAccountingPeriodVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(t.AccountingPeriod)
	}
}

// The contact to whom the transaction relates to.
type TransactionContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewTransactionContactFromString(value string) *TransactionContact {
	return &TransactionContact{typeName: "string", String: value}
}

func NewTransactionContactFromContact(value *Contact) *TransactionContact {
	return &TransactionContact{typeName: "contact", Contact: value}
}

func (t *TransactionContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		t.typeName = "contact"
		t.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransactionContact) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "contact":
		return json.Marshal(t.Contact)
	}
}

type TransactionContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (t *TransactionContact) Accept(visitor TransactionContactVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "contact":
		return visitor.VisitContact(t.Contact)
	}
}

// The transaction's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type TransactionCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewTransactionCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *TransactionCurrency {
	return &TransactionCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewTransactionCurrencyFromString(value string) *TransactionCurrency {
	return &TransactionCurrency{typeName: "string", String: value}
}

func (t *TransactionCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		t.typeName = "transactionCurrencyEnum"
		t.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransactionCurrency) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transactionCurrencyEnum":
		return json.Marshal(t.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransactionCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (t *TransactionCurrency) Accept(visitor TransactionCurrencyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(t.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type TransactionCurrencyEnum string

const (
	TransactionCurrencyEnumXua TransactionCurrencyEnum = "XUA"
	TransactionCurrencyEnumAfn TransactionCurrencyEnum = "AFN"
	TransactionCurrencyEnumAfa TransactionCurrencyEnum = "AFA"
	TransactionCurrencyEnumAll TransactionCurrencyEnum = "ALL"
	TransactionCurrencyEnumAlk TransactionCurrencyEnum = "ALK"
	TransactionCurrencyEnumDzd TransactionCurrencyEnum = "DZD"
	TransactionCurrencyEnumAdp TransactionCurrencyEnum = "ADP"
	TransactionCurrencyEnumAoa TransactionCurrencyEnum = "AOA"
	TransactionCurrencyEnumAok TransactionCurrencyEnum = "AOK"
	TransactionCurrencyEnumAon TransactionCurrencyEnum = "AON"
	TransactionCurrencyEnumAor TransactionCurrencyEnum = "AOR"
	TransactionCurrencyEnumAra TransactionCurrencyEnum = "ARA"
	TransactionCurrencyEnumArs TransactionCurrencyEnum = "ARS"
	TransactionCurrencyEnumArm TransactionCurrencyEnum = "ARM"
	TransactionCurrencyEnumArp TransactionCurrencyEnum = "ARP"
	TransactionCurrencyEnumArl TransactionCurrencyEnum = "ARL"
	TransactionCurrencyEnumAmd TransactionCurrencyEnum = "AMD"
	TransactionCurrencyEnumAwg TransactionCurrencyEnum = "AWG"
	TransactionCurrencyEnumAud TransactionCurrencyEnum = "AUD"
	TransactionCurrencyEnumAts TransactionCurrencyEnum = "ATS"
	TransactionCurrencyEnumAzn TransactionCurrencyEnum = "AZN"
	TransactionCurrencyEnumAzm TransactionCurrencyEnum = "AZM"
	TransactionCurrencyEnumBsd TransactionCurrencyEnum = "BSD"
	TransactionCurrencyEnumBhd TransactionCurrencyEnum = "BHD"
	TransactionCurrencyEnumBdt TransactionCurrencyEnum = "BDT"
	TransactionCurrencyEnumBbd TransactionCurrencyEnum = "BBD"
	TransactionCurrencyEnumByn TransactionCurrencyEnum = "BYN"
	TransactionCurrencyEnumByb TransactionCurrencyEnum = "BYB"
	TransactionCurrencyEnumByr TransactionCurrencyEnum = "BYR"
	TransactionCurrencyEnumBef TransactionCurrencyEnum = "BEF"
	TransactionCurrencyEnumBec TransactionCurrencyEnum = "BEC"
	TransactionCurrencyEnumBel TransactionCurrencyEnum = "BEL"
	TransactionCurrencyEnumBzd TransactionCurrencyEnum = "BZD"
	TransactionCurrencyEnumBmd TransactionCurrencyEnum = "BMD"
	TransactionCurrencyEnumBtn TransactionCurrencyEnum = "BTN"
	TransactionCurrencyEnumBob TransactionCurrencyEnum = "BOB"
	TransactionCurrencyEnumBol TransactionCurrencyEnum = "BOL"
	TransactionCurrencyEnumBov TransactionCurrencyEnum = "BOV"
	TransactionCurrencyEnumBop TransactionCurrencyEnum = "BOP"
	TransactionCurrencyEnumBam TransactionCurrencyEnum = "BAM"
	TransactionCurrencyEnumBad TransactionCurrencyEnum = "BAD"
	TransactionCurrencyEnumBan TransactionCurrencyEnum = "BAN"
	TransactionCurrencyEnumBwp TransactionCurrencyEnum = "BWP"
	TransactionCurrencyEnumBrc TransactionCurrencyEnum = "BRC"
	TransactionCurrencyEnumBrz TransactionCurrencyEnum = "BRZ"
	TransactionCurrencyEnumBre TransactionCurrencyEnum = "BRE"
	TransactionCurrencyEnumBrr TransactionCurrencyEnum = "BRR"
	TransactionCurrencyEnumBrn TransactionCurrencyEnum = "BRN"
	TransactionCurrencyEnumBrb TransactionCurrencyEnum = "BRB"
	TransactionCurrencyEnumBrl TransactionCurrencyEnum = "BRL"
	TransactionCurrencyEnumGbp TransactionCurrencyEnum = "GBP"
	TransactionCurrencyEnumBnd TransactionCurrencyEnum = "BND"
	TransactionCurrencyEnumBgl TransactionCurrencyEnum = "BGL"
	TransactionCurrencyEnumBgn TransactionCurrencyEnum = "BGN"
	TransactionCurrencyEnumBgo TransactionCurrencyEnum = "BGO"
	TransactionCurrencyEnumBgm TransactionCurrencyEnum = "BGM"
	TransactionCurrencyEnumBuk TransactionCurrencyEnum = "BUK"
	TransactionCurrencyEnumBif TransactionCurrencyEnum = "BIF"
	TransactionCurrencyEnumXpf TransactionCurrencyEnum = "XPF"
	TransactionCurrencyEnumKhr TransactionCurrencyEnum = "KHR"
	TransactionCurrencyEnumCad TransactionCurrencyEnum = "CAD"
	TransactionCurrencyEnumCve TransactionCurrencyEnum = "CVE"
	TransactionCurrencyEnumKyd TransactionCurrencyEnum = "KYD"
	TransactionCurrencyEnumXaf TransactionCurrencyEnum = "XAF"
	TransactionCurrencyEnumCle TransactionCurrencyEnum = "CLE"
	TransactionCurrencyEnumClp TransactionCurrencyEnum = "CLP"
	TransactionCurrencyEnumClf TransactionCurrencyEnum = "CLF"
	TransactionCurrencyEnumCnx TransactionCurrencyEnum = "CNX"
	TransactionCurrencyEnumCny TransactionCurrencyEnum = "CNY"
	TransactionCurrencyEnumCnh TransactionCurrencyEnum = "CNH"
	TransactionCurrencyEnumCop TransactionCurrencyEnum = "COP"
	TransactionCurrencyEnumCou TransactionCurrencyEnum = "COU"
	TransactionCurrencyEnumKmf TransactionCurrencyEnum = "KMF"
	TransactionCurrencyEnumCdf TransactionCurrencyEnum = "CDF"
	TransactionCurrencyEnumCrc TransactionCurrencyEnum = "CRC"
	TransactionCurrencyEnumHrd TransactionCurrencyEnum = "HRD"
	TransactionCurrencyEnumHrk TransactionCurrencyEnum = "HRK"
	TransactionCurrencyEnumCuc TransactionCurrencyEnum = "CUC"
	TransactionCurrencyEnumCup TransactionCurrencyEnum = "CUP"
	TransactionCurrencyEnumCyp TransactionCurrencyEnum = "CYP"
	TransactionCurrencyEnumCzk TransactionCurrencyEnum = "CZK"
	TransactionCurrencyEnumCsk TransactionCurrencyEnum = "CSK"
	TransactionCurrencyEnumDkk TransactionCurrencyEnum = "DKK"
	TransactionCurrencyEnumDjf TransactionCurrencyEnum = "DJF"
	TransactionCurrencyEnumDop TransactionCurrencyEnum = "DOP"
	TransactionCurrencyEnumNlg TransactionCurrencyEnum = "NLG"
	TransactionCurrencyEnumXcd TransactionCurrencyEnum = "XCD"
	TransactionCurrencyEnumDdm TransactionCurrencyEnum = "DDM"
	TransactionCurrencyEnumEcs TransactionCurrencyEnum = "ECS"
	TransactionCurrencyEnumEcv TransactionCurrencyEnum = "ECV"
	TransactionCurrencyEnumEgp TransactionCurrencyEnum = "EGP"
	TransactionCurrencyEnumGqe TransactionCurrencyEnum = "GQE"
	TransactionCurrencyEnumErn TransactionCurrencyEnum = "ERN"
	TransactionCurrencyEnumEek TransactionCurrencyEnum = "EEK"
	TransactionCurrencyEnumEtb TransactionCurrencyEnum = "ETB"
	TransactionCurrencyEnumEur TransactionCurrencyEnum = "EUR"
	TransactionCurrencyEnumXba TransactionCurrencyEnum = "XBA"
	TransactionCurrencyEnumXeu TransactionCurrencyEnum = "XEU"
	TransactionCurrencyEnumXbb TransactionCurrencyEnum = "XBB"
	TransactionCurrencyEnumXbc TransactionCurrencyEnum = "XBC"
	TransactionCurrencyEnumXbd TransactionCurrencyEnum = "XBD"
	TransactionCurrencyEnumFkp TransactionCurrencyEnum = "FKP"
	TransactionCurrencyEnumFjd TransactionCurrencyEnum = "FJD"
	TransactionCurrencyEnumFim TransactionCurrencyEnum = "FIM"
	TransactionCurrencyEnumFrf TransactionCurrencyEnum = "FRF"
	TransactionCurrencyEnumXfo TransactionCurrencyEnum = "XFO"
	TransactionCurrencyEnumXfu TransactionCurrencyEnum = "XFU"
	TransactionCurrencyEnumGmd TransactionCurrencyEnum = "GMD"
	TransactionCurrencyEnumGek TransactionCurrencyEnum = "GEK"
	TransactionCurrencyEnumGel TransactionCurrencyEnum = "GEL"
	TransactionCurrencyEnumDem TransactionCurrencyEnum = "DEM"
	TransactionCurrencyEnumGhs TransactionCurrencyEnum = "GHS"
	TransactionCurrencyEnumGhc TransactionCurrencyEnum = "GHC"
	TransactionCurrencyEnumGip TransactionCurrencyEnum = "GIP"
	TransactionCurrencyEnumXau TransactionCurrencyEnum = "XAU"
	TransactionCurrencyEnumGrd TransactionCurrencyEnum = "GRD"
	TransactionCurrencyEnumGtq TransactionCurrencyEnum = "GTQ"
	TransactionCurrencyEnumGwp TransactionCurrencyEnum = "GWP"
	TransactionCurrencyEnumGnf TransactionCurrencyEnum = "GNF"
	TransactionCurrencyEnumGns TransactionCurrencyEnum = "GNS"
	TransactionCurrencyEnumGyd TransactionCurrencyEnum = "GYD"
	TransactionCurrencyEnumHtg TransactionCurrencyEnum = "HTG"
	TransactionCurrencyEnumHnl TransactionCurrencyEnum = "HNL"
	TransactionCurrencyEnumHkd TransactionCurrencyEnum = "HKD"
	TransactionCurrencyEnumHuf TransactionCurrencyEnum = "HUF"
	TransactionCurrencyEnumImp TransactionCurrencyEnum = "IMP"
	TransactionCurrencyEnumIsk TransactionCurrencyEnum = "ISK"
	TransactionCurrencyEnumIsj TransactionCurrencyEnum = "ISJ"
	TransactionCurrencyEnumInr TransactionCurrencyEnum = "INR"
	TransactionCurrencyEnumIdr TransactionCurrencyEnum = "IDR"
	TransactionCurrencyEnumIrr TransactionCurrencyEnum = "IRR"
	TransactionCurrencyEnumIqd TransactionCurrencyEnum = "IQD"
	TransactionCurrencyEnumIep TransactionCurrencyEnum = "IEP"
	TransactionCurrencyEnumIls TransactionCurrencyEnum = "ILS"
	TransactionCurrencyEnumIlp TransactionCurrencyEnum = "ILP"
	TransactionCurrencyEnumIlr TransactionCurrencyEnum = "ILR"
	TransactionCurrencyEnumItl TransactionCurrencyEnum = "ITL"
	TransactionCurrencyEnumJmd TransactionCurrencyEnum = "JMD"
	TransactionCurrencyEnumJpy TransactionCurrencyEnum = "JPY"
	TransactionCurrencyEnumJod TransactionCurrencyEnum = "JOD"
	TransactionCurrencyEnumKzt TransactionCurrencyEnum = "KZT"
	TransactionCurrencyEnumKes TransactionCurrencyEnum = "KES"
	TransactionCurrencyEnumKwd TransactionCurrencyEnum = "KWD"
	TransactionCurrencyEnumKgs TransactionCurrencyEnum = "KGS"
	TransactionCurrencyEnumLak TransactionCurrencyEnum = "LAK"
	TransactionCurrencyEnumLvl TransactionCurrencyEnum = "LVL"
	TransactionCurrencyEnumLvr TransactionCurrencyEnum = "LVR"
	TransactionCurrencyEnumLbp TransactionCurrencyEnum = "LBP"
	TransactionCurrencyEnumLsl TransactionCurrencyEnum = "LSL"
	TransactionCurrencyEnumLrd TransactionCurrencyEnum = "LRD"
	TransactionCurrencyEnumLyd TransactionCurrencyEnum = "LYD"
	TransactionCurrencyEnumLtl TransactionCurrencyEnum = "LTL"
	TransactionCurrencyEnumLtt TransactionCurrencyEnum = "LTT"
	TransactionCurrencyEnumLul TransactionCurrencyEnum = "LUL"
	TransactionCurrencyEnumLuc TransactionCurrencyEnum = "LUC"
	TransactionCurrencyEnumLuf TransactionCurrencyEnum = "LUF"
	TransactionCurrencyEnumMop TransactionCurrencyEnum = "MOP"
	TransactionCurrencyEnumMkd TransactionCurrencyEnum = "MKD"
	TransactionCurrencyEnumMkn TransactionCurrencyEnum = "MKN"
	TransactionCurrencyEnumMga TransactionCurrencyEnum = "MGA"
	TransactionCurrencyEnumMgf TransactionCurrencyEnum = "MGF"
	TransactionCurrencyEnumMwk TransactionCurrencyEnum = "MWK"
	TransactionCurrencyEnumMyr TransactionCurrencyEnum = "MYR"
	TransactionCurrencyEnumMvr TransactionCurrencyEnum = "MVR"
	TransactionCurrencyEnumMvp TransactionCurrencyEnum = "MVP"
	TransactionCurrencyEnumMlf TransactionCurrencyEnum = "MLF"
	TransactionCurrencyEnumMtl TransactionCurrencyEnum = "MTL"
	TransactionCurrencyEnumMtp TransactionCurrencyEnum = "MTP"
	TransactionCurrencyEnumMru TransactionCurrencyEnum = "MRU"
	TransactionCurrencyEnumMro TransactionCurrencyEnum = "MRO"
	TransactionCurrencyEnumMur TransactionCurrencyEnum = "MUR"
	TransactionCurrencyEnumMxv TransactionCurrencyEnum = "MXV"
	TransactionCurrencyEnumMxn TransactionCurrencyEnum = "MXN"
	TransactionCurrencyEnumMxp TransactionCurrencyEnum = "MXP"
	TransactionCurrencyEnumMdc TransactionCurrencyEnum = "MDC"
	TransactionCurrencyEnumMdl TransactionCurrencyEnum = "MDL"
	TransactionCurrencyEnumMcf TransactionCurrencyEnum = "MCF"
	TransactionCurrencyEnumMnt TransactionCurrencyEnum = "MNT"
	TransactionCurrencyEnumMad TransactionCurrencyEnum = "MAD"
	TransactionCurrencyEnumMaf TransactionCurrencyEnum = "MAF"
	TransactionCurrencyEnumMze TransactionCurrencyEnum = "MZE"
	TransactionCurrencyEnumMzn TransactionCurrencyEnum = "MZN"
	TransactionCurrencyEnumMzm TransactionCurrencyEnum = "MZM"
	TransactionCurrencyEnumMmk TransactionCurrencyEnum = "MMK"
	TransactionCurrencyEnumNad TransactionCurrencyEnum = "NAD"
	TransactionCurrencyEnumNpr TransactionCurrencyEnum = "NPR"
	TransactionCurrencyEnumAng TransactionCurrencyEnum = "ANG"
	TransactionCurrencyEnumTwd TransactionCurrencyEnum = "TWD"
	TransactionCurrencyEnumNzd TransactionCurrencyEnum = "NZD"
	TransactionCurrencyEnumNio TransactionCurrencyEnum = "NIO"
	TransactionCurrencyEnumNic TransactionCurrencyEnum = "NIC"
	TransactionCurrencyEnumNgn TransactionCurrencyEnum = "NGN"
	TransactionCurrencyEnumKpw TransactionCurrencyEnum = "KPW"
	TransactionCurrencyEnumNok TransactionCurrencyEnum = "NOK"
	TransactionCurrencyEnumOmr TransactionCurrencyEnum = "OMR"
	TransactionCurrencyEnumPkr TransactionCurrencyEnum = "PKR"
	TransactionCurrencyEnumXpd TransactionCurrencyEnum = "XPD"
	TransactionCurrencyEnumPab TransactionCurrencyEnum = "PAB"
	TransactionCurrencyEnumPgk TransactionCurrencyEnum = "PGK"
	TransactionCurrencyEnumPyg TransactionCurrencyEnum = "PYG"
	TransactionCurrencyEnumPei TransactionCurrencyEnum = "PEI"
	TransactionCurrencyEnumPen TransactionCurrencyEnum = "PEN"
	TransactionCurrencyEnumPes TransactionCurrencyEnum = "PES"
	TransactionCurrencyEnumPhp TransactionCurrencyEnum = "PHP"
	TransactionCurrencyEnumXpt TransactionCurrencyEnum = "XPT"
	TransactionCurrencyEnumPln TransactionCurrencyEnum = "PLN"
	TransactionCurrencyEnumPlz TransactionCurrencyEnum = "PLZ"
	TransactionCurrencyEnumPte TransactionCurrencyEnum = "PTE"
	TransactionCurrencyEnumGwe TransactionCurrencyEnum = "GWE"
	TransactionCurrencyEnumQar TransactionCurrencyEnum = "QAR"
	TransactionCurrencyEnumXre TransactionCurrencyEnum = "XRE"
	TransactionCurrencyEnumRhd TransactionCurrencyEnum = "RHD"
	TransactionCurrencyEnumRon TransactionCurrencyEnum = "RON"
	TransactionCurrencyEnumRol TransactionCurrencyEnum = "ROL"
	TransactionCurrencyEnumRub TransactionCurrencyEnum = "RUB"
	TransactionCurrencyEnumRur TransactionCurrencyEnum = "RUR"
	TransactionCurrencyEnumRwf TransactionCurrencyEnum = "RWF"
	TransactionCurrencyEnumSvc TransactionCurrencyEnum = "SVC"
	TransactionCurrencyEnumWst TransactionCurrencyEnum = "WST"
	TransactionCurrencyEnumSar TransactionCurrencyEnum = "SAR"
	TransactionCurrencyEnumRsd TransactionCurrencyEnum = "RSD"
	TransactionCurrencyEnumCsd TransactionCurrencyEnum = "CSD"
	TransactionCurrencyEnumScr TransactionCurrencyEnum = "SCR"
	TransactionCurrencyEnumSll TransactionCurrencyEnum = "SLL"
	TransactionCurrencyEnumXag TransactionCurrencyEnum = "XAG"
	TransactionCurrencyEnumSgd TransactionCurrencyEnum = "SGD"
	TransactionCurrencyEnumSkk TransactionCurrencyEnum = "SKK"
	TransactionCurrencyEnumSit TransactionCurrencyEnum = "SIT"
	TransactionCurrencyEnumSbd TransactionCurrencyEnum = "SBD"
	TransactionCurrencyEnumSos TransactionCurrencyEnum = "SOS"
	TransactionCurrencyEnumZar TransactionCurrencyEnum = "ZAR"
	TransactionCurrencyEnumZal TransactionCurrencyEnum = "ZAL"
	TransactionCurrencyEnumKrh TransactionCurrencyEnum = "KRH"
	TransactionCurrencyEnumKrw TransactionCurrencyEnum = "KRW"
	TransactionCurrencyEnumKro TransactionCurrencyEnum = "KRO"
	TransactionCurrencyEnumSsp TransactionCurrencyEnum = "SSP"
	TransactionCurrencyEnumSur TransactionCurrencyEnum = "SUR"
	TransactionCurrencyEnumEsp TransactionCurrencyEnum = "ESP"
	TransactionCurrencyEnumEsa TransactionCurrencyEnum = "ESA"
	TransactionCurrencyEnumEsb TransactionCurrencyEnum = "ESB"
	TransactionCurrencyEnumXdr TransactionCurrencyEnum = "XDR"
	TransactionCurrencyEnumLkr TransactionCurrencyEnum = "LKR"
	TransactionCurrencyEnumShp TransactionCurrencyEnum = "SHP"
	TransactionCurrencyEnumXsu TransactionCurrencyEnum = "XSU"
	TransactionCurrencyEnumSdd TransactionCurrencyEnum = "SDD"
	TransactionCurrencyEnumSdg TransactionCurrencyEnum = "SDG"
	TransactionCurrencyEnumSdp TransactionCurrencyEnum = "SDP"
	TransactionCurrencyEnumSrd TransactionCurrencyEnum = "SRD"
	TransactionCurrencyEnumSrg TransactionCurrencyEnum = "SRG"
	TransactionCurrencyEnumSzl TransactionCurrencyEnum = "SZL"
	TransactionCurrencyEnumSek TransactionCurrencyEnum = "SEK"
	TransactionCurrencyEnumChf TransactionCurrencyEnum = "CHF"
	TransactionCurrencyEnumSyp TransactionCurrencyEnum = "SYP"
	TransactionCurrencyEnumStn TransactionCurrencyEnum = "STN"
	TransactionCurrencyEnumStd TransactionCurrencyEnum = "STD"
	TransactionCurrencyEnumTvd TransactionCurrencyEnum = "TVD"
	TransactionCurrencyEnumTjr TransactionCurrencyEnum = "TJR"
	TransactionCurrencyEnumTjs TransactionCurrencyEnum = "TJS"
	TransactionCurrencyEnumTzs TransactionCurrencyEnum = "TZS"
	TransactionCurrencyEnumXts TransactionCurrencyEnum = "XTS"
	TransactionCurrencyEnumThb TransactionCurrencyEnum = "THB"
	TransactionCurrencyEnumXxx TransactionCurrencyEnum = "XXX"
	TransactionCurrencyEnumTpe TransactionCurrencyEnum = "TPE"
	TransactionCurrencyEnumTop TransactionCurrencyEnum = "TOP"
	TransactionCurrencyEnumTtd TransactionCurrencyEnum = "TTD"
	TransactionCurrencyEnumTnd TransactionCurrencyEnum = "TND"
	TransactionCurrencyEnumTry TransactionCurrencyEnum = "TRY"
	TransactionCurrencyEnumTrl TransactionCurrencyEnum = "TRL"
	TransactionCurrencyEnumTmt TransactionCurrencyEnum = "TMT"
	TransactionCurrencyEnumTmm TransactionCurrencyEnum = "TMM"
	TransactionCurrencyEnumUsd TransactionCurrencyEnum = "USD"
	TransactionCurrencyEnumUsn TransactionCurrencyEnum = "USN"
	TransactionCurrencyEnumUss TransactionCurrencyEnum = "USS"
	TransactionCurrencyEnumUgx TransactionCurrencyEnum = "UGX"
	TransactionCurrencyEnumUgs TransactionCurrencyEnum = "UGS"
	TransactionCurrencyEnumUah TransactionCurrencyEnum = "UAH"
	TransactionCurrencyEnumUak TransactionCurrencyEnum = "UAK"
	TransactionCurrencyEnumAed TransactionCurrencyEnum = "AED"
	TransactionCurrencyEnumUyw TransactionCurrencyEnum = "UYW"
	TransactionCurrencyEnumUyu TransactionCurrencyEnum = "UYU"
	TransactionCurrencyEnumUyp TransactionCurrencyEnum = "UYP"
	TransactionCurrencyEnumUyi TransactionCurrencyEnum = "UYI"
	TransactionCurrencyEnumUzs TransactionCurrencyEnum = "UZS"
	TransactionCurrencyEnumVuv TransactionCurrencyEnum = "VUV"
	TransactionCurrencyEnumVes TransactionCurrencyEnum = "VES"
	TransactionCurrencyEnumVeb TransactionCurrencyEnum = "VEB"
	TransactionCurrencyEnumVef TransactionCurrencyEnum = "VEF"
	TransactionCurrencyEnumVnd TransactionCurrencyEnum = "VND"
	TransactionCurrencyEnumVnn TransactionCurrencyEnum = "VNN"
	TransactionCurrencyEnumChe TransactionCurrencyEnum = "CHE"
	TransactionCurrencyEnumChw TransactionCurrencyEnum = "CHW"
	TransactionCurrencyEnumXof TransactionCurrencyEnum = "XOF"
	TransactionCurrencyEnumYdd TransactionCurrencyEnum = "YDD"
	TransactionCurrencyEnumYer TransactionCurrencyEnum = "YER"
	TransactionCurrencyEnumYun TransactionCurrencyEnum = "YUN"
	TransactionCurrencyEnumYud TransactionCurrencyEnum = "YUD"
	TransactionCurrencyEnumYum TransactionCurrencyEnum = "YUM"
	TransactionCurrencyEnumYur TransactionCurrencyEnum = "YUR"
	TransactionCurrencyEnumZwn TransactionCurrencyEnum = "ZWN"
	TransactionCurrencyEnumZrn TransactionCurrencyEnum = "ZRN"
	TransactionCurrencyEnumZrz TransactionCurrencyEnum = "ZRZ"
	TransactionCurrencyEnumZmw TransactionCurrencyEnum = "ZMW"
	TransactionCurrencyEnumZmk TransactionCurrencyEnum = "ZMK"
	TransactionCurrencyEnumZwd TransactionCurrencyEnum = "ZWD"
	TransactionCurrencyEnumZwr TransactionCurrencyEnum = "ZWR"
	TransactionCurrencyEnumZwl TransactionCurrencyEnum = "ZWL"
)

func NewTransactionCurrencyEnumFromString(s string) (TransactionCurrencyEnum, error) {
	switch s {
	case "XUA":
		return TransactionCurrencyEnumXua, nil
	case "AFN":
		return TransactionCurrencyEnumAfn, nil
	case "AFA":
		return TransactionCurrencyEnumAfa, nil
	case "ALL":
		return TransactionCurrencyEnumAll, nil
	case "ALK":
		return TransactionCurrencyEnumAlk, nil
	case "DZD":
		return TransactionCurrencyEnumDzd, nil
	case "ADP":
		return TransactionCurrencyEnumAdp, nil
	case "AOA":
		return TransactionCurrencyEnumAoa, nil
	case "AOK":
		return TransactionCurrencyEnumAok, nil
	case "AON":
		return TransactionCurrencyEnumAon, nil
	case "AOR":
		return TransactionCurrencyEnumAor, nil
	case "ARA":
		return TransactionCurrencyEnumAra, nil
	case "ARS":
		return TransactionCurrencyEnumArs, nil
	case "ARM":
		return TransactionCurrencyEnumArm, nil
	case "ARP":
		return TransactionCurrencyEnumArp, nil
	case "ARL":
		return TransactionCurrencyEnumArl, nil
	case "AMD":
		return TransactionCurrencyEnumAmd, nil
	case "AWG":
		return TransactionCurrencyEnumAwg, nil
	case "AUD":
		return TransactionCurrencyEnumAud, nil
	case "ATS":
		return TransactionCurrencyEnumAts, nil
	case "AZN":
		return TransactionCurrencyEnumAzn, nil
	case "AZM":
		return TransactionCurrencyEnumAzm, nil
	case "BSD":
		return TransactionCurrencyEnumBsd, nil
	case "BHD":
		return TransactionCurrencyEnumBhd, nil
	case "BDT":
		return TransactionCurrencyEnumBdt, nil
	case "BBD":
		return TransactionCurrencyEnumBbd, nil
	case "BYN":
		return TransactionCurrencyEnumByn, nil
	case "BYB":
		return TransactionCurrencyEnumByb, nil
	case "BYR":
		return TransactionCurrencyEnumByr, nil
	case "BEF":
		return TransactionCurrencyEnumBef, nil
	case "BEC":
		return TransactionCurrencyEnumBec, nil
	case "BEL":
		return TransactionCurrencyEnumBel, nil
	case "BZD":
		return TransactionCurrencyEnumBzd, nil
	case "BMD":
		return TransactionCurrencyEnumBmd, nil
	case "BTN":
		return TransactionCurrencyEnumBtn, nil
	case "BOB":
		return TransactionCurrencyEnumBob, nil
	case "BOL":
		return TransactionCurrencyEnumBol, nil
	case "BOV":
		return TransactionCurrencyEnumBov, nil
	case "BOP":
		return TransactionCurrencyEnumBop, nil
	case "BAM":
		return TransactionCurrencyEnumBam, nil
	case "BAD":
		return TransactionCurrencyEnumBad, nil
	case "BAN":
		return TransactionCurrencyEnumBan, nil
	case "BWP":
		return TransactionCurrencyEnumBwp, nil
	case "BRC":
		return TransactionCurrencyEnumBrc, nil
	case "BRZ":
		return TransactionCurrencyEnumBrz, nil
	case "BRE":
		return TransactionCurrencyEnumBre, nil
	case "BRR":
		return TransactionCurrencyEnumBrr, nil
	case "BRN":
		return TransactionCurrencyEnumBrn, nil
	case "BRB":
		return TransactionCurrencyEnumBrb, nil
	case "BRL":
		return TransactionCurrencyEnumBrl, nil
	case "GBP":
		return TransactionCurrencyEnumGbp, nil
	case "BND":
		return TransactionCurrencyEnumBnd, nil
	case "BGL":
		return TransactionCurrencyEnumBgl, nil
	case "BGN":
		return TransactionCurrencyEnumBgn, nil
	case "BGO":
		return TransactionCurrencyEnumBgo, nil
	case "BGM":
		return TransactionCurrencyEnumBgm, nil
	case "BUK":
		return TransactionCurrencyEnumBuk, nil
	case "BIF":
		return TransactionCurrencyEnumBif, nil
	case "XPF":
		return TransactionCurrencyEnumXpf, nil
	case "KHR":
		return TransactionCurrencyEnumKhr, nil
	case "CAD":
		return TransactionCurrencyEnumCad, nil
	case "CVE":
		return TransactionCurrencyEnumCve, nil
	case "KYD":
		return TransactionCurrencyEnumKyd, nil
	case "XAF":
		return TransactionCurrencyEnumXaf, nil
	case "CLE":
		return TransactionCurrencyEnumCle, nil
	case "CLP":
		return TransactionCurrencyEnumClp, nil
	case "CLF":
		return TransactionCurrencyEnumClf, nil
	case "CNX":
		return TransactionCurrencyEnumCnx, nil
	case "CNY":
		return TransactionCurrencyEnumCny, nil
	case "CNH":
		return TransactionCurrencyEnumCnh, nil
	case "COP":
		return TransactionCurrencyEnumCop, nil
	case "COU":
		return TransactionCurrencyEnumCou, nil
	case "KMF":
		return TransactionCurrencyEnumKmf, nil
	case "CDF":
		return TransactionCurrencyEnumCdf, nil
	case "CRC":
		return TransactionCurrencyEnumCrc, nil
	case "HRD":
		return TransactionCurrencyEnumHrd, nil
	case "HRK":
		return TransactionCurrencyEnumHrk, nil
	case "CUC":
		return TransactionCurrencyEnumCuc, nil
	case "CUP":
		return TransactionCurrencyEnumCup, nil
	case "CYP":
		return TransactionCurrencyEnumCyp, nil
	case "CZK":
		return TransactionCurrencyEnumCzk, nil
	case "CSK":
		return TransactionCurrencyEnumCsk, nil
	case "DKK":
		return TransactionCurrencyEnumDkk, nil
	case "DJF":
		return TransactionCurrencyEnumDjf, nil
	case "DOP":
		return TransactionCurrencyEnumDop, nil
	case "NLG":
		return TransactionCurrencyEnumNlg, nil
	case "XCD":
		return TransactionCurrencyEnumXcd, nil
	case "DDM":
		return TransactionCurrencyEnumDdm, nil
	case "ECS":
		return TransactionCurrencyEnumEcs, nil
	case "ECV":
		return TransactionCurrencyEnumEcv, nil
	case "EGP":
		return TransactionCurrencyEnumEgp, nil
	case "GQE":
		return TransactionCurrencyEnumGqe, nil
	case "ERN":
		return TransactionCurrencyEnumErn, nil
	case "EEK":
		return TransactionCurrencyEnumEek, nil
	case "ETB":
		return TransactionCurrencyEnumEtb, nil
	case "EUR":
		return TransactionCurrencyEnumEur, nil
	case "XBA":
		return TransactionCurrencyEnumXba, nil
	case "XEU":
		return TransactionCurrencyEnumXeu, nil
	case "XBB":
		return TransactionCurrencyEnumXbb, nil
	case "XBC":
		return TransactionCurrencyEnumXbc, nil
	case "XBD":
		return TransactionCurrencyEnumXbd, nil
	case "FKP":
		return TransactionCurrencyEnumFkp, nil
	case "FJD":
		return TransactionCurrencyEnumFjd, nil
	case "FIM":
		return TransactionCurrencyEnumFim, nil
	case "FRF":
		return TransactionCurrencyEnumFrf, nil
	case "XFO":
		return TransactionCurrencyEnumXfo, nil
	case "XFU":
		return TransactionCurrencyEnumXfu, nil
	case "GMD":
		return TransactionCurrencyEnumGmd, nil
	case "GEK":
		return TransactionCurrencyEnumGek, nil
	case "GEL":
		return TransactionCurrencyEnumGel, nil
	case "DEM":
		return TransactionCurrencyEnumDem, nil
	case "GHS":
		return TransactionCurrencyEnumGhs, nil
	case "GHC":
		return TransactionCurrencyEnumGhc, nil
	case "GIP":
		return TransactionCurrencyEnumGip, nil
	case "XAU":
		return TransactionCurrencyEnumXau, nil
	case "GRD":
		return TransactionCurrencyEnumGrd, nil
	case "GTQ":
		return TransactionCurrencyEnumGtq, nil
	case "GWP":
		return TransactionCurrencyEnumGwp, nil
	case "GNF":
		return TransactionCurrencyEnumGnf, nil
	case "GNS":
		return TransactionCurrencyEnumGns, nil
	case "GYD":
		return TransactionCurrencyEnumGyd, nil
	case "HTG":
		return TransactionCurrencyEnumHtg, nil
	case "HNL":
		return TransactionCurrencyEnumHnl, nil
	case "HKD":
		return TransactionCurrencyEnumHkd, nil
	case "HUF":
		return TransactionCurrencyEnumHuf, nil
	case "IMP":
		return TransactionCurrencyEnumImp, nil
	case "ISK":
		return TransactionCurrencyEnumIsk, nil
	case "ISJ":
		return TransactionCurrencyEnumIsj, nil
	case "INR":
		return TransactionCurrencyEnumInr, nil
	case "IDR":
		return TransactionCurrencyEnumIdr, nil
	case "IRR":
		return TransactionCurrencyEnumIrr, nil
	case "IQD":
		return TransactionCurrencyEnumIqd, nil
	case "IEP":
		return TransactionCurrencyEnumIep, nil
	case "ILS":
		return TransactionCurrencyEnumIls, nil
	case "ILP":
		return TransactionCurrencyEnumIlp, nil
	case "ILR":
		return TransactionCurrencyEnumIlr, nil
	case "ITL":
		return TransactionCurrencyEnumItl, nil
	case "JMD":
		return TransactionCurrencyEnumJmd, nil
	case "JPY":
		return TransactionCurrencyEnumJpy, nil
	case "JOD":
		return TransactionCurrencyEnumJod, nil
	case "KZT":
		return TransactionCurrencyEnumKzt, nil
	case "KES":
		return TransactionCurrencyEnumKes, nil
	case "KWD":
		return TransactionCurrencyEnumKwd, nil
	case "KGS":
		return TransactionCurrencyEnumKgs, nil
	case "LAK":
		return TransactionCurrencyEnumLak, nil
	case "LVL":
		return TransactionCurrencyEnumLvl, nil
	case "LVR":
		return TransactionCurrencyEnumLvr, nil
	case "LBP":
		return TransactionCurrencyEnumLbp, nil
	case "LSL":
		return TransactionCurrencyEnumLsl, nil
	case "LRD":
		return TransactionCurrencyEnumLrd, nil
	case "LYD":
		return TransactionCurrencyEnumLyd, nil
	case "LTL":
		return TransactionCurrencyEnumLtl, nil
	case "LTT":
		return TransactionCurrencyEnumLtt, nil
	case "LUL":
		return TransactionCurrencyEnumLul, nil
	case "LUC":
		return TransactionCurrencyEnumLuc, nil
	case "LUF":
		return TransactionCurrencyEnumLuf, nil
	case "MOP":
		return TransactionCurrencyEnumMop, nil
	case "MKD":
		return TransactionCurrencyEnumMkd, nil
	case "MKN":
		return TransactionCurrencyEnumMkn, nil
	case "MGA":
		return TransactionCurrencyEnumMga, nil
	case "MGF":
		return TransactionCurrencyEnumMgf, nil
	case "MWK":
		return TransactionCurrencyEnumMwk, nil
	case "MYR":
		return TransactionCurrencyEnumMyr, nil
	case "MVR":
		return TransactionCurrencyEnumMvr, nil
	case "MVP":
		return TransactionCurrencyEnumMvp, nil
	case "MLF":
		return TransactionCurrencyEnumMlf, nil
	case "MTL":
		return TransactionCurrencyEnumMtl, nil
	case "MTP":
		return TransactionCurrencyEnumMtp, nil
	case "MRU":
		return TransactionCurrencyEnumMru, nil
	case "MRO":
		return TransactionCurrencyEnumMro, nil
	case "MUR":
		return TransactionCurrencyEnumMur, nil
	case "MXV":
		return TransactionCurrencyEnumMxv, nil
	case "MXN":
		return TransactionCurrencyEnumMxn, nil
	case "MXP":
		return TransactionCurrencyEnumMxp, nil
	case "MDC":
		return TransactionCurrencyEnumMdc, nil
	case "MDL":
		return TransactionCurrencyEnumMdl, nil
	case "MCF":
		return TransactionCurrencyEnumMcf, nil
	case "MNT":
		return TransactionCurrencyEnumMnt, nil
	case "MAD":
		return TransactionCurrencyEnumMad, nil
	case "MAF":
		return TransactionCurrencyEnumMaf, nil
	case "MZE":
		return TransactionCurrencyEnumMze, nil
	case "MZN":
		return TransactionCurrencyEnumMzn, nil
	case "MZM":
		return TransactionCurrencyEnumMzm, nil
	case "MMK":
		return TransactionCurrencyEnumMmk, nil
	case "NAD":
		return TransactionCurrencyEnumNad, nil
	case "NPR":
		return TransactionCurrencyEnumNpr, nil
	case "ANG":
		return TransactionCurrencyEnumAng, nil
	case "TWD":
		return TransactionCurrencyEnumTwd, nil
	case "NZD":
		return TransactionCurrencyEnumNzd, nil
	case "NIO":
		return TransactionCurrencyEnumNio, nil
	case "NIC":
		return TransactionCurrencyEnumNic, nil
	case "NGN":
		return TransactionCurrencyEnumNgn, nil
	case "KPW":
		return TransactionCurrencyEnumKpw, nil
	case "NOK":
		return TransactionCurrencyEnumNok, nil
	case "OMR":
		return TransactionCurrencyEnumOmr, nil
	case "PKR":
		return TransactionCurrencyEnumPkr, nil
	case "XPD":
		return TransactionCurrencyEnumXpd, nil
	case "PAB":
		return TransactionCurrencyEnumPab, nil
	case "PGK":
		return TransactionCurrencyEnumPgk, nil
	case "PYG":
		return TransactionCurrencyEnumPyg, nil
	case "PEI":
		return TransactionCurrencyEnumPei, nil
	case "PEN":
		return TransactionCurrencyEnumPen, nil
	case "PES":
		return TransactionCurrencyEnumPes, nil
	case "PHP":
		return TransactionCurrencyEnumPhp, nil
	case "XPT":
		return TransactionCurrencyEnumXpt, nil
	case "PLN":
		return TransactionCurrencyEnumPln, nil
	case "PLZ":
		return TransactionCurrencyEnumPlz, nil
	case "PTE":
		return TransactionCurrencyEnumPte, nil
	case "GWE":
		return TransactionCurrencyEnumGwe, nil
	case "QAR":
		return TransactionCurrencyEnumQar, nil
	case "XRE":
		return TransactionCurrencyEnumXre, nil
	case "RHD":
		return TransactionCurrencyEnumRhd, nil
	case "RON":
		return TransactionCurrencyEnumRon, nil
	case "ROL":
		return TransactionCurrencyEnumRol, nil
	case "RUB":
		return TransactionCurrencyEnumRub, nil
	case "RUR":
		return TransactionCurrencyEnumRur, nil
	case "RWF":
		return TransactionCurrencyEnumRwf, nil
	case "SVC":
		return TransactionCurrencyEnumSvc, nil
	case "WST":
		return TransactionCurrencyEnumWst, nil
	case "SAR":
		return TransactionCurrencyEnumSar, nil
	case "RSD":
		return TransactionCurrencyEnumRsd, nil
	case "CSD":
		return TransactionCurrencyEnumCsd, nil
	case "SCR":
		return TransactionCurrencyEnumScr, nil
	case "SLL":
		return TransactionCurrencyEnumSll, nil
	case "XAG":
		return TransactionCurrencyEnumXag, nil
	case "SGD":
		return TransactionCurrencyEnumSgd, nil
	case "SKK":
		return TransactionCurrencyEnumSkk, nil
	case "SIT":
		return TransactionCurrencyEnumSit, nil
	case "SBD":
		return TransactionCurrencyEnumSbd, nil
	case "SOS":
		return TransactionCurrencyEnumSos, nil
	case "ZAR":
		return TransactionCurrencyEnumZar, nil
	case "ZAL":
		return TransactionCurrencyEnumZal, nil
	case "KRH":
		return TransactionCurrencyEnumKrh, nil
	case "KRW":
		return TransactionCurrencyEnumKrw, nil
	case "KRO":
		return TransactionCurrencyEnumKro, nil
	case "SSP":
		return TransactionCurrencyEnumSsp, nil
	case "SUR":
		return TransactionCurrencyEnumSur, nil
	case "ESP":
		return TransactionCurrencyEnumEsp, nil
	case "ESA":
		return TransactionCurrencyEnumEsa, nil
	case "ESB":
		return TransactionCurrencyEnumEsb, nil
	case "XDR":
		return TransactionCurrencyEnumXdr, nil
	case "LKR":
		return TransactionCurrencyEnumLkr, nil
	case "SHP":
		return TransactionCurrencyEnumShp, nil
	case "XSU":
		return TransactionCurrencyEnumXsu, nil
	case "SDD":
		return TransactionCurrencyEnumSdd, nil
	case "SDG":
		return TransactionCurrencyEnumSdg, nil
	case "SDP":
		return TransactionCurrencyEnumSdp, nil
	case "SRD":
		return TransactionCurrencyEnumSrd, nil
	case "SRG":
		return TransactionCurrencyEnumSrg, nil
	case "SZL":
		return TransactionCurrencyEnumSzl, nil
	case "SEK":
		return TransactionCurrencyEnumSek, nil
	case "CHF":
		return TransactionCurrencyEnumChf, nil
	case "SYP":
		return TransactionCurrencyEnumSyp, nil
	case "STN":
		return TransactionCurrencyEnumStn, nil
	case "STD":
		return TransactionCurrencyEnumStd, nil
	case "TVD":
		return TransactionCurrencyEnumTvd, nil
	case "TJR":
		return TransactionCurrencyEnumTjr, nil
	case "TJS":
		return TransactionCurrencyEnumTjs, nil
	case "TZS":
		return TransactionCurrencyEnumTzs, nil
	case "XTS":
		return TransactionCurrencyEnumXts, nil
	case "THB":
		return TransactionCurrencyEnumThb, nil
	case "XXX":
		return TransactionCurrencyEnumXxx, nil
	case "TPE":
		return TransactionCurrencyEnumTpe, nil
	case "TOP":
		return TransactionCurrencyEnumTop, nil
	case "TTD":
		return TransactionCurrencyEnumTtd, nil
	case "TND":
		return TransactionCurrencyEnumTnd, nil
	case "TRY":
		return TransactionCurrencyEnumTry, nil
	case "TRL":
		return TransactionCurrencyEnumTrl, nil
	case "TMT":
		return TransactionCurrencyEnumTmt, nil
	case "TMM":
		return TransactionCurrencyEnumTmm, nil
	case "USD":
		return TransactionCurrencyEnumUsd, nil
	case "USN":
		return TransactionCurrencyEnumUsn, nil
	case "USS":
		return TransactionCurrencyEnumUss, nil
	case "UGX":
		return TransactionCurrencyEnumUgx, nil
	case "UGS":
		return TransactionCurrencyEnumUgs, nil
	case "UAH":
		return TransactionCurrencyEnumUah, nil
	case "UAK":
		return TransactionCurrencyEnumUak, nil
	case "AED":
		return TransactionCurrencyEnumAed, nil
	case "UYW":
		return TransactionCurrencyEnumUyw, nil
	case "UYU":
		return TransactionCurrencyEnumUyu, nil
	case "UYP":
		return TransactionCurrencyEnumUyp, nil
	case "UYI":
		return TransactionCurrencyEnumUyi, nil
	case "UZS":
		return TransactionCurrencyEnumUzs, nil
	case "VUV":
		return TransactionCurrencyEnumVuv, nil
	case "VES":
		return TransactionCurrencyEnumVes, nil
	case "VEB":
		return TransactionCurrencyEnumVeb, nil
	case "VEF":
		return TransactionCurrencyEnumVef, nil
	case "VND":
		return TransactionCurrencyEnumVnd, nil
	case "VNN":
		return TransactionCurrencyEnumVnn, nil
	case "CHE":
		return TransactionCurrencyEnumChe, nil
	case "CHW":
		return TransactionCurrencyEnumChw, nil
	case "XOF":
		return TransactionCurrencyEnumXof, nil
	case "YDD":
		return TransactionCurrencyEnumYdd, nil
	case "YER":
		return TransactionCurrencyEnumYer, nil
	case "YUN":
		return TransactionCurrencyEnumYun, nil
	case "YUD":
		return TransactionCurrencyEnumYud, nil
	case "YUM":
		return TransactionCurrencyEnumYum, nil
	case "YUR":
		return TransactionCurrencyEnumYur, nil
	case "ZWN":
		return TransactionCurrencyEnumZwn, nil
	case "ZRN":
		return TransactionCurrencyEnumZrn, nil
	case "ZRZ":
		return TransactionCurrencyEnumZrz, nil
	case "ZMW":
		return TransactionCurrencyEnumZmw, nil
	case "ZMK":
		return TransactionCurrencyEnumZmk, nil
	case "ZWD":
		return TransactionCurrencyEnumZwd, nil
	case "ZWR":
		return TransactionCurrencyEnumZwr, nil
	case "ZWL":
		return TransactionCurrencyEnumZwl, nil
	}
	var t TransactionCurrencyEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionCurrencyEnum) Ptr() *TransactionCurrencyEnum {
	return &t
}

// # The TransactionLineItem Object
//
// ### Description
//
// The `TransactionLineItem` object is used to represent a transaction's line items.
//
// ### Usage Example
//
// Fetch from the `GET TransactionLineItem` endpoint and view the transaction's line items.
type TransactionLineItem struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// An internal note used by the business to clarify purpose of the transaction.
	Memo *string `json:"memo,omitempty"`
	// The line item's unit price.
	UnitPrice *string `json:"unit_price,omitempty"`
	// The line item's quantity.
	Quantity *string                  `json:"quantity,omitempty"`
	Item     *TransactionLineItemItem `json:"item,omitempty"`
	// The line item's account.
	Account *string `json:"account,omitempty"`
	// The line's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty"`
	// The transaction line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty"`
	// The line item's total.
	TotalLineAmount *string `json:"total_line_amount,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The line item's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionLineItemCurrency `json:"currency,omitempty"`
	// The line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// The company the line belongs to.
	Company *string `json:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TransactionLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionLineItem(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionLineItem) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The line item's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type TransactionLineItemCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewTransactionLineItemCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *TransactionLineItemCurrency {
	return &TransactionLineItemCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewTransactionLineItemCurrencyFromString(value string) *TransactionLineItemCurrency {
	return &TransactionLineItemCurrency{typeName: "string", String: value}
}

func (t *TransactionLineItemCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		t.typeName = "transactionCurrencyEnum"
		t.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransactionLineItemCurrency) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transactionCurrencyEnum":
		return json.Marshal(t.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransactionLineItemCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (t *TransactionLineItemCurrency) Accept(visitor TransactionLineItemCurrencyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(t.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransactionLineItemItem struct {
	typeName string
	String   string
	Item     *Item
}

func NewTransactionLineItemItemFromString(value string) *TransactionLineItemItem {
	return &TransactionLineItemItem{typeName: "string", String: value}
}

func NewTransactionLineItemItemFromItem(value *Item) *TransactionLineItemItem {
	return &TransactionLineItemItem{typeName: "item", Item: value}
}

func (t *TransactionLineItemItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		t.typeName = "item"
		t.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransactionLineItemItem) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "item":
		return json.Marshal(t.Item)
	}
}

type TransactionLineItemItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (t *TransactionLineItemItem) Accept(visitor TransactionLineItemItemVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "item":
		return visitor.VisitItem(t.Item)
	}
}

type TransactionTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewTransactionTrackingCategoriesItemFromString(value string) *TransactionTrackingCategoriesItem {
	return &TransactionTrackingCategoriesItem{typeName: "string", String: value}
}

func NewTransactionTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *TransactionTrackingCategoriesItem {
	return &TransactionTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (t *TransactionTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		t.typeName = "trackingCategory"
		t.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransactionTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "trackingCategory":
		return json.Marshal(t.TrackingCategory)
	}
}

type TransactionTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (t *TransactionTrackingCategoriesItem) Accept(visitor TransactionTrackingCategoriesItemVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(t.TrackingCategory)
	}
}

// - `INVOICE` - INVOICE
// - `EXPENSE` - EXPENSE
// - `TRANSACTION` - TRANSACTION
// - `JOURNAL_ENTRY` - JOURNAL_ENTRY
// - `PAYMENT` - PAYMENT
// - `VENDOR_CREDIT` - VENDOR_CREDIT
// - `CREDIT_NOTE` - CREDIT_NOTE
type UnderlyingTransactionTypeEnum string

const (
	UnderlyingTransactionTypeEnumInvoice      UnderlyingTransactionTypeEnum = "INVOICE"
	UnderlyingTransactionTypeEnumExpense      UnderlyingTransactionTypeEnum = "EXPENSE"
	UnderlyingTransactionTypeEnumTransaction  UnderlyingTransactionTypeEnum = "TRANSACTION"
	UnderlyingTransactionTypeEnumJournalEntry UnderlyingTransactionTypeEnum = "JOURNAL_ENTRY"
	UnderlyingTransactionTypeEnumPayment      UnderlyingTransactionTypeEnum = "PAYMENT"
	UnderlyingTransactionTypeEnumVendorCredit UnderlyingTransactionTypeEnum = "VENDOR_CREDIT"
	UnderlyingTransactionTypeEnumCreditNote   UnderlyingTransactionTypeEnum = "CREDIT_NOTE"
)

func NewUnderlyingTransactionTypeEnumFromString(s string) (UnderlyingTransactionTypeEnum, error) {
	switch s {
	case "INVOICE":
		return UnderlyingTransactionTypeEnumInvoice, nil
	case "EXPENSE":
		return UnderlyingTransactionTypeEnumExpense, nil
	case "TRANSACTION":
		return UnderlyingTransactionTypeEnumTransaction, nil
	case "JOURNAL_ENTRY":
		return UnderlyingTransactionTypeEnumJournalEntry, nil
	case "PAYMENT":
		return UnderlyingTransactionTypeEnumPayment, nil
	case "VENDOR_CREDIT":
		return UnderlyingTransactionTypeEnumVendorCredit, nil
	case "CREDIT_NOTE":
		return UnderlyingTransactionTypeEnumCreditNote, nil
	}
	var t UnderlyingTransactionTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UnderlyingTransactionTypeEnum) Ptr() *UnderlyingTransactionTypeEnum {
	return &u
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer"`

	_rawJSON json.RawMessage
}

func (v *ValidationProblemSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationProblemSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationProblemSource(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationProblemSource) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// # The VendorCredit Object
//
// ### Description
//
// A `VendorCredit` is transaction issued by a vendor to the accounting company, indicating a reduction or cancellation of the amount owed to the vendor. It is most generally used as an adjustment note used to rectify errors, returns, or overpayments related to a purchasing transaction. A `VendorCredit` can be applied to `Accounts Payable` Invoices to decrease the overall amount of the `Invoice`.
//
// ### Usage Example
//
// Fetch from the `GET VendorCredit` endpoint and view a company's vendor credits.
type VendorCredit struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The vendor credit's number.
	Number *string `json:"number,omitempty"`
	// The vendor credit's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The vendor that owes the gift or refund.
	Vendor *VendorCreditVendor `json:"vendor,omitempty"`
	// The vendor credit's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The vendor credit's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *VendorCreditCurrency `json:"currency,omitempty"`
	// The vendor credit's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty"`
	// The company the vendor credit belongs to.
	Company            *VendorCreditCompany                  `json:"company,omitempty"`
	Lines              []*VendorCreditLine                   `json:"lines,omitempty"`
	TrackingCategories []*VendorCreditTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// A list of VendorCredit Applied to Lines objects.
	AppliedToLines []*VendorCreditApplyLineForVendorCredit `json:"applied_to_lines,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`
	// The accounting period that the VendorCredit was generated in.
	AccountingPeriod *VendorCreditAccountingPeriod `json:"accounting_period,omitempty"`
	FieldMappings    map[string]interface{}        `json:"field_mappings,omitempty"`
	RemoteData       []*RemoteData                 `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorCredit) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCredit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCredit(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCredit) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The accounting period that the VendorCredit was generated in.
type VendorCreditAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewVendorCreditAccountingPeriodFromString(value string) *VendorCreditAccountingPeriod {
	return &VendorCreditAccountingPeriod{typeName: "string", String: value}
}

func NewVendorCreditAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *VendorCreditAccountingPeriod {
	return &VendorCreditAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (v *VendorCreditAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		v.typeName = "accountingPeriod"
		v.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "accountingPeriod":
		return json.Marshal(v.AccountingPeriod)
	}
}

type VendorCreditAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (v *VendorCreditAccountingPeriod) Accept(visitor VendorCreditAccountingPeriodVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(v.AccountingPeriod)
	}
}

// # The VendorCreditApplyLine Object
//
// ### Description
//
// The `VendorCreditApplyLine` object is used to represent a applied vendor credit.
//
// ### Usage Example
//
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's applied to lines.
type VendorCreditApplyLineForInvoice struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt   *time.Time                                   `json:"modified_at,omitempty"`
	VendorCredit *VendorCreditApplyLineForInvoiceVendorCredit `json:"vendor_credit,omitempty"`
	// Date that the vendor credit is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty"`
	// The amount of the VendorCredit applied to the invoice.
	AppliedAmount *string `json:"applied_amount,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorCreditApplyLineForInvoice) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditApplyLineForInvoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditApplyLineForInvoice(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditApplyLineForInvoice) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreditApplyLineForInvoiceVendorCredit struct {
	typeName     string
	String       string
	VendorCredit *VendorCredit
}

func NewVendorCreditApplyLineForInvoiceVendorCreditFromString(value string) *VendorCreditApplyLineForInvoiceVendorCredit {
	return &VendorCreditApplyLineForInvoiceVendorCredit{typeName: "string", String: value}
}

func NewVendorCreditApplyLineForInvoiceVendorCreditFromVendorCredit(value *VendorCredit) *VendorCreditApplyLineForInvoiceVendorCredit {
	return &VendorCreditApplyLineForInvoiceVendorCredit{typeName: "vendorCredit", VendorCredit: value}
}

func (v *VendorCreditApplyLineForInvoiceVendorCredit) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueVendorCredit := new(VendorCredit)
	if err := json.Unmarshal(data, &valueVendorCredit); err == nil {
		v.typeName = "vendorCredit"
		v.VendorCredit = valueVendorCredit
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditApplyLineForInvoiceVendorCredit) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "vendorCredit":
		return json.Marshal(v.VendorCredit)
	}
}

type VendorCreditApplyLineForInvoiceVendorCreditVisitor interface {
	VisitString(string) error
	VisitVendorCredit(*VendorCredit) error
}

func (v *VendorCreditApplyLineForInvoiceVendorCredit) Accept(visitor VendorCreditApplyLineForInvoiceVendorCreditVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "vendorCredit":
		return visitor.VisitVendorCredit(v.VendorCredit)
	}
}

// # The VendorCreditApplyLine Object
//
// ### Description
//
// The `VendorCreditApplyLine` object is used to represent a applied vendor credit.
//
// ### Usage Example
//
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's applied to lines.
type VendorCreditApplyLineForVendorCredit struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time                                   `json:"modified_at,omitempty"`
	Invoice    *VendorCreditApplyLineForVendorCreditInvoice `json:"invoice,omitempty"`
	// Date that the vendor credit is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty"`
	// The amount of the VendorCredit applied to the invoice.
	AppliedAmount *string `json:"applied_amount,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorCreditApplyLineForVendorCredit) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditApplyLineForVendorCredit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditApplyLineForVendorCredit(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditApplyLineForVendorCredit) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreditApplyLineForVendorCreditInvoice struct {
	typeName string
	String   string
	Invoice  *Invoice
}

func NewVendorCreditApplyLineForVendorCreditInvoiceFromString(value string) *VendorCreditApplyLineForVendorCreditInvoice {
	return &VendorCreditApplyLineForVendorCreditInvoice{typeName: "string", String: value}
}

func NewVendorCreditApplyLineForVendorCreditInvoiceFromInvoice(value *Invoice) *VendorCreditApplyLineForVendorCreditInvoice {
	return &VendorCreditApplyLineForVendorCreditInvoice{typeName: "invoice", Invoice: value}
}

func (v *VendorCreditApplyLineForVendorCreditInvoice) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueInvoice := new(Invoice)
	if err := json.Unmarshal(data, &valueInvoice); err == nil {
		v.typeName = "invoice"
		v.Invoice = valueInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditApplyLineForVendorCreditInvoice) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "invoice":
		return json.Marshal(v.Invoice)
	}
}

type VendorCreditApplyLineForVendorCreditInvoiceVisitor interface {
	VisitString(string) error
	VisitInvoice(*Invoice) error
}

func (v *VendorCreditApplyLineForVendorCreditInvoice) Accept(visitor VendorCreditApplyLineForVendorCreditInvoiceVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "invoice":
		return visitor.VisitInvoice(v.Invoice)
	}
}

// # The VendorCreditApplyLine Object
//
// ### Description
//
// The `VendorCreditApplyLine` object is used to represent a applied vendor credit.
//
// ### Usage Example
//
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's applied to lines.
type VendorCreditApplyLineForVendorCreditRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string                                             `json:"remote_id,omitempty"`
	Invoice  *VendorCreditApplyLineForVendorCreditRequestInvoice `json:"invoice,omitempty"`
	// Date that the vendor credit is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty"`
	// The amount of the VendorCredit applied to the invoice.
	AppliedAmount       *string                `json:"applied_amount,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorCreditApplyLineForVendorCreditRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditApplyLineForVendorCreditRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditApplyLineForVendorCreditRequest(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditApplyLineForVendorCreditRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreditApplyLineForVendorCreditRequestInvoice struct {
	typeName string
	String   string
	Invoice  *Invoice
}

func NewVendorCreditApplyLineForVendorCreditRequestInvoiceFromString(value string) *VendorCreditApplyLineForVendorCreditRequestInvoice {
	return &VendorCreditApplyLineForVendorCreditRequestInvoice{typeName: "string", String: value}
}

func NewVendorCreditApplyLineForVendorCreditRequestInvoiceFromInvoice(value *Invoice) *VendorCreditApplyLineForVendorCreditRequestInvoice {
	return &VendorCreditApplyLineForVendorCreditRequestInvoice{typeName: "invoice", Invoice: value}
}

func (v *VendorCreditApplyLineForVendorCreditRequestInvoice) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueInvoice := new(Invoice)
	if err := json.Unmarshal(data, &valueInvoice); err == nil {
		v.typeName = "invoice"
		v.Invoice = valueInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditApplyLineForVendorCreditRequestInvoice) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "invoice":
		return json.Marshal(v.Invoice)
	}
}

type VendorCreditApplyLineForVendorCreditRequestInvoiceVisitor interface {
	VisitString(string) error
	VisitInvoice(*Invoice) error
}

func (v *VendorCreditApplyLineForVendorCreditRequestInvoice) Accept(visitor VendorCreditApplyLineForVendorCreditRequestInvoiceVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "invoice":
		return visitor.VisitInvoice(v.Invoice)
	}
}

// The company the vendor credit belongs to.
type VendorCreditCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewVendorCreditCompanyFromString(value string) *VendorCreditCompany {
	return &VendorCreditCompany{typeName: "string", String: value}
}

func NewVendorCreditCompanyFromCompanyInfo(value *CompanyInfo) *VendorCreditCompany {
	return &VendorCreditCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (v *VendorCreditCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		v.typeName = "companyInfo"
		v.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditCompany) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "companyInfo":
		return json.Marshal(v.CompanyInfo)
	}
}

type VendorCreditCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (v *VendorCreditCompany) Accept(visitor VendorCreditCompanyVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(v.CompanyInfo)
	}
}

// The vendor credit's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type VendorCreditCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewVendorCreditCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *VendorCreditCurrency {
	return &VendorCreditCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewVendorCreditCurrencyFromString(value string) *VendorCreditCurrency {
	return &VendorCreditCurrency{typeName: "string", String: value}
}

func (v *VendorCreditCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		v.typeName = "transactionCurrencyEnum"
		v.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditCurrency) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "transactionCurrencyEnum":
		return json.Marshal(v.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(v.String)
	}
}

type VendorCreditCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (v *VendorCreditCurrency) Accept(visitor VendorCreditCurrencyVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(v.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(v.String)
	}
}

// # The VendorCreditLine Object
//
// ### Description
//
// The `VendorCreditLine` object is used to represent a vendor credit's line items.
//
// ### Usage Example
//
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's line items.
type VendorCreditLine struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The full value of the credit.
	NetAmount *float64 `json:"net_amount,omitempty"`
	// The line's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty"`
	// The vendor credit line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty"`
	// The line's description.
	Description *string `json:"description,omitempty"`
	// The line's account.
	Account *VendorCreditLineAccount `json:"account,omitempty"`
	// The company the line belongs to.
	Company *string `json:"company,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The vendor credit line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorCreditLine) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditLine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditLine(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditLine) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The line's account.
type VendorCreditLineAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewVendorCreditLineAccountFromString(value string) *VendorCreditLineAccount {
	return &VendorCreditLineAccount{typeName: "string", String: value}
}

func NewVendorCreditLineAccountFromAccount(value *Account) *VendorCreditLineAccount {
	return &VendorCreditLineAccount{typeName: "account", Account: value}
}

func (v *VendorCreditLineAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		v.typeName = "account"
		v.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditLineAccount) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "account":
		return json.Marshal(v.Account)
	}
}

type VendorCreditLineAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (v *VendorCreditLineAccount) Accept(visitor VendorCreditLineAccountVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "account":
		return visitor.VisitAccount(v.Account)
	}
}

// # The VendorCreditLine Object
//
// ### Description
//
// The `VendorCreditLine` object is used to represent a vendor credit's line items.
//
// ### Usage Example
//
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's line items.
type VendorCreditLineRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The full value of the credit.
	NetAmount *float64 `json:"net_amount,omitempty"`
	// The line's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty"`
	// The vendor credit line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty"`
	// The line's description.
	Description *string `json:"description,omitempty"`
	// The line's account.
	Account *VendorCreditLineRequestAccount `json:"account,omitempty"`
	// The company the line belongs to.
	Company *string `json:"company,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty"`
	// The vendor credit line item's exchange rate.
	ExchangeRate        *string                `json:"exchange_rate,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorCreditLineRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditLineRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditLineRequest(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditLineRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The line's account.
type VendorCreditLineRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewVendorCreditLineRequestAccountFromString(value string) *VendorCreditLineRequestAccount {
	return &VendorCreditLineRequestAccount{typeName: "string", String: value}
}

func NewVendorCreditLineRequestAccountFromAccount(value *Account) *VendorCreditLineRequestAccount {
	return &VendorCreditLineRequestAccount{typeName: "account", Account: value}
}

func (v *VendorCreditLineRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		v.typeName = "account"
		v.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditLineRequestAccount) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "account":
		return json.Marshal(v.Account)
	}
}

type VendorCreditLineRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (v *VendorCreditLineRequestAccount) Accept(visitor VendorCreditLineRequestAccountVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "account":
		return visitor.VisitAccount(v.Account)
	}
}

// # The VendorCredit Object
//
// ### Description
//
// A `VendorCredit` is transaction issued by a vendor to the accounting company, indicating a reduction or cancellation of the amount owed to the vendor. It is most generally used as an adjustment note used to rectify errors, returns, or overpayments related to a purchasing transaction. A `VendorCredit` can be applied to `Accounts Payable` Invoices to decrease the overall amount of the `Invoice`.
//
// ### Usage Example
//
// Fetch from the `GET VendorCredit` endpoint and view a company's vendor credits.
type VendorCreditRequest struct {
	// The vendor credit's number.
	Number *string `json:"number,omitempty"`
	// The vendor credit's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty"`
	// The vendor that owes the gift or refund.
	Vendor *VendorCreditRequestVendor `json:"vendor,omitempty"`
	// The vendor credit's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty"`
	// The vendor credit's currency.
	//
	// - `XUA` - ADB Unit of Account
	// - `AFN` - Afghan Afghani
	// - `AFA` - Afghan Afghani (1927–2002)
	// - `ALL` - Albanian Lek
	// - `ALK` - Albanian Lek (1946–1965)
	// - `DZD` - Algerian Dinar
	// - `ADP` - Andorran Peseta
	// - `AOA` - Angolan Kwanza
	// - `AOK` - Angolan Kwanza (1977–1991)
	// - `AON` - Angolan New Kwanza (1990–2000)
	// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// - `ARA` - Argentine Austral
	// - `ARS` - Argentine Peso
	// - `ARM` - Argentine Peso (1881–1970)
	// - `ARP` - Argentine Peso (1983–1985)
	// - `ARL` - Argentine Peso Ley (1970–1983)
	// - `AMD` - Armenian Dram
	// - `AWG` - Aruban Florin
	// - `AUD` - Australian Dollar
	// - `ATS` - Austrian Schilling
	// - `AZN` - Azerbaijani Manat
	// - `AZM` - Azerbaijani Manat (1993–2006)
	// - `BSD` - Bahamian Dollar
	// - `BHD` - Bahraini Dinar
	// - `BDT` - Bangladeshi Taka
	// - `BBD` - Barbadian Dollar
	// - `BYN` - Belarusian Ruble
	// - `BYB` - Belarusian Ruble (1994–1999)
	// - `BYR` - Belarusian Ruble (2000–2016)
	// - `BEF` - Belgian Franc
	// - `BEC` - Belgian Franc (convertible)
	// - `BEL` - Belgian Franc (financial)
	// - `BZD` - Belize Dollar
	// - `BMD` - Bermudan Dollar
	// - `BTN` - Bhutanese Ngultrum
	// - `BOB` - Bolivian Boliviano
	// - `BOL` - Bolivian Boliviano (1863–1963)
	// - `BOV` - Bolivian Mvdol
	// - `BOP` - Bolivian Peso
	// - `BAM` - Bosnia-Herzegovina Convertible Mark
	// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// - `BWP` - Botswanan Pula
	// - `BRC` - Brazilian Cruzado (1986–1989)
	// - `BRZ` - Brazilian Cruzeiro (1942–1967)
	// - `BRE` - Brazilian Cruzeiro (1990–1993)
	// - `BRR` - Brazilian Cruzeiro (1993–1994)
	// - `BRN` - Brazilian New Cruzado (1989–1990)
	// - `BRB` - Brazilian New Cruzeiro (1967–1986)
	// - `BRL` - Brazilian Real
	// - `GBP` - British Pound
	// - `BND` - Brunei Dollar
	// - `BGL` - Bulgarian Hard Lev
	// - `BGN` - Bulgarian Lev
	// - `BGO` - Bulgarian Lev (1879–1952)
	// - `BGM` - Bulgarian Socialist Lev
	// - `BUK` - Burmese Kyat
	// - `BIF` - Burundian Franc
	// - `XPF` - CFP Franc
	// - `KHR` - Cambodian Riel
	// - `CAD` - Canadian Dollar
	// - `CVE` - Cape Verdean Escudo
	// - `KYD` - Cayman Islands Dollar
	// - `XAF` - Central African CFA Franc
	// - `CLE` - Chilean Escudo
	// - `CLP` - Chilean Peso
	// - `CLF` - Chilean Unit of Account (UF)
	// - `CNX` - Chinese People’s Bank Dollar
	// - `CNY` - Chinese Yuan
	// - `CNH` - Chinese Yuan (offshore)
	// - `COP` - Colombian Peso
	// - `COU` - Colombian Real Value Unit
	// - `KMF` - Comorian Franc
	// - `CDF` - Congolese Franc
	// - `CRC` - Costa Rican Colón
	// - `HRD` - Croatian Dinar
	// - `HRK` - Croatian Kuna
	// - `CUC` - Cuban Convertible Peso
	// - `CUP` - Cuban Peso
	// - `CYP` - Cypriot Pound
	// - `CZK` - Czech Koruna
	// - `CSK` - Czechoslovak Hard Koruna
	// - `DKK` - Danish Krone
	// - `DJF` - Djiboutian Franc
	// - `DOP` - Dominican Peso
	// - `NLG` - Dutch Guilder
	// - `XCD` - East Caribbean Dollar
	// - `DDM` - East German Mark
	// - `ECS` - Ecuadorian Sucre
	// - `ECV` - Ecuadorian Unit of Constant Value
	// - `EGP` - Egyptian Pound
	// - `GQE` - Equatorial Guinean Ekwele
	// - `ERN` - Eritrean Nakfa
	// - `EEK` - Estonian Kroon
	// - `ETB` - Ethiopian Birr
	// - `EUR` - Euro
	// - `XBA` - European Composite Unit
	// - `XEU` - European Currency Unit
	// - `XBB` - European Monetary Unit
	// - `XBC` - European Unit of Account (XBC)
	// - `XBD` - European Unit of Account (XBD)
	// - `FKP` - Falkland Islands Pound
	// - `FJD` - Fijian Dollar
	// - `FIM` - Finnish Markka
	// - `FRF` - French Franc
	// - `XFO` - French Gold Franc
	// - `XFU` - French UIC-Franc
	// - `GMD` - Gambian Dalasi
	// - `GEK` - Georgian Kupon Larit
	// - `GEL` - Georgian Lari
	// - `DEM` - German Mark
	// - `GHS` - Ghanaian Cedi
	// - `GHC` - Ghanaian Cedi (1979–2007)
	// - `GIP` - Gibraltar Pound
	// - `XAU` - Gold
	// - `GRD` - Greek Drachma
	// - `GTQ` - Guatemalan Quetzal
	// - `GWP` - Guinea-Bissau Peso
	// - `GNF` - Guinean Franc
	// - `GNS` - Guinean Syli
	// - `GYD` - Guyanaese Dollar
	// - `HTG` - Haitian Gourde
	// - `HNL` - Honduran Lempira
	// - `HKD` - Hong Kong Dollar
	// - `HUF` - Hungarian Forint
	// - `IMP` - IMP
	// - `ISK` - Icelandic Króna
	// - `ISJ` - Icelandic Króna (1918–1981)
	// - `INR` - Indian Rupee
	// - `IDR` - Indonesian Rupiah
	// - `IRR` - Iranian Rial
	// - `IQD` - Iraqi Dinar
	// - `IEP` - Irish Pound
	// - `ILS` - Israeli New Shekel
	// - `ILP` - Israeli Pound
	// - `ILR` - Israeli Shekel (1980–1985)
	// - `ITL` - Italian Lira
	// - `JMD` - Jamaican Dollar
	// - `JPY` - Japanese Yen
	// - `JOD` - Jordanian Dinar
	// - `KZT` - Kazakhstani Tenge
	// - `KES` - Kenyan Shilling
	// - `KWD` - Kuwaiti Dinar
	// - `KGS` - Kyrgystani Som
	// - `LAK` - Laotian Kip
	// - `LVL` - Latvian Lats
	// - `LVR` - Latvian Ruble
	// - `LBP` - Lebanese Pound
	// - `LSL` - Lesotho Loti
	// - `LRD` - Liberian Dollar
	// - `LYD` - Libyan Dinar
	// - `LTL` - Lithuanian Litas
	// - `LTT` - Lithuanian Talonas
	// - `LUL` - Luxembourg Financial Franc
	// - `LUC` - Luxembourgian Convertible Franc
	// - `LUF` - Luxembourgian Franc
	// - `MOP` - Macanese Pataca
	// - `MKD` - Macedonian Denar
	// - `MKN` - Macedonian Denar (1992–1993)
	// - `MGA` - Malagasy Ariary
	// - `MGF` - Malagasy Franc
	// - `MWK` - Malawian Kwacha
	// - `MYR` - Malaysian Ringgit
	// - `MVR` - Maldivian Rufiyaa
	// - `MVP` - Maldivian Rupee (1947–1981)
	// - `MLF` - Malian Franc
	// - `MTL` - Maltese Lira
	// - `MTP` - Maltese Pound
	// - `MRU` - Mauritanian Ouguiya
	// - `MRO` - Mauritanian Ouguiya (1973–2017)
	// - `MUR` - Mauritian Rupee
	// - `MXV` - Mexican Investment Unit
	// - `MXN` - Mexican Peso
	// - `MXP` - Mexican Silver Peso (1861–1992)
	// - `MDC` - Moldovan Cupon
	// - `MDL` - Moldovan Leu
	// - `MCF` - Monegasque Franc
	// - `MNT` - Mongolian Tugrik
	// - `MAD` - Moroccan Dirham
	// - `MAF` - Moroccan Franc
	// - `MZE` - Mozambican Escudo
	// - `MZN` - Mozambican Metical
	// - `MZM` - Mozambican Metical (1980–2006)
	// - `MMK` - Myanmar Kyat
	// - `NAD` - Namibian Dollar
	// - `NPR` - Nepalese Rupee
	// - `ANG` - Netherlands Antillean Guilder
	// - `TWD` - New Taiwan Dollar
	// - `NZD` - New Zealand Dollar
	// - `NIO` - Nicaraguan Córdoba
	// - `NIC` - Nicaraguan Córdoba (1988–1991)
	// - `NGN` - Nigerian Naira
	// - `KPW` - North Korean Won
	// - `NOK` - Norwegian Krone
	// - `OMR` - Omani Rial
	// - `PKR` - Pakistani Rupee
	// - `XPD` - Palladium
	// - `PAB` - Panamanian Balboa
	// - `PGK` - Papua New Guinean Kina
	// - `PYG` - Paraguayan Guarani
	// - `PEI` - Peruvian Inti
	// - `PEN` - Peruvian Sol
	// - `PES` - Peruvian Sol (1863–1965)
	// - `PHP` - Philippine Peso
	// - `XPT` - Platinum
	// - `PLN` - Polish Zloty
	// - `PLZ` - Polish Zloty (1950–1995)
	// - `PTE` - Portuguese Escudo
	// - `GWE` - Portuguese Guinea Escudo
	// - `QAR` - Qatari Rial
	// - `XRE` - RINET Funds
	// - `RHD` - Rhodesian Dollar
	// - `RON` - Romanian Leu
	// - `ROL` - Romanian Leu (1952–2006)
	// - `RUB` - Russian Ruble
	// - `RUR` - Russian Ruble (1991–1998)
	// - `RWF` - Rwandan Franc
	// - `SVC` - Salvadoran Colón
	// - `WST` - Samoan Tala
	// - `SAR` - Saudi Riyal
	// - `RSD` - Serbian Dinar
	// - `CSD` - Serbian Dinar (2002–2006)
	// - `SCR` - Seychellois Rupee
	// - `SLL` - Sierra Leonean Leone
	// - `XAG` - Silver
	// - `SGD` - Singapore Dollar
	// - `SKK` - Slovak Koruna
	// - `SIT` - Slovenian Tolar
	// - `SBD` - Solomon Islands Dollar
	// - `SOS` - Somali Shilling
	// - `ZAR` - South African Rand
	// - `ZAL` - South African Rand (financial)
	// - `KRH` - South Korean Hwan (1953–1962)
	// - `KRW` - South Korean Won
	// - `KRO` - South Korean Won (1945–1953)
	// - `SSP` - South Sudanese Pound
	// - `SUR` - Soviet Rouble
	// - `ESP` - Spanish Peseta
	// - `ESA` - Spanish Peseta (A account)
	// - `ESB` - Spanish Peseta (convertible account)
	// - `XDR` - Special Drawing Rights
	// - `LKR` - Sri Lankan Rupee
	// - `SHP` - St. Helena Pound
	// - `XSU` - Sucre
	// - `SDD` - Sudanese Dinar (1992–2007)
	// - `SDG` - Sudanese Pound
	// - `SDP` - Sudanese Pound (1957–1998)
	// - `SRD` - Surinamese Dollar
	// - `SRG` - Surinamese Guilder
	// - `SZL` - Swazi Lilangeni
	// - `SEK` - Swedish Krona
	// - `CHF` - Swiss Franc
	// - `SYP` - Syrian Pound
	// - `STN` - São Tomé & Príncipe Dobra
	// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// - `TVD` - TVD
	// - `TJR` - Tajikistani Ruble
	// - `TJS` - Tajikistani Somoni
	// - `TZS` - Tanzanian Shilling
	// - `XTS` - Testing Currency Code
	// - `THB` - Thai Baht
	// - `XXX` - The codes assigned for transactions where no currency is involved
	// - `TPE` - Timorese Escudo
	// - `TOP` - Tongan Paʻanga
	// - `TTD` - Trinidad & Tobago Dollar
	// - `TND` - Tunisian Dinar
	// - `TRY` - Turkish Lira
	// - `TRL` - Turkish Lira (1922–2005)
	// - `TMT` - Turkmenistani Manat
	// - `TMM` - Turkmenistani Manat (1993–2009)
	// - `USD` - US Dollar
	// - `USN` - US Dollar (Next day)
	// - `USS` - US Dollar (Same day)
	// - `UGX` - Ugandan Shilling
	// - `UGS` - Ugandan Shilling (1966–1987)
	// - `UAH` - Ukrainian Hryvnia
	// - `UAK` - Ukrainian Karbovanets
	// - `AED` - United Arab Emirates Dirham
	// - `UYW` - Uruguayan Nominal Wage Index Unit
	// - `UYU` - Uruguayan Peso
	// - `UYP` - Uruguayan Peso (1975–1993)
	// - `UYI` - Uruguayan Peso (Indexed Units)
	// - `UZS` - Uzbekistani Som
	// - `VUV` - Vanuatu Vatu
	// - `VES` - Venezuelan Bolívar
	// - `VEB` - Venezuelan Bolívar (1871–2008)
	// - `VEF` - Venezuelan Bolívar (2008–2018)
	// - `VND` - Vietnamese Dong
	// - `VNN` - Vietnamese Dong (1978–1985)
	// - `CHE` - WIR Euro
	// - `CHW` - WIR Franc
	// - `XOF` - West African CFA Franc
	// - `YDD` - Yemeni Dinar
	// - `YER` - Yemeni Rial
	// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// - `YUM` - Yugoslavian New Dinar (1994–2002)
	// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// - `ZWN` - ZWN
	// - `ZRN` - Zairean New Zaire (1993–1998)
	// - `ZRZ` - Zairean Zaire (1971–1993)
	// - `ZMW` - Zambian Kwacha
	// - `ZMK` - Zambian Kwacha (1968–2012)
	// - `ZWD` - Zimbabwean Dollar (1980–2008)
	// - `ZWR` - Zimbabwean Dollar (2008)
	// - `ZWL` - Zimbabwean Dollar (2009)
	Currency *VendorCreditRequestCurrency `json:"currency,omitempty"`
	// The vendor credit's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty"`
	// The company the vendor credit belongs to.
	Company            *VendorCreditRequestCompany                  `json:"company,omitempty"`
	TrackingCategories []*VendorCreditRequestTrackingCategoriesItem `json:"tracking_categories,omitempty"`
	// A list of VendorCredit Applied to Lines objects.
	AppliedToLines []*VendorCreditApplyLineForVendorCreditRequest `json:"applied_to_lines,omitempty"`
	// The accounting period that the VendorCredit was generated in.
	AccountingPeriod    *VendorCreditRequestAccountingPeriod `json:"accounting_period,omitempty"`
	IntegrationParams   map[string]interface{}               `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}               `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorCreditRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditRequest(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The accounting period that the VendorCredit was generated in.
type VendorCreditRequestAccountingPeriod struct {
	typeName         string
	String           string
	AccountingPeriod *AccountingPeriod
}

func NewVendorCreditRequestAccountingPeriodFromString(value string) *VendorCreditRequestAccountingPeriod {
	return &VendorCreditRequestAccountingPeriod{typeName: "string", String: value}
}

func NewVendorCreditRequestAccountingPeriodFromAccountingPeriod(value *AccountingPeriod) *VendorCreditRequestAccountingPeriod {
	return &VendorCreditRequestAccountingPeriod{typeName: "accountingPeriod", AccountingPeriod: value}
}

func (v *VendorCreditRequestAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		v.typeName = "accountingPeriod"
		v.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditRequestAccountingPeriod) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "accountingPeriod":
		return json.Marshal(v.AccountingPeriod)
	}
}

type VendorCreditRequestAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (v *VendorCreditRequestAccountingPeriod) Accept(visitor VendorCreditRequestAccountingPeriodVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "accountingPeriod":
		return visitor.VisitAccountingPeriod(v.AccountingPeriod)
	}
}

// The company the vendor credit belongs to.
type VendorCreditRequestCompany struct {
	typeName    string
	String      string
	CompanyInfo *CompanyInfo
}

func NewVendorCreditRequestCompanyFromString(value string) *VendorCreditRequestCompany {
	return &VendorCreditRequestCompany{typeName: "string", String: value}
}

func NewVendorCreditRequestCompanyFromCompanyInfo(value *CompanyInfo) *VendorCreditRequestCompany {
	return &VendorCreditRequestCompany{typeName: "companyInfo", CompanyInfo: value}
}

func (v *VendorCreditRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		v.typeName = "companyInfo"
		v.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditRequestCompany) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "companyInfo":
		return json.Marshal(v.CompanyInfo)
	}
}

type VendorCreditRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (v *VendorCreditRequestCompany) Accept(visitor VendorCreditRequestCompanyVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "companyInfo":
		return visitor.VisitCompanyInfo(v.CompanyInfo)
	}
}

// The vendor credit's currency.
//
// - `XUA` - ADB Unit of Account
// - `AFN` - Afghan Afghani
// - `AFA` - Afghan Afghani (1927–2002)
// - `ALL` - Albanian Lek
// - `ALK` - Albanian Lek (1946–1965)
// - `DZD` - Algerian Dinar
// - `ADP` - Andorran Peseta
// - `AOA` - Angolan Kwanza
// - `AOK` - Angolan Kwanza (1977–1991)
// - `AON` - Angolan New Kwanza (1990–2000)
// - `AOR` - Angolan Readjusted Kwanza (1995–1999)
// - `ARA` - Argentine Austral
// - `ARS` - Argentine Peso
// - `ARM` - Argentine Peso (1881–1970)
// - `ARP` - Argentine Peso (1983–1985)
// - `ARL` - Argentine Peso Ley (1970–1983)
// - `AMD` - Armenian Dram
// - `AWG` - Aruban Florin
// - `AUD` - Australian Dollar
// - `ATS` - Austrian Schilling
// - `AZN` - Azerbaijani Manat
// - `AZM` - Azerbaijani Manat (1993–2006)
// - `BSD` - Bahamian Dollar
// - `BHD` - Bahraini Dinar
// - `BDT` - Bangladeshi Taka
// - `BBD` - Barbadian Dollar
// - `BYN` - Belarusian Ruble
// - `BYB` - Belarusian Ruble (1994–1999)
// - `BYR` - Belarusian Ruble (2000–2016)
// - `BEF` - Belgian Franc
// - `BEC` - Belgian Franc (convertible)
// - `BEL` - Belgian Franc (financial)
// - `BZD` - Belize Dollar
// - `BMD` - Bermudan Dollar
// - `BTN` - Bhutanese Ngultrum
// - `BOB` - Bolivian Boliviano
// - `BOL` - Bolivian Boliviano (1863–1963)
// - `BOV` - Bolivian Mvdol
// - `BOP` - Bolivian Peso
// - `BAM` - Bosnia-Herzegovina Convertible Mark
// - `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// - `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// - `BWP` - Botswanan Pula
// - `BRC` - Brazilian Cruzado (1986–1989)
// - `BRZ` - Brazilian Cruzeiro (1942–1967)
// - `BRE` - Brazilian Cruzeiro (1990–1993)
// - `BRR` - Brazilian Cruzeiro (1993–1994)
// - `BRN` - Brazilian New Cruzado (1989–1990)
// - `BRB` - Brazilian New Cruzeiro (1967–1986)
// - `BRL` - Brazilian Real
// - `GBP` - British Pound
// - `BND` - Brunei Dollar
// - `BGL` - Bulgarian Hard Lev
// - `BGN` - Bulgarian Lev
// - `BGO` - Bulgarian Lev (1879–1952)
// - `BGM` - Bulgarian Socialist Lev
// - `BUK` - Burmese Kyat
// - `BIF` - Burundian Franc
// - `XPF` - CFP Franc
// - `KHR` - Cambodian Riel
// - `CAD` - Canadian Dollar
// - `CVE` - Cape Verdean Escudo
// - `KYD` - Cayman Islands Dollar
// - `XAF` - Central African CFA Franc
// - `CLE` - Chilean Escudo
// - `CLP` - Chilean Peso
// - `CLF` - Chilean Unit of Account (UF)
// - `CNX` - Chinese People’s Bank Dollar
// - `CNY` - Chinese Yuan
// - `CNH` - Chinese Yuan (offshore)
// - `COP` - Colombian Peso
// - `COU` - Colombian Real Value Unit
// - `KMF` - Comorian Franc
// - `CDF` - Congolese Franc
// - `CRC` - Costa Rican Colón
// - `HRD` - Croatian Dinar
// - `HRK` - Croatian Kuna
// - `CUC` - Cuban Convertible Peso
// - `CUP` - Cuban Peso
// - `CYP` - Cypriot Pound
// - `CZK` - Czech Koruna
// - `CSK` - Czechoslovak Hard Koruna
// - `DKK` - Danish Krone
// - `DJF` - Djiboutian Franc
// - `DOP` - Dominican Peso
// - `NLG` - Dutch Guilder
// - `XCD` - East Caribbean Dollar
// - `DDM` - East German Mark
// - `ECS` - Ecuadorian Sucre
// - `ECV` - Ecuadorian Unit of Constant Value
// - `EGP` - Egyptian Pound
// - `GQE` - Equatorial Guinean Ekwele
// - `ERN` - Eritrean Nakfa
// - `EEK` - Estonian Kroon
// - `ETB` - Ethiopian Birr
// - `EUR` - Euro
// - `XBA` - European Composite Unit
// - `XEU` - European Currency Unit
// - `XBB` - European Monetary Unit
// - `XBC` - European Unit of Account (XBC)
// - `XBD` - European Unit of Account (XBD)
// - `FKP` - Falkland Islands Pound
// - `FJD` - Fijian Dollar
// - `FIM` - Finnish Markka
// - `FRF` - French Franc
// - `XFO` - French Gold Franc
// - `XFU` - French UIC-Franc
// - `GMD` - Gambian Dalasi
// - `GEK` - Georgian Kupon Larit
// - `GEL` - Georgian Lari
// - `DEM` - German Mark
// - `GHS` - Ghanaian Cedi
// - `GHC` - Ghanaian Cedi (1979–2007)
// - `GIP` - Gibraltar Pound
// - `XAU` - Gold
// - `GRD` - Greek Drachma
// - `GTQ` - Guatemalan Quetzal
// - `GWP` - Guinea-Bissau Peso
// - `GNF` - Guinean Franc
// - `GNS` - Guinean Syli
// - `GYD` - Guyanaese Dollar
// - `HTG` - Haitian Gourde
// - `HNL` - Honduran Lempira
// - `HKD` - Hong Kong Dollar
// - `HUF` - Hungarian Forint
// - `IMP` - IMP
// - `ISK` - Icelandic Króna
// - `ISJ` - Icelandic Króna (1918–1981)
// - `INR` - Indian Rupee
// - `IDR` - Indonesian Rupiah
// - `IRR` - Iranian Rial
// - `IQD` - Iraqi Dinar
// - `IEP` - Irish Pound
// - `ILS` - Israeli New Shekel
// - `ILP` - Israeli Pound
// - `ILR` - Israeli Shekel (1980–1985)
// - `ITL` - Italian Lira
// - `JMD` - Jamaican Dollar
// - `JPY` - Japanese Yen
// - `JOD` - Jordanian Dinar
// - `KZT` - Kazakhstani Tenge
// - `KES` - Kenyan Shilling
// - `KWD` - Kuwaiti Dinar
// - `KGS` - Kyrgystani Som
// - `LAK` - Laotian Kip
// - `LVL` - Latvian Lats
// - `LVR` - Latvian Ruble
// - `LBP` - Lebanese Pound
// - `LSL` - Lesotho Loti
// - `LRD` - Liberian Dollar
// - `LYD` - Libyan Dinar
// - `LTL` - Lithuanian Litas
// - `LTT` - Lithuanian Talonas
// - `LUL` - Luxembourg Financial Franc
// - `LUC` - Luxembourgian Convertible Franc
// - `LUF` - Luxembourgian Franc
// - `MOP` - Macanese Pataca
// - `MKD` - Macedonian Denar
// - `MKN` - Macedonian Denar (1992–1993)
// - `MGA` - Malagasy Ariary
// - `MGF` - Malagasy Franc
// - `MWK` - Malawian Kwacha
// - `MYR` - Malaysian Ringgit
// - `MVR` - Maldivian Rufiyaa
// - `MVP` - Maldivian Rupee (1947–1981)
// - `MLF` - Malian Franc
// - `MTL` - Maltese Lira
// - `MTP` - Maltese Pound
// - `MRU` - Mauritanian Ouguiya
// - `MRO` - Mauritanian Ouguiya (1973–2017)
// - `MUR` - Mauritian Rupee
// - `MXV` - Mexican Investment Unit
// - `MXN` - Mexican Peso
// - `MXP` - Mexican Silver Peso (1861–1992)
// - `MDC` - Moldovan Cupon
// - `MDL` - Moldovan Leu
// - `MCF` - Monegasque Franc
// - `MNT` - Mongolian Tugrik
// - `MAD` - Moroccan Dirham
// - `MAF` - Moroccan Franc
// - `MZE` - Mozambican Escudo
// - `MZN` - Mozambican Metical
// - `MZM` - Mozambican Metical (1980–2006)
// - `MMK` - Myanmar Kyat
// - `NAD` - Namibian Dollar
// - `NPR` - Nepalese Rupee
// - `ANG` - Netherlands Antillean Guilder
// - `TWD` - New Taiwan Dollar
// - `NZD` - New Zealand Dollar
// - `NIO` - Nicaraguan Córdoba
// - `NIC` - Nicaraguan Córdoba (1988–1991)
// - `NGN` - Nigerian Naira
// - `KPW` - North Korean Won
// - `NOK` - Norwegian Krone
// - `OMR` - Omani Rial
// - `PKR` - Pakistani Rupee
// - `XPD` - Palladium
// - `PAB` - Panamanian Balboa
// - `PGK` - Papua New Guinean Kina
// - `PYG` - Paraguayan Guarani
// - `PEI` - Peruvian Inti
// - `PEN` - Peruvian Sol
// - `PES` - Peruvian Sol (1863–1965)
// - `PHP` - Philippine Peso
// - `XPT` - Platinum
// - `PLN` - Polish Zloty
// - `PLZ` - Polish Zloty (1950–1995)
// - `PTE` - Portuguese Escudo
// - `GWE` - Portuguese Guinea Escudo
// - `QAR` - Qatari Rial
// - `XRE` - RINET Funds
// - `RHD` - Rhodesian Dollar
// - `RON` - Romanian Leu
// - `ROL` - Romanian Leu (1952–2006)
// - `RUB` - Russian Ruble
// - `RUR` - Russian Ruble (1991–1998)
// - `RWF` - Rwandan Franc
// - `SVC` - Salvadoran Colón
// - `WST` - Samoan Tala
// - `SAR` - Saudi Riyal
// - `RSD` - Serbian Dinar
// - `CSD` - Serbian Dinar (2002–2006)
// - `SCR` - Seychellois Rupee
// - `SLL` - Sierra Leonean Leone
// - `XAG` - Silver
// - `SGD` - Singapore Dollar
// - `SKK` - Slovak Koruna
// - `SIT` - Slovenian Tolar
// - `SBD` - Solomon Islands Dollar
// - `SOS` - Somali Shilling
// - `ZAR` - South African Rand
// - `ZAL` - South African Rand (financial)
// - `KRH` - South Korean Hwan (1953–1962)
// - `KRW` - South Korean Won
// - `KRO` - South Korean Won (1945–1953)
// - `SSP` - South Sudanese Pound
// - `SUR` - Soviet Rouble
// - `ESP` - Spanish Peseta
// - `ESA` - Spanish Peseta (A account)
// - `ESB` - Spanish Peseta (convertible account)
// - `XDR` - Special Drawing Rights
// - `LKR` - Sri Lankan Rupee
// - `SHP` - St. Helena Pound
// - `XSU` - Sucre
// - `SDD` - Sudanese Dinar (1992–2007)
// - `SDG` - Sudanese Pound
// - `SDP` - Sudanese Pound (1957–1998)
// - `SRD` - Surinamese Dollar
// - `SRG` - Surinamese Guilder
// - `SZL` - Swazi Lilangeni
// - `SEK` - Swedish Krona
// - `CHF` - Swiss Franc
// - `SYP` - Syrian Pound
// - `STN` - São Tomé & Príncipe Dobra
// - `STD` - São Tomé & Príncipe Dobra (1977–2017)
// - `TVD` - TVD
// - `TJR` - Tajikistani Ruble
// - `TJS` - Tajikistani Somoni
// - `TZS` - Tanzanian Shilling
// - `XTS` - Testing Currency Code
// - `THB` - Thai Baht
// - `XXX` - The codes assigned for transactions where no currency is involved
// - `TPE` - Timorese Escudo
// - `TOP` - Tongan Paʻanga
// - `TTD` - Trinidad & Tobago Dollar
// - `TND` - Tunisian Dinar
// - `TRY` - Turkish Lira
// - `TRL` - Turkish Lira (1922–2005)
// - `TMT` - Turkmenistani Manat
// - `TMM` - Turkmenistani Manat (1993–2009)
// - `USD` - US Dollar
// - `USN` - US Dollar (Next day)
// - `USS` - US Dollar (Same day)
// - `UGX` - Ugandan Shilling
// - `UGS` - Ugandan Shilling (1966–1987)
// - `UAH` - Ukrainian Hryvnia
// - `UAK` - Ukrainian Karbovanets
// - `AED` - United Arab Emirates Dirham
// - `UYW` - Uruguayan Nominal Wage Index Unit
// - `UYU` - Uruguayan Peso
// - `UYP` - Uruguayan Peso (1975–1993)
// - `UYI` - Uruguayan Peso (Indexed Units)
// - `UZS` - Uzbekistani Som
// - `VUV` - Vanuatu Vatu
// - `VES` - Venezuelan Bolívar
// - `VEB` - Venezuelan Bolívar (1871–2008)
// - `VEF` - Venezuelan Bolívar (2008–2018)
// - `VND` - Vietnamese Dong
// - `VNN` - Vietnamese Dong (1978–1985)
// - `CHE` - WIR Euro
// - `CHW` - WIR Franc
// - `XOF` - West African CFA Franc
// - `YDD` - Yemeni Dinar
// - `YER` - Yemeni Rial
// - `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// - `YUD` - Yugoslavian Hard Dinar (1966–1990)
// - `YUM` - Yugoslavian New Dinar (1994–2002)
// - `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// - `ZWN` - ZWN
// - `ZRN` - Zairean New Zaire (1993–1998)
// - `ZRZ` - Zairean Zaire (1971–1993)
// - `ZMW` - Zambian Kwacha
// - `ZMK` - Zambian Kwacha (1968–2012)
// - `ZWD` - Zimbabwean Dollar (1980–2008)
// - `ZWR` - Zimbabwean Dollar (2008)
// - `ZWL` - Zimbabwean Dollar (2009)
type VendorCreditRequestCurrency struct {
	typeName                string
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string
}

func NewVendorCreditRequestCurrencyFromTransactionCurrencyEnum(value TransactionCurrencyEnum) *VendorCreditRequestCurrency {
	return &VendorCreditRequestCurrency{typeName: "transactionCurrencyEnum", TransactionCurrencyEnum: value}
}

func NewVendorCreditRequestCurrencyFromString(value string) *VendorCreditRequestCurrency {
	return &VendorCreditRequestCurrency{typeName: "string", String: value}
}

func (v *VendorCreditRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		v.typeName = "transactionCurrencyEnum"
		v.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditRequestCurrency) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "transactionCurrencyEnum":
		return json.Marshal(v.TransactionCurrencyEnum)
	case "string":
		return json.Marshal(v.String)
	}
}

type VendorCreditRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (v *VendorCreditRequestCurrency) Accept(visitor VendorCreditRequestCurrencyVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "transactionCurrencyEnum":
		return visitor.VisitTransactionCurrencyEnum(v.TransactionCurrencyEnum)
	case "string":
		return visitor.VisitString(v.String)
	}
}

type VendorCreditRequestTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewVendorCreditRequestTrackingCategoriesItemFromString(value string) *VendorCreditRequestTrackingCategoriesItem {
	return &VendorCreditRequestTrackingCategoriesItem{typeName: "string", String: value}
}

func NewVendorCreditRequestTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *VendorCreditRequestTrackingCategoriesItem {
	return &VendorCreditRequestTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (v *VendorCreditRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		v.typeName = "trackingCategory"
		v.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "trackingCategory":
		return json.Marshal(v.TrackingCategory)
	}
}

type VendorCreditRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (v *VendorCreditRequestTrackingCategoriesItem) Accept(visitor VendorCreditRequestTrackingCategoriesItemVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(v.TrackingCategory)
	}
}

// The vendor that owes the gift or refund.
type VendorCreditRequestVendor struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewVendorCreditRequestVendorFromString(value string) *VendorCreditRequestVendor {
	return &VendorCreditRequestVendor{typeName: "string", String: value}
}

func NewVendorCreditRequestVendorFromContact(value *Contact) *VendorCreditRequestVendor {
	return &VendorCreditRequestVendor{typeName: "contact", Contact: value}
}

func (v *VendorCreditRequestVendor) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		v.typeName = "contact"
		v.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditRequestVendor) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "contact":
		return json.Marshal(v.Contact)
	}
}

type VendorCreditRequestVendorVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (v *VendorCreditRequestVendor) Accept(visitor VendorCreditRequestVendorVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "contact":
		return visitor.VisitContact(v.Contact)
	}
}

type VendorCreditResponse struct {
	Model    *VendorCredit               `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorCreditResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditResponse(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreditTrackingCategoriesItem struct {
	typeName         string
	String           string
	TrackingCategory *TrackingCategory
}

func NewVendorCreditTrackingCategoriesItemFromString(value string) *VendorCreditTrackingCategoriesItem {
	return &VendorCreditTrackingCategoriesItem{typeName: "string", String: value}
}

func NewVendorCreditTrackingCategoriesItemFromTrackingCategory(value *TrackingCategory) *VendorCreditTrackingCategoriesItem {
	return &VendorCreditTrackingCategoriesItem{typeName: "trackingCategory", TrackingCategory: value}
}

func (v *VendorCreditTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		v.typeName = "trackingCategory"
		v.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "trackingCategory":
		return json.Marshal(v.TrackingCategory)
	}
}

type VendorCreditTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (v *VendorCreditTrackingCategoriesItem) Accept(visitor VendorCreditTrackingCategoriesItemVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "trackingCategory":
		return visitor.VisitTrackingCategory(v.TrackingCategory)
	}
}

// The vendor that owes the gift or refund.
type VendorCreditVendor struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewVendorCreditVendorFromString(value string) *VendorCreditVendor {
	return &VendorCreditVendor{typeName: "string", String: value}
}

func NewVendorCreditVendorFromContact(value *Contact) *VendorCreditVendor {
	return &VendorCreditVendor{typeName: "contact", Contact: value}
}

func (v *VendorCreditVendor) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		v.typeName = "contact"
		v.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditVendor) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "contact":
		return json.Marshal(v.Contact)
	}
}

type VendorCreditVendorVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (v *VendorCreditVendor) Accept(visitor VendorCreditVendorVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "contact":
		return visitor.VisitContact(v.Contact)
	}
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`

	_rawJSON json.RawMessage
}

func (w *WarningValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler WarningValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WarningValidationProblem(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WarningValidationProblem) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookReceiver struct {
	Event    string  `json:"event"`
	IsActive bool    `json:"is_active"`
	Key      *string `json:"key,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WebhookReceiver) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookReceiver
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookReceiver(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookReceiver) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
