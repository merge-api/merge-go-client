// Code generated by Fern. DO NOT EDIT.

package accounting

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

// # The Account Object
// ### Description
// An `Account` represents a category in a company’s ledger in which a financial transaction is recorded against. The aggregation of each `Account` object is often referred to as the **Chart of Accounts**.
//
// An `Account` can be classified into one of the following categories, determined through the `classification` field:
// * __Asset:__ Accounts Receivable and Bank Accounts
// * __Liability:__ Accounts Payable and Credit Card Accounts
// * __Equity:__ Treasury Accounts and Retained Earnings
// * __Revenue:__ Income and Other Income
// * __Expense:__ Cost of Goods Sold and Office Expenses
//
// ### Usage Example
// Fetch from the `LIST Accounts` endpoint and view a company's accounts.
type Account struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The account's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The account's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The account's broadest grouping.
	//
	// * `ASSET` - ASSET
	// * `EQUITY` - EQUITY
	// * `EXPENSE` - EXPENSE
	// * `LIABILITY` - LIABILITY
	// * `REVENUE` - REVENUE
	Classification *ClassificationEnum `json:"classification,omitempty" url:"classification,omitempty"`
	// The account's type is a narrower and more specific grouping within the account's classification.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Normalized account type- which is a narrower and more specific grouping within the account's classification.
	//
	// * `BANK` - BANK
	// * `CREDIT_CARD` - CREDIT_CARD
	// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	// * `FIXED_ASSET` - FIXED_ASSET
	// * `OTHER_ASSET` - OTHER_ASSET
	// * `OTHER_CURRENT_ASSET` - OTHER_CURRENT_ASSET
	// * `OTHER_EXPENSE` - OTHER_EXPENSE
	// * `OTHER_INCOME` - OTHER_INCOME
	// * `COST_OF_GOODS_SOLD` - COST_OF_GOODS_SOLD
	// * `OTHER_CURRENT_LIABILITY` - OTHER_CURRENT_LIABILITY
	// * `LONG_TERM_LIABILITY` - LONG_TERM_LIABILITY
	// * `NON_POSTING` - NON_POSTING
	AccountType *AccountAccountTypeEnum `json:"account_type,omitempty" url:"account_type,omitempty"`
	// The account's status.
	//
	// * `ACTIVE` - ACTIVE
	// * `PENDING` - PENDING
	// * `INACTIVE` - INACTIVE
	Status *AccountStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// The account's current balance.
	CurrentBalance *float64 `json:"current_balance,omitempty" url:"current_balance,omitempty"`
	// The account's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// The account's number.
	AccountNumber *string `json:"account_number,omitempty" url:"account_number,omitempty"`
	// ID of the parent account.
	ParentAccount *string `json:"parent_account,omitempty" url:"parent_account,omitempty"`
	// The company the account belongs to.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Account) GetId() *string {
	if a == nil {
		return nil
	}
	return a.Id
}

func (a *Account) GetRemoteId() *string {
	if a == nil {
		return nil
	}
	return a.RemoteId
}

func (a *Account) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *Account) GetModifiedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.ModifiedAt
}

func (a *Account) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *Account) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *Account) GetClassification() *ClassificationEnum {
	if a == nil {
		return nil
	}
	return a.Classification
}

func (a *Account) GetType() *string {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *Account) GetAccountType() *AccountAccountTypeEnum {
	if a == nil {
		return nil
	}
	return a.AccountType
}

func (a *Account) GetStatus() *AccountStatusEnum {
	if a == nil {
		return nil
	}
	return a.Status
}

func (a *Account) GetCurrentBalance() *float64 {
	if a == nil {
		return nil
	}
	return a.CurrentBalance
}

func (a *Account) GetCurrency() *TransactionCurrencyEnum {
	if a == nil {
		return nil
	}
	return a.Currency
}

func (a *Account) GetAccountNumber() *string {
	if a == nil {
		return nil
	}
	return a.AccountNumber
}

func (a *Account) GetParentAccount() *string {
	if a == nil {
		return nil
	}
	return a.ParentAccount
}

func (a *Account) GetCompany() *string {
	if a == nil {
		return nil
	}
	return a.Company
}

func (a *Account) GetRemoteWasDeleted() *bool {
	if a == nil {
		return nil
	}
	return a.RemoteWasDeleted
}

func (a *Account) GetFieldMappings() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.FieldMappings
}

func (a *Account) GetRemoteData() []*RemoteData {
	if a == nil {
		return nil
	}
	return a.RemoteData
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type embed Account
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Account(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	a.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Account) MarshalJSON() ([]byte, error) {
	type embed Account
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*a),
		CreatedAt:  internal.NewOptionalDateTime(a.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(a.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Account) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// * `BANK` - BANK
// * `CREDIT_CARD` - CREDIT_CARD
// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// * `FIXED_ASSET` - FIXED_ASSET
// * `OTHER_ASSET` - OTHER_ASSET
// * `OTHER_CURRENT_ASSET` - OTHER_CURRENT_ASSET
// * `OTHER_EXPENSE` - OTHER_EXPENSE
// * `OTHER_INCOME` - OTHER_INCOME
// * `COST_OF_GOODS_SOLD` - COST_OF_GOODS_SOLD
// * `OTHER_CURRENT_LIABILITY` - OTHER_CURRENT_LIABILITY
// * `LONG_TERM_LIABILITY` - LONG_TERM_LIABILITY
// * `NON_POSTING` - NON_POSTING
type AccountAccountTypeEnum string

const (
	AccountAccountTypeEnumBank                  AccountAccountTypeEnum = "BANK"
	AccountAccountTypeEnumCreditCard            AccountAccountTypeEnum = "CREDIT_CARD"
	AccountAccountTypeEnumAccountsPayable       AccountAccountTypeEnum = "ACCOUNTS_PAYABLE"
	AccountAccountTypeEnumAccountsReceivable    AccountAccountTypeEnum = "ACCOUNTS_RECEIVABLE"
	AccountAccountTypeEnumFixedAsset            AccountAccountTypeEnum = "FIXED_ASSET"
	AccountAccountTypeEnumOtherAsset            AccountAccountTypeEnum = "OTHER_ASSET"
	AccountAccountTypeEnumOtherCurrentAsset     AccountAccountTypeEnum = "OTHER_CURRENT_ASSET"
	AccountAccountTypeEnumOtherExpense          AccountAccountTypeEnum = "OTHER_EXPENSE"
	AccountAccountTypeEnumOtherIncome           AccountAccountTypeEnum = "OTHER_INCOME"
	AccountAccountTypeEnumCostOfGoodsSold       AccountAccountTypeEnum = "COST_OF_GOODS_SOLD"
	AccountAccountTypeEnumOtherCurrentLiability AccountAccountTypeEnum = "OTHER_CURRENT_LIABILITY"
	AccountAccountTypeEnumLongTermLiability     AccountAccountTypeEnum = "LONG_TERM_LIABILITY"
	AccountAccountTypeEnumNonPosting            AccountAccountTypeEnum = "NON_POSTING"
)

func NewAccountAccountTypeEnumFromString(s string) (AccountAccountTypeEnum, error) {
	switch s {
	case "BANK":
		return AccountAccountTypeEnumBank, nil
	case "CREDIT_CARD":
		return AccountAccountTypeEnumCreditCard, nil
	case "ACCOUNTS_PAYABLE":
		return AccountAccountTypeEnumAccountsPayable, nil
	case "ACCOUNTS_RECEIVABLE":
		return AccountAccountTypeEnumAccountsReceivable, nil
	case "FIXED_ASSET":
		return AccountAccountTypeEnumFixedAsset, nil
	case "OTHER_ASSET":
		return AccountAccountTypeEnumOtherAsset, nil
	case "OTHER_CURRENT_ASSET":
		return AccountAccountTypeEnumOtherCurrentAsset, nil
	case "OTHER_EXPENSE":
		return AccountAccountTypeEnumOtherExpense, nil
	case "OTHER_INCOME":
		return AccountAccountTypeEnumOtherIncome, nil
	case "COST_OF_GOODS_SOLD":
		return AccountAccountTypeEnumCostOfGoodsSold, nil
	case "OTHER_CURRENT_LIABILITY":
		return AccountAccountTypeEnumOtherCurrentLiability, nil
	case "LONG_TERM_LIABILITY":
		return AccountAccountTypeEnumLongTermLiability, nil
	case "NON_POSTING":
		return AccountAccountTypeEnumNonPosting, nil
	}
	var t AccountAccountTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountAccountTypeEnum) Ptr() *AccountAccountTypeEnum {
	return &a
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name" url:"name"`
	// Optional. This shortened name appears in places with limited space, usually in conjunction with the platform's logo (e.g., Merge Link menu).<br><br>Example: <i>Workforce Now (in lieu of ADP Workforce Now), SuccessFactors (in lieu of SAP SuccessFactors)</i>
	AbbreviatedName *string `json:"abbreviated_name,omitempty" url:"abbreviated_name,omitempty"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty" url:"categories,omitempty"`
	// Company logo in rectangular shape.
	Image *string `json:"image,omitempty" url:"image,omitempty"`
	// Company logo in square shape.
	SquareImage *string `json:"square_image,omitempty" url:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	Slug  *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]interface{} `json:"api_endpoints_to_documentation_urls,omitempty" url:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty" url:"webhook_setup_guide_url,omitempty"`
	// Category or categories this integration is in beta status for.
	CategoryBetaStatus map[string]interface{} `json:"category_beta_status,omitempty" url:"category_beta_status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountIntegration) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AccountIntegration) GetAbbreviatedName() *string {
	if a == nil {
		return nil
	}
	return a.AbbreviatedName
}

func (a *AccountIntegration) GetCategories() []CategoriesEnum {
	if a == nil {
		return nil
	}
	return a.Categories
}

func (a *AccountIntegration) GetImage() *string {
	if a == nil {
		return nil
	}
	return a.Image
}

func (a *AccountIntegration) GetSquareImage() *string {
	if a == nil {
		return nil
	}
	return a.SquareImage
}

func (a *AccountIntegration) GetColor() *string {
	if a == nil {
		return nil
	}
	return a.Color
}

func (a *AccountIntegration) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *AccountIntegration) GetApiEndpointsToDocumentationUrls() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.ApiEndpointsToDocumentationUrls
}

func (a *AccountIntegration) GetWebhookSetupGuideUrl() *string {
	if a == nil {
		return nil
	}
	return a.WebhookSetupGuideUrl
}

func (a *AccountIntegration) GetCategoryBetaStatus() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.CategoryBetaStatus
}

func (a *AccountIntegration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountIntegration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountIntegration) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// * `ACTIVE` - ACTIVE
// * `PENDING` - PENDING
// * `INACTIVE` - INACTIVE
type AccountStatusEnum string

const (
	AccountStatusEnumActive   AccountStatusEnum = "ACTIVE"
	AccountStatusEnumPending  AccountStatusEnum = "PENDING"
	AccountStatusEnumInactive AccountStatusEnum = "INACTIVE"
)

func NewAccountStatusEnumFromString(s string) (AccountStatusEnum, error) {
	switch s {
	case "ACTIVE":
		return AccountStatusEnumActive, nil
	case "PENDING":
		return AccountStatusEnumPending, nil
	case "INACTIVE":
		return AccountStatusEnumInactive, nil
	}
	var t AccountStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountStatusEnum) Ptr() *AccountStatusEnum {
	return &a
}

// # The AccountingPeriod Object
// ### Description
// The `AccountingPeriod` object is used to define a period of time in which events occurred.
//
// ### Usage Example
// Common models like `Invoice` and `Transaction` will have `AccountingPeriod` objects which will denote when they occurred.
type AccountingPeriod struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// Name of the accounting period.
	Name   *string        `json:"name,omitempty" url:"name,omitempty"`
	Status *Status895Enum `json:"status,omitempty" url:"status,omitempty"`
	// Beginning date of the period
	StartDate *time.Time `json:"start_date,omitempty" url:"start_date,omitempty"`
	// End date of the period
	EndDate       *time.Time             `json:"end_date,omitempty" url:"end_date,omitempty"`
	FieldMappings map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData    []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountingPeriod) GetId() *string {
	if a == nil {
		return nil
	}
	return a.Id
}

func (a *AccountingPeriod) GetRemoteId() *string {
	if a == nil {
		return nil
	}
	return a.RemoteId
}

func (a *AccountingPeriod) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *AccountingPeriod) GetModifiedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.ModifiedAt
}

func (a *AccountingPeriod) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AccountingPeriod) GetStatus() *Status895Enum {
	if a == nil {
		return nil
	}
	return a.Status
}

func (a *AccountingPeriod) GetStartDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.StartDate
}

func (a *AccountingPeriod) GetEndDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.EndDate
}

func (a *AccountingPeriod) GetFieldMappings() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.FieldMappings
}

func (a *AccountingPeriod) GetRemoteData() []*RemoteData {
	if a == nil {
		return nil
	}
	return a.RemoteData
}

func (a *AccountingPeriod) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountingPeriod) UnmarshalJSON(data []byte) error {
	type embed AccountingPeriod
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
		StartDate  *internal.DateTime `json:"start_date,omitempty"`
		EndDate    *internal.DateTime `json:"end_date,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AccountingPeriod(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	a.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	a.StartDate = unmarshaler.StartDate.TimePtr()
	a.EndDate = unmarshaler.EndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingPeriod) MarshalJSON() ([]byte, error) {
	type embed AccountingPeriod
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
		StartDate  *internal.DateTime `json:"start_date,omitempty"`
		EndDate    *internal.DateTime `json:"end_date,omitempty"`
	}{
		embed:      embed(*a),
		CreatedAt:  internal.NewOptionalDateTime(a.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(a.ModifiedAt),
		StartDate:  internal.NewOptionalDateTime(a.StartDate),
		EndDate:    internal.NewOptionalDateTime(a.EndDate),
	}
	return json.Marshal(marshaler)
}

func (a *AccountingPeriod) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The AccountingPhoneNumber Object
// ### Description
// The `AccountingPhoneNumber` object is used to represent a contact's or company's phone number.
//
// ### Usage Example
// Fetch from the `GET CompanyInfo` endpoint and view the company's phone numbers.
type AccountingPhoneNumber struct {
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The phone number.
	Number *string `json:"number,omitempty" url:"number,omitempty"`
	// The phone number's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountingPhoneNumber) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *AccountingPhoneNumber) GetModifiedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.ModifiedAt
}

func (a *AccountingPhoneNumber) GetNumber() *string {
	if a == nil {
		return nil
	}
	return a.Number
}

func (a *AccountingPhoneNumber) GetType() *string {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *AccountingPhoneNumber) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountingPhoneNumber) UnmarshalJSON(data []byte) error {
	type embed AccountingPhoneNumber
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AccountingPhoneNumber(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	a.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountingPhoneNumber) MarshalJSON() ([]byte, error) {
	type embed AccountingPhoneNumber
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*a),
		CreatedAt:  internal.NewOptionalDateTime(a.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(a.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (a *AccountingPhoneNumber) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The Address Object
// ### Description
// The `Address` object is used to represent a contact's or company's address.
//
// ### Usage Example
// Fetch from the `GET CompanyInfo` endpoint and view the company's addresses.
type Address struct {
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The address type.
	//
	// * `BILLING` - BILLING
	// * `SHIPPING` - SHIPPING
	Type *AddressTypeEnum `json:"type,omitempty" url:"type,omitempty"`
	// Line 1 of the address's street.
	Street1 *string `json:"street_1,omitempty" url:"street_1,omitempty"`
	// Line 2 of the address's street.
	Street2 *string `json:"street_2,omitempty" url:"street_2,omitempty"`
	// The address's city.
	City  *string     `json:"city,omitempty" url:"city,omitempty"`
	State interface{} `json:"state,omitempty" url:"state,omitempty"`
	// The address's state or region.
	CountrySubdivision *string `json:"country_subdivision,omitempty" url:"country_subdivision,omitempty"`
	// The address's country.
	//
	// * `AF` - Afghanistan
	// * `AX` - Åland Islands
	// * `AL` - Albania
	// * `DZ` - Algeria
	// * `AS` - American Samoa
	// * `AD` - Andorra
	// * `AO` - Angola
	// * `AI` - Anguilla
	// * `AQ` - Antarctica
	// * `AG` - Antigua and Barbuda
	// * `AR` - Argentina
	// * `AM` - Armenia
	// * `AW` - Aruba
	// * `AU` - Australia
	// * `AT` - Austria
	// * `AZ` - Azerbaijan
	// * `BS` - Bahamas
	// * `BH` - Bahrain
	// * `BD` - Bangladesh
	// * `BB` - Barbados
	// * `BY` - Belarus
	// * `BE` - Belgium
	// * `BZ` - Belize
	// * `BJ` - Benin
	// * `BM` - Bermuda
	// * `BT` - Bhutan
	// * `BO` - Bolivia
	// * `BQ` - Bonaire, Sint Eustatius and Saba
	// * `BA` - Bosnia and Herzegovina
	// * `BW` - Botswana
	// * `BV` - Bouvet Island
	// * `BR` - Brazil
	// * `IO` - British Indian Ocean Territory
	// * `BN` - Brunei
	// * `BG` - Bulgaria
	// * `BF` - Burkina Faso
	// * `BI` - Burundi
	// * `CV` - Cabo Verde
	// * `KH` - Cambodia
	// * `CM` - Cameroon
	// * `CA` - Canada
	// * `KY` - Cayman Islands
	// * `CF` - Central African Republic
	// * `TD` - Chad
	// * `CL` - Chile
	// * `CN` - China
	// * `CX` - Christmas Island
	// * `CC` - Cocos (Keeling) Islands
	// * `CO` - Colombia
	// * `KM` - Comoros
	// * `CG` - Congo
	// * `CD` - Congo (the Democratic Republic of the)
	// * `CK` - Cook Islands
	// * `CR` - Costa Rica
	// * `CI` - Côte d'Ivoire
	// * `HR` - Croatia
	// * `CU` - Cuba
	// * `CW` - Curaçao
	// * `CY` - Cyprus
	// * `CZ` - Czechia
	// * `DK` - Denmark
	// * `DJ` - Djibouti
	// * `DM` - Dominica
	// * `DO` - Dominican Republic
	// * `EC` - Ecuador
	// * `EG` - Egypt
	// * `SV` - El Salvador
	// * `GQ` - Equatorial Guinea
	// * `ER` - Eritrea
	// * `EE` - Estonia
	// * `SZ` - Eswatini
	// * `ET` - Ethiopia
	// * `FK` - Falkland Islands (Malvinas)
	// * `FO` - Faroe Islands
	// * `FJ` - Fiji
	// * `FI` - Finland
	// * `FR` - France
	// * `GF` - French Guiana
	// * `PF` - French Polynesia
	// * `TF` - French Southern Territories
	// * `GA` - Gabon
	// * `GM` - Gambia
	// * `GE` - Georgia
	// * `DE` - Germany
	// * `GH` - Ghana
	// * `GI` - Gibraltar
	// * `GR` - Greece
	// * `GL` - Greenland
	// * `GD` - Grenada
	// * `GP` - Guadeloupe
	// * `GU` - Guam
	// * `GT` - Guatemala
	// * `GG` - Guernsey
	// * `GN` - Guinea
	// * `GW` - Guinea-Bissau
	// * `GY` - Guyana
	// * `HT` - Haiti
	// * `HM` - Heard Island and McDonald Islands
	// * `VA` - Holy See
	// * `HN` - Honduras
	// * `HK` - Hong Kong
	// * `HU` - Hungary
	// * `IS` - Iceland
	// * `IN` - India
	// * `ID` - Indonesia
	// * `IR` - Iran
	// * `IQ` - Iraq
	// * `IE` - Ireland
	// * `IM` - Isle of Man
	// * `IL` - Israel
	// * `IT` - Italy
	// * `JM` - Jamaica
	// * `JP` - Japan
	// * `JE` - Jersey
	// * `JO` - Jordan
	// * `KZ` - Kazakhstan
	// * `KE` - Kenya
	// * `KI` - Kiribati
	// * `KW` - Kuwait
	// * `KG` - Kyrgyzstan
	// * `LA` - Laos
	// * `LV` - Latvia
	// * `LB` - Lebanon
	// * `LS` - Lesotho
	// * `LR` - Liberia
	// * `LY` - Libya
	// * `LI` - Liechtenstein
	// * `LT` - Lithuania
	// * `LU` - Luxembourg
	// * `MO` - Macao
	// * `MG` - Madagascar
	// * `MW` - Malawi
	// * `MY` - Malaysia
	// * `MV` - Maldives
	// * `ML` - Mali
	// * `MT` - Malta
	// * `MH` - Marshall Islands
	// * `MQ` - Martinique
	// * `MR` - Mauritania
	// * `MU` - Mauritius
	// * `YT` - Mayotte
	// * `MX` - Mexico
	// * `FM` - Micronesia (Federated States of)
	// * `MD` - Moldova
	// * `MC` - Monaco
	// * `MN` - Mongolia
	// * `ME` - Montenegro
	// * `MS` - Montserrat
	// * `MA` - Morocco
	// * `MZ` - Mozambique
	// * `MM` - Myanmar
	// * `NA` - Namibia
	// * `NR` - Nauru
	// * `NP` - Nepal
	// * `NL` - Netherlands
	// * `NC` - New Caledonia
	// * `NZ` - New Zealand
	// * `NI` - Nicaragua
	// * `NE` - Niger
	// * `NG` - Nigeria
	// * `NU` - Niue
	// * `NF` - Norfolk Island
	// * `KP` - North Korea
	// * `MK` - North Macedonia
	// * `MP` - Northern Mariana Islands
	// * `NO` - Norway
	// * `OM` - Oman
	// * `PK` - Pakistan
	// * `PW` - Palau
	// * `PS` - Palestine, State of
	// * `PA` - Panama
	// * `PG` - Papua New Guinea
	// * `PY` - Paraguay
	// * `PE` - Peru
	// * `PH` - Philippines
	// * `PN` - Pitcairn
	// * `PL` - Poland
	// * `PT` - Portugal
	// * `PR` - Puerto Rico
	// * `QA` - Qatar
	// * `RE` - Réunion
	// * `RO` - Romania
	// * `RU` - Russia
	// * `RW` - Rwanda
	// * `BL` - Saint Barthélemy
	// * `SH` - Saint Helena, Ascension and Tristan da Cunha
	// * `KN` - Saint Kitts and Nevis
	// * `LC` - Saint Lucia
	// * `MF` - Saint Martin (French part)
	// * `PM` - Saint Pierre and Miquelon
	// * `VC` - Saint Vincent and the Grenadines
	// * `WS` - Samoa
	// * `SM` - San Marino
	// * `ST` - Sao Tome and Principe
	// * `SA` - Saudi Arabia
	// * `SN` - Senegal
	// * `RS` - Serbia
	// * `SC` - Seychelles
	// * `SL` - Sierra Leone
	// * `SG` - Singapore
	// * `SX` - Sint Maarten (Dutch part)
	// * `SK` - Slovakia
	// * `SI` - Slovenia
	// * `SB` - Solomon Islands
	// * `SO` - Somalia
	// * `ZA` - South Africa
	// * `GS` - South Georgia and the South Sandwich Islands
	// * `KR` - South Korea
	// * `SS` - South Sudan
	// * `ES` - Spain
	// * `LK` - Sri Lanka
	// * `SD` - Sudan
	// * `SR` - Suriname
	// * `SJ` - Svalbard and Jan Mayen
	// * `SE` - Sweden
	// * `CH` - Switzerland
	// * `SY` - Syria
	// * `TW` - Taiwan
	// * `TJ` - Tajikistan
	// * `TZ` - Tanzania
	// * `TH` - Thailand
	// * `TL` - Timor-Leste
	// * `TG` - Togo
	// * `TK` - Tokelau
	// * `TO` - Tonga
	// * `TT` - Trinidad and Tobago
	// * `TN` - Tunisia
	// * `TR` - Turkey
	// * `TM` - Turkmenistan
	// * `TC` - Turks and Caicos Islands
	// * `TV` - Tuvalu
	// * `UG` - Uganda
	// * `UA` - Ukraine
	// * `AE` - United Arab Emirates
	// * `GB` - United Kingdom
	// * `UM` - United States Minor Outlying Islands
	// * `US` - United States of America
	// * `UY` - Uruguay
	// * `UZ` - Uzbekistan
	// * `VU` - Vanuatu
	// * `VE` - Venezuela
	// * `VN` - Vietnam
	// * `VG` - Virgin Islands (British)
	// * `VI` - Virgin Islands (U.S.)
	// * `WF` - Wallis and Futuna
	// * `EH` - Western Sahara
	// * `YE` - Yemen
	// * `ZM` - Zambia
	// * `ZW` - Zimbabwe
	Country *CountryEnum `json:"country,omitempty" url:"country,omitempty"`
	// The address's zip code.
	ZipCode *string `json:"zip_code,omitempty" url:"zip_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Address) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *Address) GetModifiedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.ModifiedAt
}

func (a *Address) GetType() *AddressTypeEnum {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *Address) GetStreet1() *string {
	if a == nil {
		return nil
	}
	return a.Street1
}

func (a *Address) GetStreet2() *string {
	if a == nil {
		return nil
	}
	return a.Street2
}

func (a *Address) GetCity() *string {
	if a == nil {
		return nil
	}
	return a.City
}

func (a *Address) GetState() interface{} {
	if a == nil {
		return nil
	}
	return a.State
}

func (a *Address) GetCountrySubdivision() *string {
	if a == nil {
		return nil
	}
	return a.CountrySubdivision
}

func (a *Address) GetCountry() *CountryEnum {
	if a == nil {
		return nil
	}
	return a.Country
}

func (a *Address) GetZipCode() *string {
	if a == nil {
		return nil
	}
	return a.ZipCode
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type embed Address
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Address(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	a.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) MarshalJSON() ([]byte, error) {
	type embed Address
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*a),
		CreatedAt:  internal.NewOptionalDateTime(a.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(a.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Address) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The Address Object
// ### Description
// The `Address` object is used to represent a contact's or company's address.
//
// ### Usage Example
// Fetch from the `GET CompanyInfo` endpoint and view the company's addresses.
type AddressRequest struct {
	// The address type.
	//
	// * `BILLING` - BILLING
	// * `SHIPPING` - SHIPPING
	Type *AddressTypeEnum `json:"type,omitempty" url:"type,omitempty"`
	// Line 1 of the address's street.
	Street1 *string `json:"street_1,omitempty" url:"street_1,omitempty"`
	// Line 2 of the address's street.
	Street2 *string `json:"street_2,omitempty" url:"street_2,omitempty"`
	// The address's city.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// The address's state or region.
	CountrySubdivision *string `json:"country_subdivision,omitempty" url:"country_subdivision,omitempty"`
	// The address's country.
	//
	// * `AF` - Afghanistan
	// * `AX` - Åland Islands
	// * `AL` - Albania
	// * `DZ` - Algeria
	// * `AS` - American Samoa
	// * `AD` - Andorra
	// * `AO` - Angola
	// * `AI` - Anguilla
	// * `AQ` - Antarctica
	// * `AG` - Antigua and Barbuda
	// * `AR` - Argentina
	// * `AM` - Armenia
	// * `AW` - Aruba
	// * `AU` - Australia
	// * `AT` - Austria
	// * `AZ` - Azerbaijan
	// * `BS` - Bahamas
	// * `BH` - Bahrain
	// * `BD` - Bangladesh
	// * `BB` - Barbados
	// * `BY` - Belarus
	// * `BE` - Belgium
	// * `BZ` - Belize
	// * `BJ` - Benin
	// * `BM` - Bermuda
	// * `BT` - Bhutan
	// * `BO` - Bolivia
	// * `BQ` - Bonaire, Sint Eustatius and Saba
	// * `BA` - Bosnia and Herzegovina
	// * `BW` - Botswana
	// * `BV` - Bouvet Island
	// * `BR` - Brazil
	// * `IO` - British Indian Ocean Territory
	// * `BN` - Brunei
	// * `BG` - Bulgaria
	// * `BF` - Burkina Faso
	// * `BI` - Burundi
	// * `CV` - Cabo Verde
	// * `KH` - Cambodia
	// * `CM` - Cameroon
	// * `CA` - Canada
	// * `KY` - Cayman Islands
	// * `CF` - Central African Republic
	// * `TD` - Chad
	// * `CL` - Chile
	// * `CN` - China
	// * `CX` - Christmas Island
	// * `CC` - Cocos (Keeling) Islands
	// * `CO` - Colombia
	// * `KM` - Comoros
	// * `CG` - Congo
	// * `CD` - Congo (the Democratic Republic of the)
	// * `CK` - Cook Islands
	// * `CR` - Costa Rica
	// * `CI` - Côte d'Ivoire
	// * `HR` - Croatia
	// * `CU` - Cuba
	// * `CW` - Curaçao
	// * `CY` - Cyprus
	// * `CZ` - Czechia
	// * `DK` - Denmark
	// * `DJ` - Djibouti
	// * `DM` - Dominica
	// * `DO` - Dominican Republic
	// * `EC` - Ecuador
	// * `EG` - Egypt
	// * `SV` - El Salvador
	// * `GQ` - Equatorial Guinea
	// * `ER` - Eritrea
	// * `EE` - Estonia
	// * `SZ` - Eswatini
	// * `ET` - Ethiopia
	// * `FK` - Falkland Islands (Malvinas)
	// * `FO` - Faroe Islands
	// * `FJ` - Fiji
	// * `FI` - Finland
	// * `FR` - France
	// * `GF` - French Guiana
	// * `PF` - French Polynesia
	// * `TF` - French Southern Territories
	// * `GA` - Gabon
	// * `GM` - Gambia
	// * `GE` - Georgia
	// * `DE` - Germany
	// * `GH` - Ghana
	// * `GI` - Gibraltar
	// * `GR` - Greece
	// * `GL` - Greenland
	// * `GD` - Grenada
	// * `GP` - Guadeloupe
	// * `GU` - Guam
	// * `GT` - Guatemala
	// * `GG` - Guernsey
	// * `GN` - Guinea
	// * `GW` - Guinea-Bissau
	// * `GY` - Guyana
	// * `HT` - Haiti
	// * `HM` - Heard Island and McDonald Islands
	// * `VA` - Holy See
	// * `HN` - Honduras
	// * `HK` - Hong Kong
	// * `HU` - Hungary
	// * `IS` - Iceland
	// * `IN` - India
	// * `ID` - Indonesia
	// * `IR` - Iran
	// * `IQ` - Iraq
	// * `IE` - Ireland
	// * `IM` - Isle of Man
	// * `IL` - Israel
	// * `IT` - Italy
	// * `JM` - Jamaica
	// * `JP` - Japan
	// * `JE` - Jersey
	// * `JO` - Jordan
	// * `KZ` - Kazakhstan
	// * `KE` - Kenya
	// * `KI` - Kiribati
	// * `KW` - Kuwait
	// * `KG` - Kyrgyzstan
	// * `LA` - Laos
	// * `LV` - Latvia
	// * `LB` - Lebanon
	// * `LS` - Lesotho
	// * `LR` - Liberia
	// * `LY` - Libya
	// * `LI` - Liechtenstein
	// * `LT` - Lithuania
	// * `LU` - Luxembourg
	// * `MO` - Macao
	// * `MG` - Madagascar
	// * `MW` - Malawi
	// * `MY` - Malaysia
	// * `MV` - Maldives
	// * `ML` - Mali
	// * `MT` - Malta
	// * `MH` - Marshall Islands
	// * `MQ` - Martinique
	// * `MR` - Mauritania
	// * `MU` - Mauritius
	// * `YT` - Mayotte
	// * `MX` - Mexico
	// * `FM` - Micronesia (Federated States of)
	// * `MD` - Moldova
	// * `MC` - Monaco
	// * `MN` - Mongolia
	// * `ME` - Montenegro
	// * `MS` - Montserrat
	// * `MA` - Morocco
	// * `MZ` - Mozambique
	// * `MM` - Myanmar
	// * `NA` - Namibia
	// * `NR` - Nauru
	// * `NP` - Nepal
	// * `NL` - Netherlands
	// * `NC` - New Caledonia
	// * `NZ` - New Zealand
	// * `NI` - Nicaragua
	// * `NE` - Niger
	// * `NG` - Nigeria
	// * `NU` - Niue
	// * `NF` - Norfolk Island
	// * `KP` - North Korea
	// * `MK` - North Macedonia
	// * `MP` - Northern Mariana Islands
	// * `NO` - Norway
	// * `OM` - Oman
	// * `PK` - Pakistan
	// * `PW` - Palau
	// * `PS` - Palestine, State of
	// * `PA` - Panama
	// * `PG` - Papua New Guinea
	// * `PY` - Paraguay
	// * `PE` - Peru
	// * `PH` - Philippines
	// * `PN` - Pitcairn
	// * `PL` - Poland
	// * `PT` - Portugal
	// * `PR` - Puerto Rico
	// * `QA` - Qatar
	// * `RE` - Réunion
	// * `RO` - Romania
	// * `RU` - Russia
	// * `RW` - Rwanda
	// * `BL` - Saint Barthélemy
	// * `SH` - Saint Helena, Ascension and Tristan da Cunha
	// * `KN` - Saint Kitts and Nevis
	// * `LC` - Saint Lucia
	// * `MF` - Saint Martin (French part)
	// * `PM` - Saint Pierre and Miquelon
	// * `VC` - Saint Vincent and the Grenadines
	// * `WS` - Samoa
	// * `SM` - San Marino
	// * `ST` - Sao Tome and Principe
	// * `SA` - Saudi Arabia
	// * `SN` - Senegal
	// * `RS` - Serbia
	// * `SC` - Seychelles
	// * `SL` - Sierra Leone
	// * `SG` - Singapore
	// * `SX` - Sint Maarten (Dutch part)
	// * `SK` - Slovakia
	// * `SI` - Slovenia
	// * `SB` - Solomon Islands
	// * `SO` - Somalia
	// * `ZA` - South Africa
	// * `GS` - South Georgia and the South Sandwich Islands
	// * `KR` - South Korea
	// * `SS` - South Sudan
	// * `ES` - Spain
	// * `LK` - Sri Lanka
	// * `SD` - Sudan
	// * `SR` - Suriname
	// * `SJ` - Svalbard and Jan Mayen
	// * `SE` - Sweden
	// * `CH` - Switzerland
	// * `SY` - Syria
	// * `TW` - Taiwan
	// * `TJ` - Tajikistan
	// * `TZ` - Tanzania
	// * `TH` - Thailand
	// * `TL` - Timor-Leste
	// * `TG` - Togo
	// * `TK` - Tokelau
	// * `TO` - Tonga
	// * `TT` - Trinidad and Tobago
	// * `TN` - Tunisia
	// * `TR` - Turkey
	// * `TM` - Turkmenistan
	// * `TC` - Turks and Caicos Islands
	// * `TV` - Tuvalu
	// * `UG` - Uganda
	// * `UA` - Ukraine
	// * `AE` - United Arab Emirates
	// * `GB` - United Kingdom
	// * `UM` - United States Minor Outlying Islands
	// * `US` - United States of America
	// * `UY` - Uruguay
	// * `UZ` - Uzbekistan
	// * `VU` - Vanuatu
	// * `VE` - Venezuela
	// * `VN` - Vietnam
	// * `VG` - Virgin Islands (British)
	// * `VI` - Virgin Islands (U.S.)
	// * `WF` - Wallis and Futuna
	// * `EH` - Western Sahara
	// * `YE` - Yemen
	// * `ZM` - Zambia
	// * `ZW` - Zimbabwe
	Country *CountryEnum `json:"country,omitempty" url:"country,omitempty"`
	// The address's zip code.
	ZipCode             *string                `json:"zip_code,omitempty" url:"zip_code,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddressRequest) GetType() *AddressTypeEnum {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *AddressRequest) GetStreet1() *string {
	if a == nil {
		return nil
	}
	return a.Street1
}

func (a *AddressRequest) GetStreet2() *string {
	if a == nil {
		return nil
	}
	return a.Street2
}

func (a *AddressRequest) GetCity() *string {
	if a == nil {
		return nil
	}
	return a.City
}

func (a *AddressRequest) GetCountrySubdivision() *string {
	if a == nil {
		return nil
	}
	return a.CountrySubdivision
}

func (a *AddressRequest) GetCountry() *CountryEnum {
	if a == nil {
		return nil
	}
	return a.Country
}

func (a *AddressRequest) GetZipCode() *string {
	if a == nil {
		return nil
	}
	return a.ZipCode
}

func (a *AddressRequest) GetIntegrationParams() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.IntegrationParams
}

func (a *AddressRequest) GetLinkedAccountParams() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.LinkedAccountParams
}

func (a *AddressRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddressRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddressRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddressRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddressRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// * `BILLING` - BILLING
// * `SHIPPING` - SHIPPING
type AddressTypeEnum string

const (
	AddressTypeEnumBilling  AddressTypeEnum = "BILLING"
	AddressTypeEnumShipping AddressTypeEnum = "SHIPPING"
)

func NewAddressTypeEnumFromString(s string) (AddressTypeEnum, error) {
	switch s {
	case "BILLING":
		return AddressTypeEnumBilling, nil
	case "SHIPPING":
		return AddressTypeEnumShipping, nil
	}
	var t AddressTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AddressTypeEnum) Ptr() *AddressTypeEnum {
	return &a
}

// # The BankFeedAccount Object
// ### Description
// The `BankFeedAccount` object represents a bank feed account, detailing various attributes including account identifiers, names, currency, and balance information. This object is central to managing and tracking bank feed accounts within the system.
//
// ### Usage Example
// Fetch from the `GET BankFeedAccount` endpoint to view details of a bank feed account.
type BankFeedAccount struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The unique identifier of the source account from our customer’s platform.
	SourceAccountId *string `json:"source_account_id,omitempty" url:"source_account_id,omitempty"`
	// The unique identifier of the target account from the third party software.
	TargetAccountId *string `json:"target_account_id,omitempty" url:"target_account_id,omitempty"`
	// The name of the source account as stored in our customer’s platform.
	SourceAccountName *string `json:"source_account_name,omitempty" url:"source_account_name,omitempty"`
	// The human-readable account number of the source account as stored in our customer’s platform.
	SourceAccountNumber *string `json:"source_account_number,omitempty" url:"source_account_number,omitempty"`
	// The name of the target account from the third party software.
	TargetAccountName *string `json:"target_account_name,omitempty" url:"target_account_name,omitempty"`
	// The currency code of the bank feed.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// The status of the bank feed.
	//
	// * `ACTIVE` - ACTIVE
	// * `INACTIVE` - INACTIVE
	FeedStatus *FeedStatusEnum `json:"feed_status,omitempty" url:"feed_status,omitempty"`
	// The start date of the bank feed’s transactions.
	FeedStartDate *time.Time `json:"feed_start_date,omitempty" url:"feed_start_date,omitempty"`
	// The current balance of funds in the source account.
	SourceAccountBalance *float64 `json:"source_account_balance,omitempty" url:"source_account_balance,omitempty"`
	// The type of the account.
	//
	// * `BANK` - BANK
	// * `CREDIT_CARD` - CREDIT_CARD
	AccountType *BankFeedAccountAccountTypeEnum `json:"account_type,omitempty" url:"account_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                    `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{}   `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []map[string]interface{} `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankFeedAccount) GetId() *string {
	if b == nil {
		return nil
	}
	return b.Id
}

func (b *BankFeedAccount) GetRemoteId() *string {
	if b == nil {
		return nil
	}
	return b.RemoteId
}

func (b *BankFeedAccount) GetCreatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BankFeedAccount) GetModifiedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.ModifiedAt
}

func (b *BankFeedAccount) GetSourceAccountId() *string {
	if b == nil {
		return nil
	}
	return b.SourceAccountId
}

func (b *BankFeedAccount) GetTargetAccountId() *string {
	if b == nil {
		return nil
	}
	return b.TargetAccountId
}

func (b *BankFeedAccount) GetSourceAccountName() *string {
	if b == nil {
		return nil
	}
	return b.SourceAccountName
}

func (b *BankFeedAccount) GetSourceAccountNumber() *string {
	if b == nil {
		return nil
	}
	return b.SourceAccountNumber
}

func (b *BankFeedAccount) GetTargetAccountName() *string {
	if b == nil {
		return nil
	}
	return b.TargetAccountName
}

func (b *BankFeedAccount) GetCurrency() *TransactionCurrencyEnum {
	if b == nil {
		return nil
	}
	return b.Currency
}

func (b *BankFeedAccount) GetFeedStatus() *FeedStatusEnum {
	if b == nil {
		return nil
	}
	return b.FeedStatus
}

func (b *BankFeedAccount) GetFeedStartDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.FeedStartDate
}

func (b *BankFeedAccount) GetSourceAccountBalance() *float64 {
	if b == nil {
		return nil
	}
	return b.SourceAccountBalance
}

func (b *BankFeedAccount) GetAccountType() *BankFeedAccountAccountTypeEnum {
	if b == nil {
		return nil
	}
	return b.AccountType
}

func (b *BankFeedAccount) GetRemoteWasDeleted() *bool {
	if b == nil {
		return nil
	}
	return b.RemoteWasDeleted
}

func (b *BankFeedAccount) GetFieldMappings() map[string]interface{} {
	if b == nil {
		return nil
	}
	return b.FieldMappings
}

func (b *BankFeedAccount) GetRemoteData() []map[string]interface{} {
	if b == nil {
		return nil
	}
	return b.RemoteData
}

func (b *BankFeedAccount) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankFeedAccount) UnmarshalJSON(data []byte) error {
	type embed BankFeedAccount
	var unmarshaler = struct {
		embed
		CreatedAt     *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt    *internal.DateTime `json:"modified_at,omitempty"`
		FeedStartDate *internal.DateTime `json:"feed_start_date,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankFeedAccount(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	b.FeedStartDate = unmarshaler.FeedStartDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankFeedAccount) MarshalJSON() ([]byte, error) {
	type embed BankFeedAccount
	var marshaler = struct {
		embed
		CreatedAt     *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt    *internal.DateTime `json:"modified_at,omitempty"`
		FeedStartDate *internal.DateTime `json:"feed_start_date,omitempty"`
	}{
		embed:         embed(*b),
		CreatedAt:     internal.NewOptionalDateTime(b.CreatedAt),
		ModifiedAt:    internal.NewOptionalDateTime(b.ModifiedAt),
		FeedStartDate: internal.NewOptionalDateTime(b.FeedStartDate),
	}
	return json.Marshal(marshaler)
}

func (b *BankFeedAccount) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// * `BANK` - BANK
// * `CREDIT_CARD` - CREDIT_CARD
type BankFeedAccountAccountTypeEnum string

const (
	BankFeedAccountAccountTypeEnumBank       BankFeedAccountAccountTypeEnum = "BANK"
	BankFeedAccountAccountTypeEnumCreditCard BankFeedAccountAccountTypeEnum = "CREDIT_CARD"
)

func NewBankFeedAccountAccountTypeEnumFromString(s string) (BankFeedAccountAccountTypeEnum, error) {
	switch s {
	case "BANK":
		return BankFeedAccountAccountTypeEnumBank, nil
	case "CREDIT_CARD":
		return BankFeedAccountAccountTypeEnumCreditCard, nil
	}
	var t BankFeedAccountAccountTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankFeedAccountAccountTypeEnum) Ptr() *BankFeedAccountAccountTypeEnum {
	return &b
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoriesEnum string

const (
	CategoriesEnumHris        CategoriesEnum = "hris"
	CategoriesEnumAts         CategoriesEnum = "ats"
	CategoriesEnumAccounting  CategoriesEnum = "accounting"
	CategoriesEnumTicketing   CategoriesEnum = "ticketing"
	CategoriesEnumCrm         CategoriesEnum = "crm"
	CategoriesEnumMktg        CategoriesEnum = "mktg"
	CategoriesEnumFilestorage CategoriesEnum = "filestorage"
)

func NewCategoriesEnumFromString(s string) (CategoriesEnum, error) {
	switch s {
	case "hris":
		return CategoriesEnumHris, nil
	case "ats":
		return CategoriesEnumAts, nil
	case "accounting":
		return CategoriesEnumAccounting, nil
	case "ticketing":
		return CategoriesEnumTicketing, nil
	case "crm":
		return CategoriesEnumCrm, nil
	case "mktg":
		return CategoriesEnumMktg, nil
	case "filestorage":
		return CategoriesEnumFilestorage, nil
	}
	var t CategoriesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoriesEnum) Ptr() *CategoriesEnum {
	return &c
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoryEnum string

const (
	CategoryEnumHris        CategoryEnum = "hris"
	CategoryEnumAts         CategoryEnum = "ats"
	CategoryEnumAccounting  CategoryEnum = "accounting"
	CategoryEnumTicketing   CategoryEnum = "ticketing"
	CategoryEnumCrm         CategoryEnum = "crm"
	CategoryEnumMktg        CategoryEnum = "mktg"
	CategoryEnumFilestorage CategoryEnum = "filestorage"
)

func NewCategoryEnumFromString(s string) (CategoryEnum, error) {
	switch s {
	case "hris":
		return CategoryEnumHris, nil
	case "ats":
		return CategoryEnumAts, nil
	case "accounting":
		return CategoryEnumAccounting, nil
	case "ticketing":
		return CategoryEnumTicketing, nil
	case "crm":
		return CategoryEnumCrm, nil
	case "mktg":
		return CategoryEnumMktg, nil
	case "filestorage":
		return CategoryEnumFilestorage, nil
	}
	var t CategoryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryEnum) Ptr() *CategoryEnum {
	return &c
}

// * `CLASS` - CLASS
// * `DEPARTMENT` - DEPARTMENT
type CategoryTypeEnum string

const (
	CategoryTypeEnumClass      CategoryTypeEnum = "CLASS"
	CategoryTypeEnumDepartment CategoryTypeEnum = "DEPARTMENT"
)

func NewCategoryTypeEnumFromString(s string) (CategoryTypeEnum, error) {
	switch s {
	case "CLASS":
		return CategoryTypeEnumClass, nil
	case "DEPARTMENT":
		return CategoryTypeEnumDepartment, nil
	}
	var t CategoryTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryTypeEnum) Ptr() *CategoryTypeEnum {
	return &c
}

// * `ASSET` - ASSET
// * `EQUITY` - EQUITY
// * `EXPENSE` - EXPENSE
// * `LIABILITY` - LIABILITY
// * `REVENUE` - REVENUE
type ClassificationEnum string

const (
	ClassificationEnumAsset     ClassificationEnum = "ASSET"
	ClassificationEnumEquity    ClassificationEnum = "EQUITY"
	ClassificationEnumExpense   ClassificationEnum = "EXPENSE"
	ClassificationEnumLiability ClassificationEnum = "LIABILITY"
	ClassificationEnumRevenue   ClassificationEnum = "REVENUE"
)

func NewClassificationEnumFromString(s string) (ClassificationEnum, error) {
	switch s {
	case "ASSET":
		return ClassificationEnumAsset, nil
	case "EQUITY":
		return ClassificationEnumEquity, nil
	case "EXPENSE":
		return ClassificationEnumExpense, nil
	case "LIABILITY":
		return ClassificationEnumLiability, nil
	case "REVENUE":
		return ClassificationEnumRevenue, nil
	}
	var t ClassificationEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassificationEnum) Ptr() *ClassificationEnum {
	return &c
}

// # The CompanyInfo Object
// ### Description
// The `CompanyInfo` object contains information about the company of the linked account. If the company has multiple entities (also known as subsidiaries), each entity may show up as a single `CompanyInfo` record.
//
// ### Usage Example
// Fetch from the `GET CompanyInfo` endpoint and view a company's information.
type CompanyInfo struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The company's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The company's legal name.
	LegalName *string `json:"legal_name,omitempty" url:"legal_name,omitempty"`
	// The company's tax number.
	TaxNumber *string `json:"tax_number,omitempty" url:"tax_number,omitempty"`
	// The company's fiscal year end month.
	FiscalYearEndMonth *int `json:"fiscal_year_end_month,omitempty" url:"fiscal_year_end_month,omitempty"`
	// The company's fiscal year end day.
	FiscalYearEndDay *int `json:"fiscal_year_end_day,omitempty" url:"fiscal_year_end_day,omitempty"`
	// The currency set in the company's accounting platform.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// When the third party's company was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// The company's urls.
	Urls         []*string                `json:"urls,omitempty" url:"urls,omitempty"`
	Addresses    []*Address               `json:"addresses,omitempty" url:"addresses,omitempty"`
	PhoneNumbers []*AccountingPhoneNumber `json:"phone_numbers,omitempty" url:"phone_numbers,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CompanyInfo) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *CompanyInfo) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *CompanyInfo) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CompanyInfo) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *CompanyInfo) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CompanyInfo) GetLegalName() *string {
	if c == nil {
		return nil
	}
	return c.LegalName
}

func (c *CompanyInfo) GetTaxNumber() *string {
	if c == nil {
		return nil
	}
	return c.TaxNumber
}

func (c *CompanyInfo) GetFiscalYearEndMonth() *int {
	if c == nil {
		return nil
	}
	return c.FiscalYearEndMonth
}

func (c *CompanyInfo) GetFiscalYearEndDay() *int {
	if c == nil {
		return nil
	}
	return c.FiscalYearEndDay
}

func (c *CompanyInfo) GetCurrency() *TransactionCurrencyEnum {
	if c == nil {
		return nil
	}
	return c.Currency
}

func (c *CompanyInfo) GetRemoteCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.RemoteCreatedAt
}

func (c *CompanyInfo) GetUrls() []*string {
	if c == nil {
		return nil
	}
	return c.Urls
}

func (c *CompanyInfo) GetAddresses() []*Address {
	if c == nil {
		return nil
	}
	return c.Addresses
}

func (c *CompanyInfo) GetPhoneNumbers() []*AccountingPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumbers
}

func (c *CompanyInfo) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *CompanyInfo) GetFieldMappings() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FieldMappings
}

func (c *CompanyInfo) GetRemoteData() []*RemoteData {
	if c == nil {
		return nil
	}
	return c.RemoteData
}

func (c *CompanyInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompanyInfo) UnmarshalJSON(data []byte) error {
	type embed CompanyInfo
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CompanyInfo(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	c.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyInfo) MarshalJSON() ([]byte, error) {
	type embed CompanyInfo
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
	}{
		embed:           embed(*c),
		CreatedAt:       internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(c.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(c.RemoteCreatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CompanyInfo) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// * `SALES` - SALES
// * `PURCHASE` - PURCHASE
type ComponentTypeEnum string

const (
	ComponentTypeEnumSales    ComponentTypeEnum = "SALES"
	ComponentTypeEnumPurchase ComponentTypeEnum = "PURCHASE"
)

func NewComponentTypeEnumFromString(s string) (ComponentTypeEnum, error) {
	switch s {
	case "SALES":
		return ComponentTypeEnumSales, nil
	case "PURCHASE":
		return ComponentTypeEnumPurchase, nil
	}
	var t ComponentTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComponentTypeEnum) Ptr() *ComponentTypeEnum {
	return &c
}

// # The Contact Object
// ### Description
// A `Contact` is an individual or business entity to which products and services are sold to or purchased from. The `Contact` model contains both Customers, in which products and services are sold to, and Vendors (or Suppliers), in which products and services are purchased from.
// * A `Contact` is a Vendor/Supplier if the `is_supplier` property is true.
// * A `Contact` is a customer if the `is_customer` property is true.
//
// ### Usage Example
// Fetch from the `LIST Contacts` endpoint and view a company's contacts.
type Contact struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The contact's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Whether the contact is a supplier.
	IsSupplier *bool `json:"is_supplier,omitempty" url:"is_supplier,omitempty"`
	// Whether the contact is a customer.
	IsCustomer *bool `json:"is_customer,omitempty" url:"is_customer,omitempty"`
	// The contact's email address.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The contact's tax number.
	TaxNumber *string `json:"tax_number,omitempty" url:"tax_number,omitempty"`
	// The contact's status
	//
	// * `ACTIVE` - ACTIVE
	// * `ARCHIVED` - ARCHIVED
	Status *Status7D1Enum `json:"status,omitempty" url:"status,omitempty"`
	// The currency the contact's transactions are in.
	Currency *string `json:"currency,omitempty" url:"currency,omitempty"`
	// When the third party's contact was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// The company the contact belongs to.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// `Address` object IDs for the given `Contacts` object.
	Addresses []*ContactAddressesItem `json:"addresses,omitempty" url:"addresses,omitempty"`
	// `AccountingPhoneNumber` object for the given `Contacts` object.
	PhoneNumbers []*AccountingPhoneNumber `json:"phone_numbers,omitempty" url:"phone_numbers,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Contact) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *Contact) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *Contact) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *Contact) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *Contact) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *Contact) GetIsSupplier() *bool {
	if c == nil {
		return nil
	}
	return c.IsSupplier
}

func (c *Contact) GetIsCustomer() *bool {
	if c == nil {
		return nil
	}
	return c.IsCustomer
}

func (c *Contact) GetEmailAddress() *string {
	if c == nil {
		return nil
	}
	return c.EmailAddress
}

func (c *Contact) GetTaxNumber() *string {
	if c == nil {
		return nil
	}
	return c.TaxNumber
}

func (c *Contact) GetStatus() *Status7D1Enum {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *Contact) GetCurrency() *string {
	if c == nil {
		return nil
	}
	return c.Currency
}

func (c *Contact) GetRemoteUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.RemoteUpdatedAt
}

func (c *Contact) GetCompany() *string {
	if c == nil {
		return nil
	}
	return c.Company
}

func (c *Contact) GetAddresses() []*ContactAddressesItem {
	if c == nil {
		return nil
	}
	return c.Addresses
}

func (c *Contact) GetPhoneNumbers() []*AccountingPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumbers
}

func (c *Contact) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *Contact) GetFieldMappings() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FieldMappings
}

func (c *Contact) GetRemoteData() []*RemoteData {
	if c == nil {
		return nil
	}
	return c.RemoteData
}

func (c *Contact) GetRemoteFields() []*RemoteField {
	if c == nil {
		return nil
	}
	return c.RemoteFields
}

func (c *Contact) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Contact) UnmarshalJSON(data []byte) error {
	type embed Contact
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Contact(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	c.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Contact) MarshalJSON() ([]byte, error) {
	type embed Contact
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*c),
		CreatedAt:       internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(c.ModifiedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(c.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Contact) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContactAddressesItem struct {
	String  string
	Address *Address

	typ string
}

func (c *ContactAddressesItem) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *ContactAddressesItem) GetAddress() *Address {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *ContactAddressesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueAddress := new(Address)
	if err := json.Unmarshal(data, &valueAddress); err == nil {
		c.typ = "Address"
		c.Address = valueAddress
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ContactAddressesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Address" || c.Address != nil {
		return json.Marshal(c.Address)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ContactAddressesItemVisitor interface {
	VisitString(string) error
	VisitAddress(*Address) error
}

func (c *ContactAddressesItem) Accept(visitor ContactAddressesItemVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Address" || c.Address != nil {
		return visitor.VisitAddress(c.Address)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// * `AF` - Afghanistan
// * `AX` - Åland Islands
// * `AL` - Albania
// * `DZ` - Algeria
// * `AS` - American Samoa
// * `AD` - Andorra
// * `AO` - Angola
// * `AI` - Anguilla
// * `AQ` - Antarctica
// * `AG` - Antigua and Barbuda
// * `AR` - Argentina
// * `AM` - Armenia
// * `AW` - Aruba
// * `AU` - Australia
// * `AT` - Austria
// * `AZ` - Azerbaijan
// * `BS` - Bahamas
// * `BH` - Bahrain
// * `BD` - Bangladesh
// * `BB` - Barbados
// * `BY` - Belarus
// * `BE` - Belgium
// * `BZ` - Belize
// * `BJ` - Benin
// * `BM` - Bermuda
// * `BT` - Bhutan
// * `BO` - Bolivia
// * `BQ` - Bonaire, Sint Eustatius and Saba
// * `BA` - Bosnia and Herzegovina
// * `BW` - Botswana
// * `BV` - Bouvet Island
// * `BR` - Brazil
// * `IO` - British Indian Ocean Territory
// * `BN` - Brunei
// * `BG` - Bulgaria
// * `BF` - Burkina Faso
// * `BI` - Burundi
// * `CV` - Cabo Verde
// * `KH` - Cambodia
// * `CM` - Cameroon
// * `CA` - Canada
// * `KY` - Cayman Islands
// * `CF` - Central African Republic
// * `TD` - Chad
// * `CL` - Chile
// * `CN` - China
// * `CX` - Christmas Island
// * `CC` - Cocos (Keeling) Islands
// * `CO` - Colombia
// * `KM` - Comoros
// * `CG` - Congo
// * `CD` - Congo (the Democratic Republic of the)
// * `CK` - Cook Islands
// * `CR` - Costa Rica
// * `CI` - Côte d'Ivoire
// * `HR` - Croatia
// * `CU` - Cuba
// * `CW` - Curaçao
// * `CY` - Cyprus
// * `CZ` - Czechia
// * `DK` - Denmark
// * `DJ` - Djibouti
// * `DM` - Dominica
// * `DO` - Dominican Republic
// * `EC` - Ecuador
// * `EG` - Egypt
// * `SV` - El Salvador
// * `GQ` - Equatorial Guinea
// * `ER` - Eritrea
// * `EE` - Estonia
// * `SZ` - Eswatini
// * `ET` - Ethiopia
// * `FK` - Falkland Islands (Malvinas)
// * `FO` - Faroe Islands
// * `FJ` - Fiji
// * `FI` - Finland
// * `FR` - France
// * `GF` - French Guiana
// * `PF` - French Polynesia
// * `TF` - French Southern Territories
// * `GA` - Gabon
// * `GM` - Gambia
// * `GE` - Georgia
// * `DE` - Germany
// * `GH` - Ghana
// * `GI` - Gibraltar
// * `GR` - Greece
// * `GL` - Greenland
// * `GD` - Grenada
// * `GP` - Guadeloupe
// * `GU` - Guam
// * `GT` - Guatemala
// * `GG` - Guernsey
// * `GN` - Guinea
// * `GW` - Guinea-Bissau
// * `GY` - Guyana
// * `HT` - Haiti
// * `HM` - Heard Island and McDonald Islands
// * `VA` - Holy See
// * `HN` - Honduras
// * `HK` - Hong Kong
// * `HU` - Hungary
// * `IS` - Iceland
// * `IN` - India
// * `ID` - Indonesia
// * `IR` - Iran
// * `IQ` - Iraq
// * `IE` - Ireland
// * `IM` - Isle of Man
// * `IL` - Israel
// * `IT` - Italy
// * `JM` - Jamaica
// * `JP` - Japan
// * `JE` - Jersey
// * `JO` - Jordan
// * `KZ` - Kazakhstan
// * `KE` - Kenya
// * `KI` - Kiribati
// * `KW` - Kuwait
// * `KG` - Kyrgyzstan
// * `LA` - Laos
// * `LV` - Latvia
// * `LB` - Lebanon
// * `LS` - Lesotho
// * `LR` - Liberia
// * `LY` - Libya
// * `LI` - Liechtenstein
// * `LT` - Lithuania
// * `LU` - Luxembourg
// * `MO` - Macao
// * `MG` - Madagascar
// * `MW` - Malawi
// * `MY` - Malaysia
// * `MV` - Maldives
// * `ML` - Mali
// * `MT` - Malta
// * `MH` - Marshall Islands
// * `MQ` - Martinique
// * `MR` - Mauritania
// * `MU` - Mauritius
// * `YT` - Mayotte
// * `MX` - Mexico
// * `FM` - Micronesia (Federated States of)
// * `MD` - Moldova
// * `MC` - Monaco
// * `MN` - Mongolia
// * `ME` - Montenegro
// * `MS` - Montserrat
// * `MA` - Morocco
// * `MZ` - Mozambique
// * `MM` - Myanmar
// * `NA` - Namibia
// * `NR` - Nauru
// * `NP` - Nepal
// * `NL` - Netherlands
// * `NC` - New Caledonia
// * `NZ` - New Zealand
// * `NI` - Nicaragua
// * `NE` - Niger
// * `NG` - Nigeria
// * `NU` - Niue
// * `NF` - Norfolk Island
// * `KP` - North Korea
// * `MK` - North Macedonia
// * `MP` - Northern Mariana Islands
// * `NO` - Norway
// * `OM` - Oman
// * `PK` - Pakistan
// * `PW` - Palau
// * `PS` - Palestine, State of
// * `PA` - Panama
// * `PG` - Papua New Guinea
// * `PY` - Paraguay
// * `PE` - Peru
// * `PH` - Philippines
// * `PN` - Pitcairn
// * `PL` - Poland
// * `PT` - Portugal
// * `PR` - Puerto Rico
// * `QA` - Qatar
// * `RE` - Réunion
// * `RO` - Romania
// * `RU` - Russia
// * `RW` - Rwanda
// * `BL` - Saint Barthélemy
// * `SH` - Saint Helena, Ascension and Tristan da Cunha
// * `KN` - Saint Kitts and Nevis
// * `LC` - Saint Lucia
// * `MF` - Saint Martin (French part)
// * `PM` - Saint Pierre and Miquelon
// * `VC` - Saint Vincent and the Grenadines
// * `WS` - Samoa
// * `SM` - San Marino
// * `ST` - Sao Tome and Principe
// * `SA` - Saudi Arabia
// * `SN` - Senegal
// * `RS` - Serbia
// * `SC` - Seychelles
// * `SL` - Sierra Leone
// * `SG` - Singapore
// * `SX` - Sint Maarten (Dutch part)
// * `SK` - Slovakia
// * `SI` - Slovenia
// * `SB` - Solomon Islands
// * `SO` - Somalia
// * `ZA` - South Africa
// * `GS` - South Georgia and the South Sandwich Islands
// * `KR` - South Korea
// * `SS` - South Sudan
// * `ES` - Spain
// * `LK` - Sri Lanka
// * `SD` - Sudan
// * `SR` - Suriname
// * `SJ` - Svalbard and Jan Mayen
// * `SE` - Sweden
// * `CH` - Switzerland
// * `SY` - Syria
// * `TW` - Taiwan
// * `TJ` - Tajikistan
// * `TZ` - Tanzania
// * `TH` - Thailand
// * `TL` - Timor-Leste
// * `TG` - Togo
// * `TK` - Tokelau
// * `TO` - Tonga
// * `TT` - Trinidad and Tobago
// * `TN` - Tunisia
// * `TR` - Turkey
// * `TM` - Turkmenistan
// * `TC` - Turks and Caicos Islands
// * `TV` - Tuvalu
// * `UG` - Uganda
// * `UA` - Ukraine
// * `AE` - United Arab Emirates
// * `GB` - United Kingdom
// * `UM` - United States Minor Outlying Islands
// * `US` - United States of America
// * `UY` - Uruguay
// * `UZ` - Uzbekistan
// * `VU` - Vanuatu
// * `VE` - Venezuela
// * `VN` - Vietnam
// * `VG` - Virgin Islands (British)
// * `VI` - Virgin Islands (U.S.)
// * `WF` - Wallis and Futuna
// * `EH` - Western Sahara
// * `YE` - Yemen
// * `ZM` - Zambia
// * `ZW` - Zimbabwe
type CountryEnum string

const (
	CountryEnumAf CountryEnum = "AF"
	CountryEnumAx CountryEnum = "AX"
	CountryEnumAl CountryEnum = "AL"
	CountryEnumDz CountryEnum = "DZ"
	CountryEnumAs CountryEnum = "AS"
	CountryEnumAd CountryEnum = "AD"
	CountryEnumAo CountryEnum = "AO"
	CountryEnumAi CountryEnum = "AI"
	CountryEnumAq CountryEnum = "AQ"
	CountryEnumAg CountryEnum = "AG"
	CountryEnumAr CountryEnum = "AR"
	CountryEnumAm CountryEnum = "AM"
	CountryEnumAw CountryEnum = "AW"
	CountryEnumAu CountryEnum = "AU"
	CountryEnumAt CountryEnum = "AT"
	CountryEnumAz CountryEnum = "AZ"
	CountryEnumBs CountryEnum = "BS"
	CountryEnumBh CountryEnum = "BH"
	CountryEnumBd CountryEnum = "BD"
	CountryEnumBb CountryEnum = "BB"
	CountryEnumBy CountryEnum = "BY"
	CountryEnumBe CountryEnum = "BE"
	CountryEnumBz CountryEnum = "BZ"
	CountryEnumBj CountryEnum = "BJ"
	CountryEnumBm CountryEnum = "BM"
	CountryEnumBt CountryEnum = "BT"
	CountryEnumBo CountryEnum = "BO"
	CountryEnumBq CountryEnum = "BQ"
	CountryEnumBa CountryEnum = "BA"
	CountryEnumBw CountryEnum = "BW"
	CountryEnumBv CountryEnum = "BV"
	CountryEnumBr CountryEnum = "BR"
	CountryEnumIo CountryEnum = "IO"
	CountryEnumBn CountryEnum = "BN"
	CountryEnumBg CountryEnum = "BG"
	CountryEnumBf CountryEnum = "BF"
	CountryEnumBi CountryEnum = "BI"
	CountryEnumCv CountryEnum = "CV"
	CountryEnumKh CountryEnum = "KH"
	CountryEnumCm CountryEnum = "CM"
	CountryEnumCa CountryEnum = "CA"
	CountryEnumKy CountryEnum = "KY"
	CountryEnumCf CountryEnum = "CF"
	CountryEnumTd CountryEnum = "TD"
	CountryEnumCl CountryEnum = "CL"
	CountryEnumCn CountryEnum = "CN"
	CountryEnumCx CountryEnum = "CX"
	CountryEnumCc CountryEnum = "CC"
	CountryEnumCo CountryEnum = "CO"
	CountryEnumKm CountryEnum = "KM"
	CountryEnumCg CountryEnum = "CG"
	CountryEnumCd CountryEnum = "CD"
	CountryEnumCk CountryEnum = "CK"
	CountryEnumCr CountryEnum = "CR"
	CountryEnumCi CountryEnum = "CI"
	CountryEnumHr CountryEnum = "HR"
	CountryEnumCu CountryEnum = "CU"
	CountryEnumCw CountryEnum = "CW"
	CountryEnumCy CountryEnum = "CY"
	CountryEnumCz CountryEnum = "CZ"
	CountryEnumDk CountryEnum = "DK"
	CountryEnumDj CountryEnum = "DJ"
	CountryEnumDm CountryEnum = "DM"
	CountryEnumDo CountryEnum = "DO"
	CountryEnumEc CountryEnum = "EC"
	CountryEnumEg CountryEnum = "EG"
	CountryEnumSv CountryEnum = "SV"
	CountryEnumGq CountryEnum = "GQ"
	CountryEnumEr CountryEnum = "ER"
	CountryEnumEe CountryEnum = "EE"
	CountryEnumSz CountryEnum = "SZ"
	CountryEnumEt CountryEnum = "ET"
	CountryEnumFk CountryEnum = "FK"
	CountryEnumFo CountryEnum = "FO"
	CountryEnumFj CountryEnum = "FJ"
	CountryEnumFi CountryEnum = "FI"
	CountryEnumFr CountryEnum = "FR"
	CountryEnumGf CountryEnum = "GF"
	CountryEnumPf CountryEnum = "PF"
	CountryEnumTf CountryEnum = "TF"
	CountryEnumGa CountryEnum = "GA"
	CountryEnumGm CountryEnum = "GM"
	CountryEnumGe CountryEnum = "GE"
	CountryEnumDe CountryEnum = "DE"
	CountryEnumGh CountryEnum = "GH"
	CountryEnumGi CountryEnum = "GI"
	CountryEnumGr CountryEnum = "GR"
	CountryEnumGl CountryEnum = "GL"
	CountryEnumGd CountryEnum = "GD"
	CountryEnumGp CountryEnum = "GP"
	CountryEnumGu CountryEnum = "GU"
	CountryEnumGt CountryEnum = "GT"
	CountryEnumGg CountryEnum = "GG"
	CountryEnumGn CountryEnum = "GN"
	CountryEnumGw CountryEnum = "GW"
	CountryEnumGy CountryEnum = "GY"
	CountryEnumHt CountryEnum = "HT"
	CountryEnumHm CountryEnum = "HM"
	CountryEnumVa CountryEnum = "VA"
	CountryEnumHn CountryEnum = "HN"
	CountryEnumHk CountryEnum = "HK"
	CountryEnumHu CountryEnum = "HU"
	CountryEnumIs CountryEnum = "IS"
	CountryEnumIn CountryEnum = "IN"
	CountryEnumId CountryEnum = "ID"
	CountryEnumIr CountryEnum = "IR"
	CountryEnumIq CountryEnum = "IQ"
	CountryEnumIe CountryEnum = "IE"
	CountryEnumIm CountryEnum = "IM"
	CountryEnumIl CountryEnum = "IL"
	CountryEnumIt CountryEnum = "IT"
	CountryEnumJm CountryEnum = "JM"
	CountryEnumJp CountryEnum = "JP"
	CountryEnumJe CountryEnum = "JE"
	CountryEnumJo CountryEnum = "JO"
	CountryEnumKz CountryEnum = "KZ"
	CountryEnumKe CountryEnum = "KE"
	CountryEnumKi CountryEnum = "KI"
	CountryEnumKw CountryEnum = "KW"
	CountryEnumKg CountryEnum = "KG"
	CountryEnumLa CountryEnum = "LA"
	CountryEnumLv CountryEnum = "LV"
	CountryEnumLb CountryEnum = "LB"
	CountryEnumLs CountryEnum = "LS"
	CountryEnumLr CountryEnum = "LR"
	CountryEnumLy CountryEnum = "LY"
	CountryEnumLi CountryEnum = "LI"
	CountryEnumLt CountryEnum = "LT"
	CountryEnumLu CountryEnum = "LU"
	CountryEnumMo CountryEnum = "MO"
	CountryEnumMg CountryEnum = "MG"
	CountryEnumMw CountryEnum = "MW"
	CountryEnumMy CountryEnum = "MY"
	CountryEnumMv CountryEnum = "MV"
	CountryEnumMl CountryEnum = "ML"
	CountryEnumMt CountryEnum = "MT"
	CountryEnumMh CountryEnum = "MH"
	CountryEnumMq CountryEnum = "MQ"
	CountryEnumMr CountryEnum = "MR"
	CountryEnumMu CountryEnum = "MU"
	CountryEnumYt CountryEnum = "YT"
	CountryEnumMx CountryEnum = "MX"
	CountryEnumFm CountryEnum = "FM"
	CountryEnumMd CountryEnum = "MD"
	CountryEnumMc CountryEnum = "MC"
	CountryEnumMn CountryEnum = "MN"
	CountryEnumMe CountryEnum = "ME"
	CountryEnumMs CountryEnum = "MS"
	CountryEnumMa CountryEnum = "MA"
	CountryEnumMz CountryEnum = "MZ"
	CountryEnumMm CountryEnum = "MM"
	CountryEnumNa CountryEnum = "NA"
	CountryEnumNr CountryEnum = "NR"
	CountryEnumNp CountryEnum = "NP"
	CountryEnumNl CountryEnum = "NL"
	CountryEnumNc CountryEnum = "NC"
	CountryEnumNz CountryEnum = "NZ"
	CountryEnumNi CountryEnum = "NI"
	CountryEnumNe CountryEnum = "NE"
	CountryEnumNg CountryEnum = "NG"
	CountryEnumNu CountryEnum = "NU"
	CountryEnumNf CountryEnum = "NF"
	CountryEnumKp CountryEnum = "KP"
	CountryEnumMk CountryEnum = "MK"
	CountryEnumMp CountryEnum = "MP"
	CountryEnumNo CountryEnum = "NO"
	CountryEnumOm CountryEnum = "OM"
	CountryEnumPk CountryEnum = "PK"
	CountryEnumPw CountryEnum = "PW"
	CountryEnumPs CountryEnum = "PS"
	CountryEnumPa CountryEnum = "PA"
	CountryEnumPg CountryEnum = "PG"
	CountryEnumPy CountryEnum = "PY"
	CountryEnumPe CountryEnum = "PE"
	CountryEnumPh CountryEnum = "PH"
	CountryEnumPn CountryEnum = "PN"
	CountryEnumPl CountryEnum = "PL"
	CountryEnumPt CountryEnum = "PT"
	CountryEnumPr CountryEnum = "PR"
	CountryEnumQa CountryEnum = "QA"
	CountryEnumRe CountryEnum = "RE"
	CountryEnumRo CountryEnum = "RO"
	CountryEnumRu CountryEnum = "RU"
	CountryEnumRw CountryEnum = "RW"
	CountryEnumBl CountryEnum = "BL"
	CountryEnumSh CountryEnum = "SH"
	CountryEnumKn CountryEnum = "KN"
	CountryEnumLc CountryEnum = "LC"
	CountryEnumMf CountryEnum = "MF"
	CountryEnumPm CountryEnum = "PM"
	CountryEnumVc CountryEnum = "VC"
	CountryEnumWs CountryEnum = "WS"
	CountryEnumSm CountryEnum = "SM"
	CountryEnumSt CountryEnum = "ST"
	CountryEnumSa CountryEnum = "SA"
	CountryEnumSn CountryEnum = "SN"
	CountryEnumRs CountryEnum = "RS"
	CountryEnumSc CountryEnum = "SC"
	CountryEnumSl CountryEnum = "SL"
	CountryEnumSg CountryEnum = "SG"
	CountryEnumSx CountryEnum = "SX"
	CountryEnumSk CountryEnum = "SK"
	CountryEnumSi CountryEnum = "SI"
	CountryEnumSb CountryEnum = "SB"
	CountryEnumSo CountryEnum = "SO"
	CountryEnumZa CountryEnum = "ZA"
	CountryEnumGs CountryEnum = "GS"
	CountryEnumKr CountryEnum = "KR"
	CountryEnumSs CountryEnum = "SS"
	CountryEnumEs CountryEnum = "ES"
	CountryEnumLk CountryEnum = "LK"
	CountryEnumSd CountryEnum = "SD"
	CountryEnumSr CountryEnum = "SR"
	CountryEnumSj CountryEnum = "SJ"
	CountryEnumSe CountryEnum = "SE"
	CountryEnumCh CountryEnum = "CH"
	CountryEnumSy CountryEnum = "SY"
	CountryEnumTw CountryEnum = "TW"
	CountryEnumTj CountryEnum = "TJ"
	CountryEnumTz CountryEnum = "TZ"
	CountryEnumTh CountryEnum = "TH"
	CountryEnumTl CountryEnum = "TL"
	CountryEnumTg CountryEnum = "TG"
	CountryEnumTk CountryEnum = "TK"
	CountryEnumTo CountryEnum = "TO"
	CountryEnumTt CountryEnum = "TT"
	CountryEnumTn CountryEnum = "TN"
	CountryEnumTr CountryEnum = "TR"
	CountryEnumTm CountryEnum = "TM"
	CountryEnumTc CountryEnum = "TC"
	CountryEnumTv CountryEnum = "TV"
	CountryEnumUg CountryEnum = "UG"
	CountryEnumUa CountryEnum = "UA"
	CountryEnumAe CountryEnum = "AE"
	CountryEnumGb CountryEnum = "GB"
	CountryEnumUm CountryEnum = "UM"
	CountryEnumUs CountryEnum = "US"
	CountryEnumUy CountryEnum = "UY"
	CountryEnumUz CountryEnum = "UZ"
	CountryEnumVu CountryEnum = "VU"
	CountryEnumVe CountryEnum = "VE"
	CountryEnumVn CountryEnum = "VN"
	CountryEnumVg CountryEnum = "VG"
	CountryEnumVi CountryEnum = "VI"
	CountryEnumWf CountryEnum = "WF"
	CountryEnumEh CountryEnum = "EH"
	CountryEnumYe CountryEnum = "YE"
	CountryEnumZm CountryEnum = "ZM"
	CountryEnumZw CountryEnum = "ZW"
)

func NewCountryEnumFromString(s string) (CountryEnum, error) {
	switch s {
	case "AF":
		return CountryEnumAf, nil
	case "AX":
		return CountryEnumAx, nil
	case "AL":
		return CountryEnumAl, nil
	case "DZ":
		return CountryEnumDz, nil
	case "AS":
		return CountryEnumAs, nil
	case "AD":
		return CountryEnumAd, nil
	case "AO":
		return CountryEnumAo, nil
	case "AI":
		return CountryEnumAi, nil
	case "AQ":
		return CountryEnumAq, nil
	case "AG":
		return CountryEnumAg, nil
	case "AR":
		return CountryEnumAr, nil
	case "AM":
		return CountryEnumAm, nil
	case "AW":
		return CountryEnumAw, nil
	case "AU":
		return CountryEnumAu, nil
	case "AT":
		return CountryEnumAt, nil
	case "AZ":
		return CountryEnumAz, nil
	case "BS":
		return CountryEnumBs, nil
	case "BH":
		return CountryEnumBh, nil
	case "BD":
		return CountryEnumBd, nil
	case "BB":
		return CountryEnumBb, nil
	case "BY":
		return CountryEnumBy, nil
	case "BE":
		return CountryEnumBe, nil
	case "BZ":
		return CountryEnumBz, nil
	case "BJ":
		return CountryEnumBj, nil
	case "BM":
		return CountryEnumBm, nil
	case "BT":
		return CountryEnumBt, nil
	case "BO":
		return CountryEnumBo, nil
	case "BQ":
		return CountryEnumBq, nil
	case "BA":
		return CountryEnumBa, nil
	case "BW":
		return CountryEnumBw, nil
	case "BV":
		return CountryEnumBv, nil
	case "BR":
		return CountryEnumBr, nil
	case "IO":
		return CountryEnumIo, nil
	case "BN":
		return CountryEnumBn, nil
	case "BG":
		return CountryEnumBg, nil
	case "BF":
		return CountryEnumBf, nil
	case "BI":
		return CountryEnumBi, nil
	case "CV":
		return CountryEnumCv, nil
	case "KH":
		return CountryEnumKh, nil
	case "CM":
		return CountryEnumCm, nil
	case "CA":
		return CountryEnumCa, nil
	case "KY":
		return CountryEnumKy, nil
	case "CF":
		return CountryEnumCf, nil
	case "TD":
		return CountryEnumTd, nil
	case "CL":
		return CountryEnumCl, nil
	case "CN":
		return CountryEnumCn, nil
	case "CX":
		return CountryEnumCx, nil
	case "CC":
		return CountryEnumCc, nil
	case "CO":
		return CountryEnumCo, nil
	case "KM":
		return CountryEnumKm, nil
	case "CG":
		return CountryEnumCg, nil
	case "CD":
		return CountryEnumCd, nil
	case "CK":
		return CountryEnumCk, nil
	case "CR":
		return CountryEnumCr, nil
	case "CI":
		return CountryEnumCi, nil
	case "HR":
		return CountryEnumHr, nil
	case "CU":
		return CountryEnumCu, nil
	case "CW":
		return CountryEnumCw, nil
	case "CY":
		return CountryEnumCy, nil
	case "CZ":
		return CountryEnumCz, nil
	case "DK":
		return CountryEnumDk, nil
	case "DJ":
		return CountryEnumDj, nil
	case "DM":
		return CountryEnumDm, nil
	case "DO":
		return CountryEnumDo, nil
	case "EC":
		return CountryEnumEc, nil
	case "EG":
		return CountryEnumEg, nil
	case "SV":
		return CountryEnumSv, nil
	case "GQ":
		return CountryEnumGq, nil
	case "ER":
		return CountryEnumEr, nil
	case "EE":
		return CountryEnumEe, nil
	case "SZ":
		return CountryEnumSz, nil
	case "ET":
		return CountryEnumEt, nil
	case "FK":
		return CountryEnumFk, nil
	case "FO":
		return CountryEnumFo, nil
	case "FJ":
		return CountryEnumFj, nil
	case "FI":
		return CountryEnumFi, nil
	case "FR":
		return CountryEnumFr, nil
	case "GF":
		return CountryEnumGf, nil
	case "PF":
		return CountryEnumPf, nil
	case "TF":
		return CountryEnumTf, nil
	case "GA":
		return CountryEnumGa, nil
	case "GM":
		return CountryEnumGm, nil
	case "GE":
		return CountryEnumGe, nil
	case "DE":
		return CountryEnumDe, nil
	case "GH":
		return CountryEnumGh, nil
	case "GI":
		return CountryEnumGi, nil
	case "GR":
		return CountryEnumGr, nil
	case "GL":
		return CountryEnumGl, nil
	case "GD":
		return CountryEnumGd, nil
	case "GP":
		return CountryEnumGp, nil
	case "GU":
		return CountryEnumGu, nil
	case "GT":
		return CountryEnumGt, nil
	case "GG":
		return CountryEnumGg, nil
	case "GN":
		return CountryEnumGn, nil
	case "GW":
		return CountryEnumGw, nil
	case "GY":
		return CountryEnumGy, nil
	case "HT":
		return CountryEnumHt, nil
	case "HM":
		return CountryEnumHm, nil
	case "VA":
		return CountryEnumVa, nil
	case "HN":
		return CountryEnumHn, nil
	case "HK":
		return CountryEnumHk, nil
	case "HU":
		return CountryEnumHu, nil
	case "IS":
		return CountryEnumIs, nil
	case "IN":
		return CountryEnumIn, nil
	case "ID":
		return CountryEnumId, nil
	case "IR":
		return CountryEnumIr, nil
	case "IQ":
		return CountryEnumIq, nil
	case "IE":
		return CountryEnumIe, nil
	case "IM":
		return CountryEnumIm, nil
	case "IL":
		return CountryEnumIl, nil
	case "IT":
		return CountryEnumIt, nil
	case "JM":
		return CountryEnumJm, nil
	case "JP":
		return CountryEnumJp, nil
	case "JE":
		return CountryEnumJe, nil
	case "JO":
		return CountryEnumJo, nil
	case "KZ":
		return CountryEnumKz, nil
	case "KE":
		return CountryEnumKe, nil
	case "KI":
		return CountryEnumKi, nil
	case "KW":
		return CountryEnumKw, nil
	case "KG":
		return CountryEnumKg, nil
	case "LA":
		return CountryEnumLa, nil
	case "LV":
		return CountryEnumLv, nil
	case "LB":
		return CountryEnumLb, nil
	case "LS":
		return CountryEnumLs, nil
	case "LR":
		return CountryEnumLr, nil
	case "LY":
		return CountryEnumLy, nil
	case "LI":
		return CountryEnumLi, nil
	case "LT":
		return CountryEnumLt, nil
	case "LU":
		return CountryEnumLu, nil
	case "MO":
		return CountryEnumMo, nil
	case "MG":
		return CountryEnumMg, nil
	case "MW":
		return CountryEnumMw, nil
	case "MY":
		return CountryEnumMy, nil
	case "MV":
		return CountryEnumMv, nil
	case "ML":
		return CountryEnumMl, nil
	case "MT":
		return CountryEnumMt, nil
	case "MH":
		return CountryEnumMh, nil
	case "MQ":
		return CountryEnumMq, nil
	case "MR":
		return CountryEnumMr, nil
	case "MU":
		return CountryEnumMu, nil
	case "YT":
		return CountryEnumYt, nil
	case "MX":
		return CountryEnumMx, nil
	case "FM":
		return CountryEnumFm, nil
	case "MD":
		return CountryEnumMd, nil
	case "MC":
		return CountryEnumMc, nil
	case "MN":
		return CountryEnumMn, nil
	case "ME":
		return CountryEnumMe, nil
	case "MS":
		return CountryEnumMs, nil
	case "MA":
		return CountryEnumMa, nil
	case "MZ":
		return CountryEnumMz, nil
	case "MM":
		return CountryEnumMm, nil
	case "NA":
		return CountryEnumNa, nil
	case "NR":
		return CountryEnumNr, nil
	case "NP":
		return CountryEnumNp, nil
	case "NL":
		return CountryEnumNl, nil
	case "NC":
		return CountryEnumNc, nil
	case "NZ":
		return CountryEnumNz, nil
	case "NI":
		return CountryEnumNi, nil
	case "NE":
		return CountryEnumNe, nil
	case "NG":
		return CountryEnumNg, nil
	case "NU":
		return CountryEnumNu, nil
	case "NF":
		return CountryEnumNf, nil
	case "KP":
		return CountryEnumKp, nil
	case "MK":
		return CountryEnumMk, nil
	case "MP":
		return CountryEnumMp, nil
	case "NO":
		return CountryEnumNo, nil
	case "OM":
		return CountryEnumOm, nil
	case "PK":
		return CountryEnumPk, nil
	case "PW":
		return CountryEnumPw, nil
	case "PS":
		return CountryEnumPs, nil
	case "PA":
		return CountryEnumPa, nil
	case "PG":
		return CountryEnumPg, nil
	case "PY":
		return CountryEnumPy, nil
	case "PE":
		return CountryEnumPe, nil
	case "PH":
		return CountryEnumPh, nil
	case "PN":
		return CountryEnumPn, nil
	case "PL":
		return CountryEnumPl, nil
	case "PT":
		return CountryEnumPt, nil
	case "PR":
		return CountryEnumPr, nil
	case "QA":
		return CountryEnumQa, nil
	case "RE":
		return CountryEnumRe, nil
	case "RO":
		return CountryEnumRo, nil
	case "RU":
		return CountryEnumRu, nil
	case "RW":
		return CountryEnumRw, nil
	case "BL":
		return CountryEnumBl, nil
	case "SH":
		return CountryEnumSh, nil
	case "KN":
		return CountryEnumKn, nil
	case "LC":
		return CountryEnumLc, nil
	case "MF":
		return CountryEnumMf, nil
	case "PM":
		return CountryEnumPm, nil
	case "VC":
		return CountryEnumVc, nil
	case "WS":
		return CountryEnumWs, nil
	case "SM":
		return CountryEnumSm, nil
	case "ST":
		return CountryEnumSt, nil
	case "SA":
		return CountryEnumSa, nil
	case "SN":
		return CountryEnumSn, nil
	case "RS":
		return CountryEnumRs, nil
	case "SC":
		return CountryEnumSc, nil
	case "SL":
		return CountryEnumSl, nil
	case "SG":
		return CountryEnumSg, nil
	case "SX":
		return CountryEnumSx, nil
	case "SK":
		return CountryEnumSk, nil
	case "SI":
		return CountryEnumSi, nil
	case "SB":
		return CountryEnumSb, nil
	case "SO":
		return CountryEnumSo, nil
	case "ZA":
		return CountryEnumZa, nil
	case "GS":
		return CountryEnumGs, nil
	case "KR":
		return CountryEnumKr, nil
	case "SS":
		return CountryEnumSs, nil
	case "ES":
		return CountryEnumEs, nil
	case "LK":
		return CountryEnumLk, nil
	case "SD":
		return CountryEnumSd, nil
	case "SR":
		return CountryEnumSr, nil
	case "SJ":
		return CountryEnumSj, nil
	case "SE":
		return CountryEnumSe, nil
	case "CH":
		return CountryEnumCh, nil
	case "SY":
		return CountryEnumSy, nil
	case "TW":
		return CountryEnumTw, nil
	case "TJ":
		return CountryEnumTj, nil
	case "TZ":
		return CountryEnumTz, nil
	case "TH":
		return CountryEnumTh, nil
	case "TL":
		return CountryEnumTl, nil
	case "TG":
		return CountryEnumTg, nil
	case "TK":
		return CountryEnumTk, nil
	case "TO":
		return CountryEnumTo, nil
	case "TT":
		return CountryEnumTt, nil
	case "TN":
		return CountryEnumTn, nil
	case "TR":
		return CountryEnumTr, nil
	case "TM":
		return CountryEnumTm, nil
	case "TC":
		return CountryEnumTc, nil
	case "TV":
		return CountryEnumTv, nil
	case "UG":
		return CountryEnumUg, nil
	case "UA":
		return CountryEnumUa, nil
	case "AE":
		return CountryEnumAe, nil
	case "GB":
		return CountryEnumGb, nil
	case "UM":
		return CountryEnumUm, nil
	case "US":
		return CountryEnumUs, nil
	case "UY":
		return CountryEnumUy, nil
	case "UZ":
		return CountryEnumUz, nil
	case "VU":
		return CountryEnumVu, nil
	case "VE":
		return CountryEnumVe, nil
	case "VN":
		return CountryEnumVn, nil
	case "VG":
		return CountryEnumVg, nil
	case "VI":
		return CountryEnumVi, nil
	case "WF":
		return CountryEnumWf, nil
	case "EH":
		return CountryEnumEh, nil
	case "YE":
		return CountryEnumYe, nil
	case "ZM":
		return CountryEnumZm, nil
	case "ZW":
		return CountryEnumZw, nil
	}
	var t CountryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountryEnum) Ptr() *CountryEnum {
	return &c
}

// # The CreditNote Object
// ### Description
// A `CreditNote` is transaction issued to a customer, indicating a reduction or cancellation of the amount owed by the customer. It is most generally used as an adjustment note used to rectify errors, returns, or overpayments related to a sales transaction. A `CreditNote` can be applied to *Accounts Receivable* Invoices to decrease the overall amount of the Invoice.
//
// ### Usage Example
// Fetch from the `LIST CreditNotes` endpoint and view a company's credit notes.
type CreditNote struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The credit note's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty" url:"transaction_date,omitempty"`
	// The credit note's status.
	//
	// * `SUBMITTED` - SUBMITTED
	// * `AUTHORIZED` - AUTHORIZED
	// * `PAID` - PAID
	Status *CreditNoteStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// The credit note's number.
	Number *string `json:"number,omitempty" url:"number,omitempty"`
	// The credit note's contact.
	Contact *CreditNoteContact `json:"contact,omitempty" url:"contact,omitempty"`
	// The company the credit note belongs to.
	Company *CreditNoteCompany `json:"company,omitempty" url:"company,omitempty"`
	// The credit note's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The credit note's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The amount of value remaining in the credit note that the customer can use.
	RemainingCredit *float64 `json:"remaining_credit,omitempty" url:"remaining_credit,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax     *bool                               `json:"inclusive_of_tax,omitempty" url:"inclusive_of_tax,omitempty"`
	LineItems          []*CreditNoteLineItem               `json:"line_items,omitempty" url:"line_items,omitempty"`
	TrackingCategories []*CreditNoteTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The credit note's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// When the third party's credit note was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's credit note was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// Array of `Payment` object IDs
	Payments []*CreditNotePaymentsItem `json:"payments,omitempty" url:"payments,omitempty"`
	// A list of the Payment Applied to Lines common models related to a given Invoice, Credit Note, or Journal Entry.
	AppliedPayments []*CreditNoteAppliedPaymentsItem `json:"applied_payments,omitempty" url:"applied_payments,omitempty"`
	// The accounting period that the CreditNote was generated in.
	AccountingPeriod *CreditNoteAccountingPeriod `json:"accounting_period,omitempty" url:"accounting_period,omitempty"`
	// A list of the CreditNote Applied to Lines common models related to a given Credit Note
	AppliedToLines []*CreditNoteApplyLineForCreditNote `json:"applied_to_lines,omitempty" url:"applied_to_lines,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreditNote) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *CreditNote) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *CreditNote) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CreditNote) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *CreditNote) GetTransactionDate() *time.Time {
	if c == nil {
		return nil
	}
	return c.TransactionDate
}

func (c *CreditNote) GetStatus() *CreditNoteStatusEnum {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CreditNote) GetNumber() *string {
	if c == nil {
		return nil
	}
	return c.Number
}

func (c *CreditNote) GetContact() *CreditNoteContact {
	if c == nil {
		return nil
	}
	return c.Contact
}

func (c *CreditNote) GetCompany() *CreditNoteCompany {
	if c == nil {
		return nil
	}
	return c.Company
}

func (c *CreditNote) GetExchangeRate() *string {
	if c == nil {
		return nil
	}
	return c.ExchangeRate
}

func (c *CreditNote) GetTotalAmount() *float64 {
	if c == nil {
		return nil
	}
	return c.TotalAmount
}

func (c *CreditNote) GetRemainingCredit() *float64 {
	if c == nil {
		return nil
	}
	return c.RemainingCredit
}

func (c *CreditNote) GetInclusiveOfTax() *bool {
	if c == nil {
		return nil
	}
	return c.InclusiveOfTax
}

func (c *CreditNote) GetLineItems() []*CreditNoteLineItem {
	if c == nil {
		return nil
	}
	return c.LineItems
}

func (c *CreditNote) GetTrackingCategories() []*CreditNoteTrackingCategoriesItem {
	if c == nil {
		return nil
	}
	return c.TrackingCategories
}

func (c *CreditNote) GetCurrency() *TransactionCurrencyEnum {
	if c == nil {
		return nil
	}
	return c.Currency
}

func (c *CreditNote) GetRemoteCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.RemoteCreatedAt
}

func (c *CreditNote) GetRemoteUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.RemoteUpdatedAt
}

func (c *CreditNote) GetPayments() []*CreditNotePaymentsItem {
	if c == nil {
		return nil
	}
	return c.Payments
}

func (c *CreditNote) GetAppliedPayments() []*CreditNoteAppliedPaymentsItem {
	if c == nil {
		return nil
	}
	return c.AppliedPayments
}

func (c *CreditNote) GetAccountingPeriod() *CreditNoteAccountingPeriod {
	if c == nil {
		return nil
	}
	return c.AccountingPeriod
}

func (c *CreditNote) GetAppliedToLines() []*CreditNoteApplyLineForCreditNote {
	if c == nil {
		return nil
	}
	return c.AppliedToLines
}

func (c *CreditNote) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *CreditNote) GetFieldMappings() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FieldMappings
}

func (c *CreditNote) GetRemoteData() []*RemoteData {
	if c == nil {
		return nil
	}
	return c.RemoteData
}

func (c *CreditNote) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreditNote) UnmarshalJSON(data []byte) error {
	type embed CreditNote
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreditNote(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	c.TransactionDate = unmarshaler.TransactionDate.TimePtr()
	c.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	c.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNote) MarshalJSON() ([]byte, error) {
	type embed CreditNote
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*c),
		CreatedAt:       internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(c.ModifiedAt),
		TransactionDate: internal.NewOptionalDateTime(c.TransactionDate),
		RemoteCreatedAt: internal.NewOptionalDateTime(c.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(c.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CreditNote) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The accounting period that the CreditNote was generated in.
type CreditNoteAccountingPeriod struct {
	String           string
	AccountingPeriod *AccountingPeriod

	typ string
}

func (c *CreditNoteAccountingPeriod) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteAccountingPeriod) GetAccountingPeriod() *AccountingPeriod {
	if c == nil {
		return nil
	}
	return c.AccountingPeriod
}

func (c *CreditNoteAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		c.typ = "AccountingPeriod"
		c.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteAccountingPeriod) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "AccountingPeriod" || c.AccountingPeriod != nil {
		return json.Marshal(c.AccountingPeriod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (c *CreditNoteAccountingPeriod) Accept(visitor CreditNoteAccountingPeriodVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "AccountingPeriod" || c.AccountingPeriod != nil {
		return visitor.VisitAccountingPeriod(c.AccountingPeriod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteAppliedPaymentsItem struct {
	String          string
	PaymentLineItem *PaymentLineItem

	typ string
}

func (c *CreditNoteAppliedPaymentsItem) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteAppliedPaymentsItem) GetPaymentLineItem() *PaymentLineItem {
	if c == nil {
		return nil
	}
	return c.PaymentLineItem
}

func (c *CreditNoteAppliedPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		c.typ = "PaymentLineItem"
		c.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteAppliedPaymentsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "PaymentLineItem" || c.PaymentLineItem != nil {
		return json.Marshal(c.PaymentLineItem)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteAppliedPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (c *CreditNoteAppliedPaymentsItem) Accept(visitor CreditNoteAppliedPaymentsItemVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "PaymentLineItem" || c.PaymentLineItem != nil {
		return visitor.VisitPaymentLineItem(c.PaymentLineItem)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// # The CreditNoteApplyLine Object
// ### Description
// The `CreditNoteApplyLine` is attached to the CreditNote model.
//
// ### Usage Example
// Fetch from the `GET CreditNote` endpoint and view the invoice's applied to lines.
type CreditNoteApplyLineForCreditNote struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time                               `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	Invoice    *CreditNoteApplyLineForCreditNoteInvoice `json:"invoice,omitempty" url:"invoice,omitempty"`
	// Date that the credit note is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty" url:"applied_date,omitempty"`
	// The amount of the Credit Note applied to the invoice.
	AppliedAmount *string `json:"applied_amount,omitempty" url:"applied_amount,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreditNoteApplyLineForCreditNote) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *CreditNoteApplyLineForCreditNote) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CreditNoteApplyLineForCreditNote) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *CreditNoteApplyLineForCreditNote) GetInvoice() *CreditNoteApplyLineForCreditNoteInvoice {
	if c == nil {
		return nil
	}
	return c.Invoice
}

func (c *CreditNoteApplyLineForCreditNote) GetAppliedDate() *time.Time {
	if c == nil {
		return nil
	}
	return c.AppliedDate
}

func (c *CreditNoteApplyLineForCreditNote) GetAppliedAmount() *string {
	if c == nil {
		return nil
	}
	return c.AppliedAmount
}

func (c *CreditNoteApplyLineForCreditNote) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *CreditNoteApplyLineForCreditNote) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreditNoteApplyLineForCreditNote) UnmarshalJSON(data []byte) error {
	type embed CreditNoteApplyLineForCreditNote
	var unmarshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreditNoteApplyLineForCreditNote(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	c.AppliedDate = unmarshaler.AppliedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteApplyLineForCreditNote) MarshalJSON() ([]byte, error) {
	type embed CreditNoteApplyLineForCreditNote
	var marshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed:       embed(*c),
		CreatedAt:   internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt:  internal.NewOptionalDateTime(c.ModifiedAt),
		AppliedDate: internal.NewOptionalDateTime(c.AppliedDate),
	}
	return json.Marshal(marshaler)
}

func (c *CreditNoteApplyLineForCreditNote) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreditNoteApplyLineForCreditNoteInvoice struct {
	String  string
	Invoice *Invoice

	typ string
}

func (c *CreditNoteApplyLineForCreditNoteInvoice) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteApplyLineForCreditNoteInvoice) GetInvoice() *Invoice {
	if c == nil {
		return nil
	}
	return c.Invoice
}

func (c *CreditNoteApplyLineForCreditNoteInvoice) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueInvoice := new(Invoice)
	if err := json.Unmarshal(data, &valueInvoice); err == nil {
		c.typ = "Invoice"
		c.Invoice = valueInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteApplyLineForCreditNoteInvoice) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Invoice" || c.Invoice != nil {
		return json.Marshal(c.Invoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteApplyLineForCreditNoteInvoiceVisitor interface {
	VisitString(string) error
	VisitInvoice(*Invoice) error
}

func (c *CreditNoteApplyLineForCreditNoteInvoice) Accept(visitor CreditNoteApplyLineForCreditNoteInvoiceVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Invoice" || c.Invoice != nil {
		return visitor.VisitInvoice(c.Invoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// # The CreditNoteApplyLine Object
// ### Description
// The `CreditNoteApplyLine` is attached to the CreditNote model.
//
// ### Usage Example
// Fetch from the `GET CreditNote` endpoint and view the invoice's applied to lines.
type CreditNoteApplyLineForInvoice struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time                               `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	CreditNote *CreditNoteApplyLineForInvoiceCreditNote `json:"credit_note,omitempty" url:"credit_note,omitempty"`
	// Date that the credit note is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty" url:"applied_date,omitempty"`
	// The amount of the Credit Note applied to the invoice.
	AppliedAmount *string `json:"applied_amount,omitempty" url:"applied_amount,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreditNoteApplyLineForInvoice) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *CreditNoteApplyLineForInvoice) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CreditNoteApplyLineForInvoice) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *CreditNoteApplyLineForInvoice) GetCreditNote() *CreditNoteApplyLineForInvoiceCreditNote {
	if c == nil {
		return nil
	}
	return c.CreditNote
}

func (c *CreditNoteApplyLineForInvoice) GetAppliedDate() *time.Time {
	if c == nil {
		return nil
	}
	return c.AppliedDate
}

func (c *CreditNoteApplyLineForInvoice) GetAppliedAmount() *string {
	if c == nil {
		return nil
	}
	return c.AppliedAmount
}

func (c *CreditNoteApplyLineForInvoice) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *CreditNoteApplyLineForInvoice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreditNoteApplyLineForInvoice) UnmarshalJSON(data []byte) error {
	type embed CreditNoteApplyLineForInvoice
	var unmarshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreditNoteApplyLineForInvoice(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	c.AppliedDate = unmarshaler.AppliedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteApplyLineForInvoice) MarshalJSON() ([]byte, error) {
	type embed CreditNoteApplyLineForInvoice
	var marshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed:       embed(*c),
		CreatedAt:   internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt:  internal.NewOptionalDateTime(c.ModifiedAt),
		AppliedDate: internal.NewOptionalDateTime(c.AppliedDate),
	}
	return json.Marshal(marshaler)
}

func (c *CreditNoteApplyLineForInvoice) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreditNoteApplyLineForInvoiceCreditNote struct {
	String     string
	CreditNote *CreditNote

	typ string
}

func (c *CreditNoteApplyLineForInvoiceCreditNote) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteApplyLineForInvoiceCreditNote) GetCreditNote() *CreditNote {
	if c == nil {
		return nil
	}
	return c.CreditNote
}

func (c *CreditNoteApplyLineForInvoiceCreditNote) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueCreditNote := new(CreditNote)
	if err := json.Unmarshal(data, &valueCreditNote); err == nil {
		c.typ = "CreditNote"
		c.CreditNote = valueCreditNote
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteApplyLineForInvoiceCreditNote) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "CreditNote" || c.CreditNote != nil {
		return json.Marshal(c.CreditNote)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteApplyLineForInvoiceCreditNoteVisitor interface {
	VisitString(string) error
	VisitCreditNote(*CreditNote) error
}

func (c *CreditNoteApplyLineForInvoiceCreditNote) Accept(visitor CreditNoteApplyLineForInvoiceCreditNoteVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "CreditNote" || c.CreditNote != nil {
		return visitor.VisitCreditNote(c.CreditNote)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// The company the credit note belongs to.
type CreditNoteCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (c *CreditNoteCompany) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteCompany) GetCompanyInfo() *CompanyInfo {
	if c == nil {
		return nil
	}
	return c.CompanyInfo
}

func (c *CreditNoteCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		c.typ = "CompanyInfo"
		c.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteCompany) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "CompanyInfo" || c.CompanyInfo != nil {
		return json.Marshal(c.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (c *CreditNoteCompany) Accept(visitor CreditNoteCompanyVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "CompanyInfo" || c.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(c.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// The credit note's contact.
type CreditNoteContact struct {
	String  string
	Contact *Contact

	typ string
}

func (c *CreditNoteContact) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteContact) GetContact() *Contact {
	if c == nil {
		return nil
	}
	return c.Contact
}

func (c *CreditNoteContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		c.typ = "Contact"
		c.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteContact) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Contact" || c.Contact != nil {
		return json.Marshal(c.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (c *CreditNoteContact) Accept(visitor CreditNoteContactVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Contact" || c.Contact != nil {
		return visitor.VisitContact(c.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// # The CreditNoteLineItem Object
// ### Description
// The `CreditNoteLineItem` object is used to represent a credit note's line items.
//
// ### Usage Example
// Fetch from the `GET CreditNote` endpoint and view the credit note's line items.
type CreditNoteLineItem struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time              `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	Item       *CreditNoteLineItemItem `json:"item,omitempty" url:"item,omitempty"`
	// The credit note line item's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the item that is owed.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The credit note line item's quantity.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The credit note line item's memo.
	Memo *string `json:"memo,omitempty" url:"memo,omitempty"`
	// The credit note line item's unit price.
	UnitPrice *string `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty" url:"tax_rate,omitempty"`
	// The credit note line item's total.
	TotalLineAmount *string `json:"total_line_amount,omitempty" url:"total_line_amount,omitempty"`
	// The credit note line item's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty" url:"tracking_category,omitempty"`
	// The credit note line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The credit note line item's account.
	Account *string `json:"account,omitempty" url:"account,omitempty"`
	// The company the credit note belongs to.
	Company *CreditNoteLineItemCompany `json:"company,omitempty" url:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreditNoteLineItem) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *CreditNoteLineItem) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *CreditNoteLineItem) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CreditNoteLineItem) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *CreditNoteLineItem) GetItem() *CreditNoteLineItemItem {
	if c == nil {
		return nil
	}
	return c.Item
}

func (c *CreditNoteLineItem) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreditNoteLineItem) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreditNoteLineItem) GetQuantity() *string {
	if c == nil {
		return nil
	}
	return c.Quantity
}

func (c *CreditNoteLineItem) GetMemo() *string {
	if c == nil {
		return nil
	}
	return c.Memo
}

func (c *CreditNoteLineItem) GetUnitPrice() *string {
	if c == nil {
		return nil
	}
	return c.UnitPrice
}

func (c *CreditNoteLineItem) GetTaxRate() *string {
	if c == nil {
		return nil
	}
	return c.TaxRate
}

func (c *CreditNoteLineItem) GetTotalLineAmount() *string {
	if c == nil {
		return nil
	}
	return c.TotalLineAmount
}

func (c *CreditNoteLineItem) GetTrackingCategory() *string {
	if c == nil {
		return nil
	}
	return c.TrackingCategory
}

func (c *CreditNoteLineItem) GetTrackingCategories() []*string {
	if c == nil {
		return nil
	}
	return c.TrackingCategories
}

func (c *CreditNoteLineItem) GetAccount() *string {
	if c == nil {
		return nil
	}
	return c.Account
}

func (c *CreditNoteLineItem) GetCompany() *CreditNoteLineItemCompany {
	if c == nil {
		return nil
	}
	return c.Company
}

func (c *CreditNoteLineItem) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *CreditNoteLineItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreditNoteLineItem) UnmarshalJSON(data []byte) error {
	type embed CreditNoteLineItem
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreditNoteLineItem(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreditNoteLineItem) MarshalJSON() ([]byte, error) {
	type embed CreditNoteLineItem
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*c),
		CreatedAt:  internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(c.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CreditNoteLineItem) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The company the credit note belongs to.
type CreditNoteLineItemCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (c *CreditNoteLineItemCompany) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteLineItemCompany) GetCompanyInfo() *CompanyInfo {
	if c == nil {
		return nil
	}
	return c.CompanyInfo
}

func (c *CreditNoteLineItemCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		c.typ = "CompanyInfo"
		c.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteLineItemCompany) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "CompanyInfo" || c.CompanyInfo != nil {
		return json.Marshal(c.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteLineItemCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (c *CreditNoteLineItemCompany) Accept(visitor CreditNoteLineItemCompanyVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "CompanyInfo" || c.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(c.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteLineItemItem struct {
	String string
	Item   *Item

	typ string
}

func (c *CreditNoteLineItemItem) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteLineItemItem) GetItem() *Item {
	if c == nil {
		return nil
	}
	return c.Item
}

func (c *CreditNoteLineItemItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		c.typ = "Item"
		c.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteLineItemItem) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Item" || c.Item != nil {
		return json.Marshal(c.Item)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteLineItemItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (c *CreditNoteLineItemItem) Accept(visitor CreditNoteLineItemItemVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Item" || c.Item != nil {
		return visitor.VisitItem(c.Item)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNotePaymentsItem struct {
	String  string
	Payment *Payment

	typ string
}

func (c *CreditNotePaymentsItem) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNotePaymentsItem) GetPayment() *Payment {
	if c == nil {
		return nil
	}
	return c.Payment
}

func (c *CreditNotePaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		c.typ = "Payment"
		c.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNotePaymentsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Payment" || c.Payment != nil {
		return json.Marshal(c.Payment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNotePaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (c *CreditNotePaymentsItem) Accept(visitor CreditNotePaymentsItemVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Payment" || c.Payment != nil {
		return visitor.VisitPayment(c.Payment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// * `SUBMITTED` - SUBMITTED
// * `AUTHORIZED` - AUTHORIZED
// * `PAID` - PAID
type CreditNoteStatusEnum string

const (
	CreditNoteStatusEnumSubmitted  CreditNoteStatusEnum = "SUBMITTED"
	CreditNoteStatusEnumAuthorized CreditNoteStatusEnum = "AUTHORIZED"
	CreditNoteStatusEnumPaid       CreditNoteStatusEnum = "PAID"
)

func NewCreditNoteStatusEnumFromString(s string) (CreditNoteStatusEnum, error) {
	switch s {
	case "SUBMITTED":
		return CreditNoteStatusEnumSubmitted, nil
	case "AUTHORIZED":
		return CreditNoteStatusEnumAuthorized, nil
	case "PAID":
		return CreditNoteStatusEnumPaid, nil
	}
	var t CreditNoteStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreditNoteStatusEnum) Ptr() *CreditNoteStatusEnum {
	return &c
}

type CreditNoteTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (c *CreditNoteTrackingCategoriesItem) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreditNoteTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if c == nil {
		return nil
	}
	return c.TrackingCategory
}

func (c *CreditNoteTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		c.typ = "TrackingCategory"
		c.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreditNoteTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "TrackingCategory" || c.TrackingCategory != nil {
		return json.Marshal(c.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreditNoteTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (c *CreditNoteTrackingCategoriesItem) Accept(visitor CreditNoteTrackingCategoriesItemVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "TrackingCategory" || c.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(c.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// # The DataPassthrough Object
// ### Description
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method" url:"method"`
	// The path of the request in the third party's platform.
	Path string `json:"path" url:"path"`
	// An optional override of the third party's base url for the request.
	BaseUrlOverride *string `json:"base_url_override,omitempty" url:"base_url_override,omitempty"`
	// The data with the request. You must include a `request_format` parameter matching the data's format
	Data *string `json:"data,omitempty" url:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty" url:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`
	RequestFormat *RequestFormatEnum     `json:"request_format,omitempty" url:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty" url:"normalize_response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DataPassthroughRequest) GetMethod() MethodEnum {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DataPassthroughRequest) GetPath() string {
	if d == nil {
		return ""
	}
	return d.Path
}

func (d *DataPassthroughRequest) GetBaseUrlOverride() *string {
	if d == nil {
		return nil
	}
	return d.BaseUrlOverride
}

func (d *DataPassthroughRequest) GetData() *string {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DataPassthroughRequest) GetMultipartFormData() []*MultipartFormFieldRequest {
	if d == nil {
		return nil
	}
	return d.MultipartFormData
}

func (d *DataPassthroughRequest) GetHeaders() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DataPassthroughRequest) GetRequestFormat() *RequestFormatEnum {
	if d == nil {
		return nil
	}
	return d.RequestFormat
}

func (d *DataPassthroughRequest) GetNormalizeResponse() *bool {
	if d == nil {
		return nil
	}
	return d.NormalizeResponse
}

func (d *DataPassthroughRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DataPassthroughRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DataPassthroughRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataPassthroughRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataPassthroughRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModeLog struct {
	LogId         string                `json:"log_id" url:"log_id"`
	DashboardView string                `json:"dashboard_view" url:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary" url:"log_summary"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModeLog) GetLogId() string {
	if d == nil {
		return ""
	}
	return d.LogId
}

func (d *DebugModeLog) GetDashboardView() string {
	if d == nil {
		return ""
	}
	return d.DashboardView
}

func (d *DebugModeLog) GetLogSummary() *DebugModelLogSummary {
	if d == nil {
		return nil
	}
	return d.LogSummary
}

func (d *DebugModeLog) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModeLog) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModeLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModeLog(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModeLog) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModelLogSummary struct {
	Url        string `json:"url" url:"url"`
	Method     string `json:"method" url:"method"`
	StatusCode int    `json:"status_code" url:"status_code"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModelLogSummary) GetUrl() string {
	if d == nil {
		return ""
	}
	return d.Url
}

func (d *DebugModelLogSummary) GetMethod() string {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DebugModelLogSummary) GetStatusCode() int {
	if d == nil {
		return 0
	}
	return d.StatusCode
}

func (d *DebugModelLogSummary) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModelLogSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModelLogSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModelLogSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModelLogSummary) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The Employee Object
// ### Description
// An `Employee` is an individual who works for the company of the linked account. The `Employee` model contains both contractors and full time employees.
// * An `Employee` is a contractor if `is_contractor` property is `True`
// * An `Employee` is a full time employee if `is_contractor` property is `False`
//
// ### Usage Example
// Fetch from the `LIST Employees` endpoint and view a company's employees.
type Employee struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`
	// `True` if the employee is a contractor, `False` if not.
	IsContractor *bool `json:"is_contractor,omitempty" url:"is_contractor,omitempty"`
	// The employee's internal identification number.
	EmployeeNumber *string `json:"employee_number,omitempty" url:"employee_number,omitempty"`
	// The employee's email address.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The subsidiary that the employee belongs to.
	Company *EmployeeCompany `json:"company,omitempty" url:"company,omitempty"`
	// The employee's status in the accounting system.
	//
	// * `ACTIVE` - ACTIVE
	// * `INACTIVE` - INACTIVE
	Status Status895Enum `json:"status" url:"status"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Employee) GetId() *string {
	if e == nil {
		return nil
	}
	return e.Id
}

func (e *Employee) GetRemoteId() *string {
	if e == nil {
		return nil
	}
	return e.RemoteId
}

func (e *Employee) GetCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *Employee) GetModifiedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.ModifiedAt
}

func (e *Employee) GetFirstName() *string {
	if e == nil {
		return nil
	}
	return e.FirstName
}

func (e *Employee) GetLastName() *string {
	if e == nil {
		return nil
	}
	return e.LastName
}

func (e *Employee) GetIsContractor() *bool {
	if e == nil {
		return nil
	}
	return e.IsContractor
}

func (e *Employee) GetEmployeeNumber() *string {
	if e == nil {
		return nil
	}
	return e.EmployeeNumber
}

func (e *Employee) GetEmailAddress() *string {
	if e == nil {
		return nil
	}
	return e.EmailAddress
}

func (e *Employee) GetCompany() *EmployeeCompany {
	if e == nil {
		return nil
	}
	return e.Company
}

func (e *Employee) GetStatus() Status895Enum {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *Employee) GetRemoteWasDeleted() *bool {
	if e == nil {
		return nil
	}
	return e.RemoteWasDeleted
}

func (e *Employee) GetFieldMappings() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.FieldMappings
}

func (e *Employee) GetRemoteData() []*RemoteData {
	if e == nil {
		return nil
	}
	return e.RemoteData
}

func (e *Employee) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Employee) UnmarshalJSON(data []byte) error {
	type embed Employee
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Employee(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	e.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Employee) MarshalJSON() ([]byte, error) {
	type embed Employee
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*e),
		CreatedAt:  internal.NewOptionalDateTime(e.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(e.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (e *Employee) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The subsidiary that the employee belongs to.
type EmployeeCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (e *EmployeeCompany) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EmployeeCompany) GetCompanyInfo() *CompanyInfo {
	if e == nil {
		return nil
	}
	return e.CompanyInfo
}

func (e *EmployeeCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		e.typ = "CompanyInfo"
		e.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EmployeeCompany) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "CompanyInfo" || e.CompanyInfo != nil {
		return json.Marshal(e.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EmployeeCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (e *EmployeeCompany) Accept(visitor EmployeeCompanyVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "CompanyInfo" || e.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(e.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum string

const (
	EncodingEnumRaw        EncodingEnum = "RAW"
	EncodingEnumBase64     EncodingEnum = "BASE64"
	EncodingEnumGzipBase64 EncodingEnum = "GZIP_BASE64"
)

func NewEncodingEnumFromString(s string) (EncodingEnum, error) {
	switch s {
	case "RAW":
		return EncodingEnumRaw, nil
	case "BASE64":
		return EncodingEnumBase64, nil
	case "GZIP_BASE64":
		return EncodingEnumGzipBase64, nil
	}
	var t EncodingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncodingEnum) Ptr() *EncodingEnum {
	return &e
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorValidationProblem) GetSource() *ValidationProblemSource {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *ErrorValidationProblem) GetTitle() string {
	if e == nil {
		return ""
	}
	return e.Title
}

func (e *ErrorValidationProblem) GetDetail() string {
	if e == nil {
		return ""
	}
	return e.Detail
}

func (e *ErrorValidationProblem) GetProblemType() string {
	if e == nil {
		return ""
	}
	return e.ProblemType
}

func (e *ErrorValidationProblem) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorValidationProblem) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// * `ACTIVE` - ACTIVE
// * `INACTIVE` - INACTIVE
type FeedStatusEnum string

const (
	FeedStatusEnumActive   FeedStatusEnum = "ACTIVE"
	FeedStatusEnumInactive FeedStatusEnum = "INACTIVE"
)

func NewFeedStatusEnumFromString(s string) (FeedStatusEnum, error) {
	switch s {
	case "ACTIVE":
		return FeedStatusEnumActive, nil
	case "INACTIVE":
		return FeedStatusEnumInactive, nil
	}
	var t FeedStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FeedStatusEnum) Ptr() *FeedStatusEnum {
	return &f
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type FieldFormatEnum string

const (
	FieldFormatEnumString   FieldFormatEnum = "string"
	FieldFormatEnumNumber   FieldFormatEnum = "number"
	FieldFormatEnumDate     FieldFormatEnum = "date"
	FieldFormatEnumDatetime FieldFormatEnum = "datetime"
	FieldFormatEnumBool     FieldFormatEnum = "bool"
	FieldFormatEnumList     FieldFormatEnum = "list"
)

func NewFieldFormatEnumFromString(s string) (FieldFormatEnum, error) {
	switch s {
	case "string":
		return FieldFormatEnumString, nil
	case "number":
		return FieldFormatEnumNumber, nil
	case "date":
		return FieldFormatEnumDate, nil
	case "datetime":
		return FieldFormatEnumDatetime, nil
	case "bool":
		return FieldFormatEnumBool, nil
	case "list":
		return FieldFormatEnumList, nil
	}
	var t FieldFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldFormatEnum) Ptr() *FieldFormatEnum {
	return &f
}

type FieldPermissionDeserializerRequest struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty" url:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty" url:"disabled_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FieldPermissionDeserializerRequest) GetEnabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.EnabledFields
}

func (f *FieldPermissionDeserializerRequest) GetDisabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.DisabledFields
}

func (f *FieldPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializerRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type FieldTypeEnum string

const (
	FieldTypeEnumString   FieldTypeEnum = "string"
	FieldTypeEnumNumber   FieldTypeEnum = "number"
	FieldTypeEnumDate     FieldTypeEnum = "date"
	FieldTypeEnumDatetime FieldTypeEnum = "datetime"
	FieldTypeEnumBool     FieldTypeEnum = "bool"
	FieldTypeEnumList     FieldTypeEnum = "list"
)

func NewFieldTypeEnumFromString(s string) (FieldTypeEnum, error) {
	switch s {
	case "string":
		return FieldTypeEnumString, nil
	case "number":
		return FieldTypeEnumNumber, nil
	case "date":
		return FieldTypeEnumDate, nil
	case "datetime":
		return FieldTypeEnumDatetime, nil
	case "bool":
		return FieldTypeEnumBool, nil
	case "list":
		return FieldTypeEnumList, nil
	}
	var t FieldTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldTypeEnum) Ptr() *FieldTypeEnum {
	return &f
}

type IndividualCommonModelScopeDeserializerRequest struct {
	ModelName        string                                         `json:"model_name" url:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializerRequest `json:"model_permissions,omitempty" url:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializerRequest            `json:"field_permissions,omitempty" url:"field_permissions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelName() string {
	if i == nil {
		return ""
	}
	return i.ModelName
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelPermissions() map[string]*ModelPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.ModelPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetFieldPermissions() *FieldPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.FieldPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualCommonModelScopeDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializerRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// # The Invoice Object
// ### Description
// The `Invoice` object represents an itemized record of goods and/or services sold to a customer or bought from a vendor.
//
// Represents a Bill when the `Invoice` type is `ACCOUNTS_PAYABLE`. References an Invoice when the `Invoice` type is `ACCOUNTS_RECEIVABLE`.
//
// ### Usage Example
// Fetch from the `LIST Invoices` endpoint and view a company's invoices.
type Invoice struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// Whether the invoice is an accounts receivable or accounts payable. If `type` is `ACCOUNTS_PAYABLE`, the invoice is a bill. If `type` is `ACCOUNTS_RECEIVABLE`, it is an invoice.
	//
	// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	Type *InvoiceTypeEnum `json:"type,omitempty" url:"type,omitempty"`
	// The invoice's contact.
	Contact *InvoiceContact `json:"contact,omitempty" url:"contact,omitempty"`
	// The invoice's number.
	Number *string `json:"number,omitempty" url:"number,omitempty"`
	// The invoice's issue date.
	IssueDate *time.Time `json:"issue_date,omitempty" url:"issue_date,omitempty"`
	// The invoice's due date.
	DueDate *time.Time `json:"due_date,omitempty" url:"due_date,omitempty"`
	// The invoice's paid date.
	PaidOnDate *time.Time `json:"paid_on_date,omitempty" url:"paid_on_date,omitempty"`
	// The invoice's private note.
	Memo *string `json:"memo,omitempty" url:"memo,omitempty"`
	// The company the invoice belongs to.
	Company *InvoiceCompany `json:"company,omitempty" url:"company,omitempty"`
	// The employee this overall transaction relates to.
	Employee *InvoiceEmployee `json:"employee,omitempty" url:"employee,omitempty"`
	// The invoice's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// The invoice's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The payment term that applies to this transaction.
	PaymentTerm *InvoicePaymentTerm `json:"payment_term,omitempty" url:"payment_term,omitempty"`
	// The total discounts applied to the total cost.
	TotalDiscount *float64 `json:"total_discount,omitempty" url:"total_discount,omitempty"`
	// The total amount being paid before taxes.
	SubTotal *float64 `json:"sub_total,omitempty" url:"sub_total,omitempty"`
	// The status of the invoice.
	//
	// * `PAID` - PAID
	// * `DRAFT` - DRAFT
	// * `SUBMITTED` - SUBMITTED
	// * `PARTIALLY_PAID` - PARTIALLY_PAID
	// * `OPEN` - OPEN
	// * `VOID` - VOID
	Status *InvoiceStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// The total amount being paid in taxes.
	TotalTaxAmount *float64 `json:"total_tax_amount,omitempty" url:"total_tax_amount,omitempty"`
	// The invoice's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The invoice's remaining balance.
	Balance *float64 `json:"balance,omitempty" url:"balance,omitempty"`
	// When the third party's invoice entry was updated.
	RemoteUpdatedAt    *time.Time                       `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	TrackingCategories []*InvoiceTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The accounting period that the Invoice was generated in.
	AccountingPeriod *InvoiceAccountingPeriod     `json:"accounting_period,omitempty" url:"accounting_period,omitempty"`
	PurchaseOrders   []*InvoicePurchaseOrdersItem `json:"purchase_orders,omitempty" url:"purchase_orders,omitempty"`
	// Array of `Payment` object IDs.
	Payments []*InvoicePaymentsItem `json:"payments,omitempty" url:"payments,omitempty"`
	// A list of the Payment Applied to Lines common models related to a given Invoice, Credit Note, or Journal Entry.
	AppliedPayments []*InvoiceAppliedPaymentsItem `json:"applied_payments,omitempty" url:"applied_payments,omitempty"`
	LineItems       []*InvoiceLineItem            `json:"line_items,omitempty" url:"line_items,omitempty"`
	// `CreditNoteApplyLines` applied to the Invoice.
	AppliedCreditNotes []*InvoiceAppliedCreditNotesItem `json:"applied_credit_notes,omitempty" url:"applied_credit_notes,omitempty"`
	// `VendorCreditApplyLines` applied to the Invoice.
	AppliedVendorCredits []*InvoiceAppliedVendorCreditsItem `json:"applied_vendor_credits,omitempty" url:"applied_vendor_credits,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty" url:"inclusive_of_tax,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Invoice) GetId() *string {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *Invoice) GetRemoteId() *string {
	if i == nil {
		return nil
	}
	return i.RemoteId
}

func (i *Invoice) GetCreatedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *Invoice) GetModifiedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.ModifiedAt
}

func (i *Invoice) GetType() *InvoiceTypeEnum {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *Invoice) GetContact() *InvoiceContact {
	if i == nil {
		return nil
	}
	return i.Contact
}

func (i *Invoice) GetNumber() *string {
	if i == nil {
		return nil
	}
	return i.Number
}

func (i *Invoice) GetIssueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.IssueDate
}

func (i *Invoice) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *Invoice) GetPaidOnDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.PaidOnDate
}

func (i *Invoice) GetMemo() *string {
	if i == nil {
		return nil
	}
	return i.Memo
}

func (i *Invoice) GetCompany() *InvoiceCompany {
	if i == nil {
		return nil
	}
	return i.Company
}

func (i *Invoice) GetEmployee() *InvoiceEmployee {
	if i == nil {
		return nil
	}
	return i.Employee
}

func (i *Invoice) GetCurrency() *TransactionCurrencyEnum {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *Invoice) GetExchangeRate() *string {
	if i == nil {
		return nil
	}
	return i.ExchangeRate
}

func (i *Invoice) GetPaymentTerm() *InvoicePaymentTerm {
	if i == nil {
		return nil
	}
	return i.PaymentTerm
}

func (i *Invoice) GetTotalDiscount() *float64 {
	if i == nil {
		return nil
	}
	return i.TotalDiscount
}

func (i *Invoice) GetSubTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.SubTotal
}

func (i *Invoice) GetStatus() *InvoiceStatusEnum {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *Invoice) GetTotalTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TotalTaxAmount
}

func (i *Invoice) GetTotalAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TotalAmount
}

func (i *Invoice) GetBalance() *float64 {
	if i == nil {
		return nil
	}
	return i.Balance
}

func (i *Invoice) GetRemoteUpdatedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.RemoteUpdatedAt
}

func (i *Invoice) GetTrackingCategories() []*InvoiceTrackingCategoriesItem {
	if i == nil {
		return nil
	}
	return i.TrackingCategories
}

func (i *Invoice) GetAccountingPeriod() *InvoiceAccountingPeriod {
	if i == nil {
		return nil
	}
	return i.AccountingPeriod
}

func (i *Invoice) GetPurchaseOrders() []*InvoicePurchaseOrdersItem {
	if i == nil {
		return nil
	}
	return i.PurchaseOrders
}

func (i *Invoice) GetPayments() []*InvoicePaymentsItem {
	if i == nil {
		return nil
	}
	return i.Payments
}

func (i *Invoice) GetAppliedPayments() []*InvoiceAppliedPaymentsItem {
	if i == nil {
		return nil
	}
	return i.AppliedPayments
}

func (i *Invoice) GetLineItems() []*InvoiceLineItem {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *Invoice) GetAppliedCreditNotes() []*InvoiceAppliedCreditNotesItem {
	if i == nil {
		return nil
	}
	return i.AppliedCreditNotes
}

func (i *Invoice) GetAppliedVendorCredits() []*InvoiceAppliedVendorCreditsItem {
	if i == nil {
		return nil
	}
	return i.AppliedVendorCredits
}

func (i *Invoice) GetInclusiveOfTax() *bool {
	if i == nil {
		return nil
	}
	return i.InclusiveOfTax
}

func (i *Invoice) GetRemoteWasDeleted() *bool {
	if i == nil {
		return nil
	}
	return i.RemoteWasDeleted
}

func (i *Invoice) GetFieldMappings() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.FieldMappings
}

func (i *Invoice) GetRemoteData() []*RemoteData {
	if i == nil {
		return nil
	}
	return i.RemoteData
}

func (i *Invoice) GetRemoteFields() []*RemoteField {
	if i == nil {
		return nil
	}
	return i.RemoteFields
}

func (i *Invoice) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Invoice) UnmarshalJSON(data []byte) error {
	type embed Invoice
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		IssueDate       *internal.DateTime `json:"issue_date,omitempty"`
		DueDate         *internal.DateTime `json:"due_date,omitempty"`
		PaidOnDate      *internal.DateTime `json:"paid_on_date,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Invoice(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	i.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	i.IssueDate = unmarshaler.IssueDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.PaidOnDate = unmarshaler.PaidOnDate.TimePtr()
	i.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Invoice) MarshalJSON() ([]byte, error) {
	type embed Invoice
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		IssueDate       *internal.DateTime `json:"issue_date,omitempty"`
		DueDate         *internal.DateTime `json:"due_date,omitempty"`
		PaidOnDate      *internal.DateTime `json:"paid_on_date,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*i),
		CreatedAt:       internal.NewOptionalDateTime(i.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(i.ModifiedAt),
		IssueDate:       internal.NewOptionalDateTime(i.IssueDate),
		DueDate:         internal.NewOptionalDateTime(i.DueDate),
		PaidOnDate:      internal.NewOptionalDateTime(i.PaidOnDate),
		RemoteUpdatedAt: internal.NewOptionalDateTime(i.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *Invoice) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The accounting period that the Invoice was generated in.
type InvoiceAccountingPeriod struct {
	String           string
	AccountingPeriod *AccountingPeriod

	typ string
}

func (i *InvoiceAccountingPeriod) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceAccountingPeriod) GetAccountingPeriod() *AccountingPeriod {
	if i == nil {
		return nil
	}
	return i.AccountingPeriod
}

func (i *InvoiceAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		i.typ = "AccountingPeriod"
		i.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceAccountingPeriod) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "AccountingPeriod" || i.AccountingPeriod != nil {
		return json.Marshal(i.AccountingPeriod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (i *InvoiceAccountingPeriod) Accept(visitor InvoiceAccountingPeriodVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "AccountingPeriod" || i.AccountingPeriod != nil {
		return visitor.VisitAccountingPeriod(i.AccountingPeriod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceAppliedCreditNotesItem struct {
	String                        string
	CreditNoteApplyLineForInvoice *CreditNoteApplyLineForInvoice

	typ string
}

func (i *InvoiceAppliedCreditNotesItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceAppliedCreditNotesItem) GetCreditNoteApplyLineForInvoice() *CreditNoteApplyLineForInvoice {
	if i == nil {
		return nil
	}
	return i.CreditNoteApplyLineForInvoice
}

func (i *InvoiceAppliedCreditNotesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueCreditNoteApplyLineForInvoice := new(CreditNoteApplyLineForInvoice)
	if err := json.Unmarshal(data, &valueCreditNoteApplyLineForInvoice); err == nil {
		i.typ = "CreditNoteApplyLineForInvoice"
		i.CreditNoteApplyLineForInvoice = valueCreditNoteApplyLineForInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceAppliedCreditNotesItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "CreditNoteApplyLineForInvoice" || i.CreditNoteApplyLineForInvoice != nil {
		return json.Marshal(i.CreditNoteApplyLineForInvoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceAppliedCreditNotesItemVisitor interface {
	VisitString(string) error
	VisitCreditNoteApplyLineForInvoice(*CreditNoteApplyLineForInvoice) error
}

func (i *InvoiceAppliedCreditNotesItem) Accept(visitor InvoiceAppliedCreditNotesItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "CreditNoteApplyLineForInvoice" || i.CreditNoteApplyLineForInvoice != nil {
		return visitor.VisitCreditNoteApplyLineForInvoice(i.CreditNoteApplyLineForInvoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceAppliedPaymentsItem struct {
	String          string
	PaymentLineItem *PaymentLineItem

	typ string
}

func (i *InvoiceAppliedPaymentsItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceAppliedPaymentsItem) GetPaymentLineItem() *PaymentLineItem {
	if i == nil {
		return nil
	}
	return i.PaymentLineItem
}

func (i *InvoiceAppliedPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		i.typ = "PaymentLineItem"
		i.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceAppliedPaymentsItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "PaymentLineItem" || i.PaymentLineItem != nil {
		return json.Marshal(i.PaymentLineItem)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceAppliedPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (i *InvoiceAppliedPaymentsItem) Accept(visitor InvoiceAppliedPaymentsItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "PaymentLineItem" || i.PaymentLineItem != nil {
		return visitor.VisitPaymentLineItem(i.PaymentLineItem)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceAppliedVendorCreditsItem struct {
	String                          string
	VendorCreditApplyLineForInvoice *VendorCreditApplyLineForInvoice

	typ string
}

func (i *InvoiceAppliedVendorCreditsItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceAppliedVendorCreditsItem) GetVendorCreditApplyLineForInvoice() *VendorCreditApplyLineForInvoice {
	if i == nil {
		return nil
	}
	return i.VendorCreditApplyLineForInvoice
}

func (i *InvoiceAppliedVendorCreditsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueVendorCreditApplyLineForInvoice := new(VendorCreditApplyLineForInvoice)
	if err := json.Unmarshal(data, &valueVendorCreditApplyLineForInvoice); err == nil {
		i.typ = "VendorCreditApplyLineForInvoice"
		i.VendorCreditApplyLineForInvoice = valueVendorCreditApplyLineForInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceAppliedVendorCreditsItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "VendorCreditApplyLineForInvoice" || i.VendorCreditApplyLineForInvoice != nil {
		return json.Marshal(i.VendorCreditApplyLineForInvoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceAppliedVendorCreditsItemVisitor interface {
	VisitString(string) error
	VisitVendorCreditApplyLineForInvoice(*VendorCreditApplyLineForInvoice) error
}

func (i *InvoiceAppliedVendorCreditsItem) Accept(visitor InvoiceAppliedVendorCreditsItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "VendorCreditApplyLineForInvoice" || i.VendorCreditApplyLineForInvoice != nil {
		return visitor.VisitVendorCreditApplyLineForInvoice(i.VendorCreditApplyLineForInvoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The company the invoice belongs to.
type InvoiceCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (i *InvoiceCompany) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceCompany) GetCompanyInfo() *CompanyInfo {
	if i == nil {
		return nil
	}
	return i.CompanyInfo
}

func (i *InvoiceCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		i.typ = "CompanyInfo"
		i.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceCompany) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "CompanyInfo" || i.CompanyInfo != nil {
		return json.Marshal(i.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (i *InvoiceCompany) Accept(visitor InvoiceCompanyVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "CompanyInfo" || i.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(i.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The invoice's contact.
type InvoiceContact struct {
	String  string
	Contact *Contact

	typ string
}

func (i *InvoiceContact) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceContact) GetContact() *Contact {
	if i == nil {
		return nil
	}
	return i.Contact
}

func (i *InvoiceContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		i.typ = "Contact"
		i.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceContact) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Contact" || i.Contact != nil {
		return json.Marshal(i.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (i *InvoiceContact) Accept(visitor InvoiceContactVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Contact" || i.Contact != nil {
		return visitor.VisitContact(i.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The employee this overall transaction relates to.
type InvoiceEmployee struct {
	String   string
	Employee *Employee

	typ string
}

func (i *InvoiceEmployee) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceEmployee) GetEmployee() *Employee {
	if i == nil {
		return nil
	}
	return i.Employee
}

func (i *InvoiceEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		i.typ = "Employee"
		i.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceEmployee) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Employee" || i.Employee != nil {
		return json.Marshal(i.Employee)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (i *InvoiceEmployee) Accept(visitor InvoiceEmployeeVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Employee" || i.Employee != nil {
		return visitor.VisitEmployee(i.Employee)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// # The InvoiceLineItem Object
// ### Description
// The `InvoiceLineItem` object represents an itemized record of goods and/or services sold to a customer.
//
// ### Usage Example
// Fetch from the `GET Invoice` endpoint and view the invoice's line items.
type InvoiceLineItem struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The line item's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The line item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// The line item's quantity.
	Quantity *float64 `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The line item's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The employee this overall transaction relates to.
	Employee *InvoiceLineItemEmployee `json:"employee,omitempty" url:"employee,omitempty"`
	// The line item's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// The line item's exchange rate.
	ExchangeRate *string                 `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	Item         *InvoiceLineItemItem    `json:"item,omitempty" url:"item,omitempty"`
	Account      *InvoiceLineItemAccount `json:"account,omitempty" url:"account,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate          *string                          `json:"tax_rate,omitempty" url:"tax_rate,omitempty"`
	TrackingCategory *InvoiceLineItemTrackingCategory `json:"tracking_category,omitempty" url:"tracking_category,omitempty"`
	// The invoice line item's associated tracking categories.
	TrackingCategories []*InvoiceLineItemTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The company the invoice belongs to.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItem) GetId() *string {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *InvoiceLineItem) GetRemoteId() *string {
	if i == nil {
		return nil
	}
	return i.RemoteId
}

func (i *InvoiceLineItem) GetCreatedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoiceLineItem) GetModifiedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.ModifiedAt
}

func (i *InvoiceLineItem) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItem) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItem) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItem) GetTotalAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TotalAmount
}

func (i *InvoiceLineItem) GetEmployee() *InvoiceLineItemEmployee {
	if i == nil {
		return nil
	}
	return i.Employee
}

func (i *InvoiceLineItem) GetCurrency() *TransactionCurrencyEnum {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceLineItem) GetExchangeRate() *string {
	if i == nil {
		return nil
	}
	return i.ExchangeRate
}

func (i *InvoiceLineItem) GetItem() *InvoiceLineItemItem {
	if i == nil {
		return nil
	}
	return i.Item
}

func (i *InvoiceLineItem) GetAccount() *InvoiceLineItemAccount {
	if i == nil {
		return nil
	}
	return i.Account
}

func (i *InvoiceLineItem) GetTaxRate() *string {
	if i == nil {
		return nil
	}
	return i.TaxRate
}

func (i *InvoiceLineItem) GetTrackingCategory() *InvoiceLineItemTrackingCategory {
	if i == nil {
		return nil
	}
	return i.TrackingCategory
}

func (i *InvoiceLineItem) GetTrackingCategories() []*InvoiceLineItemTrackingCategoriesItem {
	if i == nil {
		return nil
	}
	return i.TrackingCategories
}

func (i *InvoiceLineItem) GetCompany() *string {
	if i == nil {
		return nil
	}
	return i.Company
}

func (i *InvoiceLineItem) GetRemoteWasDeleted() *bool {
	if i == nil {
		return nil
	}
	return i.RemoteWasDeleted
}

func (i *InvoiceLineItem) GetFieldMappings() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.FieldMappings
}

func (i *InvoiceLineItem) GetRemoteFields() []*RemoteField {
	if i == nil {
		return nil
	}
	return i.RemoteFields
}

func (i *InvoiceLineItem) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItem) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItem
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItem(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	i.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItem) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItem
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*i),
		CreatedAt:  internal.NewOptionalDateTime(i.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(i.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItem) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemAccount struct {
	String  string
	Account *Account

	typ string
}

func (i *InvoiceLineItemAccount) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemAccount) GetAccount() *Account {
	if i == nil {
		return nil
	}
	return i.Account
}

func (i *InvoiceLineItemAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		i.typ = "Account"
		i.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemAccount) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Account" || i.Account != nil {
		return json.Marshal(i.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (i *InvoiceLineItemAccount) Accept(visitor InvoiceLineItemAccountVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Account" || i.Account != nil {
		return visitor.VisitAccount(i.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The employee this overall transaction relates to.
type InvoiceLineItemEmployee struct {
	String   string
	Employee *Employee

	typ string
}

func (i *InvoiceLineItemEmployee) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemEmployee) GetEmployee() *Employee {
	if i == nil {
		return nil
	}
	return i.Employee
}

func (i *InvoiceLineItemEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		i.typ = "Employee"
		i.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemEmployee) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Employee" || i.Employee != nil {
		return json.Marshal(i.Employee)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (i *InvoiceLineItemEmployee) Accept(visitor InvoiceLineItemEmployeeVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Employee" || i.Employee != nil {
		return visitor.VisitEmployee(i.Employee)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemItem struct {
	String string
	Item   *Item

	typ string
}

func (i *InvoiceLineItemItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemItem) GetItem() *Item {
	if i == nil {
		return nil
	}
	return i.Item
}

func (i *InvoiceLineItemItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		i.typ = "Item"
		i.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Item" || i.Item != nil {
		return json.Marshal(i.Item)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (i *InvoiceLineItemItem) Accept(visitor InvoiceLineItemItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Item" || i.Item != nil {
		return visitor.VisitItem(i.Item)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (i *InvoiceLineItemTrackingCategoriesItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if i == nil {
		return nil
	}
	return i.TrackingCategory
}

func (i *InvoiceLineItemTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typ = "TrackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return json.Marshal(i.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceLineItemTrackingCategoriesItem) Accept(visitor InvoiceLineItemTrackingCategoriesItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemTrackingCategory struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (i *InvoiceLineItemTrackingCategory) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemTrackingCategory) GetTrackingCategory() *TrackingCategory {
	if i == nil {
		return nil
	}
	return i.TrackingCategory
}

func (i *InvoiceLineItemTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typ = "TrackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemTrackingCategory) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return json.Marshal(i.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceLineItemTrackingCategory) Accept(visitor InvoiceLineItemTrackingCategoryVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The payment term that applies to this transaction.
type InvoicePaymentTerm struct {
	String      string
	PaymentTerm *PaymentTerm

	typ string
}

func (i *InvoicePaymentTerm) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoicePaymentTerm) GetPaymentTerm() *PaymentTerm {
	if i == nil {
		return nil
	}
	return i.PaymentTerm
}

func (i *InvoicePaymentTerm) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valuePaymentTerm := new(PaymentTerm)
	if err := json.Unmarshal(data, &valuePaymentTerm); err == nil {
		i.typ = "PaymentTerm"
		i.PaymentTerm = valuePaymentTerm
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoicePaymentTerm) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "PaymentTerm" || i.PaymentTerm != nil {
		return json.Marshal(i.PaymentTerm)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoicePaymentTermVisitor interface {
	VisitString(string) error
	VisitPaymentTerm(*PaymentTerm) error
}

func (i *InvoicePaymentTerm) Accept(visitor InvoicePaymentTermVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "PaymentTerm" || i.PaymentTerm != nil {
		return visitor.VisitPaymentTerm(i.PaymentTerm)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoicePaymentsItem struct {
	String  string
	Payment *Payment

	typ string
}

func (i *InvoicePaymentsItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoicePaymentsItem) GetPayment() *Payment {
	if i == nil {
		return nil
	}
	return i.Payment
}

func (i *InvoicePaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		i.typ = "Payment"
		i.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoicePaymentsItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Payment" || i.Payment != nil {
		return json.Marshal(i.Payment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoicePaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (i *InvoicePaymentsItem) Accept(visitor InvoicePaymentsItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Payment" || i.Payment != nil {
		return visitor.VisitPayment(i.Payment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoicePurchaseOrdersItem struct {
	String        string
	PurchaseOrder *PurchaseOrder

	typ string
}

func (i *InvoicePurchaseOrdersItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoicePurchaseOrdersItem) GetPurchaseOrder() *PurchaseOrder {
	if i == nil {
		return nil
	}
	return i.PurchaseOrder
}

func (i *InvoicePurchaseOrdersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valuePurchaseOrder := new(PurchaseOrder)
	if err := json.Unmarshal(data, &valuePurchaseOrder); err == nil {
		i.typ = "PurchaseOrder"
		i.PurchaseOrder = valuePurchaseOrder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoicePurchaseOrdersItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "PurchaseOrder" || i.PurchaseOrder != nil {
		return json.Marshal(i.PurchaseOrder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoicePurchaseOrdersItemVisitor interface {
	VisitString(string) error
	VisitPurchaseOrder(*PurchaseOrder) error
}

func (i *InvoicePurchaseOrdersItem) Accept(visitor InvoicePurchaseOrdersItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "PurchaseOrder" || i.PurchaseOrder != nil {
		return visitor.VisitPurchaseOrder(i.PurchaseOrder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// * `PAID` - PAID
// * `DRAFT` - DRAFT
// * `SUBMITTED` - SUBMITTED
// * `PARTIALLY_PAID` - PARTIALLY_PAID
// * `OPEN` - OPEN
// * `VOID` - VOID
type InvoiceStatusEnum string

const (
	InvoiceStatusEnumPaid          InvoiceStatusEnum = "PAID"
	InvoiceStatusEnumDraft         InvoiceStatusEnum = "DRAFT"
	InvoiceStatusEnumSubmitted     InvoiceStatusEnum = "SUBMITTED"
	InvoiceStatusEnumPartiallyPaid InvoiceStatusEnum = "PARTIALLY_PAID"
	InvoiceStatusEnumOpen          InvoiceStatusEnum = "OPEN"
	InvoiceStatusEnumVoid          InvoiceStatusEnum = "VOID"
)

func NewInvoiceStatusEnumFromString(s string) (InvoiceStatusEnum, error) {
	switch s {
	case "PAID":
		return InvoiceStatusEnumPaid, nil
	case "DRAFT":
		return InvoiceStatusEnumDraft, nil
	case "SUBMITTED":
		return InvoiceStatusEnumSubmitted, nil
	case "PARTIALLY_PAID":
		return InvoiceStatusEnumPartiallyPaid, nil
	case "OPEN":
		return InvoiceStatusEnumOpen, nil
	case "VOID":
		return InvoiceStatusEnumVoid, nil
	}
	var t InvoiceStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceStatusEnum) Ptr() *InvoiceStatusEnum {
	return &i
}

type InvoiceTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (i *InvoiceTrackingCategoriesItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if i == nil {
		return nil
	}
	return i.TrackingCategory
}

func (i *InvoiceTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typ = "TrackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return json.Marshal(i.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceTrackingCategoriesItem) Accept(visitor InvoiceTrackingCategoriesItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
type InvoiceTypeEnum string

const (
	InvoiceTypeEnumAccountsReceivable InvoiceTypeEnum = "ACCOUNTS_RECEIVABLE"
	InvoiceTypeEnumAccountsPayable    InvoiceTypeEnum = "ACCOUNTS_PAYABLE"
)

func NewInvoiceTypeEnumFromString(s string) (InvoiceTypeEnum, error) {
	switch s {
	case "ACCOUNTS_RECEIVABLE":
		return InvoiceTypeEnumAccountsReceivable, nil
	case "ACCOUNTS_PAYABLE":
		return InvoiceTypeEnumAccountsPayable, nil
	}
	var t InvoiceTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceTypeEnum) Ptr() *InvoiceTypeEnum {
	return &i
}

// # The Item Object
// ### Description
// The `Item` object refers to the goods involved in a transaction.
//
// ### Usage Example
// Fetch from the `LIST Items` endpoint and view a company's items.
type Item struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The item's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item's status.
	//
	// * `ACTIVE` - ACTIVE
	// * `ARCHIVED` - ARCHIVED
	Status *Status7D1Enum `json:"status,omitempty" url:"status,omitempty"`
	// The item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// The price at which the item is purchased from a vendor.
	PurchasePrice *float64 `json:"purchase_price,omitempty" url:"purchase_price,omitempty"`
	// References the default account used to record a purchase of the item.
	PurchaseAccount *ItemPurchaseAccount `json:"purchase_account,omitempty" url:"purchase_account,omitempty"`
	// References the default account used to record a sale.
	SalesAccount *ItemSalesAccount `json:"sales_account,omitempty" url:"sales_account,omitempty"`
	// The company the item belongs to.
	Company *ItemCompany `json:"company,omitempty" url:"company,omitempty"`
	// The default purchase tax rate for this item.
	PurchaseTaxRate *ItemPurchaseTaxRate `json:"purchase_tax_rate,omitempty" url:"purchase_tax_rate,omitempty"`
	// The default sales tax rate for this item.
	SalesTaxRate *ItemSalesTaxRate `json:"sales_tax_rate,omitempty" url:"sales_tax_rate,omitempty"`
	// When the third party's item note was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Item) GetId() *string {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *Item) GetRemoteId() *string {
	if i == nil {
		return nil
	}
	return i.RemoteId
}

func (i *Item) GetCreatedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *Item) GetModifiedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.ModifiedAt
}

func (i *Item) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *Item) GetStatus() *Status7D1Enum {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *Item) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *Item) GetPurchasePrice() *float64 {
	if i == nil {
		return nil
	}
	return i.PurchasePrice
}

func (i *Item) GetPurchaseAccount() *ItemPurchaseAccount {
	if i == nil {
		return nil
	}
	return i.PurchaseAccount
}

func (i *Item) GetSalesAccount() *ItemSalesAccount {
	if i == nil {
		return nil
	}
	return i.SalesAccount
}

func (i *Item) GetCompany() *ItemCompany {
	if i == nil {
		return nil
	}
	return i.Company
}

func (i *Item) GetPurchaseTaxRate() *ItemPurchaseTaxRate {
	if i == nil {
		return nil
	}
	return i.PurchaseTaxRate
}

func (i *Item) GetSalesTaxRate() *ItemSalesTaxRate {
	if i == nil {
		return nil
	}
	return i.SalesTaxRate
}

func (i *Item) GetRemoteUpdatedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.RemoteUpdatedAt
}

func (i *Item) GetRemoteWasDeleted() *bool {
	if i == nil {
		return nil
	}
	return i.RemoteWasDeleted
}

func (i *Item) GetFieldMappings() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.FieldMappings
}

func (i *Item) GetRemoteData() []*RemoteData {
	if i == nil {
		return nil
	}
	return i.RemoteData
}

func (i *Item) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Item) UnmarshalJSON(data []byte) error {
	type embed Item
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Item(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	i.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	i.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Item) MarshalJSON() ([]byte, error) {
	type embed Item
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*i),
		CreatedAt:       internal.NewOptionalDateTime(i.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(i.ModifiedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(i.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *Item) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The company the item belongs to.
type ItemCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (i *ItemCompany) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *ItemCompany) GetCompanyInfo() *CompanyInfo {
	if i == nil {
		return nil
	}
	return i.CompanyInfo
}

func (i *ItemCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		i.typ = "CompanyInfo"
		i.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemCompany) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "CompanyInfo" || i.CompanyInfo != nil {
		return json.Marshal(i.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ItemCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (i *ItemCompany) Accept(visitor ItemCompanyVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "CompanyInfo" || i.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(i.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// * `string` - uuid
// * `number` - url
// * `date` - email
// * `datetime` - phone
// * `bool` - currency
// * `list` - decimal
type ItemFormatEnum string

const (
	ItemFormatEnumString   ItemFormatEnum = "string"
	ItemFormatEnumNumber   ItemFormatEnum = "number"
	ItemFormatEnumDate     ItemFormatEnum = "date"
	ItemFormatEnumDatetime ItemFormatEnum = "datetime"
	ItemFormatEnumBool     ItemFormatEnum = "bool"
	ItemFormatEnumList     ItemFormatEnum = "list"
)

func NewItemFormatEnumFromString(s string) (ItemFormatEnum, error) {
	switch s {
	case "string":
		return ItemFormatEnumString, nil
	case "number":
		return ItemFormatEnumNumber, nil
	case "date":
		return ItemFormatEnumDate, nil
	case "datetime":
		return ItemFormatEnumDatetime, nil
	case "bool":
		return ItemFormatEnumBool, nil
	case "list":
		return ItemFormatEnumList, nil
	}
	var t ItemFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ItemFormatEnum) Ptr() *ItemFormatEnum {
	return &i
}

// References the default account used to record a purchase of the item.
type ItemPurchaseAccount struct {
	String  string
	Account *Account

	typ string
}

func (i *ItemPurchaseAccount) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *ItemPurchaseAccount) GetAccount() *Account {
	if i == nil {
		return nil
	}
	return i.Account
}

func (i *ItemPurchaseAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		i.typ = "Account"
		i.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemPurchaseAccount) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Account" || i.Account != nil {
		return json.Marshal(i.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ItemPurchaseAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (i *ItemPurchaseAccount) Accept(visitor ItemPurchaseAccountVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Account" || i.Account != nil {
		return visitor.VisitAccount(i.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The default purchase tax rate for this item.
type ItemPurchaseTaxRate struct {
	String  string
	TaxRate *TaxRate

	typ string
}

func (i *ItemPurchaseTaxRate) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *ItemPurchaseTaxRate) GetTaxRate() *TaxRate {
	if i == nil {
		return nil
	}
	return i.TaxRate
}

func (i *ItemPurchaseTaxRate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueTaxRate := new(TaxRate)
	if err := json.Unmarshal(data, &valueTaxRate); err == nil {
		i.typ = "TaxRate"
		i.TaxRate = valueTaxRate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemPurchaseTaxRate) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "TaxRate" || i.TaxRate != nil {
		return json.Marshal(i.TaxRate)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ItemPurchaseTaxRateVisitor interface {
	VisitString(string) error
	VisitTaxRate(*TaxRate) error
}

func (i *ItemPurchaseTaxRate) Accept(visitor ItemPurchaseTaxRateVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "TaxRate" || i.TaxRate != nil {
		return visitor.VisitTaxRate(i.TaxRate)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// References the default account used to record a sale.
type ItemSalesAccount struct {
	String  string
	Account *Account

	typ string
}

func (i *ItemSalesAccount) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *ItemSalesAccount) GetAccount() *Account {
	if i == nil {
		return nil
	}
	return i.Account
}

func (i *ItemSalesAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		i.typ = "Account"
		i.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemSalesAccount) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Account" || i.Account != nil {
		return json.Marshal(i.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ItemSalesAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (i *ItemSalesAccount) Accept(visitor ItemSalesAccountVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Account" || i.Account != nil {
		return visitor.VisitAccount(i.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The default sales tax rate for this item.
type ItemSalesTaxRate struct {
	String  string
	TaxRate *TaxRate

	typ string
}

func (i *ItemSalesTaxRate) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *ItemSalesTaxRate) GetTaxRate() *TaxRate {
	if i == nil {
		return nil
	}
	return i.TaxRate
}

func (i *ItemSalesTaxRate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueTaxRate := new(TaxRate)
	if err := json.Unmarshal(data, &valueTaxRate); err == nil {
		i.typ = "TaxRate"
		i.TaxRate = valueTaxRate
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ItemSalesTaxRate) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "TaxRate" || i.TaxRate != nil {
		return json.Marshal(i.TaxRate)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ItemSalesTaxRateVisitor interface {
	VisitString(string) error
	VisitTaxRate(*TaxRate) error
}

func (i *ItemSalesTaxRate) Accept(visitor ItemSalesTaxRateVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "TaxRate" || i.TaxRate != nil {
		return visitor.VisitTaxRate(i.TaxRate)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ItemSchema struct {
	ItemType    *ItemTypeEnum   `json:"item_type,omitempty" url:"item_type,omitempty"`
	ItemFormat  *ItemFormatEnum `json:"item_format,omitempty" url:"item_format,omitempty"`
	ItemChoices []string        `json:"item_choices,omitempty" url:"item_choices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ItemSchema) GetItemType() *ItemTypeEnum {
	if i == nil {
		return nil
	}
	return i.ItemType
}

func (i *ItemSchema) GetItemFormat() *ItemFormatEnum {
	if i == nil {
		return nil
	}
	return i.ItemFormat
}

func (i *ItemSchema) GetItemChoices() []string {
	if i == nil {
		return nil
	}
	return i.ItemChoices
}

func (i *ItemSchema) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ItemSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemSchema) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type ItemTypeEnum string

const (
	ItemTypeEnumString   ItemTypeEnum = "string"
	ItemTypeEnumNumber   ItemTypeEnum = "number"
	ItemTypeEnumDate     ItemTypeEnum = "date"
	ItemTypeEnumDatetime ItemTypeEnum = "datetime"
	ItemTypeEnumBool     ItemTypeEnum = "bool"
	ItemTypeEnumList     ItemTypeEnum = "list"
)

func NewItemTypeEnumFromString(s string) (ItemTypeEnum, error) {
	switch s {
	case "string":
		return ItemTypeEnumString, nil
	case "number":
		return ItemTypeEnumNumber, nil
	case "date":
		return ItemTypeEnumDate, nil
	case "datetime":
		return ItemTypeEnumDatetime, nil
	case "bool":
		return ItemTypeEnumBool, nil
	case "list":
		return ItemTypeEnumList, nil
	}
	var t ItemTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ItemTypeEnum) Ptr() *ItemTypeEnum {
	return &i
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type LastSyncResultEnum string

const (
	LastSyncResultEnumSyncing         LastSyncResultEnum = "SYNCING"
	LastSyncResultEnumDone            LastSyncResultEnum = "DONE"
	LastSyncResultEnumFailed          LastSyncResultEnum = "FAILED"
	LastSyncResultEnumDisabled        LastSyncResultEnum = "DISABLED"
	LastSyncResultEnumPaused          LastSyncResultEnum = "PAUSED"
	LastSyncResultEnumPartiallySynced LastSyncResultEnum = "PARTIALLY_SYNCED"
)

func NewLastSyncResultEnumFromString(s string) (LastSyncResultEnum, error) {
	switch s {
	case "SYNCING":
		return LastSyncResultEnumSyncing, nil
	case "DONE":
		return LastSyncResultEnumDone, nil
	case "FAILED":
		return LastSyncResultEnumFailed, nil
	case "DISABLED":
		return LastSyncResultEnumDisabled, nil
	case "PAUSED":
		return LastSyncResultEnumPaused, nil
	case "PARTIALLY_SYNCED":
		return LastSyncResultEnumPartiallySynced, nil
	}
	var t LastSyncResultEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LastSyncResultEnum) Ptr() *LastSyncResultEnum {
	return &l
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status" url:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request" url:"can_make_request"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LinkedAccountStatus) GetLinkedAccountStatus() string {
	if l == nil {
		return ""
	}
	return l.LinkedAccountStatus
}

func (l *LinkedAccountStatus) GetCanMakeRequest() bool {
	if l == nil {
		return false
	}
	return l.CanMakeRequest
}

func (l *LinkedAccountStatus) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkedAccountStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedAccountStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedAccountStatus(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedAccountStatus) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MetaResponse struct {
	RequestSchema                  map[string]interface{} `json:"request_schema" url:"request_schema"`
	RemoteFieldClasses             map[string]interface{} `json:"remote_field_classes,omitempty" url:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus   `json:"status,omitempty" url:"status,omitempty"`
	HasConditionalParams           bool                   `json:"has_conditional_params" url:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                   `json:"has_required_linked_account_params" url:"has_required_linked_account_params"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetaResponse) GetRequestSchema() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RequestSchema
}

func (m *MetaResponse) GetRemoteFieldClasses() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RemoteFieldClasses
}

func (m *MetaResponse) GetStatus() *LinkedAccountStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

func (m *MetaResponse) GetHasConditionalParams() bool {
	if m == nil {
		return false
	}
	return m.HasConditionalParams
}

func (m *MetaResponse) GetHasRequiredLinkedAccountParams() bool {
	if m == nil {
		return false
	}
	return m.HasRequiredLinkedAccountParams
}

func (m *MetaResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetaResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// * `GET` - GET
// * `OPTIONS` - OPTIONS
// * `HEAD` - HEAD
// * `POST` - POST
// * `PUT` - PUT
// * `PATCH` - PATCH
// * `DELETE` - DELETE
type MethodEnum string

const (
	MethodEnumGet     MethodEnum = "GET"
	MethodEnumOptions MethodEnum = "OPTIONS"
	MethodEnumHead    MethodEnum = "HEAD"
	MethodEnumPost    MethodEnum = "POST"
	MethodEnumPut     MethodEnum = "PUT"
	MethodEnumPatch   MethodEnum = "PATCH"
	MethodEnumDelete  MethodEnum = "DELETE"
)

func NewMethodEnumFromString(s string) (MethodEnum, error) {
	switch s {
	case "GET":
		return MethodEnumGet, nil
	case "OPTIONS":
		return MethodEnumOptions, nil
	case "HEAD":
		return MethodEnumHead, nil
	case "POST":
		return MethodEnumPost, nil
	case "PUT":
		return MethodEnumPut, nil
	case "PATCH":
		return MethodEnumPatch, nil
	case "DELETE":
		return MethodEnumDelete, nil
	}
	var t MethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodEnum) Ptr() *MethodEnum {
	return &m
}

// * `CREDIT_CARD` - CREDIT_CARD
// * `DEBIT_CARD` - DEBIT_CARD
// * `ACH` - ACH
// * `CASH` - CASH
// * `CHECK` - CHECK
type MethodTypeEnum string

const (
	MethodTypeEnumCreditCard MethodTypeEnum = "CREDIT_CARD"
	MethodTypeEnumDebitCard  MethodTypeEnum = "DEBIT_CARD"
	MethodTypeEnumAch        MethodTypeEnum = "ACH"
	MethodTypeEnumCash       MethodTypeEnum = "CASH"
	MethodTypeEnumCheck      MethodTypeEnum = "CHECK"
)

func NewMethodTypeEnumFromString(s string) (MethodTypeEnum, error) {
	switch s {
	case "CREDIT_CARD":
		return MethodTypeEnumCreditCard, nil
	case "DEBIT_CARD":
		return MethodTypeEnumDebitCard, nil
	case "ACH":
		return MethodTypeEnumAch, nil
	case "CASH":
		return MethodTypeEnumCash, nil
	case "CHECK":
		return MethodTypeEnumCheck, nil
	}
	var t MethodTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodTypeEnum) Ptr() *MethodTypeEnum {
	return &m
}

// # The ModelOperation Object
// ### Description
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name" url:"model_name"`
	AvailableOperations    []string `json:"available_operations" url:"available_operations"`
	RequiredPostParameters []string `json:"required_post_parameters" url:"required_post_parameters"`
	SupportedFields        []string `json:"supported_fields" url:"supported_fields"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelOperation) GetModelName() string {
	if m == nil {
		return ""
	}
	return m.ModelName
}

func (m *ModelOperation) GetAvailableOperations() []string {
	if m == nil {
		return nil
	}
	return m.AvailableOperations
}

func (m *ModelOperation) GetRequiredPostParameters() []string {
	if m == nil {
		return nil
	}
	return m.RequiredPostParameters
}

func (m *ModelOperation) GetSupportedFields() []string {
	if m == nil {
		return nil
	}
	return m.SupportedFields
}

func (m *ModelOperation) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelOperation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelOperation) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializerRequest struct {
	IsEnabled *bool `json:"is_enabled,omitempty" url:"is_enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelPermissionDeserializerRequest) GetIsEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.IsEnabled
}

func (m *ModelPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializerRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The MultipartFormField Object
// ### Description
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name" url:"name"`
	// The data for the form field.
	Data string `json:"data" url:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// * `RAW` - RAW
	// * `BASE64` - BASE64
	// * `GZIP_BASE64` - GZIP_BASE64
	Encoding *EncodingEnum `json:"encoding,omitempty" url:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MultipartFormFieldRequest) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MultipartFormFieldRequest) GetData() string {
	if m == nil {
		return ""
	}
	return m.Data
}

func (m *MultipartFormFieldRequest) GetEncoding() *EncodingEnum {
	if m == nil {
		return nil
	}
	return m.Encoding
}

func (m *MultipartFormFieldRequest) GetFileName() *string {
	if m == nil {
		return nil
	}
	return m.FileName
}

func (m *MultipartFormFieldRequest) GetContentType() *string {
	if m == nil {
		return nil
	}
	return m.ContentType
}

func (m *MultipartFormFieldRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipartFormFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipartFormFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipartFormFieldRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipartFormFieldRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PaginatedRemoteFieldClassList struct {
	Next     *string             `json:"next,omitempty" url:"next,omitempty"`
	Previous *string             `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*RemoteFieldClass `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedRemoteFieldClassList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedRemoteFieldClassList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedRemoteFieldClassList) GetResults() []*RemoteFieldClass {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedRemoteFieldClassList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedRemoteFieldClassList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedRemoteFieldClassList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedRemoteFieldClassList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedRemoteFieldClassList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The Payment Object
// ### Description
// The `Payment` object represents general payments made towards a specific transaction.
//
// ### Usage Example
// Fetch from the `GET Payment` endpoint and view an invoice's payment.
type Payment struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The payment's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty" url:"transaction_date,omitempty"`
	// The supplier, or customer involved in the payment.
	Contact *PaymentContact `json:"contact,omitempty" url:"contact,omitempty"`
	// The supplier’s or customer’s account in which the payment is made.
	Account *PaymentAccount `json:"account,omitempty" url:"account,omitempty"`
	// The method which this payment was made by.
	PaymentMethod *PaymentPaymentMethod `json:"payment_method,omitempty" url:"payment_method,omitempty"`
	// The payment's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// The payment's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The company the payment belongs to.
	Company *PaymentCompany `json:"company,omitempty" url:"company,omitempty"`
	// The total amount of money being paid to the supplier, or customer, after taxes.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The type of the invoice.
	//
	// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	Type               *PaymentTypeEnum                 `json:"type,omitempty" url:"type,omitempty"`
	TrackingCategories []*PaymentTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The accounting period that the Payment was generated in.
	AccountingPeriod *PaymentAccountingPeriod `json:"accounting_period,omitempty" url:"accounting_period,omitempty"`
	// A list of “Payment Applied to Lines” objects.
	AppliedToLines []*PaymentAppliedToLinesItem `json:"applied_to_lines,omitempty" url:"applied_to_lines,omitempty"`
	// When the third party's payment entry was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Payment) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *Payment) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *Payment) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *Payment) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *Payment) GetTransactionDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.TransactionDate
}

func (p *Payment) GetContact() *PaymentContact {
	if p == nil {
		return nil
	}
	return p.Contact
}

func (p *Payment) GetAccount() *PaymentAccount {
	if p == nil {
		return nil
	}
	return p.Account
}

func (p *Payment) GetPaymentMethod() *PaymentPaymentMethod {
	if p == nil {
		return nil
	}
	return p.PaymentMethod
}

func (p *Payment) GetCurrency() *TransactionCurrencyEnum {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *Payment) GetExchangeRate() *string {
	if p == nil {
		return nil
	}
	return p.ExchangeRate
}

func (p *Payment) GetCompany() *PaymentCompany {
	if p == nil {
		return nil
	}
	return p.Company
}

func (p *Payment) GetTotalAmount() *float64 {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *Payment) GetType() *PaymentTypeEnum {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *Payment) GetTrackingCategories() []*PaymentTrackingCategoriesItem {
	if p == nil {
		return nil
	}
	return p.TrackingCategories
}

func (p *Payment) GetAccountingPeriod() *PaymentAccountingPeriod {
	if p == nil {
		return nil
	}
	return p.AccountingPeriod
}

func (p *Payment) GetAppliedToLines() []*PaymentAppliedToLinesItem {
	if p == nil {
		return nil
	}
	return p.AppliedToLines
}

func (p *Payment) GetRemoteUpdatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.RemoteUpdatedAt
}

func (p *Payment) GetRemoteWasDeleted() *bool {
	if p == nil {
		return nil
	}
	return p.RemoteWasDeleted
}

func (p *Payment) GetFieldMappings() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.FieldMappings
}

func (p *Payment) GetRemoteData() []*RemoteData {
	if p == nil {
		return nil
	}
	return p.RemoteData
}

func (p *Payment) GetRemoteFields() []*RemoteField {
	if p == nil {
		return nil
	}
	return p.RemoteFields
}

func (p *Payment) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payment) UnmarshalJSON(data []byte) error {
	type embed Payment
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Payment(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	p.TransactionDate = unmarshaler.TransactionDate.TimePtr()
	p.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payment) MarshalJSON() ([]byte, error) {
	type embed Payment
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*p),
		CreatedAt:       internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(p.ModifiedAt),
		TransactionDate: internal.NewOptionalDateTime(p.TransactionDate),
		RemoteUpdatedAt: internal.NewOptionalDateTime(p.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *Payment) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The supplier’s or customer’s account in which the payment is made.
type PaymentAccount struct {
	String  string
	Account *Account

	typ string
}

func (p *PaymentAccount) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentAccount) GetAccount() *Account {
	if p == nil {
		return nil
	}
	return p.Account
}

func (p *PaymentAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		p.typ = "Account"
		p.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentAccount) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Account" || p.Account != nil {
		return json.Marshal(p.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (p *PaymentAccount) Accept(visitor PaymentAccountVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Account" || p.Account != nil {
		return visitor.VisitAccount(p.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The accounting period that the Payment was generated in.
type PaymentAccountingPeriod struct {
	String           string
	AccountingPeriod *AccountingPeriod

	typ string
}

func (p *PaymentAccountingPeriod) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentAccountingPeriod) GetAccountingPeriod() *AccountingPeriod {
	if p == nil {
		return nil
	}
	return p.AccountingPeriod
}

func (p *PaymentAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		p.typ = "AccountingPeriod"
		p.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentAccountingPeriod) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "AccountingPeriod" || p.AccountingPeriod != nil {
		return json.Marshal(p.AccountingPeriod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (p *PaymentAccountingPeriod) Accept(visitor PaymentAccountingPeriodVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "AccountingPeriod" || p.AccountingPeriod != nil {
		return visitor.VisitAccountingPeriod(p.AccountingPeriod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentAppliedToLinesItem struct {
	String          string
	PaymentLineItem *PaymentLineItem

	typ string
}

func (p *PaymentAppliedToLinesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentAppliedToLinesItem) GetPaymentLineItem() *PaymentLineItem {
	if p == nil {
		return nil
	}
	return p.PaymentLineItem
}

func (p *PaymentAppliedToLinesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		p.typ = "PaymentLineItem"
		p.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentAppliedToLinesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "PaymentLineItem" || p.PaymentLineItem != nil {
		return json.Marshal(p.PaymentLineItem)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentAppliedToLinesItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (p *PaymentAppliedToLinesItem) Accept(visitor PaymentAppliedToLinesItemVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "PaymentLineItem" || p.PaymentLineItem != nil {
		return visitor.VisitPaymentLineItem(p.PaymentLineItem)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The company the payment belongs to.
type PaymentCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (p *PaymentCompany) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentCompany) GetCompanyInfo() *CompanyInfo {
	if p == nil {
		return nil
	}
	return p.CompanyInfo
}

func (p *PaymentCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typ = "CompanyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentCompany) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return json.Marshal(p.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PaymentCompany) Accept(visitor PaymentCompanyVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The supplier, or customer involved in the payment.
type PaymentContact struct {
	String  string
	Contact *Contact

	typ string
}

func (p *PaymentContact) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentContact) GetContact() *Contact {
	if p == nil {
		return nil
	}
	return p.Contact
}

func (p *PaymentContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typ = "Contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentContact) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Contact" || p.Contact != nil {
		return json.Marshal(p.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PaymentContact) Accept(visitor PaymentContactVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Contact" || p.Contact != nil {
		return visitor.VisitContact(p.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// # The PaymentLineItem Object
// ### Description
// The `PaymentLineItem` object is an applied-to-line on a `Payment` that can either be a `Invoice`, `CreditNote`, or `JournalEntry`.
//
// ### Usage Example
// `Payment` will have a field called `applied-to-lines` which will be an array of `PaymentLineItemInternalMappingSerializer` objects that can either be a `Invoice`, `CreditNote`, or `JournalEntry`.
type PaymentLineItem struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The amount being applied to the transaction.
	AppliedAmount *string `json:"applied_amount,omitempty" url:"applied_amount,omitempty"`
	// The date the payment portion is applied.
	AppliedDate *time.Time `json:"applied_date,omitempty" url:"applied_date,omitempty"`
	// The Merge ID of the transaction the payment portion is being applied to.
	RelatedObjectId *string `json:"related_object_id,omitempty" url:"related_object_id,omitempty"`
	// The type of transaction the payment portion is being applied to. Possible values include: INVOICE, JOURNAL_ENTRY, or CREDIT_NOTE.
	RelatedObjectType *string `json:"related_object_type,omitempty" url:"related_object_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentLineItem) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PaymentLineItem) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PaymentLineItem) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PaymentLineItem) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *PaymentLineItem) GetAppliedAmount() *string {
	if p == nil {
		return nil
	}
	return p.AppliedAmount
}

func (p *PaymentLineItem) GetAppliedDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.AppliedDate
}

func (p *PaymentLineItem) GetRelatedObjectId() *string {
	if p == nil {
		return nil
	}
	return p.RelatedObjectId
}

func (p *PaymentLineItem) GetRelatedObjectType() *string {
	if p == nil {
		return nil
	}
	return p.RelatedObjectType
}

func (p *PaymentLineItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLineItem) UnmarshalJSON(data []byte) error {
	type embed PaymentLineItem
	var unmarshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentLineItem(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	p.AppliedDate = unmarshaler.AppliedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLineItem) MarshalJSON() ([]byte, error) {
	type embed PaymentLineItem
	var marshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed:       embed(*p),
		CreatedAt:   internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt:  internal.NewOptionalDateTime(p.ModifiedAt),
		AppliedDate: internal.NewOptionalDateTime(p.AppliedDate),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentLineItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The PaymentMethod Object
// ### Description
// The `PaymentMethod` object defines how a payment against an invoice is made.
//
// ### Usage Example
// Fetch from the `GET PaymentMethod` endpoint and view payment method information.
type PaymentMethod struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The type of the payment method.
	//
	// * `CREDIT_CARD` - CREDIT_CARD
	// * `DEBIT_CARD` - DEBIT_CARD
	// * `ACH` - ACH
	// * `CASH` - CASH
	// * `CHECK` - CHECK
	MethodType MethodTypeEnum `json:"method_type" url:"method_type"`
	// The payment method’s name
	Name string `json:"name" url:"name"`
	// `True` if the payment method is active, `False` if not.
	IsActive *bool `json:"is_active,omitempty" url:"is_active,omitempty"`
	// When the third party's payment method was updated.
	RemoteUpdatedAt *time.Time             `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	FieldMappings   map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData      []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethod) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PaymentMethod) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PaymentMethod) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PaymentMethod) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *PaymentMethod) GetMethodType() MethodTypeEnum {
	if p == nil {
		return ""
	}
	return p.MethodType
}

func (p *PaymentMethod) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PaymentMethod) GetIsActive() *bool {
	if p == nil {
		return nil
	}
	return p.IsActive
}

func (p *PaymentMethod) GetRemoteUpdatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.RemoteUpdatedAt
}

func (p *PaymentMethod) GetFieldMappings() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.FieldMappings
}

func (p *PaymentMethod) GetRemoteData() []*RemoteData {
	if p == nil {
		return nil
	}
	return p.RemoteData
}

func (p *PaymentMethod) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethod) UnmarshalJSON(data []byte) error {
	type embed PaymentMethod
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentMethod(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	p.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethod) MarshalJSON() ([]byte, error) {
	type embed PaymentMethod
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*p),
		CreatedAt:       internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(p.ModifiedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(p.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentMethod) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The method which this payment was made by.
type PaymentPaymentMethod struct {
	String        string
	PaymentMethod *PaymentMethod

	typ string
}

func (p *PaymentPaymentMethod) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentPaymentMethod) GetPaymentMethod() *PaymentMethod {
	if p == nil {
		return nil
	}
	return p.PaymentMethod
}

func (p *PaymentPaymentMethod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valuePaymentMethod := new(PaymentMethod)
	if err := json.Unmarshal(data, &valuePaymentMethod); err == nil {
		p.typ = "PaymentMethod"
		p.PaymentMethod = valuePaymentMethod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentPaymentMethod) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "PaymentMethod" || p.PaymentMethod != nil {
		return json.Marshal(p.PaymentMethod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentPaymentMethodVisitor interface {
	VisitString(string) error
	VisitPaymentMethod(*PaymentMethod) error
}

func (p *PaymentPaymentMethod) Accept(visitor PaymentPaymentMethodVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "PaymentMethod" || p.PaymentMethod != nil {
		return visitor.VisitPaymentMethod(p.PaymentMethod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// # The PaymentTerm Object
// ### Description
// The `PaymentTerm` object is the agreed-upon conditions between a buyer and a seller that define the timing,
// amount, and conditions under which payment for goods or services must be made.
//
// ### Usage Example
// Fetch from the `GET PaymentTerm` endpoint and view payment term information.
type PaymentTerm struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The name of the payment term.
	Name string `json:"name" url:"name"`
	// `True` if the payment term is active, `False` if not.
	IsActive *bool `json:"is_active,omitempty" url:"is_active,omitempty"`
	// The subsidiary that the payment term belongs to.
	Company *PaymentTermCompany `json:"company,omitempty" url:"company,omitempty"`
	// The number of days after the invoice date that payment is due.
	DaysUntilDue *int `json:"days_until_due,omitempty" url:"days_until_due,omitempty"`
	// The number of days the invoice must be paid before discounts expire.
	DiscountDays *int `json:"discount_days,omitempty" url:"discount_days,omitempty"`
	// When the third party's payment term was modified.
	RemoteLastModifiedAt *time.Time             `json:"remote_last_modified_at,omitempty" url:"remote_last_modified_at,omitempty"`
	FieldMappings        map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData           []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentTerm) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PaymentTerm) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PaymentTerm) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PaymentTerm) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *PaymentTerm) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PaymentTerm) GetIsActive() *bool {
	if p == nil {
		return nil
	}
	return p.IsActive
}

func (p *PaymentTerm) GetCompany() *PaymentTermCompany {
	if p == nil {
		return nil
	}
	return p.Company
}

func (p *PaymentTerm) GetDaysUntilDue() *int {
	if p == nil {
		return nil
	}
	return p.DaysUntilDue
}

func (p *PaymentTerm) GetDiscountDays() *int {
	if p == nil {
		return nil
	}
	return p.DiscountDays
}

func (p *PaymentTerm) GetRemoteLastModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.RemoteLastModifiedAt
}

func (p *PaymentTerm) GetFieldMappings() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.FieldMappings
}

func (p *PaymentTerm) GetRemoteData() []*RemoteData {
	if p == nil {
		return nil
	}
	return p.RemoteData
}

func (p *PaymentTerm) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentTerm) UnmarshalJSON(data []byte) error {
	type embed PaymentTerm
	var unmarshaler = struct {
		embed
		CreatedAt            *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt           *internal.DateTime `json:"modified_at,omitempty"`
		RemoteLastModifiedAt *internal.DateTime `json:"remote_last_modified_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentTerm(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	p.RemoteLastModifiedAt = unmarshaler.RemoteLastModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentTerm) MarshalJSON() ([]byte, error) {
	type embed PaymentTerm
	var marshaler = struct {
		embed
		CreatedAt            *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt           *internal.DateTime `json:"modified_at,omitempty"`
		RemoteLastModifiedAt *internal.DateTime `json:"remote_last_modified_at,omitempty"`
	}{
		embed:                embed(*p),
		CreatedAt:            internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt:           internal.NewOptionalDateTime(p.ModifiedAt),
		RemoteLastModifiedAt: internal.NewOptionalDateTime(p.RemoteLastModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentTerm) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The subsidiary that the payment term belongs to.
type PaymentTermCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (p *PaymentTermCompany) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentTermCompany) GetCompanyInfo() *CompanyInfo {
	if p == nil {
		return nil
	}
	return p.CompanyInfo
}

func (p *PaymentTermCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typ = "CompanyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentTermCompany) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return json.Marshal(p.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentTermCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PaymentTermCompany) Accept(visitor PaymentTermCompanyVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (p *PaymentTrackingCategoriesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if p == nil {
		return nil
	}
	return p.TrackingCategory
}

func (p *PaymentTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typ = "TrackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "TrackingCategory" || p.TrackingCategory != nil {
		return json.Marshal(p.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PaymentTrackingCategoriesItem) Accept(visitor PaymentTrackingCategoriesItemVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "TrackingCategory" || p.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
type PaymentTypeEnum string

const (
	PaymentTypeEnumAccountsPayable    PaymentTypeEnum = "ACCOUNTS_PAYABLE"
	PaymentTypeEnumAccountsReceivable PaymentTypeEnum = "ACCOUNTS_RECEIVABLE"
)

func NewPaymentTypeEnumFromString(s string) (PaymentTypeEnum, error) {
	switch s {
	case "ACCOUNTS_PAYABLE":
		return PaymentTypeEnumAccountsPayable, nil
	case "ACCOUNTS_RECEIVABLE":
		return PaymentTypeEnumAccountsReceivable, nil
	}
	var t PaymentTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentTypeEnum) Ptr() *PaymentTypeEnum {
	return &p
}

// # The PurchaseOrder Object
// ### Description
// A `PurchaseOrder` represents a request to purchase goods or services from a vendor. It outlines the details of the purchase, such as the items or services requested, quantities, prices, and delivery details.
//
// A `PurchaseOrder` is a crucial component of the procurement process, but does not typically result in any impact on the company’s general ledger. The general ledger is typically only affected when the `PurchaseOrder` is fulfilled as an *Accounts Payable* `Invoice` object (also known as a Bill).
//
// ### Usage Example
// Fetch from the `LIST PurchaseOrders` endpoint and view a company's purchase orders.
type PurchaseOrder struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The purchase order's status.
	//
	// * `DRAFT` - DRAFT
	// * `SUBMITTED` - SUBMITTED
	// * `AUTHORIZED` - AUTHORIZED
	// * `BILLED` - BILLED
	// * `DELETED` - DELETED
	Status *PurchaseOrderStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// The purchase order's issue date.
	IssueDate *time.Time `json:"issue_date,omitempty" url:"issue_date,omitempty"`
	// The human-readable number of the purchase order.
	PurchaseOrderNumber *string `json:"purchase_order_number,omitempty" url:"purchase_order_number,omitempty"`
	// The purchase order's delivery date.
	DeliveryDate *time.Time `json:"delivery_date,omitempty" url:"delivery_date,omitempty"`
	// The purchase order's delivery address.
	DeliveryAddress *PurchaseOrderDeliveryAddress `json:"delivery_address,omitempty" url:"delivery_address,omitempty"`
	// The contact making the purchase order.
	Customer *string `json:"customer,omitempty" url:"customer,omitempty"`
	// The party fulfilling the purchase order.
	Vendor *PurchaseOrderVendor `json:"vendor,omitempty" url:"vendor,omitempty"`
	// A memo attached to the purchase order.
	Memo *string `json:"memo,omitempty" url:"memo,omitempty"`
	// The company the purchase order belongs to.
	Company *PurchaseOrderCompany `json:"company,omitempty" url:"company,omitempty"`
	// The purchase order's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The purchase order's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// The purchase order's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The payment term that applies to this transaction.
	PaymentTerm *PurchaseOrderPaymentTerm `json:"payment_term,omitempty" url:"payment_term,omitempty"`
	LineItems   []*PurchaseOrderLineItem  `json:"line_items,omitempty" url:"line_items,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax     *bool                                  `json:"inclusive_of_tax,omitempty" url:"inclusive_of_tax,omitempty"`
	TrackingCategories []*PurchaseOrderTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The accounting period that the PurchaseOrder was generated in.
	AccountingPeriod *PurchaseOrderAccountingPeriod `json:"accounting_period,omitempty" url:"accounting_period,omitempty"`
	// When the third party's purchase order note was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's purchase order note was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PurchaseOrder) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PurchaseOrder) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PurchaseOrder) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PurchaseOrder) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *PurchaseOrder) GetStatus() *PurchaseOrderStatusEnum {
	if p == nil {
		return nil
	}
	return p.Status
}

func (p *PurchaseOrder) GetIssueDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.IssueDate
}

func (p *PurchaseOrder) GetPurchaseOrderNumber() *string {
	if p == nil {
		return nil
	}
	return p.PurchaseOrderNumber
}

func (p *PurchaseOrder) GetDeliveryDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.DeliveryDate
}

func (p *PurchaseOrder) GetDeliveryAddress() *PurchaseOrderDeliveryAddress {
	if p == nil {
		return nil
	}
	return p.DeliveryAddress
}

func (p *PurchaseOrder) GetCustomer() *string {
	if p == nil {
		return nil
	}
	return p.Customer
}

func (p *PurchaseOrder) GetVendor() *PurchaseOrderVendor {
	if p == nil {
		return nil
	}
	return p.Vendor
}

func (p *PurchaseOrder) GetMemo() *string {
	if p == nil {
		return nil
	}
	return p.Memo
}

func (p *PurchaseOrder) GetCompany() *PurchaseOrderCompany {
	if p == nil {
		return nil
	}
	return p.Company
}

func (p *PurchaseOrder) GetTotalAmount() *float64 {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *PurchaseOrder) GetCurrency() *TransactionCurrencyEnum {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PurchaseOrder) GetExchangeRate() *string {
	if p == nil {
		return nil
	}
	return p.ExchangeRate
}

func (p *PurchaseOrder) GetPaymentTerm() *PurchaseOrderPaymentTerm {
	if p == nil {
		return nil
	}
	return p.PaymentTerm
}

func (p *PurchaseOrder) GetLineItems() []*PurchaseOrderLineItem {
	if p == nil {
		return nil
	}
	return p.LineItems
}

func (p *PurchaseOrder) GetInclusiveOfTax() *bool {
	if p == nil {
		return nil
	}
	return p.InclusiveOfTax
}

func (p *PurchaseOrder) GetTrackingCategories() []*PurchaseOrderTrackingCategoriesItem {
	if p == nil {
		return nil
	}
	return p.TrackingCategories
}

func (p *PurchaseOrder) GetAccountingPeriod() *PurchaseOrderAccountingPeriod {
	if p == nil {
		return nil
	}
	return p.AccountingPeriod
}

func (p *PurchaseOrder) GetRemoteCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.RemoteCreatedAt
}

func (p *PurchaseOrder) GetRemoteUpdatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.RemoteUpdatedAt
}

func (p *PurchaseOrder) GetRemoteWasDeleted() *bool {
	if p == nil {
		return nil
	}
	return p.RemoteWasDeleted
}

func (p *PurchaseOrder) GetFieldMappings() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.FieldMappings
}

func (p *PurchaseOrder) GetRemoteData() []*RemoteData {
	if p == nil {
		return nil
	}
	return p.RemoteData
}

func (p *PurchaseOrder) GetRemoteFields() []*RemoteField {
	if p == nil {
		return nil
	}
	return p.RemoteFields
}

func (p *PurchaseOrder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PurchaseOrder) UnmarshalJSON(data []byte) error {
	type embed PurchaseOrder
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		IssueDate       *internal.DateTime `json:"issue_date,omitempty"`
		DeliveryDate    *internal.DateTime `json:"delivery_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PurchaseOrder(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	p.IssueDate = unmarshaler.IssueDate.TimePtr()
	p.DeliveryDate = unmarshaler.DeliveryDate.TimePtr()
	p.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	p.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PurchaseOrder) MarshalJSON() ([]byte, error) {
	type embed PurchaseOrder
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		IssueDate       *internal.DateTime `json:"issue_date,omitempty"`
		DeliveryDate    *internal.DateTime `json:"delivery_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*p),
		CreatedAt:       internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(p.ModifiedAt),
		IssueDate:       internal.NewOptionalDateTime(p.IssueDate),
		DeliveryDate:    internal.NewOptionalDateTime(p.DeliveryDate),
		RemoteCreatedAt: internal.NewOptionalDateTime(p.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(p.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PurchaseOrder) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The accounting period that the PurchaseOrder was generated in.
type PurchaseOrderAccountingPeriod struct {
	String           string
	AccountingPeriod *AccountingPeriod

	typ string
}

func (p *PurchaseOrderAccountingPeriod) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PurchaseOrderAccountingPeriod) GetAccountingPeriod() *AccountingPeriod {
	if p == nil {
		return nil
	}
	return p.AccountingPeriod
}

func (p *PurchaseOrderAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		p.typ = "AccountingPeriod"
		p.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderAccountingPeriod) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "AccountingPeriod" || p.AccountingPeriod != nil {
		return json.Marshal(p.AccountingPeriod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PurchaseOrderAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (p *PurchaseOrderAccountingPeriod) Accept(visitor PurchaseOrderAccountingPeriodVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "AccountingPeriod" || p.AccountingPeriod != nil {
		return visitor.VisitAccountingPeriod(p.AccountingPeriod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The company the purchase order belongs to.
type PurchaseOrderCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (p *PurchaseOrderCompany) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PurchaseOrderCompany) GetCompanyInfo() *CompanyInfo {
	if p == nil {
		return nil
	}
	return p.CompanyInfo
}

func (p *PurchaseOrderCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typ = "CompanyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderCompany) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return json.Marshal(p.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PurchaseOrderCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PurchaseOrderCompany) Accept(visitor PurchaseOrderCompanyVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The purchase order's delivery address.
type PurchaseOrderDeliveryAddress struct {
	String  string
	Address *Address

	typ string
}

func (p *PurchaseOrderDeliveryAddress) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PurchaseOrderDeliveryAddress) GetAddress() *Address {
	if p == nil {
		return nil
	}
	return p.Address
}

func (p *PurchaseOrderDeliveryAddress) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueAddress := new(Address)
	if err := json.Unmarshal(data, &valueAddress); err == nil {
		p.typ = "Address"
		p.Address = valueAddress
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderDeliveryAddress) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Address" || p.Address != nil {
		return json.Marshal(p.Address)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PurchaseOrderDeliveryAddressVisitor interface {
	VisitString(string) error
	VisitAddress(*Address) error
}

func (p *PurchaseOrderDeliveryAddress) Accept(visitor PurchaseOrderDeliveryAddressVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Address" || p.Address != nil {
		return visitor.VisitAddress(p.Address)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// # The PurchaseOrderLineItem Object
// ### Description
// The `PurchaseOrderLineItem` object is used to represent a purchase order's line item.
//
// ### Usage Example
// Fetch from the `GET PurchaseOrder` endpoint and view a company's purchase orders.
type PurchaseOrderLineItem struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// A description of the good being purchased.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The line item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// The line item's quantity.
	Quantity *float64                   `json:"quantity,omitempty" url:"quantity,omitempty"`
	Item     *PurchaseOrderLineItemItem `json:"item,omitempty" url:"item,omitempty"`
	// The purchase order line item's account.
	Account *string `json:"account,omitempty" url:"account,omitempty"`
	// The purchase order line item's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty" url:"tracking_category,omitempty"`
	// The purchase order line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The purchase order line item's tax amount.
	TaxAmount *string `json:"tax_amount,omitempty" url:"tax_amount,omitempty"`
	// The purchase order line item's total amount.
	TotalLineAmount *string `json:"total_line_amount,omitempty" url:"total_line_amount,omitempty"`
	// The purchase order line item's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty" url:"tax_rate,omitempty"`
	// The purchase order line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The company the purchase order line item belongs to.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool          `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	RemoteFields     []*RemoteField `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PurchaseOrderLineItem) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PurchaseOrderLineItem) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PurchaseOrderLineItem) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PurchaseOrderLineItem) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *PurchaseOrderLineItem) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PurchaseOrderLineItem) GetUnitPrice() *float64 {
	if p == nil {
		return nil
	}
	return p.UnitPrice
}

func (p *PurchaseOrderLineItem) GetQuantity() *float64 {
	if p == nil {
		return nil
	}
	return p.Quantity
}

func (p *PurchaseOrderLineItem) GetItem() *PurchaseOrderLineItemItem {
	if p == nil {
		return nil
	}
	return p.Item
}

func (p *PurchaseOrderLineItem) GetAccount() *string {
	if p == nil {
		return nil
	}
	return p.Account
}

func (p *PurchaseOrderLineItem) GetTrackingCategory() *string {
	if p == nil {
		return nil
	}
	return p.TrackingCategory
}

func (p *PurchaseOrderLineItem) GetTrackingCategories() []*string {
	if p == nil {
		return nil
	}
	return p.TrackingCategories
}

func (p *PurchaseOrderLineItem) GetTaxAmount() *string {
	if p == nil {
		return nil
	}
	return p.TaxAmount
}

func (p *PurchaseOrderLineItem) GetTotalLineAmount() *string {
	if p == nil {
		return nil
	}
	return p.TotalLineAmount
}

func (p *PurchaseOrderLineItem) GetCurrency() *TransactionCurrencyEnum {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PurchaseOrderLineItem) GetTaxRate() *string {
	if p == nil {
		return nil
	}
	return p.TaxRate
}

func (p *PurchaseOrderLineItem) GetExchangeRate() *string {
	if p == nil {
		return nil
	}
	return p.ExchangeRate
}

func (p *PurchaseOrderLineItem) GetCompany() *string {
	if p == nil {
		return nil
	}
	return p.Company
}

func (p *PurchaseOrderLineItem) GetRemoteWasDeleted() *bool {
	if p == nil {
		return nil
	}
	return p.RemoteWasDeleted
}

func (p *PurchaseOrderLineItem) GetRemoteFields() []*RemoteField {
	if p == nil {
		return nil
	}
	return p.RemoteFields
}

func (p *PurchaseOrderLineItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PurchaseOrderLineItem) UnmarshalJSON(data []byte) error {
	type embed PurchaseOrderLineItem
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PurchaseOrderLineItem(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PurchaseOrderLineItem) MarshalJSON() ([]byte, error) {
	type embed PurchaseOrderLineItem
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*p),
		CreatedAt:  internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(p.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PurchaseOrderLineItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PurchaseOrderLineItemItem struct {
	String string
	Item   *Item

	typ string
}

func (p *PurchaseOrderLineItemItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PurchaseOrderLineItemItem) GetItem() *Item {
	if p == nil {
		return nil
	}
	return p.Item
}

func (p *PurchaseOrderLineItemItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		p.typ = "Item"
		p.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderLineItemItem) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Item" || p.Item != nil {
		return json.Marshal(p.Item)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PurchaseOrderLineItemItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (p *PurchaseOrderLineItemItem) Accept(visitor PurchaseOrderLineItemItemVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Item" || p.Item != nil {
		return visitor.VisitItem(p.Item)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The payment term that applies to this transaction.
type PurchaseOrderPaymentTerm struct {
	String      string
	PaymentTerm *PaymentTerm

	typ string
}

func (p *PurchaseOrderPaymentTerm) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PurchaseOrderPaymentTerm) GetPaymentTerm() *PaymentTerm {
	if p == nil {
		return nil
	}
	return p.PaymentTerm
}

func (p *PurchaseOrderPaymentTerm) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valuePaymentTerm := new(PaymentTerm)
	if err := json.Unmarshal(data, &valuePaymentTerm); err == nil {
		p.typ = "PaymentTerm"
		p.PaymentTerm = valuePaymentTerm
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderPaymentTerm) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "PaymentTerm" || p.PaymentTerm != nil {
		return json.Marshal(p.PaymentTerm)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PurchaseOrderPaymentTermVisitor interface {
	VisitString(string) error
	VisitPaymentTerm(*PaymentTerm) error
}

func (p *PurchaseOrderPaymentTerm) Accept(visitor PurchaseOrderPaymentTermVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "PaymentTerm" || p.PaymentTerm != nil {
		return visitor.VisitPaymentTerm(p.PaymentTerm)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// * `DRAFT` - DRAFT
// * `SUBMITTED` - SUBMITTED
// * `AUTHORIZED` - AUTHORIZED
// * `BILLED` - BILLED
// * `DELETED` - DELETED
type PurchaseOrderStatusEnum string

const (
	PurchaseOrderStatusEnumDraft      PurchaseOrderStatusEnum = "DRAFT"
	PurchaseOrderStatusEnumSubmitted  PurchaseOrderStatusEnum = "SUBMITTED"
	PurchaseOrderStatusEnumAuthorized PurchaseOrderStatusEnum = "AUTHORIZED"
	PurchaseOrderStatusEnumBilled     PurchaseOrderStatusEnum = "BILLED"
	PurchaseOrderStatusEnumDeleted    PurchaseOrderStatusEnum = "DELETED"
)

func NewPurchaseOrderStatusEnumFromString(s string) (PurchaseOrderStatusEnum, error) {
	switch s {
	case "DRAFT":
		return PurchaseOrderStatusEnumDraft, nil
	case "SUBMITTED":
		return PurchaseOrderStatusEnumSubmitted, nil
	case "AUTHORIZED":
		return PurchaseOrderStatusEnumAuthorized, nil
	case "BILLED":
		return PurchaseOrderStatusEnumBilled, nil
	case "DELETED":
		return PurchaseOrderStatusEnumDeleted, nil
	}
	var t PurchaseOrderStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PurchaseOrderStatusEnum) Ptr() *PurchaseOrderStatusEnum {
	return &p
}

type PurchaseOrderTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (p *PurchaseOrderTrackingCategoriesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PurchaseOrderTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if p == nil {
		return nil
	}
	return p.TrackingCategory
}

func (p *PurchaseOrderTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typ = "TrackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "TrackingCategory" || p.TrackingCategory != nil {
		return json.Marshal(p.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PurchaseOrderTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PurchaseOrderTrackingCategoriesItem) Accept(visitor PurchaseOrderTrackingCategoriesItemVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "TrackingCategory" || p.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The party fulfilling the purchase order.
type PurchaseOrderVendor struct {
	String  string
	Contact *Contact

	typ string
}

func (p *PurchaseOrderVendor) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PurchaseOrderVendor) GetContact() *Contact {
	if p == nil {
		return nil
	}
	return p.Contact
}

func (p *PurchaseOrderVendor) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typ = "Contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PurchaseOrderVendor) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Contact" || p.Contact != nil {
		return json.Marshal(p.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PurchaseOrderVendorVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PurchaseOrderVendor) Accept(visitor PurchaseOrderVendorVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Contact" || p.Contact != nil {
		return visitor.VisitContact(p.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// # The RemoteData Object
// ### Description
// The `RemoteData` object is used to represent the full data pulled from the third-party API for an object.
//
// ### Usage Example
// TODO
type RemoteData struct {
	// The third-party API path that is being called.
	Path string      `json:"path" url:"path"`
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteData) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteData) GetData() interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RemoteData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteData) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteField struct {
	RemoteFieldClass *RemoteFieldRemoteFieldClass `json:"remote_field_class" url:"remote_field_class"`
	Value            interface{}                  `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteField) GetRemoteFieldClass() *RemoteFieldRemoteFieldClass {
	if r == nil {
		return nil
	}
	return r.RemoteFieldClass
}

func (r *RemoteField) GetValue() interface{} {
	if r == nil {
		return nil
	}
	return r.Value
}

func (r *RemoteField) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteField) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteField) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldClass struct {
	Id            *string          `json:"id,omitempty" url:"id,omitempty"`
	DisplayName   *string          `json:"display_name,omitempty" url:"display_name,omitempty"`
	RemoteKeyName *string          `json:"remote_key_name,omitempty" url:"remote_key_name,omitempty"`
	Description   *string          `json:"description,omitempty" url:"description,omitempty"`
	IsCustom      *bool            `json:"is_custom,omitempty" url:"is_custom,omitempty"`
	IsRequired    *bool            `json:"is_required,omitempty" url:"is_required,omitempty"`
	FieldType     *FieldTypeEnum   `json:"field_type,omitempty" url:"field_type,omitempty"`
	FieldFormat   *FieldFormatEnum `json:"field_format,omitempty" url:"field_format,omitempty"`
	FieldChoices  []string         `json:"field_choices,omitempty" url:"field_choices,omitempty"`
	ItemSchema    *ItemSchema      `json:"item_schema,omitempty" url:"item_schema,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteFieldClass) GetId() *string {
	if r == nil {
		return nil
	}
	return r.Id
}

func (r *RemoteFieldClass) GetDisplayName() *string {
	if r == nil {
		return nil
	}
	return r.DisplayName
}

func (r *RemoteFieldClass) GetRemoteKeyName() *string {
	if r == nil {
		return nil
	}
	return r.RemoteKeyName
}

func (r *RemoteFieldClass) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RemoteFieldClass) GetIsCustom() *bool {
	if r == nil {
		return nil
	}
	return r.IsCustom
}

func (r *RemoteFieldClass) GetIsRequired() *bool {
	if r == nil {
		return nil
	}
	return r.IsRequired
}

func (r *RemoteFieldClass) GetFieldType() *FieldTypeEnum {
	if r == nil {
		return nil
	}
	return r.FieldType
}

func (r *RemoteFieldClass) GetFieldFormat() *FieldFormatEnum {
	if r == nil {
		return nil
	}
	return r.FieldFormat
}

func (r *RemoteFieldClass) GetFieldChoices() []string {
	if r == nil {
		return nil
	}
	return r.FieldChoices
}

func (r *RemoteFieldClass) GetItemSchema() *ItemSchema {
	if r == nil {
		return nil
	}
	return r.ItemSchema
}

func (r *RemoteFieldClass) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteFieldClass) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldClass
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldClass(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldClass) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldRemoteFieldClass struct {
	String           string
	RemoteFieldClass *RemoteFieldClass

	typ string
}

func (r *RemoteFieldRemoteFieldClass) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *RemoteFieldRemoteFieldClass) GetRemoteFieldClass() *RemoteFieldClass {
	if r == nil {
		return nil
	}
	return r.RemoteFieldClass
}

func (r *RemoteFieldRemoteFieldClass) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	valueRemoteFieldClass := new(RemoteFieldClass)
	if err := json.Unmarshal(data, &valueRemoteFieldClass); err == nil {
		r.typ = "RemoteFieldClass"
		r.RemoteFieldClass = valueRemoteFieldClass
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldRemoteFieldClass) MarshalJSON() ([]byte, error) {
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	if r.typ == "RemoteFieldClass" || r.RemoteFieldClass != nil {
		return json.Marshal(r.RemoteFieldClass)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RemoteFieldRemoteFieldClassVisitor interface {
	VisitString(string) error
	VisitRemoteFieldClass(*RemoteFieldClass) error
}

func (r *RemoteFieldRemoteFieldClass) Accept(visitor RemoteFieldRemoteFieldClassVisitor) error {
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	if r.typ == "RemoteFieldClass" || r.RemoteFieldClass != nil {
		return visitor.VisitRemoteFieldClass(r.RemoteFieldClass)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RemoteFieldRequest struct {
	RemoteFieldClass *RemoteFieldRequestRemoteFieldClass `json:"remote_field_class" url:"remote_field_class"`
	Value            interface{}                         `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteFieldRequest) GetRemoteFieldClass() *RemoteFieldRequestRemoteFieldClass {
	if r == nil {
		return nil
	}
	return r.RemoteFieldClass
}

func (r *RemoteFieldRequest) GetValue() interface{} {
	if r == nil {
		return nil
	}
	return r.Value
}

func (r *RemoteFieldRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldRequest) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldRequestRemoteFieldClass struct {
	String           string
	RemoteFieldClass *RemoteFieldClass

	typ string
}

func (r *RemoteFieldRequestRemoteFieldClass) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *RemoteFieldRequestRemoteFieldClass) GetRemoteFieldClass() *RemoteFieldClass {
	if r == nil {
		return nil
	}
	return r.RemoteFieldClass
}

func (r *RemoteFieldRequestRemoteFieldClass) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	valueRemoteFieldClass := new(RemoteFieldClass)
	if err := json.Unmarshal(data, &valueRemoteFieldClass); err == nil {
		r.typ = "RemoteFieldClass"
		r.RemoteFieldClass = valueRemoteFieldClass
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldRequestRemoteFieldClass) MarshalJSON() ([]byte, error) {
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	if r.typ == "RemoteFieldClass" || r.RemoteFieldClass != nil {
		return json.Marshal(r.RemoteFieldClass)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RemoteFieldRequestRemoteFieldClassVisitor interface {
	VisitString(string) error
	VisitRemoteFieldClass(*RemoteFieldClass) error
}

func (r *RemoteFieldRequestRemoteFieldClass) Accept(visitor RemoteFieldRequestRemoteFieldClassVisitor) error {
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	if r.typ == "RemoteFieldClass" || r.RemoteFieldClass != nil {
		return visitor.VisitRemoteFieldClass(r.RemoteFieldClass)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

// # The RemoteKey Object
// ### Description
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name" url:"name"`
	Key  string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteKey) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

func (r *RemoteKey) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *RemoteKey) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteKey) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteResponse Object
// ### Description
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                 `json:"method" url:"method"`
	Path            string                 `json:"path" url:"path"`
	Status          int                    `json:"status" url:"status"`
	Response        interface{}            `json:"response" url:"response"`
	ResponseHeaders map[string]interface{} `json:"response_headers,omitempty" url:"response_headers,omitempty"`
	ResponseType    *ResponseTypeEnum      `json:"response_type,omitempty" url:"response_type,omitempty"`
	Headers         map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteResponse) GetMethod() string {
	if r == nil {
		return ""
	}
	return r.Method
}

func (r *RemoteResponse) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteResponse) GetStatus() int {
	if r == nil {
		return 0
	}
	return r.Status
}

func (r *RemoteResponse) GetResponse() interface{} {
	if r == nil {
		return nil
	}
	return r.Response
}

func (r *RemoteResponse) GetResponseHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.ResponseHeaders
}

func (r *RemoteResponse) GetResponseType() *ResponseTypeEnum {
	if r == nil {
		return nil
	}
	return r.ResponseType
}

func (r *RemoteResponse) GetHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Headers
}

func (r *RemoteResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The ReportItem Object
// ### Description
// The `ReportItem` object is used to represent a report item for a Balance Sheet, Cash Flow Statement or Profit and Loss Report.
//
// ### Usage Example
// Fetch from the `GET BalanceSheet` endpoint and view the balance sheet's report items.
type ReportItem struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The report item's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The report item's value.
	Value    *float64                 `json:"value,omitempty" url:"value,omitempty"`
	SubItems []map[string]interface{} `json:"sub_items,omitempty" url:"sub_items,omitempty"`
	// The company the report item belongs to.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReportItem) GetRemoteId() *string {
	if r == nil {
		return nil
	}
	return r.RemoteId
}

func (r *ReportItem) GetCreatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *ReportItem) GetModifiedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.ModifiedAt
}

func (r *ReportItem) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *ReportItem) GetValue() *float64 {
	if r == nil {
		return nil
	}
	return r.Value
}

func (r *ReportItem) GetSubItems() []map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.SubItems
}

func (r *ReportItem) GetCompany() *string {
	if r == nil {
		return nil
	}
	return r.Company
}

func (r *ReportItem) GetRemoteWasDeleted() *bool {
	if r == nil {
		return nil
	}
	return r.RemoteWasDeleted
}

func (r *ReportItem) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReportItem) UnmarshalJSON(data []byte) error {
	type embed ReportItem
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ReportItem(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	r.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReportItem) MarshalJSON() ([]byte, error) {
	type embed ReportItem
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*r),
		CreatedAt:  internal.NewOptionalDateTime(r.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(r.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (r *ReportItem) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// * `JSON` - JSON
// * `XML` - XML
// * `MULTIPART` - MULTIPART
type RequestFormatEnum string

const (
	RequestFormatEnumJson      RequestFormatEnum = "JSON"
	RequestFormatEnumXml       RequestFormatEnum = "XML"
	RequestFormatEnumMultipart RequestFormatEnum = "MULTIPART"
)

func NewRequestFormatEnumFromString(s string) (RequestFormatEnum, error) {
	switch s {
	case "JSON":
		return RequestFormatEnumJson, nil
	case "XML":
		return RequestFormatEnumXml, nil
	case "MULTIPART":
		return RequestFormatEnumMultipart, nil
	}
	var t RequestFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestFormatEnum) Ptr() *RequestFormatEnum {
	return &r
}

// * `JSON` - JSON
// * `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum string

const (
	ResponseTypeEnumJson       ResponseTypeEnum = "JSON"
	ResponseTypeEnumBase64Gzip ResponseTypeEnum = "BASE64_GZIP"
)

func NewResponseTypeEnumFromString(s string) (ResponseTypeEnum, error) {
	switch s {
	case "JSON":
		return ResponseTypeEnumJson, nil
	case "BASE64_GZIP":
		return ResponseTypeEnumBase64Gzip, nil
	}
	var t ResponseTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTypeEnum) Ptr() *ResponseTypeEnum {
	return &r
}

// * `IN_NEXT_SYNC` - IN_NEXT_SYNC
// * `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum string

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = "IN_NEXT_SYNC"
	SelectiveSyncConfigurationsUsageEnumInLastSync SelectiveSyncConfigurationsUsageEnum = "IN_LAST_SYNC"
)

func NewSelectiveSyncConfigurationsUsageEnumFromString(s string) (SelectiveSyncConfigurationsUsageEnum, error) {
	switch s {
	case "IN_NEXT_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInNextSync, nil
	case "IN_LAST_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInLastSync, nil
	}
	var t SelectiveSyncConfigurationsUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SelectiveSyncConfigurationsUsageEnum) Ptr() *SelectiveSyncConfigurationsUsageEnum {
	return &s
}

// * `ACTIVE` - ACTIVE
// * `ARCHIVED` - ARCHIVED
type Status7D1Enum string

const (
	Status7D1EnumActive   Status7D1Enum = "ACTIVE"
	Status7D1EnumArchived Status7D1Enum = "ARCHIVED"
)

func NewStatus7D1EnumFromString(s string) (Status7D1Enum, error) {
	switch s {
	case "ACTIVE":
		return Status7D1EnumActive, nil
	case "ARCHIVED":
		return Status7D1EnumArchived, nil
	}
	var t Status7D1Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Status7D1Enum) Ptr() *Status7D1Enum {
	return &s
}

// * `ACTIVE` - ACTIVE
// * `INACTIVE` - INACTIVE
type Status895Enum string

const (
	Status895EnumActive   Status895Enum = "ACTIVE"
	Status895EnumInactive Status895Enum = "INACTIVE"
)

func NewStatus895EnumFromString(s string) (Status895Enum, error) {
	switch s {
	case "ACTIVE":
		return Status895EnumActive, nil
	case "INACTIVE":
		return Status895EnumInactive, nil
	}
	var t Status895Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Status895Enum) Ptr() *Status895Enum {
	return &s
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type StatusFd5Enum string

const (
	StatusFd5EnumSyncing         StatusFd5Enum = "SYNCING"
	StatusFd5EnumDone            StatusFd5Enum = "DONE"
	StatusFd5EnumFailed          StatusFd5Enum = "FAILED"
	StatusFd5EnumDisabled        StatusFd5Enum = "DISABLED"
	StatusFd5EnumPaused          StatusFd5Enum = "PAUSED"
	StatusFd5EnumPartiallySynced StatusFd5Enum = "PARTIALLY_SYNCED"
)

func NewStatusFd5EnumFromString(s string) (StatusFd5Enum, error) {
	switch s {
	case "SYNCING":
		return StatusFd5EnumSyncing, nil
	case "DONE":
		return StatusFd5EnumDone, nil
	case "FAILED":
		return StatusFd5EnumFailed, nil
	case "DISABLED":
		return StatusFd5EnumDisabled, nil
	case "PAUSED":
		return StatusFd5EnumPaused, nil
	case "PARTIALLY_SYNCED":
		return StatusFd5EnumPartiallySynced, nil
	}
	var t StatusFd5Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusFd5Enum) Ptr() *StatusFd5Enum {
	return &s
}

// # The SyncStatus Object
// ### Description
// The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name" url:"model_name"`
	ModelId                          string                                `json:"model_id" url:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty" url:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty" url:"next_sync_start,omitempty"`
	LastSyncResult                   *LastSyncResultEnum                   `json:"last_sync_result,omitempty" url:"last_sync_result,omitempty"`
	LastSyncFinished                 *time.Time                            `json:"last_sync_finished,omitempty" url:"last_sync_finished,omitempty"`
	Status                           StatusFd5Enum                         `json:"status" url:"status"`
	IsInitialSync                    bool                                  `json:"is_initial_sync" url:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty" url:"selective_sync_configurations_usage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncStatus) GetModelName() string {
	if s == nil {
		return ""
	}
	return s.ModelName
}

func (s *SyncStatus) GetModelId() string {
	if s == nil {
		return ""
	}
	return s.ModelId
}

func (s *SyncStatus) GetLastSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncStart
}

func (s *SyncStatus) GetNextSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.NextSyncStart
}

func (s *SyncStatus) GetLastSyncResult() *LastSyncResultEnum {
	if s == nil {
		return nil
	}
	return s.LastSyncResult
}

func (s *SyncStatus) GetLastSyncFinished() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncFinished
}

func (s *SyncStatus) GetStatus() StatusFd5Enum {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SyncStatus) GetIsInitialSync() bool {
	if s == nil {
		return false
	}
	return s.IsInitialSync
}

func (s *SyncStatus) GetSelectiveSyncConfigurationsUsage() *SelectiveSyncConfigurationsUsageEnum {
	if s == nil {
		return nil
	}
	return s.SelectiveSyncConfigurationsUsage
}

func (s *SyncStatus) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncStatus) UnmarshalJSON(data []byte) error {
	type embed SyncStatus
	var unmarshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SyncStatus(unmarshaler.embed)
	s.LastSyncStart = unmarshaler.LastSyncStart.TimePtr()
	s.NextSyncStart = unmarshaler.NextSyncStart.TimePtr()
	s.LastSyncFinished = unmarshaler.LastSyncFinished.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatus) MarshalJSON() ([]byte, error) {
	type embed SyncStatus
	var marshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed:            embed(*s),
		LastSyncStart:    internal.NewOptionalDateTime(s.LastSyncStart),
		NextSyncStart:    internal.NewOptionalDateTime(s.NextSyncStart),
		LastSyncFinished: internal.NewOptionalDateTime(s.LastSyncFinished),
	}
	return json.Marshal(marshaler)
}

func (s *SyncStatus) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// # The TaxRate Object
// ### Description
// The `TaxComponent` object is used to represent any sub-taxes that make up the `TaxRate`.
//
// ### Usage Example
// Fetch from the `LIST TaxRates` endpoint and view tax components relevant to a tax rate.
type TaxComponent struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The tax rate’s name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The tax component’s rate.
	Rate *string `json:"rate,omitempty" url:"rate,omitempty"`
	// Returns True if the tax component is compound, False if not.
	IsCompound *bool `json:"is_compound,omitempty" url:"is_compound,omitempty"`
	// Returns PURCHASE if the tax component corresponds to a purchase tax or SALES if the tax component corresponds to a sales tax.
	//
	// * `SALES` - SALES
	// * `PURCHASE` - PURCHASE
	ComponentType *ComponentTypeEnum `json:"component_type,omitempty" url:"component_type,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaxComponent) GetId() *string {
	if t == nil {
		return nil
	}
	return t.Id
}

func (t *TaxComponent) GetRemoteId() *string {
	if t == nil {
		return nil
	}
	return t.RemoteId
}

func (t *TaxComponent) GetCreatedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TaxComponent) GetModifiedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.ModifiedAt
}

func (t *TaxComponent) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TaxComponent) GetRate() *string {
	if t == nil {
		return nil
	}
	return t.Rate
}

func (t *TaxComponent) GetIsCompound() *bool {
	if t == nil {
		return nil
	}
	return t.IsCompound
}

func (t *TaxComponent) GetComponentType() *ComponentTypeEnum {
	if t == nil {
		return nil
	}
	return t.ComponentType
}

func (t *TaxComponent) GetRemoteWasDeleted() *bool {
	if t == nil {
		return nil
	}
	return t.RemoteWasDeleted
}

func (t *TaxComponent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxComponent) UnmarshalJSON(data []byte) error {
	type embed TaxComponent
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TaxComponent(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	t.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxComponent) MarshalJSON() ([]byte, error) {
	type embed TaxComponent
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*t),
		CreatedAt:  internal.NewOptionalDateTime(t.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(t.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TaxComponent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// # The TaxRate Object
// ### Description
// The `TaxRate` object is used to represent a tax rate.
//
// ### Usage Example
// Fetch from the `LIST TaxRates` endpoint and view tax rates relevant to a company.
type TaxRate struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The subsidiary that the tax rate belongs to (in the case of multi-entity systems).
	Company *TaxRateCompany `json:"company,omitempty" url:"company,omitempty"`
	// The tax code associated with this tax rate or group of tax rates from the third-party platform.
	Code *string `json:"code,omitempty" url:"code,omitempty"`
	// The tax rate’s name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The tax rate's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The tax rate’s status - `ACTIVE` if an active tax rate, `ARCHIVED` if not active.
	//
	// * `ACTIVE` - ACTIVE
	// * `ARCHIVED` - ARCHIVED
	Status *Status7D1Enum `json:"status,omitempty" url:"status,omitempty"`
	// The country the tax rate is associated with.
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// The tax’s total tax rate - sum of the tax components (not compounded).
	TotalTaxRate *float64 `json:"total_tax_rate,omitempty" url:"total_tax_rate,omitempty"`
	// The tax rate’s effective tax rate - total amount of tax with compounding.
	EffectiveTaxRate *float64 `json:"effective_tax_rate,omitempty" url:"effective_tax_rate,omitempty"`
	// The related tax components of the tax rate.
	TaxComponents []*TaxRateTaxComponentsItem `json:"tax_components,omitempty" url:"tax_components,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaxRate) GetId() *string {
	if t == nil {
		return nil
	}
	return t.Id
}

func (t *TaxRate) GetRemoteId() *string {
	if t == nil {
		return nil
	}
	return t.RemoteId
}

func (t *TaxRate) GetCreatedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TaxRate) GetModifiedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.ModifiedAt
}

func (t *TaxRate) GetCompany() *TaxRateCompany {
	if t == nil {
		return nil
	}
	return t.Company
}

func (t *TaxRate) GetCode() *string {
	if t == nil {
		return nil
	}
	return t.Code
}

func (t *TaxRate) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TaxRate) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TaxRate) GetStatus() *Status7D1Enum {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TaxRate) GetCountry() *string {
	if t == nil {
		return nil
	}
	return t.Country
}

func (t *TaxRate) GetTotalTaxRate() *float64 {
	if t == nil {
		return nil
	}
	return t.TotalTaxRate
}

func (t *TaxRate) GetEffectiveTaxRate() *float64 {
	if t == nil {
		return nil
	}
	return t.EffectiveTaxRate
}

func (t *TaxRate) GetTaxComponents() []*TaxRateTaxComponentsItem {
	if t == nil {
		return nil
	}
	return t.TaxComponents
}

func (t *TaxRate) GetRemoteWasDeleted() *bool {
	if t == nil {
		return nil
	}
	return t.RemoteWasDeleted
}

func (t *TaxRate) GetFieldMappings() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.FieldMappings
}

func (t *TaxRate) GetRemoteData() []*RemoteData {
	if t == nil {
		return nil
	}
	return t.RemoteData
}

func (t *TaxRate) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxRate) UnmarshalJSON(data []byte) error {
	type embed TaxRate
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TaxRate(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	t.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxRate) MarshalJSON() ([]byte, error) {
	type embed TaxRate
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*t),
		CreatedAt:  internal.NewOptionalDateTime(t.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(t.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TaxRate) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The subsidiary that the tax rate belongs to (in the case of multi-entity systems).
type TaxRateCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (t *TaxRateCompany) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TaxRateCompany) GetCompanyInfo() *CompanyInfo {
	if t == nil {
		return nil
	}
	return t.CompanyInfo
}

func (t *TaxRateCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		t.typ = "CompanyInfo"
		t.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaxRateCompany) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CompanyInfo" || t.CompanyInfo != nil {
		return json.Marshal(t.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TaxRateCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (t *TaxRateCompany) Accept(visitor TaxRateCompanyVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CompanyInfo" || t.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(t.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TaxRateTaxComponentsItem struct {
	String       string
	TaxComponent *TaxComponent

	typ string
}

func (t *TaxRateTaxComponentsItem) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TaxRateTaxComponentsItem) GetTaxComponent() *TaxComponent {
	if t == nil {
		return nil
	}
	return t.TaxComponent
}

func (t *TaxRateTaxComponentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueTaxComponent := new(TaxComponent)
	if err := json.Unmarshal(data, &valueTaxComponent); err == nil {
		t.typ = "TaxComponent"
		t.TaxComponent = valueTaxComponent
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaxRateTaxComponentsItem) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "TaxComponent" || t.TaxComponent != nil {
		return json.Marshal(t.TaxComponent)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TaxRateTaxComponentsItemVisitor interface {
	VisitString(string) error
	VisitTaxComponent(*TaxComponent) error
}

func (t *TaxRateTaxComponentsItem) Accept(visitor TaxRateTaxComponentsItemVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "TaxComponent" || t.TaxComponent != nil {
		return visitor.VisitTaxComponent(t.TaxComponent)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// # The TrackingCategory Object
// ### Description
// A `TrackingCategory` object represents a categorization method used to classify transactions within an accounting platform. They are often used to group records for reporting and analysis purposes. The most common types of `TrackingCategories` are Classes and Departments.
//
// ### Usage Example
// Fetch from the `GET TrackingCategory` endpoint and view a company's tracking category.
type TrackingCategory struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The tracking category's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The tracking category's status.
	//
	// * `ACTIVE` - ACTIVE
	// * `ARCHIVED` - ARCHIVED
	Status *Status7D1Enum `json:"status,omitempty" url:"status,omitempty"`
	// The tracking category’s type.
	//
	// * `CLASS` - CLASS
	// * `DEPARTMENT` - DEPARTMENT
	CategoryType   *CategoryTypeEnum `json:"category_type,omitempty" url:"category_type,omitempty"`
	ParentCategory *string           `json:"parent_category,omitempty" url:"parent_category,omitempty"`
	// The company the GeneralLedgerTransaction belongs to.
	Company *TrackingCategoryCompany `json:"company,omitempty" url:"company,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TrackingCategory) GetId() *string {
	if t == nil {
		return nil
	}
	return t.Id
}

func (t *TrackingCategory) GetRemoteId() *string {
	if t == nil {
		return nil
	}
	return t.RemoteId
}

func (t *TrackingCategory) GetCreatedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TrackingCategory) GetModifiedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.ModifiedAt
}

func (t *TrackingCategory) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TrackingCategory) GetStatus() *Status7D1Enum {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TrackingCategory) GetCategoryType() *CategoryTypeEnum {
	if t == nil {
		return nil
	}
	return t.CategoryType
}

func (t *TrackingCategory) GetParentCategory() *string {
	if t == nil {
		return nil
	}
	return t.ParentCategory
}

func (t *TrackingCategory) GetCompany() *TrackingCategoryCompany {
	if t == nil {
		return nil
	}
	return t.Company
}

func (t *TrackingCategory) GetRemoteWasDeleted() *bool {
	if t == nil {
		return nil
	}
	return t.RemoteWasDeleted
}

func (t *TrackingCategory) GetFieldMappings() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.FieldMappings
}

func (t *TrackingCategory) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TrackingCategory) UnmarshalJSON(data []byte) error {
	type embed TrackingCategory
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TrackingCategory(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	t.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrackingCategory) MarshalJSON() ([]byte, error) {
	type embed TrackingCategory
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*t),
		CreatedAt:  internal.NewOptionalDateTime(t.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(t.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TrackingCategory) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The company the GeneralLedgerTransaction belongs to.
type TrackingCategoryCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (t *TrackingCategoryCompany) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TrackingCategoryCompany) GetCompanyInfo() *CompanyInfo {
	if t == nil {
		return nil
	}
	return t.CompanyInfo
}

func (t *TrackingCategoryCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		t.typ = "CompanyInfo"
		t.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TrackingCategoryCompany) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CompanyInfo" || t.CompanyInfo != nil {
		return json.Marshal(t.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TrackingCategoryCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (t *TrackingCategoryCompany) Accept(visitor TrackingCategoryCompanyVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CompanyInfo" || t.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(t.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type TransactionCurrencyEnum string

const (
	TransactionCurrencyEnumXua TransactionCurrencyEnum = "XUA"
	TransactionCurrencyEnumAfn TransactionCurrencyEnum = "AFN"
	TransactionCurrencyEnumAfa TransactionCurrencyEnum = "AFA"
	TransactionCurrencyEnumAll TransactionCurrencyEnum = "ALL"
	TransactionCurrencyEnumAlk TransactionCurrencyEnum = "ALK"
	TransactionCurrencyEnumDzd TransactionCurrencyEnum = "DZD"
	TransactionCurrencyEnumAdp TransactionCurrencyEnum = "ADP"
	TransactionCurrencyEnumAoa TransactionCurrencyEnum = "AOA"
	TransactionCurrencyEnumAok TransactionCurrencyEnum = "AOK"
	TransactionCurrencyEnumAon TransactionCurrencyEnum = "AON"
	TransactionCurrencyEnumAor TransactionCurrencyEnum = "AOR"
	TransactionCurrencyEnumAra TransactionCurrencyEnum = "ARA"
	TransactionCurrencyEnumArs TransactionCurrencyEnum = "ARS"
	TransactionCurrencyEnumArm TransactionCurrencyEnum = "ARM"
	TransactionCurrencyEnumArp TransactionCurrencyEnum = "ARP"
	TransactionCurrencyEnumArl TransactionCurrencyEnum = "ARL"
	TransactionCurrencyEnumAmd TransactionCurrencyEnum = "AMD"
	TransactionCurrencyEnumAwg TransactionCurrencyEnum = "AWG"
	TransactionCurrencyEnumAud TransactionCurrencyEnum = "AUD"
	TransactionCurrencyEnumAts TransactionCurrencyEnum = "ATS"
	TransactionCurrencyEnumAzn TransactionCurrencyEnum = "AZN"
	TransactionCurrencyEnumAzm TransactionCurrencyEnum = "AZM"
	TransactionCurrencyEnumBsd TransactionCurrencyEnum = "BSD"
	TransactionCurrencyEnumBhd TransactionCurrencyEnum = "BHD"
	TransactionCurrencyEnumBdt TransactionCurrencyEnum = "BDT"
	TransactionCurrencyEnumBbd TransactionCurrencyEnum = "BBD"
	TransactionCurrencyEnumByn TransactionCurrencyEnum = "BYN"
	TransactionCurrencyEnumByb TransactionCurrencyEnum = "BYB"
	TransactionCurrencyEnumByr TransactionCurrencyEnum = "BYR"
	TransactionCurrencyEnumBef TransactionCurrencyEnum = "BEF"
	TransactionCurrencyEnumBec TransactionCurrencyEnum = "BEC"
	TransactionCurrencyEnumBel TransactionCurrencyEnum = "BEL"
	TransactionCurrencyEnumBzd TransactionCurrencyEnum = "BZD"
	TransactionCurrencyEnumBmd TransactionCurrencyEnum = "BMD"
	TransactionCurrencyEnumBtn TransactionCurrencyEnum = "BTN"
	TransactionCurrencyEnumBob TransactionCurrencyEnum = "BOB"
	TransactionCurrencyEnumBol TransactionCurrencyEnum = "BOL"
	TransactionCurrencyEnumBov TransactionCurrencyEnum = "BOV"
	TransactionCurrencyEnumBop TransactionCurrencyEnum = "BOP"
	TransactionCurrencyEnumBam TransactionCurrencyEnum = "BAM"
	TransactionCurrencyEnumBad TransactionCurrencyEnum = "BAD"
	TransactionCurrencyEnumBan TransactionCurrencyEnum = "BAN"
	TransactionCurrencyEnumBwp TransactionCurrencyEnum = "BWP"
	TransactionCurrencyEnumBrc TransactionCurrencyEnum = "BRC"
	TransactionCurrencyEnumBrz TransactionCurrencyEnum = "BRZ"
	TransactionCurrencyEnumBre TransactionCurrencyEnum = "BRE"
	TransactionCurrencyEnumBrr TransactionCurrencyEnum = "BRR"
	TransactionCurrencyEnumBrn TransactionCurrencyEnum = "BRN"
	TransactionCurrencyEnumBrb TransactionCurrencyEnum = "BRB"
	TransactionCurrencyEnumBrl TransactionCurrencyEnum = "BRL"
	TransactionCurrencyEnumGbp TransactionCurrencyEnum = "GBP"
	TransactionCurrencyEnumBnd TransactionCurrencyEnum = "BND"
	TransactionCurrencyEnumBgl TransactionCurrencyEnum = "BGL"
	TransactionCurrencyEnumBgn TransactionCurrencyEnum = "BGN"
	TransactionCurrencyEnumBgo TransactionCurrencyEnum = "BGO"
	TransactionCurrencyEnumBgm TransactionCurrencyEnum = "BGM"
	TransactionCurrencyEnumBuk TransactionCurrencyEnum = "BUK"
	TransactionCurrencyEnumBif TransactionCurrencyEnum = "BIF"
	TransactionCurrencyEnumXpf TransactionCurrencyEnum = "XPF"
	TransactionCurrencyEnumKhr TransactionCurrencyEnum = "KHR"
	TransactionCurrencyEnumCad TransactionCurrencyEnum = "CAD"
	TransactionCurrencyEnumCve TransactionCurrencyEnum = "CVE"
	TransactionCurrencyEnumKyd TransactionCurrencyEnum = "KYD"
	TransactionCurrencyEnumXaf TransactionCurrencyEnum = "XAF"
	TransactionCurrencyEnumCle TransactionCurrencyEnum = "CLE"
	TransactionCurrencyEnumClp TransactionCurrencyEnum = "CLP"
	TransactionCurrencyEnumClf TransactionCurrencyEnum = "CLF"
	TransactionCurrencyEnumCnx TransactionCurrencyEnum = "CNX"
	TransactionCurrencyEnumCny TransactionCurrencyEnum = "CNY"
	TransactionCurrencyEnumCnh TransactionCurrencyEnum = "CNH"
	TransactionCurrencyEnumCop TransactionCurrencyEnum = "COP"
	TransactionCurrencyEnumCou TransactionCurrencyEnum = "COU"
	TransactionCurrencyEnumKmf TransactionCurrencyEnum = "KMF"
	TransactionCurrencyEnumCdf TransactionCurrencyEnum = "CDF"
	TransactionCurrencyEnumCrc TransactionCurrencyEnum = "CRC"
	TransactionCurrencyEnumHrd TransactionCurrencyEnum = "HRD"
	TransactionCurrencyEnumHrk TransactionCurrencyEnum = "HRK"
	TransactionCurrencyEnumCuc TransactionCurrencyEnum = "CUC"
	TransactionCurrencyEnumCup TransactionCurrencyEnum = "CUP"
	TransactionCurrencyEnumCyp TransactionCurrencyEnum = "CYP"
	TransactionCurrencyEnumCzk TransactionCurrencyEnum = "CZK"
	TransactionCurrencyEnumCsk TransactionCurrencyEnum = "CSK"
	TransactionCurrencyEnumDkk TransactionCurrencyEnum = "DKK"
	TransactionCurrencyEnumDjf TransactionCurrencyEnum = "DJF"
	TransactionCurrencyEnumDop TransactionCurrencyEnum = "DOP"
	TransactionCurrencyEnumNlg TransactionCurrencyEnum = "NLG"
	TransactionCurrencyEnumXcd TransactionCurrencyEnum = "XCD"
	TransactionCurrencyEnumDdm TransactionCurrencyEnum = "DDM"
	TransactionCurrencyEnumEcs TransactionCurrencyEnum = "ECS"
	TransactionCurrencyEnumEcv TransactionCurrencyEnum = "ECV"
	TransactionCurrencyEnumEgp TransactionCurrencyEnum = "EGP"
	TransactionCurrencyEnumGqe TransactionCurrencyEnum = "GQE"
	TransactionCurrencyEnumErn TransactionCurrencyEnum = "ERN"
	TransactionCurrencyEnumEek TransactionCurrencyEnum = "EEK"
	TransactionCurrencyEnumEtb TransactionCurrencyEnum = "ETB"
	TransactionCurrencyEnumEur TransactionCurrencyEnum = "EUR"
	TransactionCurrencyEnumXba TransactionCurrencyEnum = "XBA"
	TransactionCurrencyEnumXeu TransactionCurrencyEnum = "XEU"
	TransactionCurrencyEnumXbb TransactionCurrencyEnum = "XBB"
	TransactionCurrencyEnumXbc TransactionCurrencyEnum = "XBC"
	TransactionCurrencyEnumXbd TransactionCurrencyEnum = "XBD"
	TransactionCurrencyEnumFkp TransactionCurrencyEnum = "FKP"
	TransactionCurrencyEnumFjd TransactionCurrencyEnum = "FJD"
	TransactionCurrencyEnumFim TransactionCurrencyEnum = "FIM"
	TransactionCurrencyEnumFrf TransactionCurrencyEnum = "FRF"
	TransactionCurrencyEnumXfo TransactionCurrencyEnum = "XFO"
	TransactionCurrencyEnumXfu TransactionCurrencyEnum = "XFU"
	TransactionCurrencyEnumGmd TransactionCurrencyEnum = "GMD"
	TransactionCurrencyEnumGek TransactionCurrencyEnum = "GEK"
	TransactionCurrencyEnumGel TransactionCurrencyEnum = "GEL"
	TransactionCurrencyEnumDem TransactionCurrencyEnum = "DEM"
	TransactionCurrencyEnumGhs TransactionCurrencyEnum = "GHS"
	TransactionCurrencyEnumGhc TransactionCurrencyEnum = "GHC"
	TransactionCurrencyEnumGip TransactionCurrencyEnum = "GIP"
	TransactionCurrencyEnumXau TransactionCurrencyEnum = "XAU"
	TransactionCurrencyEnumGrd TransactionCurrencyEnum = "GRD"
	TransactionCurrencyEnumGtq TransactionCurrencyEnum = "GTQ"
	TransactionCurrencyEnumGwp TransactionCurrencyEnum = "GWP"
	TransactionCurrencyEnumGnf TransactionCurrencyEnum = "GNF"
	TransactionCurrencyEnumGns TransactionCurrencyEnum = "GNS"
	TransactionCurrencyEnumGyd TransactionCurrencyEnum = "GYD"
	TransactionCurrencyEnumHtg TransactionCurrencyEnum = "HTG"
	TransactionCurrencyEnumHnl TransactionCurrencyEnum = "HNL"
	TransactionCurrencyEnumHkd TransactionCurrencyEnum = "HKD"
	TransactionCurrencyEnumHuf TransactionCurrencyEnum = "HUF"
	TransactionCurrencyEnumImp TransactionCurrencyEnum = "IMP"
	TransactionCurrencyEnumIsk TransactionCurrencyEnum = "ISK"
	TransactionCurrencyEnumIsj TransactionCurrencyEnum = "ISJ"
	TransactionCurrencyEnumInr TransactionCurrencyEnum = "INR"
	TransactionCurrencyEnumIdr TransactionCurrencyEnum = "IDR"
	TransactionCurrencyEnumIrr TransactionCurrencyEnum = "IRR"
	TransactionCurrencyEnumIqd TransactionCurrencyEnum = "IQD"
	TransactionCurrencyEnumIep TransactionCurrencyEnum = "IEP"
	TransactionCurrencyEnumIls TransactionCurrencyEnum = "ILS"
	TransactionCurrencyEnumIlp TransactionCurrencyEnum = "ILP"
	TransactionCurrencyEnumIlr TransactionCurrencyEnum = "ILR"
	TransactionCurrencyEnumItl TransactionCurrencyEnum = "ITL"
	TransactionCurrencyEnumJmd TransactionCurrencyEnum = "JMD"
	TransactionCurrencyEnumJpy TransactionCurrencyEnum = "JPY"
	TransactionCurrencyEnumJod TransactionCurrencyEnum = "JOD"
	TransactionCurrencyEnumKzt TransactionCurrencyEnum = "KZT"
	TransactionCurrencyEnumKes TransactionCurrencyEnum = "KES"
	TransactionCurrencyEnumKwd TransactionCurrencyEnum = "KWD"
	TransactionCurrencyEnumKgs TransactionCurrencyEnum = "KGS"
	TransactionCurrencyEnumLak TransactionCurrencyEnum = "LAK"
	TransactionCurrencyEnumLvl TransactionCurrencyEnum = "LVL"
	TransactionCurrencyEnumLvr TransactionCurrencyEnum = "LVR"
	TransactionCurrencyEnumLbp TransactionCurrencyEnum = "LBP"
	TransactionCurrencyEnumLsl TransactionCurrencyEnum = "LSL"
	TransactionCurrencyEnumLrd TransactionCurrencyEnum = "LRD"
	TransactionCurrencyEnumLyd TransactionCurrencyEnum = "LYD"
	TransactionCurrencyEnumLtl TransactionCurrencyEnum = "LTL"
	TransactionCurrencyEnumLtt TransactionCurrencyEnum = "LTT"
	TransactionCurrencyEnumLul TransactionCurrencyEnum = "LUL"
	TransactionCurrencyEnumLuc TransactionCurrencyEnum = "LUC"
	TransactionCurrencyEnumLuf TransactionCurrencyEnum = "LUF"
	TransactionCurrencyEnumMop TransactionCurrencyEnum = "MOP"
	TransactionCurrencyEnumMkd TransactionCurrencyEnum = "MKD"
	TransactionCurrencyEnumMkn TransactionCurrencyEnum = "MKN"
	TransactionCurrencyEnumMga TransactionCurrencyEnum = "MGA"
	TransactionCurrencyEnumMgf TransactionCurrencyEnum = "MGF"
	TransactionCurrencyEnumMwk TransactionCurrencyEnum = "MWK"
	TransactionCurrencyEnumMyr TransactionCurrencyEnum = "MYR"
	TransactionCurrencyEnumMvr TransactionCurrencyEnum = "MVR"
	TransactionCurrencyEnumMvp TransactionCurrencyEnum = "MVP"
	TransactionCurrencyEnumMlf TransactionCurrencyEnum = "MLF"
	TransactionCurrencyEnumMtl TransactionCurrencyEnum = "MTL"
	TransactionCurrencyEnumMtp TransactionCurrencyEnum = "MTP"
	TransactionCurrencyEnumMru TransactionCurrencyEnum = "MRU"
	TransactionCurrencyEnumMro TransactionCurrencyEnum = "MRO"
	TransactionCurrencyEnumMur TransactionCurrencyEnum = "MUR"
	TransactionCurrencyEnumMxv TransactionCurrencyEnum = "MXV"
	TransactionCurrencyEnumMxn TransactionCurrencyEnum = "MXN"
	TransactionCurrencyEnumMxp TransactionCurrencyEnum = "MXP"
	TransactionCurrencyEnumMdc TransactionCurrencyEnum = "MDC"
	TransactionCurrencyEnumMdl TransactionCurrencyEnum = "MDL"
	TransactionCurrencyEnumMcf TransactionCurrencyEnum = "MCF"
	TransactionCurrencyEnumMnt TransactionCurrencyEnum = "MNT"
	TransactionCurrencyEnumMad TransactionCurrencyEnum = "MAD"
	TransactionCurrencyEnumMaf TransactionCurrencyEnum = "MAF"
	TransactionCurrencyEnumMze TransactionCurrencyEnum = "MZE"
	TransactionCurrencyEnumMzn TransactionCurrencyEnum = "MZN"
	TransactionCurrencyEnumMzm TransactionCurrencyEnum = "MZM"
	TransactionCurrencyEnumMmk TransactionCurrencyEnum = "MMK"
	TransactionCurrencyEnumNad TransactionCurrencyEnum = "NAD"
	TransactionCurrencyEnumNpr TransactionCurrencyEnum = "NPR"
	TransactionCurrencyEnumAng TransactionCurrencyEnum = "ANG"
	TransactionCurrencyEnumTwd TransactionCurrencyEnum = "TWD"
	TransactionCurrencyEnumNzd TransactionCurrencyEnum = "NZD"
	TransactionCurrencyEnumNio TransactionCurrencyEnum = "NIO"
	TransactionCurrencyEnumNic TransactionCurrencyEnum = "NIC"
	TransactionCurrencyEnumNgn TransactionCurrencyEnum = "NGN"
	TransactionCurrencyEnumKpw TransactionCurrencyEnum = "KPW"
	TransactionCurrencyEnumNok TransactionCurrencyEnum = "NOK"
	TransactionCurrencyEnumOmr TransactionCurrencyEnum = "OMR"
	TransactionCurrencyEnumPkr TransactionCurrencyEnum = "PKR"
	TransactionCurrencyEnumXpd TransactionCurrencyEnum = "XPD"
	TransactionCurrencyEnumPab TransactionCurrencyEnum = "PAB"
	TransactionCurrencyEnumPgk TransactionCurrencyEnum = "PGK"
	TransactionCurrencyEnumPyg TransactionCurrencyEnum = "PYG"
	TransactionCurrencyEnumPei TransactionCurrencyEnum = "PEI"
	TransactionCurrencyEnumPen TransactionCurrencyEnum = "PEN"
	TransactionCurrencyEnumPes TransactionCurrencyEnum = "PES"
	TransactionCurrencyEnumPhp TransactionCurrencyEnum = "PHP"
	TransactionCurrencyEnumXpt TransactionCurrencyEnum = "XPT"
	TransactionCurrencyEnumPln TransactionCurrencyEnum = "PLN"
	TransactionCurrencyEnumPlz TransactionCurrencyEnum = "PLZ"
	TransactionCurrencyEnumPte TransactionCurrencyEnum = "PTE"
	TransactionCurrencyEnumGwe TransactionCurrencyEnum = "GWE"
	TransactionCurrencyEnumQar TransactionCurrencyEnum = "QAR"
	TransactionCurrencyEnumXre TransactionCurrencyEnum = "XRE"
	TransactionCurrencyEnumRhd TransactionCurrencyEnum = "RHD"
	TransactionCurrencyEnumRon TransactionCurrencyEnum = "RON"
	TransactionCurrencyEnumRol TransactionCurrencyEnum = "ROL"
	TransactionCurrencyEnumRub TransactionCurrencyEnum = "RUB"
	TransactionCurrencyEnumRur TransactionCurrencyEnum = "RUR"
	TransactionCurrencyEnumRwf TransactionCurrencyEnum = "RWF"
	TransactionCurrencyEnumSvc TransactionCurrencyEnum = "SVC"
	TransactionCurrencyEnumWst TransactionCurrencyEnum = "WST"
	TransactionCurrencyEnumSar TransactionCurrencyEnum = "SAR"
	TransactionCurrencyEnumRsd TransactionCurrencyEnum = "RSD"
	TransactionCurrencyEnumCsd TransactionCurrencyEnum = "CSD"
	TransactionCurrencyEnumScr TransactionCurrencyEnum = "SCR"
	TransactionCurrencyEnumSll TransactionCurrencyEnum = "SLL"
	TransactionCurrencyEnumXag TransactionCurrencyEnum = "XAG"
	TransactionCurrencyEnumSgd TransactionCurrencyEnum = "SGD"
	TransactionCurrencyEnumSkk TransactionCurrencyEnum = "SKK"
	TransactionCurrencyEnumSit TransactionCurrencyEnum = "SIT"
	TransactionCurrencyEnumSbd TransactionCurrencyEnum = "SBD"
	TransactionCurrencyEnumSos TransactionCurrencyEnum = "SOS"
	TransactionCurrencyEnumZar TransactionCurrencyEnum = "ZAR"
	TransactionCurrencyEnumZal TransactionCurrencyEnum = "ZAL"
	TransactionCurrencyEnumKrh TransactionCurrencyEnum = "KRH"
	TransactionCurrencyEnumKrw TransactionCurrencyEnum = "KRW"
	TransactionCurrencyEnumKro TransactionCurrencyEnum = "KRO"
	TransactionCurrencyEnumSsp TransactionCurrencyEnum = "SSP"
	TransactionCurrencyEnumSur TransactionCurrencyEnum = "SUR"
	TransactionCurrencyEnumEsp TransactionCurrencyEnum = "ESP"
	TransactionCurrencyEnumEsa TransactionCurrencyEnum = "ESA"
	TransactionCurrencyEnumEsb TransactionCurrencyEnum = "ESB"
	TransactionCurrencyEnumXdr TransactionCurrencyEnum = "XDR"
	TransactionCurrencyEnumLkr TransactionCurrencyEnum = "LKR"
	TransactionCurrencyEnumShp TransactionCurrencyEnum = "SHP"
	TransactionCurrencyEnumXsu TransactionCurrencyEnum = "XSU"
	TransactionCurrencyEnumSdd TransactionCurrencyEnum = "SDD"
	TransactionCurrencyEnumSdg TransactionCurrencyEnum = "SDG"
	TransactionCurrencyEnumSdp TransactionCurrencyEnum = "SDP"
	TransactionCurrencyEnumSrd TransactionCurrencyEnum = "SRD"
	TransactionCurrencyEnumSrg TransactionCurrencyEnum = "SRG"
	TransactionCurrencyEnumSzl TransactionCurrencyEnum = "SZL"
	TransactionCurrencyEnumSek TransactionCurrencyEnum = "SEK"
	TransactionCurrencyEnumChf TransactionCurrencyEnum = "CHF"
	TransactionCurrencyEnumSyp TransactionCurrencyEnum = "SYP"
	TransactionCurrencyEnumStn TransactionCurrencyEnum = "STN"
	TransactionCurrencyEnumStd TransactionCurrencyEnum = "STD"
	TransactionCurrencyEnumTvd TransactionCurrencyEnum = "TVD"
	TransactionCurrencyEnumTjr TransactionCurrencyEnum = "TJR"
	TransactionCurrencyEnumTjs TransactionCurrencyEnum = "TJS"
	TransactionCurrencyEnumTzs TransactionCurrencyEnum = "TZS"
	TransactionCurrencyEnumXts TransactionCurrencyEnum = "XTS"
	TransactionCurrencyEnumThb TransactionCurrencyEnum = "THB"
	TransactionCurrencyEnumXxx TransactionCurrencyEnum = "XXX"
	TransactionCurrencyEnumTpe TransactionCurrencyEnum = "TPE"
	TransactionCurrencyEnumTop TransactionCurrencyEnum = "TOP"
	TransactionCurrencyEnumTtd TransactionCurrencyEnum = "TTD"
	TransactionCurrencyEnumTnd TransactionCurrencyEnum = "TND"
	TransactionCurrencyEnumTry TransactionCurrencyEnum = "TRY"
	TransactionCurrencyEnumTrl TransactionCurrencyEnum = "TRL"
	TransactionCurrencyEnumTmt TransactionCurrencyEnum = "TMT"
	TransactionCurrencyEnumTmm TransactionCurrencyEnum = "TMM"
	TransactionCurrencyEnumUsd TransactionCurrencyEnum = "USD"
	TransactionCurrencyEnumUsn TransactionCurrencyEnum = "USN"
	TransactionCurrencyEnumUss TransactionCurrencyEnum = "USS"
	TransactionCurrencyEnumUgx TransactionCurrencyEnum = "UGX"
	TransactionCurrencyEnumUgs TransactionCurrencyEnum = "UGS"
	TransactionCurrencyEnumUah TransactionCurrencyEnum = "UAH"
	TransactionCurrencyEnumUak TransactionCurrencyEnum = "UAK"
	TransactionCurrencyEnumAed TransactionCurrencyEnum = "AED"
	TransactionCurrencyEnumUyw TransactionCurrencyEnum = "UYW"
	TransactionCurrencyEnumUyu TransactionCurrencyEnum = "UYU"
	TransactionCurrencyEnumUyp TransactionCurrencyEnum = "UYP"
	TransactionCurrencyEnumUyi TransactionCurrencyEnum = "UYI"
	TransactionCurrencyEnumUzs TransactionCurrencyEnum = "UZS"
	TransactionCurrencyEnumVuv TransactionCurrencyEnum = "VUV"
	TransactionCurrencyEnumVes TransactionCurrencyEnum = "VES"
	TransactionCurrencyEnumVeb TransactionCurrencyEnum = "VEB"
	TransactionCurrencyEnumVef TransactionCurrencyEnum = "VEF"
	TransactionCurrencyEnumVnd TransactionCurrencyEnum = "VND"
	TransactionCurrencyEnumVnn TransactionCurrencyEnum = "VNN"
	TransactionCurrencyEnumChe TransactionCurrencyEnum = "CHE"
	TransactionCurrencyEnumChw TransactionCurrencyEnum = "CHW"
	TransactionCurrencyEnumXof TransactionCurrencyEnum = "XOF"
	TransactionCurrencyEnumYdd TransactionCurrencyEnum = "YDD"
	TransactionCurrencyEnumYer TransactionCurrencyEnum = "YER"
	TransactionCurrencyEnumYun TransactionCurrencyEnum = "YUN"
	TransactionCurrencyEnumYud TransactionCurrencyEnum = "YUD"
	TransactionCurrencyEnumYum TransactionCurrencyEnum = "YUM"
	TransactionCurrencyEnumYur TransactionCurrencyEnum = "YUR"
	TransactionCurrencyEnumZwn TransactionCurrencyEnum = "ZWN"
	TransactionCurrencyEnumZrn TransactionCurrencyEnum = "ZRN"
	TransactionCurrencyEnumZrz TransactionCurrencyEnum = "ZRZ"
	TransactionCurrencyEnumZmw TransactionCurrencyEnum = "ZMW"
	TransactionCurrencyEnumZmk TransactionCurrencyEnum = "ZMK"
	TransactionCurrencyEnumZwd TransactionCurrencyEnum = "ZWD"
	TransactionCurrencyEnumZwr TransactionCurrencyEnum = "ZWR"
	TransactionCurrencyEnumZwl TransactionCurrencyEnum = "ZWL"
)

func NewTransactionCurrencyEnumFromString(s string) (TransactionCurrencyEnum, error) {
	switch s {
	case "XUA":
		return TransactionCurrencyEnumXua, nil
	case "AFN":
		return TransactionCurrencyEnumAfn, nil
	case "AFA":
		return TransactionCurrencyEnumAfa, nil
	case "ALL":
		return TransactionCurrencyEnumAll, nil
	case "ALK":
		return TransactionCurrencyEnumAlk, nil
	case "DZD":
		return TransactionCurrencyEnumDzd, nil
	case "ADP":
		return TransactionCurrencyEnumAdp, nil
	case "AOA":
		return TransactionCurrencyEnumAoa, nil
	case "AOK":
		return TransactionCurrencyEnumAok, nil
	case "AON":
		return TransactionCurrencyEnumAon, nil
	case "AOR":
		return TransactionCurrencyEnumAor, nil
	case "ARA":
		return TransactionCurrencyEnumAra, nil
	case "ARS":
		return TransactionCurrencyEnumArs, nil
	case "ARM":
		return TransactionCurrencyEnumArm, nil
	case "ARP":
		return TransactionCurrencyEnumArp, nil
	case "ARL":
		return TransactionCurrencyEnumArl, nil
	case "AMD":
		return TransactionCurrencyEnumAmd, nil
	case "AWG":
		return TransactionCurrencyEnumAwg, nil
	case "AUD":
		return TransactionCurrencyEnumAud, nil
	case "ATS":
		return TransactionCurrencyEnumAts, nil
	case "AZN":
		return TransactionCurrencyEnumAzn, nil
	case "AZM":
		return TransactionCurrencyEnumAzm, nil
	case "BSD":
		return TransactionCurrencyEnumBsd, nil
	case "BHD":
		return TransactionCurrencyEnumBhd, nil
	case "BDT":
		return TransactionCurrencyEnumBdt, nil
	case "BBD":
		return TransactionCurrencyEnumBbd, nil
	case "BYN":
		return TransactionCurrencyEnumByn, nil
	case "BYB":
		return TransactionCurrencyEnumByb, nil
	case "BYR":
		return TransactionCurrencyEnumByr, nil
	case "BEF":
		return TransactionCurrencyEnumBef, nil
	case "BEC":
		return TransactionCurrencyEnumBec, nil
	case "BEL":
		return TransactionCurrencyEnumBel, nil
	case "BZD":
		return TransactionCurrencyEnumBzd, nil
	case "BMD":
		return TransactionCurrencyEnumBmd, nil
	case "BTN":
		return TransactionCurrencyEnumBtn, nil
	case "BOB":
		return TransactionCurrencyEnumBob, nil
	case "BOL":
		return TransactionCurrencyEnumBol, nil
	case "BOV":
		return TransactionCurrencyEnumBov, nil
	case "BOP":
		return TransactionCurrencyEnumBop, nil
	case "BAM":
		return TransactionCurrencyEnumBam, nil
	case "BAD":
		return TransactionCurrencyEnumBad, nil
	case "BAN":
		return TransactionCurrencyEnumBan, nil
	case "BWP":
		return TransactionCurrencyEnumBwp, nil
	case "BRC":
		return TransactionCurrencyEnumBrc, nil
	case "BRZ":
		return TransactionCurrencyEnumBrz, nil
	case "BRE":
		return TransactionCurrencyEnumBre, nil
	case "BRR":
		return TransactionCurrencyEnumBrr, nil
	case "BRN":
		return TransactionCurrencyEnumBrn, nil
	case "BRB":
		return TransactionCurrencyEnumBrb, nil
	case "BRL":
		return TransactionCurrencyEnumBrl, nil
	case "GBP":
		return TransactionCurrencyEnumGbp, nil
	case "BND":
		return TransactionCurrencyEnumBnd, nil
	case "BGL":
		return TransactionCurrencyEnumBgl, nil
	case "BGN":
		return TransactionCurrencyEnumBgn, nil
	case "BGO":
		return TransactionCurrencyEnumBgo, nil
	case "BGM":
		return TransactionCurrencyEnumBgm, nil
	case "BUK":
		return TransactionCurrencyEnumBuk, nil
	case "BIF":
		return TransactionCurrencyEnumBif, nil
	case "XPF":
		return TransactionCurrencyEnumXpf, nil
	case "KHR":
		return TransactionCurrencyEnumKhr, nil
	case "CAD":
		return TransactionCurrencyEnumCad, nil
	case "CVE":
		return TransactionCurrencyEnumCve, nil
	case "KYD":
		return TransactionCurrencyEnumKyd, nil
	case "XAF":
		return TransactionCurrencyEnumXaf, nil
	case "CLE":
		return TransactionCurrencyEnumCle, nil
	case "CLP":
		return TransactionCurrencyEnumClp, nil
	case "CLF":
		return TransactionCurrencyEnumClf, nil
	case "CNX":
		return TransactionCurrencyEnumCnx, nil
	case "CNY":
		return TransactionCurrencyEnumCny, nil
	case "CNH":
		return TransactionCurrencyEnumCnh, nil
	case "COP":
		return TransactionCurrencyEnumCop, nil
	case "COU":
		return TransactionCurrencyEnumCou, nil
	case "KMF":
		return TransactionCurrencyEnumKmf, nil
	case "CDF":
		return TransactionCurrencyEnumCdf, nil
	case "CRC":
		return TransactionCurrencyEnumCrc, nil
	case "HRD":
		return TransactionCurrencyEnumHrd, nil
	case "HRK":
		return TransactionCurrencyEnumHrk, nil
	case "CUC":
		return TransactionCurrencyEnumCuc, nil
	case "CUP":
		return TransactionCurrencyEnumCup, nil
	case "CYP":
		return TransactionCurrencyEnumCyp, nil
	case "CZK":
		return TransactionCurrencyEnumCzk, nil
	case "CSK":
		return TransactionCurrencyEnumCsk, nil
	case "DKK":
		return TransactionCurrencyEnumDkk, nil
	case "DJF":
		return TransactionCurrencyEnumDjf, nil
	case "DOP":
		return TransactionCurrencyEnumDop, nil
	case "NLG":
		return TransactionCurrencyEnumNlg, nil
	case "XCD":
		return TransactionCurrencyEnumXcd, nil
	case "DDM":
		return TransactionCurrencyEnumDdm, nil
	case "ECS":
		return TransactionCurrencyEnumEcs, nil
	case "ECV":
		return TransactionCurrencyEnumEcv, nil
	case "EGP":
		return TransactionCurrencyEnumEgp, nil
	case "GQE":
		return TransactionCurrencyEnumGqe, nil
	case "ERN":
		return TransactionCurrencyEnumErn, nil
	case "EEK":
		return TransactionCurrencyEnumEek, nil
	case "ETB":
		return TransactionCurrencyEnumEtb, nil
	case "EUR":
		return TransactionCurrencyEnumEur, nil
	case "XBA":
		return TransactionCurrencyEnumXba, nil
	case "XEU":
		return TransactionCurrencyEnumXeu, nil
	case "XBB":
		return TransactionCurrencyEnumXbb, nil
	case "XBC":
		return TransactionCurrencyEnumXbc, nil
	case "XBD":
		return TransactionCurrencyEnumXbd, nil
	case "FKP":
		return TransactionCurrencyEnumFkp, nil
	case "FJD":
		return TransactionCurrencyEnumFjd, nil
	case "FIM":
		return TransactionCurrencyEnumFim, nil
	case "FRF":
		return TransactionCurrencyEnumFrf, nil
	case "XFO":
		return TransactionCurrencyEnumXfo, nil
	case "XFU":
		return TransactionCurrencyEnumXfu, nil
	case "GMD":
		return TransactionCurrencyEnumGmd, nil
	case "GEK":
		return TransactionCurrencyEnumGek, nil
	case "GEL":
		return TransactionCurrencyEnumGel, nil
	case "DEM":
		return TransactionCurrencyEnumDem, nil
	case "GHS":
		return TransactionCurrencyEnumGhs, nil
	case "GHC":
		return TransactionCurrencyEnumGhc, nil
	case "GIP":
		return TransactionCurrencyEnumGip, nil
	case "XAU":
		return TransactionCurrencyEnumXau, nil
	case "GRD":
		return TransactionCurrencyEnumGrd, nil
	case "GTQ":
		return TransactionCurrencyEnumGtq, nil
	case "GWP":
		return TransactionCurrencyEnumGwp, nil
	case "GNF":
		return TransactionCurrencyEnumGnf, nil
	case "GNS":
		return TransactionCurrencyEnumGns, nil
	case "GYD":
		return TransactionCurrencyEnumGyd, nil
	case "HTG":
		return TransactionCurrencyEnumHtg, nil
	case "HNL":
		return TransactionCurrencyEnumHnl, nil
	case "HKD":
		return TransactionCurrencyEnumHkd, nil
	case "HUF":
		return TransactionCurrencyEnumHuf, nil
	case "IMP":
		return TransactionCurrencyEnumImp, nil
	case "ISK":
		return TransactionCurrencyEnumIsk, nil
	case "ISJ":
		return TransactionCurrencyEnumIsj, nil
	case "INR":
		return TransactionCurrencyEnumInr, nil
	case "IDR":
		return TransactionCurrencyEnumIdr, nil
	case "IRR":
		return TransactionCurrencyEnumIrr, nil
	case "IQD":
		return TransactionCurrencyEnumIqd, nil
	case "IEP":
		return TransactionCurrencyEnumIep, nil
	case "ILS":
		return TransactionCurrencyEnumIls, nil
	case "ILP":
		return TransactionCurrencyEnumIlp, nil
	case "ILR":
		return TransactionCurrencyEnumIlr, nil
	case "ITL":
		return TransactionCurrencyEnumItl, nil
	case "JMD":
		return TransactionCurrencyEnumJmd, nil
	case "JPY":
		return TransactionCurrencyEnumJpy, nil
	case "JOD":
		return TransactionCurrencyEnumJod, nil
	case "KZT":
		return TransactionCurrencyEnumKzt, nil
	case "KES":
		return TransactionCurrencyEnumKes, nil
	case "KWD":
		return TransactionCurrencyEnumKwd, nil
	case "KGS":
		return TransactionCurrencyEnumKgs, nil
	case "LAK":
		return TransactionCurrencyEnumLak, nil
	case "LVL":
		return TransactionCurrencyEnumLvl, nil
	case "LVR":
		return TransactionCurrencyEnumLvr, nil
	case "LBP":
		return TransactionCurrencyEnumLbp, nil
	case "LSL":
		return TransactionCurrencyEnumLsl, nil
	case "LRD":
		return TransactionCurrencyEnumLrd, nil
	case "LYD":
		return TransactionCurrencyEnumLyd, nil
	case "LTL":
		return TransactionCurrencyEnumLtl, nil
	case "LTT":
		return TransactionCurrencyEnumLtt, nil
	case "LUL":
		return TransactionCurrencyEnumLul, nil
	case "LUC":
		return TransactionCurrencyEnumLuc, nil
	case "LUF":
		return TransactionCurrencyEnumLuf, nil
	case "MOP":
		return TransactionCurrencyEnumMop, nil
	case "MKD":
		return TransactionCurrencyEnumMkd, nil
	case "MKN":
		return TransactionCurrencyEnumMkn, nil
	case "MGA":
		return TransactionCurrencyEnumMga, nil
	case "MGF":
		return TransactionCurrencyEnumMgf, nil
	case "MWK":
		return TransactionCurrencyEnumMwk, nil
	case "MYR":
		return TransactionCurrencyEnumMyr, nil
	case "MVR":
		return TransactionCurrencyEnumMvr, nil
	case "MVP":
		return TransactionCurrencyEnumMvp, nil
	case "MLF":
		return TransactionCurrencyEnumMlf, nil
	case "MTL":
		return TransactionCurrencyEnumMtl, nil
	case "MTP":
		return TransactionCurrencyEnumMtp, nil
	case "MRU":
		return TransactionCurrencyEnumMru, nil
	case "MRO":
		return TransactionCurrencyEnumMro, nil
	case "MUR":
		return TransactionCurrencyEnumMur, nil
	case "MXV":
		return TransactionCurrencyEnumMxv, nil
	case "MXN":
		return TransactionCurrencyEnumMxn, nil
	case "MXP":
		return TransactionCurrencyEnumMxp, nil
	case "MDC":
		return TransactionCurrencyEnumMdc, nil
	case "MDL":
		return TransactionCurrencyEnumMdl, nil
	case "MCF":
		return TransactionCurrencyEnumMcf, nil
	case "MNT":
		return TransactionCurrencyEnumMnt, nil
	case "MAD":
		return TransactionCurrencyEnumMad, nil
	case "MAF":
		return TransactionCurrencyEnumMaf, nil
	case "MZE":
		return TransactionCurrencyEnumMze, nil
	case "MZN":
		return TransactionCurrencyEnumMzn, nil
	case "MZM":
		return TransactionCurrencyEnumMzm, nil
	case "MMK":
		return TransactionCurrencyEnumMmk, nil
	case "NAD":
		return TransactionCurrencyEnumNad, nil
	case "NPR":
		return TransactionCurrencyEnumNpr, nil
	case "ANG":
		return TransactionCurrencyEnumAng, nil
	case "TWD":
		return TransactionCurrencyEnumTwd, nil
	case "NZD":
		return TransactionCurrencyEnumNzd, nil
	case "NIO":
		return TransactionCurrencyEnumNio, nil
	case "NIC":
		return TransactionCurrencyEnumNic, nil
	case "NGN":
		return TransactionCurrencyEnumNgn, nil
	case "KPW":
		return TransactionCurrencyEnumKpw, nil
	case "NOK":
		return TransactionCurrencyEnumNok, nil
	case "OMR":
		return TransactionCurrencyEnumOmr, nil
	case "PKR":
		return TransactionCurrencyEnumPkr, nil
	case "XPD":
		return TransactionCurrencyEnumXpd, nil
	case "PAB":
		return TransactionCurrencyEnumPab, nil
	case "PGK":
		return TransactionCurrencyEnumPgk, nil
	case "PYG":
		return TransactionCurrencyEnumPyg, nil
	case "PEI":
		return TransactionCurrencyEnumPei, nil
	case "PEN":
		return TransactionCurrencyEnumPen, nil
	case "PES":
		return TransactionCurrencyEnumPes, nil
	case "PHP":
		return TransactionCurrencyEnumPhp, nil
	case "XPT":
		return TransactionCurrencyEnumXpt, nil
	case "PLN":
		return TransactionCurrencyEnumPln, nil
	case "PLZ":
		return TransactionCurrencyEnumPlz, nil
	case "PTE":
		return TransactionCurrencyEnumPte, nil
	case "GWE":
		return TransactionCurrencyEnumGwe, nil
	case "QAR":
		return TransactionCurrencyEnumQar, nil
	case "XRE":
		return TransactionCurrencyEnumXre, nil
	case "RHD":
		return TransactionCurrencyEnumRhd, nil
	case "RON":
		return TransactionCurrencyEnumRon, nil
	case "ROL":
		return TransactionCurrencyEnumRol, nil
	case "RUB":
		return TransactionCurrencyEnumRub, nil
	case "RUR":
		return TransactionCurrencyEnumRur, nil
	case "RWF":
		return TransactionCurrencyEnumRwf, nil
	case "SVC":
		return TransactionCurrencyEnumSvc, nil
	case "WST":
		return TransactionCurrencyEnumWst, nil
	case "SAR":
		return TransactionCurrencyEnumSar, nil
	case "RSD":
		return TransactionCurrencyEnumRsd, nil
	case "CSD":
		return TransactionCurrencyEnumCsd, nil
	case "SCR":
		return TransactionCurrencyEnumScr, nil
	case "SLL":
		return TransactionCurrencyEnumSll, nil
	case "XAG":
		return TransactionCurrencyEnumXag, nil
	case "SGD":
		return TransactionCurrencyEnumSgd, nil
	case "SKK":
		return TransactionCurrencyEnumSkk, nil
	case "SIT":
		return TransactionCurrencyEnumSit, nil
	case "SBD":
		return TransactionCurrencyEnumSbd, nil
	case "SOS":
		return TransactionCurrencyEnumSos, nil
	case "ZAR":
		return TransactionCurrencyEnumZar, nil
	case "ZAL":
		return TransactionCurrencyEnumZal, nil
	case "KRH":
		return TransactionCurrencyEnumKrh, nil
	case "KRW":
		return TransactionCurrencyEnumKrw, nil
	case "KRO":
		return TransactionCurrencyEnumKro, nil
	case "SSP":
		return TransactionCurrencyEnumSsp, nil
	case "SUR":
		return TransactionCurrencyEnumSur, nil
	case "ESP":
		return TransactionCurrencyEnumEsp, nil
	case "ESA":
		return TransactionCurrencyEnumEsa, nil
	case "ESB":
		return TransactionCurrencyEnumEsb, nil
	case "XDR":
		return TransactionCurrencyEnumXdr, nil
	case "LKR":
		return TransactionCurrencyEnumLkr, nil
	case "SHP":
		return TransactionCurrencyEnumShp, nil
	case "XSU":
		return TransactionCurrencyEnumXsu, nil
	case "SDD":
		return TransactionCurrencyEnumSdd, nil
	case "SDG":
		return TransactionCurrencyEnumSdg, nil
	case "SDP":
		return TransactionCurrencyEnumSdp, nil
	case "SRD":
		return TransactionCurrencyEnumSrd, nil
	case "SRG":
		return TransactionCurrencyEnumSrg, nil
	case "SZL":
		return TransactionCurrencyEnumSzl, nil
	case "SEK":
		return TransactionCurrencyEnumSek, nil
	case "CHF":
		return TransactionCurrencyEnumChf, nil
	case "SYP":
		return TransactionCurrencyEnumSyp, nil
	case "STN":
		return TransactionCurrencyEnumStn, nil
	case "STD":
		return TransactionCurrencyEnumStd, nil
	case "TVD":
		return TransactionCurrencyEnumTvd, nil
	case "TJR":
		return TransactionCurrencyEnumTjr, nil
	case "TJS":
		return TransactionCurrencyEnumTjs, nil
	case "TZS":
		return TransactionCurrencyEnumTzs, nil
	case "XTS":
		return TransactionCurrencyEnumXts, nil
	case "THB":
		return TransactionCurrencyEnumThb, nil
	case "XXX":
		return TransactionCurrencyEnumXxx, nil
	case "TPE":
		return TransactionCurrencyEnumTpe, nil
	case "TOP":
		return TransactionCurrencyEnumTop, nil
	case "TTD":
		return TransactionCurrencyEnumTtd, nil
	case "TND":
		return TransactionCurrencyEnumTnd, nil
	case "TRY":
		return TransactionCurrencyEnumTry, nil
	case "TRL":
		return TransactionCurrencyEnumTrl, nil
	case "TMT":
		return TransactionCurrencyEnumTmt, nil
	case "TMM":
		return TransactionCurrencyEnumTmm, nil
	case "USD":
		return TransactionCurrencyEnumUsd, nil
	case "USN":
		return TransactionCurrencyEnumUsn, nil
	case "USS":
		return TransactionCurrencyEnumUss, nil
	case "UGX":
		return TransactionCurrencyEnumUgx, nil
	case "UGS":
		return TransactionCurrencyEnumUgs, nil
	case "UAH":
		return TransactionCurrencyEnumUah, nil
	case "UAK":
		return TransactionCurrencyEnumUak, nil
	case "AED":
		return TransactionCurrencyEnumAed, nil
	case "UYW":
		return TransactionCurrencyEnumUyw, nil
	case "UYU":
		return TransactionCurrencyEnumUyu, nil
	case "UYP":
		return TransactionCurrencyEnumUyp, nil
	case "UYI":
		return TransactionCurrencyEnumUyi, nil
	case "UZS":
		return TransactionCurrencyEnumUzs, nil
	case "VUV":
		return TransactionCurrencyEnumVuv, nil
	case "VES":
		return TransactionCurrencyEnumVes, nil
	case "VEB":
		return TransactionCurrencyEnumVeb, nil
	case "VEF":
		return TransactionCurrencyEnumVef, nil
	case "VND":
		return TransactionCurrencyEnumVnd, nil
	case "VNN":
		return TransactionCurrencyEnumVnn, nil
	case "CHE":
		return TransactionCurrencyEnumChe, nil
	case "CHW":
		return TransactionCurrencyEnumChw, nil
	case "XOF":
		return TransactionCurrencyEnumXof, nil
	case "YDD":
		return TransactionCurrencyEnumYdd, nil
	case "YER":
		return TransactionCurrencyEnumYer, nil
	case "YUN":
		return TransactionCurrencyEnumYun, nil
	case "YUD":
		return TransactionCurrencyEnumYud, nil
	case "YUM":
		return TransactionCurrencyEnumYum, nil
	case "YUR":
		return TransactionCurrencyEnumYur, nil
	case "ZWN":
		return TransactionCurrencyEnumZwn, nil
	case "ZRN":
		return TransactionCurrencyEnumZrn, nil
	case "ZRZ":
		return TransactionCurrencyEnumZrz, nil
	case "ZMW":
		return TransactionCurrencyEnumZmw, nil
	case "ZMK":
		return TransactionCurrencyEnumZmk, nil
	case "ZWD":
		return TransactionCurrencyEnumZwd, nil
	case "ZWR":
		return TransactionCurrencyEnumZwr, nil
	case "ZWL":
		return TransactionCurrencyEnumZwl, nil
	}
	var t TransactionCurrencyEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionCurrencyEnum) Ptr() *TransactionCurrencyEnum {
	return &t
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer" url:"pointer"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValidationProblemSource) GetPointer() string {
	if v == nil {
		return ""
	}
	return v.Pointer
}

func (v *ValidationProblemSource) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationProblemSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationProblemSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationProblemSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationProblemSource) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// # The VendorCredit Object
// ### Description
// A `VendorCredit` is transaction issued by a vendor to the accounting company, indicating a reduction or cancellation of the amount owed to the vendor. It is most generally used as an adjustment note used to rectify errors, returns, or overpayments related to a purchasing transaction. A `VendorCredit` can be applied to `Accounts Payable` Invoices to decrease the overall amount of the `Invoice`.
//
// ### Usage Example
// Fetch from the `GET VendorCredit` endpoint and view a company's vendor credits.
type VendorCredit struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The vendor credit's number.
	Number *string `json:"number,omitempty" url:"number,omitempty"`
	// The vendor credit's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty" url:"transaction_date,omitempty"`
	// The vendor that owes the gift or refund.
	Vendor *VendorCreditVendor `json:"vendor,omitempty" url:"vendor,omitempty"`
	// The vendor credit's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The vendor credit's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *TransactionCurrencyEnum `json:"currency,omitempty" url:"currency,omitempty"`
	// The vendor credit's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty" url:"inclusive_of_tax,omitempty"`
	// The company the vendor credit belongs to.
	Company            *VendorCreditCompany                  `json:"company,omitempty" url:"company,omitempty"`
	Lines              []*VendorCreditLine                   `json:"lines,omitempty" url:"lines,omitempty"`
	TrackingCategories []*VendorCreditTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// A list of VendorCredit Applied to Lines objects.
	AppliedToLines []*VendorCreditApplyLineForVendorCredit `json:"applied_to_lines,omitempty" url:"applied_to_lines,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	// The accounting period that the VendorCredit was generated in.
	AccountingPeriod *VendorCreditAccountingPeriod `json:"accounting_period,omitempty" url:"accounting_period,omitempty"`
	FieldMappings    map[string]interface{}        `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData                 `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCredit) GetId() *string {
	if v == nil {
		return nil
	}
	return v.Id
}

func (v *VendorCredit) GetRemoteId() *string {
	if v == nil {
		return nil
	}
	return v.RemoteId
}

func (v *VendorCredit) GetCreatedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.CreatedAt
}

func (v *VendorCredit) GetModifiedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.ModifiedAt
}

func (v *VendorCredit) GetNumber() *string {
	if v == nil {
		return nil
	}
	return v.Number
}

func (v *VendorCredit) GetTransactionDate() *time.Time {
	if v == nil {
		return nil
	}
	return v.TransactionDate
}

func (v *VendorCredit) GetVendor() *VendorCreditVendor {
	if v == nil {
		return nil
	}
	return v.Vendor
}

func (v *VendorCredit) GetTotalAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.TotalAmount
}

func (v *VendorCredit) GetCurrency() *TransactionCurrencyEnum {
	if v == nil {
		return nil
	}
	return v.Currency
}

func (v *VendorCredit) GetExchangeRate() *string {
	if v == nil {
		return nil
	}
	return v.ExchangeRate
}

func (v *VendorCredit) GetInclusiveOfTax() *bool {
	if v == nil {
		return nil
	}
	return v.InclusiveOfTax
}

func (v *VendorCredit) GetCompany() *VendorCreditCompany {
	if v == nil {
		return nil
	}
	return v.Company
}

func (v *VendorCredit) GetLines() []*VendorCreditLine {
	if v == nil {
		return nil
	}
	return v.Lines
}

func (v *VendorCredit) GetTrackingCategories() []*VendorCreditTrackingCategoriesItem {
	if v == nil {
		return nil
	}
	return v.TrackingCategories
}

func (v *VendorCredit) GetAppliedToLines() []*VendorCreditApplyLineForVendorCredit {
	if v == nil {
		return nil
	}
	return v.AppliedToLines
}

func (v *VendorCredit) GetRemoteWasDeleted() *bool {
	if v == nil {
		return nil
	}
	return v.RemoteWasDeleted
}

func (v *VendorCredit) GetAccountingPeriod() *VendorCreditAccountingPeriod {
	if v == nil {
		return nil
	}
	return v.AccountingPeriod
}

func (v *VendorCredit) GetFieldMappings() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.FieldMappings
}

func (v *VendorCredit) GetRemoteData() []*RemoteData {
	if v == nil {
		return nil
	}
	return v.RemoteData
}

func (v *VendorCredit) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCredit) UnmarshalJSON(data []byte) error {
	type embed VendorCredit
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VendorCredit(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	v.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	v.TransactionDate = unmarshaler.TransactionDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCredit) MarshalJSON() ([]byte, error) {
	type embed VendorCredit
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
	}{
		embed:           embed(*v),
		CreatedAt:       internal.NewOptionalDateTime(v.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(v.ModifiedAt),
		TransactionDate: internal.NewOptionalDateTime(v.TransactionDate),
	}
	return json.Marshal(marshaler)
}

func (v *VendorCredit) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The accounting period that the VendorCredit was generated in.
type VendorCreditAccountingPeriod struct {
	String           string
	AccountingPeriod *AccountingPeriod

	typ string
}

func (v *VendorCreditAccountingPeriod) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *VendorCreditAccountingPeriod) GetAccountingPeriod() *AccountingPeriod {
	if v == nil {
		return nil
	}
	return v.AccountingPeriod
}

func (v *VendorCreditAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		v.typ = "AccountingPeriod"
		v.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditAccountingPeriod) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "AccountingPeriod" || v.AccountingPeriod != nil {
		return json.Marshal(v.AccountingPeriod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (v *VendorCreditAccountingPeriod) Accept(visitor VendorCreditAccountingPeriodVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "AccountingPeriod" || v.AccountingPeriod != nil {
		return visitor.VisitAccountingPeriod(v.AccountingPeriod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// # The VendorCreditApplyLine Object
// ### Description
// The `VendorCreditApplyLine` object is used to represent a applied vendor credit.
//
// ### Usage Example
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's applied to lines.
type VendorCreditApplyLineForInvoice struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt   *time.Time                                   `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	VendorCredit *VendorCreditApplyLineForInvoiceVendorCredit `json:"vendor_credit,omitempty" url:"vendor_credit,omitempty"`
	// Date that the vendor credit is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty" url:"applied_date,omitempty"`
	// The amount of the VendorCredit applied to the invoice.
	AppliedAmount *string `json:"applied_amount,omitempty" url:"applied_amount,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreditApplyLineForInvoice) GetRemoteId() *string {
	if v == nil {
		return nil
	}
	return v.RemoteId
}

func (v *VendorCreditApplyLineForInvoice) GetCreatedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.CreatedAt
}

func (v *VendorCreditApplyLineForInvoice) GetModifiedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.ModifiedAt
}

func (v *VendorCreditApplyLineForInvoice) GetVendorCredit() *VendorCreditApplyLineForInvoiceVendorCredit {
	if v == nil {
		return nil
	}
	return v.VendorCredit
}

func (v *VendorCreditApplyLineForInvoice) GetAppliedDate() *time.Time {
	if v == nil {
		return nil
	}
	return v.AppliedDate
}

func (v *VendorCreditApplyLineForInvoice) GetAppliedAmount() *string {
	if v == nil {
		return nil
	}
	return v.AppliedAmount
}

func (v *VendorCreditApplyLineForInvoice) GetRemoteWasDeleted() *bool {
	if v == nil {
		return nil
	}
	return v.RemoteWasDeleted
}

func (v *VendorCreditApplyLineForInvoice) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreditApplyLineForInvoice) UnmarshalJSON(data []byte) error {
	type embed VendorCreditApplyLineForInvoice
	var unmarshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VendorCreditApplyLineForInvoice(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	v.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	v.AppliedDate = unmarshaler.AppliedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditApplyLineForInvoice) MarshalJSON() ([]byte, error) {
	type embed VendorCreditApplyLineForInvoice
	var marshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed:       embed(*v),
		CreatedAt:   internal.NewOptionalDateTime(v.CreatedAt),
		ModifiedAt:  internal.NewOptionalDateTime(v.ModifiedAt),
		AppliedDate: internal.NewOptionalDateTime(v.AppliedDate),
	}
	return json.Marshal(marshaler)
}

func (v *VendorCreditApplyLineForInvoice) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreditApplyLineForInvoiceVendorCredit struct {
	String       string
	VendorCredit *VendorCredit

	typ string
}

func (v *VendorCreditApplyLineForInvoiceVendorCredit) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *VendorCreditApplyLineForInvoiceVendorCredit) GetVendorCredit() *VendorCredit {
	if v == nil {
		return nil
	}
	return v.VendorCredit
}

func (v *VendorCreditApplyLineForInvoiceVendorCredit) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueVendorCredit := new(VendorCredit)
	if err := json.Unmarshal(data, &valueVendorCredit); err == nil {
		v.typ = "VendorCredit"
		v.VendorCredit = valueVendorCredit
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditApplyLineForInvoiceVendorCredit) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "VendorCredit" || v.VendorCredit != nil {
		return json.Marshal(v.VendorCredit)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditApplyLineForInvoiceVendorCreditVisitor interface {
	VisitString(string) error
	VisitVendorCredit(*VendorCredit) error
}

func (v *VendorCreditApplyLineForInvoiceVendorCredit) Accept(visitor VendorCreditApplyLineForInvoiceVendorCreditVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "VendorCredit" || v.VendorCredit != nil {
		return visitor.VisitVendorCredit(v.VendorCredit)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// # The VendorCreditApplyLine Object
// ### Description
// The `VendorCreditApplyLine` object is used to represent a applied vendor credit.
//
// ### Usage Example
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's applied to lines.
type VendorCreditApplyLineForVendorCredit struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time                                   `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	Invoice    *VendorCreditApplyLineForVendorCreditInvoice `json:"invoice,omitempty" url:"invoice,omitempty"`
	// Date that the vendor credit is applied to the invoice.
	AppliedDate *time.Time `json:"applied_date,omitempty" url:"applied_date,omitempty"`
	// The amount of the VendorCredit applied to the invoice.
	AppliedAmount *string `json:"applied_amount,omitempty" url:"applied_amount,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreditApplyLineForVendorCredit) GetRemoteId() *string {
	if v == nil {
		return nil
	}
	return v.RemoteId
}

func (v *VendorCreditApplyLineForVendorCredit) GetCreatedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.CreatedAt
}

func (v *VendorCreditApplyLineForVendorCredit) GetModifiedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.ModifiedAt
}

func (v *VendorCreditApplyLineForVendorCredit) GetInvoice() *VendorCreditApplyLineForVendorCreditInvoice {
	if v == nil {
		return nil
	}
	return v.Invoice
}

func (v *VendorCreditApplyLineForVendorCredit) GetAppliedDate() *time.Time {
	if v == nil {
		return nil
	}
	return v.AppliedDate
}

func (v *VendorCreditApplyLineForVendorCredit) GetAppliedAmount() *string {
	if v == nil {
		return nil
	}
	return v.AppliedAmount
}

func (v *VendorCreditApplyLineForVendorCredit) GetRemoteWasDeleted() *bool {
	if v == nil {
		return nil
	}
	return v.RemoteWasDeleted
}

func (v *VendorCreditApplyLineForVendorCredit) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreditApplyLineForVendorCredit) UnmarshalJSON(data []byte) error {
	type embed VendorCreditApplyLineForVendorCredit
	var unmarshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VendorCreditApplyLineForVendorCredit(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	v.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	v.AppliedDate = unmarshaler.AppliedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditApplyLineForVendorCredit) MarshalJSON() ([]byte, error) {
	type embed VendorCreditApplyLineForVendorCredit
	var marshaler = struct {
		embed
		CreatedAt   *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt  *internal.DateTime `json:"modified_at,omitempty"`
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed:       embed(*v),
		CreatedAt:   internal.NewOptionalDateTime(v.CreatedAt),
		ModifiedAt:  internal.NewOptionalDateTime(v.ModifiedAt),
		AppliedDate: internal.NewOptionalDateTime(v.AppliedDate),
	}
	return json.Marshal(marshaler)
}

func (v *VendorCreditApplyLineForVendorCredit) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreditApplyLineForVendorCreditInvoice struct {
	String  string
	Invoice *Invoice

	typ string
}

func (v *VendorCreditApplyLineForVendorCreditInvoice) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *VendorCreditApplyLineForVendorCreditInvoice) GetInvoice() *Invoice {
	if v == nil {
		return nil
	}
	return v.Invoice
}

func (v *VendorCreditApplyLineForVendorCreditInvoice) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueInvoice := new(Invoice)
	if err := json.Unmarshal(data, &valueInvoice); err == nil {
		v.typ = "Invoice"
		v.Invoice = valueInvoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditApplyLineForVendorCreditInvoice) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Invoice" || v.Invoice != nil {
		return json.Marshal(v.Invoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditApplyLineForVendorCreditInvoiceVisitor interface {
	VisitString(string) error
	VisitInvoice(*Invoice) error
}

func (v *VendorCreditApplyLineForVendorCreditInvoice) Accept(visitor VendorCreditApplyLineForVendorCreditInvoiceVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Invoice" || v.Invoice != nil {
		return visitor.VisitInvoice(v.Invoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// The company the vendor credit belongs to.
type VendorCreditCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (v *VendorCreditCompany) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *VendorCreditCompany) GetCompanyInfo() *CompanyInfo {
	if v == nil {
		return nil
	}
	return v.CompanyInfo
}

func (v *VendorCreditCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		v.typ = "CompanyInfo"
		v.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditCompany) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "CompanyInfo" || v.CompanyInfo != nil {
		return json.Marshal(v.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (v *VendorCreditCompany) Accept(visitor VendorCreditCompanyVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "CompanyInfo" || v.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(v.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// # The VendorCreditLine Object
// ### Description
// The `VendorCreditLine` object is used to represent a vendor credit's line items.
//
// ### Usage Example
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's line items.
type VendorCreditLine struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The full value of the credit.
	NetAmount *float64 `json:"net_amount,omitempty" url:"net_amount,omitempty"`
	// The line's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty" url:"tracking_category,omitempty"`
	// The vendor credit line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The line's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The line's account.
	Account *VendorCreditLineAccount `json:"account,omitempty" url:"account,omitempty"`
	// The company the line belongs to.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty" url:"tax_rate,omitempty"`
	// The vendor credit line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreditLine) GetId() *string {
	if v == nil {
		return nil
	}
	return v.Id
}

func (v *VendorCreditLine) GetRemoteId() *string {
	if v == nil {
		return nil
	}
	return v.RemoteId
}

func (v *VendorCreditLine) GetCreatedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.CreatedAt
}

func (v *VendorCreditLine) GetModifiedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.ModifiedAt
}

func (v *VendorCreditLine) GetNetAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.NetAmount
}

func (v *VendorCreditLine) GetTrackingCategory() *string {
	if v == nil {
		return nil
	}
	return v.TrackingCategory
}

func (v *VendorCreditLine) GetTrackingCategories() []*string {
	if v == nil {
		return nil
	}
	return v.TrackingCategories
}

func (v *VendorCreditLine) GetDescription() *string {
	if v == nil {
		return nil
	}
	return v.Description
}

func (v *VendorCreditLine) GetAccount() *VendorCreditLineAccount {
	if v == nil {
		return nil
	}
	return v.Account
}

func (v *VendorCreditLine) GetCompany() *string {
	if v == nil {
		return nil
	}
	return v.Company
}

func (v *VendorCreditLine) GetTaxRate() *string {
	if v == nil {
		return nil
	}
	return v.TaxRate
}

func (v *VendorCreditLine) GetExchangeRate() *string {
	if v == nil {
		return nil
	}
	return v.ExchangeRate
}

func (v *VendorCreditLine) GetRemoteWasDeleted() *bool {
	if v == nil {
		return nil
	}
	return v.RemoteWasDeleted
}

func (v *VendorCreditLine) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreditLine) UnmarshalJSON(data []byte) error {
	type embed VendorCreditLine
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VendorCreditLine(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	v.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditLine) MarshalJSON() ([]byte, error) {
	type embed VendorCreditLine
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*v),
		CreatedAt:  internal.NewOptionalDateTime(v.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(v.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (v *VendorCreditLine) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The line's account.
type VendorCreditLineAccount struct {
	String  string
	Account *Account

	typ string
}

func (v *VendorCreditLineAccount) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *VendorCreditLineAccount) GetAccount() *Account {
	if v == nil {
		return nil
	}
	return v.Account
}

func (v *VendorCreditLineAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		v.typ = "Account"
		v.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditLineAccount) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Account" || v.Account != nil {
		return json.Marshal(v.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditLineAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (v *VendorCreditLineAccount) Accept(visitor VendorCreditLineAccountVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Account" || v.Account != nil {
		return visitor.VisitAccount(v.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// # The VendorCreditLine Object
// ### Description
// The `VendorCreditLine` object is used to represent a vendor credit's line items.
//
// ### Usage Example
// Fetch from the `GET VendorCredit` endpoint and view the vendor credit's line items.
type VendorCreditLineRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The full value of the credit.
	NetAmount *float64 `json:"net_amount,omitempty" url:"net_amount,omitempty"`
	// The line's associated tracking category.
	TrackingCategory *string `json:"tracking_category,omitempty" url:"tracking_category,omitempty"`
	// The vendor credit line item's associated tracking categories.
	TrackingCategories []*string `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The line's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The line's account.
	Account *VendorCreditLineRequestAccount `json:"account,omitempty" url:"account,omitempty"`
	// The company the line belongs to.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty" url:"tax_rate,omitempty"`
	// The vendor credit line item's exchange rate.
	ExchangeRate        *string                `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreditLineRequest) GetRemoteId() *string {
	if v == nil {
		return nil
	}
	return v.RemoteId
}

func (v *VendorCreditLineRequest) GetNetAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.NetAmount
}

func (v *VendorCreditLineRequest) GetTrackingCategory() *string {
	if v == nil {
		return nil
	}
	return v.TrackingCategory
}

func (v *VendorCreditLineRequest) GetTrackingCategories() []*string {
	if v == nil {
		return nil
	}
	return v.TrackingCategories
}

func (v *VendorCreditLineRequest) GetDescription() *string {
	if v == nil {
		return nil
	}
	return v.Description
}

func (v *VendorCreditLineRequest) GetAccount() *VendorCreditLineRequestAccount {
	if v == nil {
		return nil
	}
	return v.Account
}

func (v *VendorCreditLineRequest) GetCompany() *string {
	if v == nil {
		return nil
	}
	return v.Company
}

func (v *VendorCreditLineRequest) GetTaxRate() *string {
	if v == nil {
		return nil
	}
	return v.TaxRate
}

func (v *VendorCreditLineRequest) GetExchangeRate() *string {
	if v == nil {
		return nil
	}
	return v.ExchangeRate
}

func (v *VendorCreditLineRequest) GetIntegrationParams() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.IntegrationParams
}

func (v *VendorCreditLineRequest) GetLinkedAccountParams() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.LinkedAccountParams
}

func (v *VendorCreditLineRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreditLineRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditLineRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditLineRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditLineRequest) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The line's account.
type VendorCreditLineRequestAccount struct {
	String  string
	Account *Account

	typ string
}

func (v *VendorCreditLineRequestAccount) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *VendorCreditLineRequestAccount) GetAccount() *Account {
	if v == nil {
		return nil
	}
	return v.Account
}

func (v *VendorCreditLineRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		v.typ = "Account"
		v.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditLineRequestAccount) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Account" || v.Account != nil {
		return json.Marshal(v.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditLineRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (v *VendorCreditLineRequestAccount) Accept(visitor VendorCreditLineRequestAccountVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Account" || v.Account != nil {
		return visitor.VisitAccount(v.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (v *VendorCreditTrackingCategoriesItem) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *VendorCreditTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if v == nil {
		return nil
	}
	return v.TrackingCategory
}

func (v *VendorCreditTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		v.typ = "TrackingCategory"
		v.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "TrackingCategory" || v.TrackingCategory != nil {
		return json.Marshal(v.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (v *VendorCreditTrackingCategoriesItem) Accept(visitor VendorCreditTrackingCategoriesItemVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "TrackingCategory" || v.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(v.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// The vendor that owes the gift or refund.
type VendorCreditVendor struct {
	String  string
	Contact *Contact

	typ string
}

func (v *VendorCreditVendor) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *VendorCreditVendor) GetContact() *Contact {
	if v == nil {
		return nil
	}
	return v.Contact
}

func (v *VendorCreditVendor) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		v.typ = "Contact"
		v.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VendorCreditVendor) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Contact" || v.Contact != nil {
		return json.Marshal(v.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VendorCreditVendorVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (v *VendorCreditVendor) Accept(visitor VendorCreditVendorVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Contact" || v.Contact != nil {
		return visitor.VisitContact(v.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WarningValidationProblem) GetSource() *ValidationProblemSource {
	if w == nil {
		return nil
	}
	return w.Source
}

func (w *WarningValidationProblem) GetTitle() string {
	if w == nil {
		return ""
	}
	return w.Title
}

func (w *WarningValidationProblem) GetDetail() string {
	if w == nil {
		return ""
	}
	return w.Detail
}

func (w *WarningValidationProblem) GetProblemType() string {
	if w == nil {
		return ""
	}
	return w.ProblemType
}

func (w *WarningValidationProblem) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WarningValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler WarningValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WarningValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WarningValidationProblem) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
