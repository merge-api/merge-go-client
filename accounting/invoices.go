// Code generated by Fern. DO NOT EDIT.

package accounting

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/internal"
	big "math/big"
	time "time"
)

var (
	invoiceEndpointRequestFieldIsDebugMode = big.NewInt(1 << 0)
	invoiceEndpointRequestFieldRunAsync    = big.NewInt(1 << 1)
	invoiceEndpointRequestFieldModel       = big.NewInt(1 << 2)
)

type InvoiceEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool           `json:"-" url:"run_async,omitempty"`
	Model    *InvoiceRequest `json:"model,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InvoiceEndpointRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetIsDebugMode sets the IsDebugMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceEndpointRequest) SetIsDebugMode(isDebugMode *bool) {
	i.IsDebugMode = isDebugMode
	i.require(invoiceEndpointRequestFieldIsDebugMode)
}

// SetRunAsync sets the RunAsync field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceEndpointRequest) SetRunAsync(runAsync *bool) {
	i.RunAsync = runAsync
	i.require(invoiceEndpointRequestFieldRunAsync)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceEndpointRequest) SetModel(model *InvoiceRequest) {
	i.Model = model
	i.require(invoiceEndpointRequestFieldModel)
}

var (
	invoicesLineItemsRemoteFieldClassesListRequestFieldCursor             = big.NewInt(1 << 0)
	invoicesLineItemsRemoteFieldClassesListRequestFieldIncludeDeletedData = big.NewInt(1 << 1)
	invoicesLineItemsRemoteFieldClassesListRequestFieldIncludeRemoteData  = big.NewInt(1 << 2)
	invoicesLineItemsRemoteFieldClassesListRequestFieldIncludeShellData   = big.NewInt(1 << 3)
	invoicesLineItemsRemoteFieldClassesListRequestFieldIsCommonModelField = big.NewInt(1 << 4)
	invoicesLineItemsRemoteFieldClassesListRequestFieldIsCustom           = big.NewInt(1 << 5)
	invoicesLineItemsRemoteFieldClassesListRequestFieldPageSize           = big.NewInt(1 << 6)
)

type InvoicesLineItemsRemoteFieldClassesListRequest struct {
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return remote field classes with this is_common_model_field value
	IsCommonModelField *bool `json:"-" url:"is_common_model_field,omitempty"`
	// If provided, will only return remote fields classes with this is_custom value
	IsCustom *bool `json:"-" url:"is_custom,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InvoicesLineItemsRemoteFieldClassesListRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesLineItemsRemoteFieldClassesListRequest) SetCursor(cursor *string) {
	i.Cursor = cursor
	i.require(invoicesLineItemsRemoteFieldClassesListRequestFieldCursor)
}

// SetIncludeDeletedData sets the IncludeDeletedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesLineItemsRemoteFieldClassesListRequest) SetIncludeDeletedData(includeDeletedData *bool) {
	i.IncludeDeletedData = includeDeletedData
	i.require(invoicesLineItemsRemoteFieldClassesListRequestFieldIncludeDeletedData)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesLineItemsRemoteFieldClassesListRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	i.IncludeRemoteData = includeRemoteData
	i.require(invoicesLineItemsRemoteFieldClassesListRequestFieldIncludeRemoteData)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesLineItemsRemoteFieldClassesListRequest) SetIncludeShellData(includeShellData *bool) {
	i.IncludeShellData = includeShellData
	i.require(invoicesLineItemsRemoteFieldClassesListRequestFieldIncludeShellData)
}

// SetIsCommonModelField sets the IsCommonModelField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesLineItemsRemoteFieldClassesListRequest) SetIsCommonModelField(isCommonModelField *bool) {
	i.IsCommonModelField = isCommonModelField
	i.require(invoicesLineItemsRemoteFieldClassesListRequestFieldIsCommonModelField)
}

// SetIsCustom sets the IsCustom field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesLineItemsRemoteFieldClassesListRequest) SetIsCustom(isCustom *bool) {
	i.IsCustom = isCustom
	i.require(invoicesLineItemsRemoteFieldClassesListRequestFieldIsCustom)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesLineItemsRemoteFieldClassesListRequest) SetPageSize(pageSize *int) {
	i.PageSize = pageSize
	i.require(invoicesLineItemsRemoteFieldClassesListRequestFieldPageSize)
}

var (
	invoicesListRequestFieldCompanyId           = big.NewInt(1 << 0)
	invoicesListRequestFieldContactId           = big.NewInt(1 << 1)
	invoicesListRequestFieldCreatedAfter        = big.NewInt(1 << 2)
	invoicesListRequestFieldCreatedBefore       = big.NewInt(1 << 3)
	invoicesListRequestFieldCursor              = big.NewInt(1 << 4)
	invoicesListRequestFieldExpand              = big.NewInt(1 << 5)
	invoicesListRequestFieldIncludeDeletedData  = big.NewInt(1 << 6)
	invoicesListRequestFieldIncludeRemoteData   = big.NewInt(1 << 7)
	invoicesListRequestFieldIncludeRemoteFields = big.NewInt(1 << 8)
	invoicesListRequestFieldIncludeShellData    = big.NewInt(1 << 9)
	invoicesListRequestFieldIssueDateAfter      = big.NewInt(1 << 10)
	invoicesListRequestFieldIssueDateBefore     = big.NewInt(1 << 11)
	invoicesListRequestFieldModifiedAfter       = big.NewInt(1 << 12)
	invoicesListRequestFieldModifiedBefore      = big.NewInt(1 << 13)
	invoicesListRequestFieldNumber              = big.NewInt(1 << 14)
	invoicesListRequestFieldPageSize            = big.NewInt(1 << 15)
	invoicesListRequestFieldRemoteFields        = big.NewInt(1 << 16)
	invoicesListRequestFieldRemoteId            = big.NewInt(1 << 17)
	invoicesListRequestFieldShowEnumOrigins     = big.NewInt(1 << 18)
	invoicesListRequestFieldStatus              = big.NewInt(1 << 19)
	invoicesListRequestFieldType                = big.NewInt(1 << 20)
)

type InvoicesListRequest struct {
	// If provided, will only return invoices for this company.
	CompanyId *string `json:"-" url:"company_id,omitempty"`
	// If provided, will only return invoices for this contact.
	ContactId *string `json:"-" url:"contact_id,omitempty"`
	// If provided, will only return objects created after this datetime.
	CreatedAfter *time.Time `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *time.Time `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*InvoicesListRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return objects created after this datetime.
	IssueDateAfter *time.Time `json:"-" url:"issue_date_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	IssueDateBefore *time.Time `json:"-" url:"issue_date_before,omitempty"`
	// If provided, only objects synced by Merge after this date time will be returned.
	ModifiedAfter *time.Time `json:"-" url:"modified_after,omitempty"`
	// If provided, only objects synced by Merge before this date time will be returned.
	ModifiedBefore *time.Time `json:"-" url:"modified_before,omitempty"`
	// If provided, will only return Invoices with this number.
	Number *string `json:"-" url:"number,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// Deprecated. Use show_enum_origins.
	RemoteFields *string `json:"-" url:"remote_fields,omitempty"`
	// The API provider's ID for the given object.
	RemoteId *string `json:"-" url:"remote_id,omitempty"`
	// A comma separated list of enum field names for which you'd like the original values to be returned, instead of Merge's normalized enum values. [Learn more](https://help.merge.dev/en/articles/8950958-show_enum_origins-query-parameter)
	ShowEnumOrigins *string `json:"-" url:"show_enum_origins,omitempty"`
	// If provided, will only return Invoices with this status.
	//
	// * `PAID` - PAID
	// * `DRAFT` - DRAFT
	// * `SUBMITTED` - SUBMITTED
	// * `PARTIALLY_PAID` - PARTIALLY_PAID
	// * `OPEN` - OPEN
	// * `VOID` - VOID
	Status *InvoicesListRequestStatus `json:"-" url:"status,omitempty"`
	// If provided, will only return Invoices with this type.
	//
	// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	Type *InvoicesListRequestType `json:"-" url:"type,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InvoicesListRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetCompanyId sets the CompanyId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetCompanyId(companyId *string) {
	i.CompanyId = companyId
	i.require(invoicesListRequestFieldCompanyId)
}

// SetContactId sets the ContactId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetContactId(contactId *string) {
	i.ContactId = contactId
	i.require(invoicesListRequestFieldContactId)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetCreatedAfter(createdAfter *time.Time) {
	i.CreatedAfter = createdAfter
	i.require(invoicesListRequestFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetCreatedBefore(createdBefore *time.Time) {
	i.CreatedBefore = createdBefore
	i.require(invoicesListRequestFieldCreatedBefore)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetCursor(cursor *string) {
	i.Cursor = cursor
	i.require(invoicesListRequestFieldCursor)
}

// SetExpand sets the Expand field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetExpand(expand []*InvoicesListRequestExpandItem) {
	i.Expand = expand
	i.require(invoicesListRequestFieldExpand)
}

// SetIncludeDeletedData sets the IncludeDeletedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetIncludeDeletedData(includeDeletedData *bool) {
	i.IncludeDeletedData = includeDeletedData
	i.require(invoicesListRequestFieldIncludeDeletedData)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	i.IncludeRemoteData = includeRemoteData
	i.require(invoicesListRequestFieldIncludeRemoteData)
}

// SetIncludeRemoteFields sets the IncludeRemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetIncludeRemoteFields(includeRemoteFields *bool) {
	i.IncludeRemoteFields = includeRemoteFields
	i.require(invoicesListRequestFieldIncludeRemoteFields)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetIncludeShellData(includeShellData *bool) {
	i.IncludeShellData = includeShellData
	i.require(invoicesListRequestFieldIncludeShellData)
}

// SetIssueDateAfter sets the IssueDateAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetIssueDateAfter(issueDateAfter *time.Time) {
	i.IssueDateAfter = issueDateAfter
	i.require(invoicesListRequestFieldIssueDateAfter)
}

// SetIssueDateBefore sets the IssueDateBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetIssueDateBefore(issueDateBefore *time.Time) {
	i.IssueDateBefore = issueDateBefore
	i.require(invoicesListRequestFieldIssueDateBefore)
}

// SetModifiedAfter sets the ModifiedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetModifiedAfter(modifiedAfter *time.Time) {
	i.ModifiedAfter = modifiedAfter
	i.require(invoicesListRequestFieldModifiedAfter)
}

// SetModifiedBefore sets the ModifiedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetModifiedBefore(modifiedBefore *time.Time) {
	i.ModifiedBefore = modifiedBefore
	i.require(invoicesListRequestFieldModifiedBefore)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetNumber(number *string) {
	i.Number = number
	i.require(invoicesListRequestFieldNumber)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetPageSize(pageSize *int) {
	i.PageSize = pageSize
	i.require(invoicesListRequestFieldPageSize)
}

// SetRemoteFields sets the RemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetRemoteFields(remoteFields *string) {
	i.RemoteFields = remoteFields
	i.require(invoicesListRequestFieldRemoteFields)
}

// SetRemoteId sets the RemoteId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetRemoteId(remoteId *string) {
	i.RemoteId = remoteId
	i.require(invoicesListRequestFieldRemoteId)
}

// SetShowEnumOrigins sets the ShowEnumOrigins field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetShowEnumOrigins(showEnumOrigins *string) {
	i.ShowEnumOrigins = showEnumOrigins
	i.require(invoicesListRequestFieldShowEnumOrigins)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetStatus(status *InvoicesListRequestStatus) {
	i.Status = status
	i.require(invoicesListRequestFieldStatus)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesListRequest) SetType(type_ *InvoicesListRequestType) {
	i.Type = type_
	i.require(invoicesListRequestFieldType)
}

var (
	patchedInvoiceEndpointRequestFieldIsDebugMode = big.NewInt(1 << 0)
	patchedInvoiceEndpointRequestFieldRunAsync    = big.NewInt(1 << 1)
	patchedInvoiceEndpointRequestFieldModel       = big.NewInt(1 << 2)
)

type PatchedInvoiceEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool           `json:"-" url:"run_async,omitempty"`
	Model    *InvoiceRequest `json:"model,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PatchedInvoiceEndpointRequest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetIsDebugMode sets the IsDebugMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchedInvoiceEndpointRequest) SetIsDebugMode(isDebugMode *bool) {
	p.IsDebugMode = isDebugMode
	p.require(patchedInvoiceEndpointRequestFieldIsDebugMode)
}

// SetRunAsync sets the RunAsync field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchedInvoiceEndpointRequest) SetRunAsync(runAsync *bool) {
	p.RunAsync = runAsync
	p.require(patchedInvoiceEndpointRequestFieldRunAsync)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchedInvoiceEndpointRequest) SetModel(model *InvoiceRequest) {
	p.Model = model
	p.require(patchedInvoiceEndpointRequestFieldModel)
}

var (
	invoicesRemoteFieldClassesListRequestFieldCursor             = big.NewInt(1 << 0)
	invoicesRemoteFieldClassesListRequestFieldIncludeDeletedData = big.NewInt(1 << 1)
	invoicesRemoteFieldClassesListRequestFieldIncludeRemoteData  = big.NewInt(1 << 2)
	invoicesRemoteFieldClassesListRequestFieldIncludeShellData   = big.NewInt(1 << 3)
	invoicesRemoteFieldClassesListRequestFieldIsCommonModelField = big.NewInt(1 << 4)
	invoicesRemoteFieldClassesListRequestFieldIsCustom           = big.NewInt(1 << 5)
	invoicesRemoteFieldClassesListRequestFieldPageSize           = big.NewInt(1 << 6)
)

type InvoicesRemoteFieldClassesListRequest struct {
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return remote field classes with this is_common_model_field value
	IsCommonModelField *bool `json:"-" url:"is_common_model_field,omitempty"`
	// If provided, will only return remote fields classes with this is_custom value
	IsCustom *bool `json:"-" url:"is_custom,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InvoicesRemoteFieldClassesListRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRemoteFieldClassesListRequest) SetCursor(cursor *string) {
	i.Cursor = cursor
	i.require(invoicesRemoteFieldClassesListRequestFieldCursor)
}

// SetIncludeDeletedData sets the IncludeDeletedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRemoteFieldClassesListRequest) SetIncludeDeletedData(includeDeletedData *bool) {
	i.IncludeDeletedData = includeDeletedData
	i.require(invoicesRemoteFieldClassesListRequestFieldIncludeDeletedData)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRemoteFieldClassesListRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	i.IncludeRemoteData = includeRemoteData
	i.require(invoicesRemoteFieldClassesListRequestFieldIncludeRemoteData)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRemoteFieldClassesListRequest) SetIncludeShellData(includeShellData *bool) {
	i.IncludeShellData = includeShellData
	i.require(invoicesRemoteFieldClassesListRequestFieldIncludeShellData)
}

// SetIsCommonModelField sets the IsCommonModelField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRemoteFieldClassesListRequest) SetIsCommonModelField(isCommonModelField *bool) {
	i.IsCommonModelField = isCommonModelField
	i.require(invoicesRemoteFieldClassesListRequestFieldIsCommonModelField)
}

// SetIsCustom sets the IsCustom field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRemoteFieldClassesListRequest) SetIsCustom(isCustom *bool) {
	i.IsCustom = isCustom
	i.require(invoicesRemoteFieldClassesListRequestFieldIsCustom)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRemoteFieldClassesListRequest) SetPageSize(pageSize *int) {
	i.PageSize = pageSize
	i.require(invoicesRemoteFieldClassesListRequestFieldPageSize)
}

var (
	invoicesRetrieveRequestFieldExpand              = big.NewInt(1 << 0)
	invoicesRetrieveRequestFieldIncludeRemoteData   = big.NewInt(1 << 1)
	invoicesRetrieveRequestFieldIncludeRemoteFields = big.NewInt(1 << 2)
	invoicesRetrieveRequestFieldIncludeShellData    = big.NewInt(1 << 3)
	invoicesRetrieveRequestFieldRemoteFields        = big.NewInt(1 << 4)
	invoicesRetrieveRequestFieldShowEnumOrigins     = big.NewInt(1 << 5)
)

type InvoicesRetrieveRequest struct {
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*InvoicesRetrieveRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// Deprecated. Use show_enum_origins.
	RemoteFields *string `json:"-" url:"remote_fields,omitempty"`
	// A comma separated list of enum field names for which you'd like the original values to be returned, instead of Merge's normalized enum values. [Learn more](https://help.merge.dev/en/articles/8950958-show_enum_origins-query-parameter)
	ShowEnumOrigins *string `json:"-" url:"show_enum_origins,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InvoicesRetrieveRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetExpand sets the Expand field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRetrieveRequest) SetExpand(expand []*InvoicesRetrieveRequestExpandItem) {
	i.Expand = expand
	i.require(invoicesRetrieveRequestFieldExpand)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRetrieveRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	i.IncludeRemoteData = includeRemoteData
	i.require(invoicesRetrieveRequestFieldIncludeRemoteData)
}

// SetIncludeRemoteFields sets the IncludeRemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRetrieveRequest) SetIncludeRemoteFields(includeRemoteFields *bool) {
	i.IncludeRemoteFields = includeRemoteFields
	i.require(invoicesRetrieveRequestFieldIncludeRemoteFields)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRetrieveRequest) SetIncludeShellData(includeShellData *bool) {
	i.IncludeShellData = includeShellData
	i.require(invoicesRetrieveRequestFieldIncludeShellData)
}

// SetRemoteFields sets the RemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRetrieveRequest) SetRemoteFields(remoteFields *string) {
	i.RemoteFields = remoteFields
	i.require(invoicesRetrieveRequestFieldRemoteFields)
}

// SetShowEnumOrigins sets the ShowEnumOrigins field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoicesRetrieveRequest) SetShowEnumOrigins(showEnumOrigins *string) {
	i.ShowEnumOrigins = showEnumOrigins
	i.require(invoicesRetrieveRequestFieldShowEnumOrigins)
}

type InvoicesListRequestExpandItem string

const (
	InvoicesListRequestExpandItemAccountingPeriod     InvoicesListRequestExpandItem = "accounting_period"
	InvoicesListRequestExpandItemAppliedCreditNotes   InvoicesListRequestExpandItem = "applied_credit_notes"
	InvoicesListRequestExpandItemAppliedPayments      InvoicesListRequestExpandItem = "applied_payments"
	InvoicesListRequestExpandItemAppliedVendorCredits InvoicesListRequestExpandItem = "applied_vendor_credits"
	InvoicesListRequestExpandItemCompany              InvoicesListRequestExpandItem = "company"
	InvoicesListRequestExpandItemContact              InvoicesListRequestExpandItem = "contact"
	InvoicesListRequestExpandItemEmployee             InvoicesListRequestExpandItem = "employee"
	InvoicesListRequestExpandItemLineItems            InvoicesListRequestExpandItem = "line_items"
	InvoicesListRequestExpandItemPaymentTerm          InvoicesListRequestExpandItem = "payment_term"
	InvoicesListRequestExpandItemPayments             InvoicesListRequestExpandItem = "payments"
	InvoicesListRequestExpandItemPurchaseOrders       InvoicesListRequestExpandItem = "purchase_orders"
	InvoicesListRequestExpandItemTrackingCategories   InvoicesListRequestExpandItem = "tracking_categories"
)

func NewInvoicesListRequestExpandItemFromString(s string) (InvoicesListRequestExpandItem, error) {
	switch s {
	case "accounting_period":
		return InvoicesListRequestExpandItemAccountingPeriod, nil
	case "applied_credit_notes":
		return InvoicesListRequestExpandItemAppliedCreditNotes, nil
	case "applied_payments":
		return InvoicesListRequestExpandItemAppliedPayments, nil
	case "applied_vendor_credits":
		return InvoicesListRequestExpandItemAppliedVendorCredits, nil
	case "company":
		return InvoicesListRequestExpandItemCompany, nil
	case "contact":
		return InvoicesListRequestExpandItemContact, nil
	case "employee":
		return InvoicesListRequestExpandItemEmployee, nil
	case "line_items":
		return InvoicesListRequestExpandItemLineItems, nil
	case "payment_term":
		return InvoicesListRequestExpandItemPaymentTerm, nil
	case "payments":
		return InvoicesListRequestExpandItemPayments, nil
	case "purchase_orders":
		return InvoicesListRequestExpandItemPurchaseOrders, nil
	case "tracking_categories":
		return InvoicesListRequestExpandItemTrackingCategories, nil
	}
	var t InvoicesListRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoicesListRequestExpandItem) Ptr() *InvoicesListRequestExpandItem {
	return &i
}

type InvoicesListRequestStatus string

const (
	InvoicesListRequestStatusDraft         InvoicesListRequestStatus = "DRAFT"
	InvoicesListRequestStatusOpen          InvoicesListRequestStatus = "OPEN"
	InvoicesListRequestStatusPaid          InvoicesListRequestStatus = "PAID"
	InvoicesListRequestStatusPartiallyPaid InvoicesListRequestStatus = "PARTIALLY_PAID"
	InvoicesListRequestStatusSubmitted     InvoicesListRequestStatus = "SUBMITTED"
	InvoicesListRequestStatusVoid          InvoicesListRequestStatus = "VOID"
)

func NewInvoicesListRequestStatusFromString(s string) (InvoicesListRequestStatus, error) {
	switch s {
	case "DRAFT":
		return InvoicesListRequestStatusDraft, nil
	case "OPEN":
		return InvoicesListRequestStatusOpen, nil
	case "PAID":
		return InvoicesListRequestStatusPaid, nil
	case "PARTIALLY_PAID":
		return InvoicesListRequestStatusPartiallyPaid, nil
	case "SUBMITTED":
		return InvoicesListRequestStatusSubmitted, nil
	case "VOID":
		return InvoicesListRequestStatusVoid, nil
	}
	var t InvoicesListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoicesListRequestStatus) Ptr() *InvoicesListRequestStatus {
	return &i
}

type InvoicesListRequestType string

const (
	InvoicesListRequestTypeAccountsPayable    InvoicesListRequestType = "ACCOUNTS_PAYABLE"
	InvoicesListRequestTypeAccountsReceivable InvoicesListRequestType = "ACCOUNTS_RECEIVABLE"
)

func NewInvoicesListRequestTypeFromString(s string) (InvoicesListRequestType, error) {
	switch s {
	case "ACCOUNTS_PAYABLE":
		return InvoicesListRequestTypeAccountsPayable, nil
	case "ACCOUNTS_RECEIVABLE":
		return InvoicesListRequestTypeAccountsReceivable, nil
	}
	var t InvoicesListRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoicesListRequestType) Ptr() *InvoicesListRequestType {
	return &i
}

type InvoicesRetrieveRequestExpandItem string

const (
	InvoicesRetrieveRequestExpandItemAccountingPeriod     InvoicesRetrieveRequestExpandItem = "accounting_period"
	InvoicesRetrieveRequestExpandItemAppliedCreditNotes   InvoicesRetrieveRequestExpandItem = "applied_credit_notes"
	InvoicesRetrieveRequestExpandItemAppliedPayments      InvoicesRetrieveRequestExpandItem = "applied_payments"
	InvoicesRetrieveRequestExpandItemAppliedVendorCredits InvoicesRetrieveRequestExpandItem = "applied_vendor_credits"
	InvoicesRetrieveRequestExpandItemCompany              InvoicesRetrieveRequestExpandItem = "company"
	InvoicesRetrieveRequestExpandItemContact              InvoicesRetrieveRequestExpandItem = "contact"
	InvoicesRetrieveRequestExpandItemEmployee             InvoicesRetrieveRequestExpandItem = "employee"
	InvoicesRetrieveRequestExpandItemLineItems            InvoicesRetrieveRequestExpandItem = "line_items"
	InvoicesRetrieveRequestExpandItemPaymentTerm          InvoicesRetrieveRequestExpandItem = "payment_term"
	InvoicesRetrieveRequestExpandItemPayments             InvoicesRetrieveRequestExpandItem = "payments"
	InvoicesRetrieveRequestExpandItemPurchaseOrders       InvoicesRetrieveRequestExpandItem = "purchase_orders"
	InvoicesRetrieveRequestExpandItemTrackingCategories   InvoicesRetrieveRequestExpandItem = "tracking_categories"
)

func NewInvoicesRetrieveRequestExpandItemFromString(s string) (InvoicesRetrieveRequestExpandItem, error) {
	switch s {
	case "accounting_period":
		return InvoicesRetrieveRequestExpandItemAccountingPeriod, nil
	case "applied_credit_notes":
		return InvoicesRetrieveRequestExpandItemAppliedCreditNotes, nil
	case "applied_payments":
		return InvoicesRetrieveRequestExpandItemAppliedPayments, nil
	case "applied_vendor_credits":
		return InvoicesRetrieveRequestExpandItemAppliedVendorCredits, nil
	case "company":
		return InvoicesRetrieveRequestExpandItemCompany, nil
	case "contact":
		return InvoicesRetrieveRequestExpandItemContact, nil
	case "employee":
		return InvoicesRetrieveRequestExpandItemEmployee, nil
	case "line_items":
		return InvoicesRetrieveRequestExpandItemLineItems, nil
	case "payment_term":
		return InvoicesRetrieveRequestExpandItemPaymentTerm, nil
	case "payments":
		return InvoicesRetrieveRequestExpandItemPayments, nil
	case "purchase_orders":
		return InvoicesRetrieveRequestExpandItemPurchaseOrders, nil
	case "tracking_categories":
		return InvoicesRetrieveRequestExpandItemTrackingCategories, nil
	}
	var t InvoicesRetrieveRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoicesRetrieveRequestExpandItem) Ptr() *InvoicesRetrieveRequestExpandItem {
	return &i
}

// # The InvoiceLineItem Object
// ### Description
// The `InvoiceLineItem` object represents an itemized record of goods and/or services sold to a customer.
//
// ### Usage Example
// Fetch from the `GET Invoice` endpoint and view the invoice's line items.
var (
	invoiceLineItemRequestFieldRemoteId            = big.NewInt(1 << 0)
	invoiceLineItemRequestFieldDescription         = big.NewInt(1 << 1)
	invoiceLineItemRequestFieldUnitPrice           = big.NewInt(1 << 2)
	invoiceLineItemRequestFieldQuantity            = big.NewInt(1 << 3)
	invoiceLineItemRequestFieldTotalAmount         = big.NewInt(1 << 4)
	invoiceLineItemRequestFieldEmployee            = big.NewInt(1 << 5)
	invoiceLineItemRequestFieldProject             = big.NewInt(1 << 6)
	invoiceLineItemRequestFieldContact             = big.NewInt(1 << 7)
	invoiceLineItemRequestFieldCurrency            = big.NewInt(1 << 8)
	invoiceLineItemRequestFieldExchangeRate        = big.NewInt(1 << 9)
	invoiceLineItemRequestFieldItem                = big.NewInt(1 << 10)
	invoiceLineItemRequestFieldAccount             = big.NewInt(1 << 11)
	invoiceLineItemRequestFieldTaxRate             = big.NewInt(1 << 12)
	invoiceLineItemRequestFieldTrackingCategory    = big.NewInt(1 << 13)
	invoiceLineItemRequestFieldTrackingCategories  = big.NewInt(1 << 14)
	invoiceLineItemRequestFieldCompany             = big.NewInt(1 << 15)
	invoiceLineItemRequestFieldIntegrationParams   = big.NewInt(1 << 16)
	invoiceLineItemRequestFieldLinkedAccountParams = big.NewInt(1 << 17)
	invoiceLineItemRequestFieldRemoteFields        = big.NewInt(1 << 18)
)

type InvoiceLineItemRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The line item's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The line item's unit price.
	UnitPrice *float64 `json:"unit_price,omitempty" url:"unit_price,omitempty"`
	// The line item's quantity.
	Quantity *float64 `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The line item's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The employee this overall transaction relates to.
	Employee *InvoiceLineItemRequestEmployee `json:"employee,omitempty" url:"employee,omitempty"`
	Project  *InvoiceLineItemRequestProject  `json:"project,omitempty" url:"project,omitempty"`
	// The invoice's contact.
	Contact *InvoiceLineItemRequestContact `json:"contact,omitempty" url:"contact,omitempty"`
	// The line item's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *InvoiceLineItemRequestCurrency `json:"currency,omitempty" url:"currency,omitempty"`
	// The line item's exchange rate.
	ExchangeRate *string                        `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	Item         *InvoiceLineItemRequestItem    `json:"item,omitempty" url:"item,omitempty"`
	Account      *InvoiceLineItemRequestAccount `json:"account,omitempty" url:"account,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate          *string                                 `json:"tax_rate,omitempty" url:"tax_rate,omitempty"`
	TrackingCategory *InvoiceLineItemRequestTrackingCategory `json:"tracking_category,omitempty" url:"tracking_category,omitempty"`
	// The invoice line item's associated tracking categories.
	TrackingCategories []*InvoiceLineItemRequestTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The company the invoice belongs to.
	Company             *string                `json:"company,omitempty" url:"company,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemRequest) GetRemoteId() *string {
	if i == nil {
		return nil
	}
	return i.RemoteId
}

func (i *InvoiceLineItemRequest) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemRequest) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemRequest) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemRequest) GetTotalAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TotalAmount
}

func (i *InvoiceLineItemRequest) GetEmployee() *InvoiceLineItemRequestEmployee {
	if i == nil {
		return nil
	}
	return i.Employee
}

func (i *InvoiceLineItemRequest) GetProject() *InvoiceLineItemRequestProject {
	if i == nil {
		return nil
	}
	return i.Project
}

func (i *InvoiceLineItemRequest) GetContact() *InvoiceLineItemRequestContact {
	if i == nil {
		return nil
	}
	return i.Contact
}

func (i *InvoiceLineItemRequest) GetCurrency() *InvoiceLineItemRequestCurrency {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceLineItemRequest) GetExchangeRate() *string {
	if i == nil {
		return nil
	}
	return i.ExchangeRate
}

func (i *InvoiceLineItemRequest) GetItem() *InvoiceLineItemRequestItem {
	if i == nil {
		return nil
	}
	return i.Item
}

func (i *InvoiceLineItemRequest) GetAccount() *InvoiceLineItemRequestAccount {
	if i == nil {
		return nil
	}
	return i.Account
}

func (i *InvoiceLineItemRequest) GetTaxRate() *string {
	if i == nil {
		return nil
	}
	return i.TaxRate
}

func (i *InvoiceLineItemRequest) GetTrackingCategory() *InvoiceLineItemRequestTrackingCategory {
	if i == nil {
		return nil
	}
	return i.TrackingCategory
}

func (i *InvoiceLineItemRequest) GetTrackingCategories() []*InvoiceLineItemRequestTrackingCategoriesItem {
	if i == nil {
		return nil
	}
	return i.TrackingCategories
}

func (i *InvoiceLineItemRequest) GetCompany() *string {
	if i == nil {
		return nil
	}
	return i.Company
}

func (i *InvoiceLineItemRequest) GetIntegrationParams() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.IntegrationParams
}

func (i *InvoiceLineItemRequest) GetLinkedAccountParams() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.LinkedAccountParams
}

func (i *InvoiceLineItemRequest) GetRemoteFields() []*RemoteFieldRequest {
	if i == nil {
		return nil
	}
	return i.RemoteFields
}

func (i *InvoiceLineItemRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetRemoteId sets the RemoteId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetRemoteId(remoteId *string) {
	i.RemoteId = remoteId
	i.require(invoiceLineItemRequestFieldRemoteId)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetDescription(description *string) {
	i.Description = description
	i.require(invoiceLineItemRequestFieldDescription)
}

// SetUnitPrice sets the UnitPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetUnitPrice(unitPrice *float64) {
	i.UnitPrice = unitPrice
	i.require(invoiceLineItemRequestFieldUnitPrice)
}

// SetQuantity sets the Quantity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetQuantity(quantity *float64) {
	i.Quantity = quantity
	i.require(invoiceLineItemRequestFieldQuantity)
}

// SetTotalAmount sets the TotalAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetTotalAmount(totalAmount *float64) {
	i.TotalAmount = totalAmount
	i.require(invoiceLineItemRequestFieldTotalAmount)
}

// SetEmployee sets the Employee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetEmployee(employee *InvoiceLineItemRequestEmployee) {
	i.Employee = employee
	i.require(invoiceLineItemRequestFieldEmployee)
}

// SetProject sets the Project field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetProject(project *InvoiceLineItemRequestProject) {
	i.Project = project
	i.require(invoiceLineItemRequestFieldProject)
}

// SetContact sets the Contact field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetContact(contact *InvoiceLineItemRequestContact) {
	i.Contact = contact
	i.require(invoiceLineItemRequestFieldContact)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetCurrency(currency *InvoiceLineItemRequestCurrency) {
	i.Currency = currency
	i.require(invoiceLineItemRequestFieldCurrency)
}

// SetExchangeRate sets the ExchangeRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetExchangeRate(exchangeRate *string) {
	i.ExchangeRate = exchangeRate
	i.require(invoiceLineItemRequestFieldExchangeRate)
}

// SetItem sets the Item field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetItem(item *InvoiceLineItemRequestItem) {
	i.Item = item
	i.require(invoiceLineItemRequestFieldItem)
}

// SetAccount sets the Account field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetAccount(account *InvoiceLineItemRequestAccount) {
	i.Account = account
	i.require(invoiceLineItemRequestFieldAccount)
}

// SetTaxRate sets the TaxRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetTaxRate(taxRate *string) {
	i.TaxRate = taxRate
	i.require(invoiceLineItemRequestFieldTaxRate)
}

// SetTrackingCategory sets the TrackingCategory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetTrackingCategory(trackingCategory *InvoiceLineItemRequestTrackingCategory) {
	i.TrackingCategory = trackingCategory
	i.require(invoiceLineItemRequestFieldTrackingCategory)
}

// SetTrackingCategories sets the TrackingCategories field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetTrackingCategories(trackingCategories []*InvoiceLineItemRequestTrackingCategoriesItem) {
	i.TrackingCategories = trackingCategories
	i.require(invoiceLineItemRequestFieldTrackingCategories)
}

// SetCompany sets the Company field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetCompany(company *string) {
	i.Company = company
	i.require(invoiceLineItemRequestFieldCompany)
}

// SetIntegrationParams sets the IntegrationParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetIntegrationParams(integrationParams map[string]interface{}) {
	i.IntegrationParams = integrationParams
	i.require(invoiceLineItemRequestFieldIntegrationParams)
}

// SetLinkedAccountParams sets the LinkedAccountParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetLinkedAccountParams(linkedAccountParams map[string]interface{}) {
	i.LinkedAccountParams = linkedAccountParams
	i.require(invoiceLineItemRequestFieldLinkedAccountParams)
}

// SetRemoteFields sets the RemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceLineItemRequest) SetRemoteFields(remoteFields []*RemoteFieldRequest) {
	i.RemoteFields = remoteFields
	i.require(invoiceLineItemRequestFieldRemoteFields)
}

func (i *InvoiceLineItemRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceLineItemRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceLineItemRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InvoiceLineItemRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemRequestAccount struct {
	String  string
	Account *Account

	typ string
}

func (i *InvoiceLineItemRequestAccount) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemRequestAccount) GetAccount() *Account {
	if i == nil {
		return nil
	}
	return i.Account
}

func (i *InvoiceLineItemRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		i.typ = "Account"
		i.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestAccount) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Account" || i.Account != nil {
		return json.Marshal(i.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (i *InvoiceLineItemRequestAccount) Accept(visitor InvoiceLineItemRequestAccountVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Account" || i.Account != nil {
		return visitor.VisitAccount(i.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The invoice's contact.
type InvoiceLineItemRequestContact struct {
	String  string
	Contact *Contact

	typ string
}

func (i *InvoiceLineItemRequestContact) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemRequestContact) GetContact() *Contact {
	if i == nil {
		return nil
	}
	return i.Contact
}

func (i *InvoiceLineItemRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		i.typ = "Contact"
		i.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestContact) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Contact" || i.Contact != nil {
		return json.Marshal(i.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (i *InvoiceLineItemRequestContact) Accept(visitor InvoiceLineItemRequestContactVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Contact" || i.Contact != nil {
		return visitor.VisitContact(i.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The line item's currency.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type InvoiceLineItemRequestCurrency struct {
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string

	typ string
}

func (i *InvoiceLineItemRequestCurrency) GetTransactionCurrencyEnum() TransactionCurrencyEnum {
	if i == nil {
		return ""
	}
	return i.TransactionCurrencyEnum
}

func (i *InvoiceLineItemRequestCurrency) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		i.typ = "TransactionCurrencyEnum"
		i.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestCurrency) MarshalJSON() ([]byte, error) {
	if i.typ == "TransactionCurrencyEnum" || i.TransactionCurrencyEnum != "" {
		return json.Marshal(i.TransactionCurrencyEnum)
	}
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (i *InvoiceLineItemRequestCurrency) Accept(visitor InvoiceLineItemRequestCurrencyVisitor) error {
	if i.typ == "TransactionCurrencyEnum" || i.TransactionCurrencyEnum != "" {
		return visitor.VisitTransactionCurrencyEnum(i.TransactionCurrencyEnum)
	}
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The employee this overall transaction relates to.
type InvoiceLineItemRequestEmployee struct {
	String   string
	Employee *Employee

	typ string
}

func (i *InvoiceLineItemRequestEmployee) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemRequestEmployee) GetEmployee() *Employee {
	if i == nil {
		return nil
	}
	return i.Employee
}

func (i *InvoiceLineItemRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		i.typ = "Employee"
		i.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestEmployee) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Employee" || i.Employee != nil {
		return json.Marshal(i.Employee)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (i *InvoiceLineItemRequestEmployee) Accept(visitor InvoiceLineItemRequestEmployeeVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Employee" || i.Employee != nil {
		return visitor.VisitEmployee(i.Employee)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestItem struct {
	String string
	Item   *Item

	typ string
}

func (i *InvoiceLineItemRequestItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemRequestItem) GetItem() *Item {
	if i == nil {
		return nil
	}
	return i.Item
}

func (i *InvoiceLineItemRequestItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueItem := new(Item)
	if err := json.Unmarshal(data, &valueItem); err == nil {
		i.typ = "Item"
		i.Item = valueItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Item" || i.Item != nil {
		return json.Marshal(i.Item)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestItemVisitor interface {
	VisitString(string) error
	VisitItem(*Item) error
}

func (i *InvoiceLineItemRequestItem) Accept(visitor InvoiceLineItemRequestItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Item" || i.Item != nil {
		return visitor.VisitItem(i.Item)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestProject struct {
	String  string
	Project *Project

	typ string
}

func (i *InvoiceLineItemRequestProject) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemRequestProject) GetProject() *Project {
	if i == nil {
		return nil
	}
	return i.Project
}

func (i *InvoiceLineItemRequestProject) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueProject := new(Project)
	if err := json.Unmarshal(data, &valueProject); err == nil {
		i.typ = "Project"
		i.Project = valueProject
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestProject) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Project" || i.Project != nil {
		return json.Marshal(i.Project)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestProjectVisitor interface {
	VisitString(string) error
	VisitProject(*Project) error
}

func (i *InvoiceLineItemRequestProject) Accept(visitor InvoiceLineItemRequestProjectVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Project" || i.Project != nil {
		return visitor.VisitProject(i.Project)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (i *InvoiceLineItemRequestTrackingCategoriesItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemRequestTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if i == nil {
		return nil
	}
	return i.TrackingCategory
}

func (i *InvoiceLineItemRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typ = "TrackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return json.Marshal(i.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceLineItemRequestTrackingCategoriesItem) Accept(visitor InvoiceLineItemRequestTrackingCategoriesItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestTrackingCategory struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (i *InvoiceLineItemRequestTrackingCategory) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceLineItemRequestTrackingCategory) GetTrackingCategory() *TrackingCategory {
	if i == nil {
		return nil
	}
	return i.TrackingCategory
}

func (i *InvoiceLineItemRequestTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typ = "TrackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceLineItemRequestTrackingCategory) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return json.Marshal(i.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceLineItemRequestTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceLineItemRequestTrackingCategory) Accept(visitor InvoiceLineItemRequestTrackingCategoryVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// # The Invoice Object
// ### Description
// The `Invoice` object represents an itemized record of goods and/or services sold to a customer or bought from a vendor.
//
// Represents a Bill when the `Invoice` type is `ACCOUNTS_PAYABLE`. References an Invoice when the `Invoice` type is `ACCOUNTS_RECEIVABLE`.
//
// ### Usage Example
// Fetch from the `LIST Invoices` endpoint and view a company's invoices.
var (
	invoiceRequestFieldType                = big.NewInt(1 << 0)
	invoiceRequestFieldContact             = big.NewInt(1 << 1)
	invoiceRequestFieldNumber              = big.NewInt(1 << 2)
	invoiceRequestFieldIssueDate           = big.NewInt(1 << 3)
	invoiceRequestFieldDueDate             = big.NewInt(1 << 4)
	invoiceRequestFieldPaidOnDate          = big.NewInt(1 << 5)
	invoiceRequestFieldEmployee            = big.NewInt(1 << 6)
	invoiceRequestFieldMemo                = big.NewInt(1 << 7)
	invoiceRequestFieldStatus              = big.NewInt(1 << 8)
	invoiceRequestFieldCompany             = big.NewInt(1 << 9)
	invoiceRequestFieldCurrency            = big.NewInt(1 << 10)
	invoiceRequestFieldExchangeRate        = big.NewInt(1 << 11)
	invoiceRequestFieldTotalDiscount       = big.NewInt(1 << 12)
	invoiceRequestFieldSubTotal            = big.NewInt(1 << 13)
	invoiceRequestFieldPaymentTerm         = big.NewInt(1 << 14)
	invoiceRequestFieldTotalTaxAmount      = big.NewInt(1 << 15)
	invoiceRequestFieldInclusiveOfTax      = big.NewInt(1 << 16)
	invoiceRequestFieldTotalAmount         = big.NewInt(1 << 17)
	invoiceRequestFieldBalance             = big.NewInt(1 << 18)
	invoiceRequestFieldPayments            = big.NewInt(1 << 19)
	invoiceRequestFieldTrackingCategories  = big.NewInt(1 << 20)
	invoiceRequestFieldLineItems           = big.NewInt(1 << 21)
	invoiceRequestFieldPurchaseOrders      = big.NewInt(1 << 22)
	invoiceRequestFieldIntegrationParams   = big.NewInt(1 << 23)
	invoiceRequestFieldLinkedAccountParams = big.NewInt(1 << 24)
	invoiceRequestFieldRemoteFields        = big.NewInt(1 << 25)
)

type InvoiceRequest struct {
	// Whether the invoice is an accounts receivable or accounts payable. If `type` is `ACCOUNTS_PAYABLE`, the invoice is a bill. If `type` is `ACCOUNTS_RECEIVABLE`, it is an invoice.
	//
	// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	Type *InvoiceRequestType `json:"type,omitempty" url:"type,omitempty"`
	// The invoice's contact.
	Contact *InvoiceRequestContact `json:"contact,omitempty" url:"contact,omitempty"`
	// The invoice's number.
	Number *string `json:"number,omitempty" url:"number,omitempty"`
	// The invoice's issue date.
	IssueDate *time.Time `json:"issue_date,omitempty" url:"issue_date,omitempty"`
	// The invoice's due date.
	DueDate *time.Time `json:"due_date,omitempty" url:"due_date,omitempty"`
	// The invoice's paid date.
	PaidOnDate *time.Time `json:"paid_on_date,omitempty" url:"paid_on_date,omitempty"`
	// The employee this overall transaction relates to.
	Employee *InvoiceRequestEmployee `json:"employee,omitempty" url:"employee,omitempty"`
	// The invoice's private note.
	Memo *string `json:"memo,omitempty" url:"memo,omitempty"`
	// The status of the invoice.
	//
	// * `PAID` - PAID
	// * `DRAFT` - DRAFT
	// * `SUBMITTED` - SUBMITTED
	// * `PARTIALLY_PAID` - PARTIALLY_PAID
	// * `OPEN` - OPEN
	// * `VOID` - VOID
	Status *InvoiceRequestStatus `json:"status,omitempty" url:"status,omitempty"`
	// The company the invoice belongs to.
	Company *InvoiceRequestCompany `json:"company,omitempty" url:"company,omitempty"`
	// The invoice's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *InvoiceRequestCurrency `json:"currency,omitempty" url:"currency,omitempty"`
	// The invoice's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The total discounts applied to the total cost.
	TotalDiscount *float64 `json:"total_discount,omitempty" url:"total_discount,omitempty"`
	// The total amount being paid before taxes.
	SubTotal *float64 `json:"sub_total,omitempty" url:"sub_total,omitempty"`
	// The payment term that applies to this transaction.
	PaymentTerm *InvoiceRequestPaymentTerm `json:"payment_term,omitempty" url:"payment_term,omitempty"`
	// The total amount being paid in taxes.
	TotalTaxAmount *float64 `json:"total_tax_amount,omitempty" url:"total_tax_amount,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool `json:"inclusive_of_tax,omitempty" url:"inclusive_of_tax,omitempty"`
	// The invoice's total amount.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The invoice's remaining balance.
	Balance *float64 `json:"balance,omitempty" url:"balance,omitempty"`
	// Array of `Payment` object IDs.
	Payments            []*InvoiceRequestPaymentsItem           `json:"payments,omitempty" url:"payments,omitempty"`
	TrackingCategories  []*InvoiceRequestTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	LineItems           []*InvoiceLineItemRequest               `json:"line_items,omitempty" url:"line_items,omitempty"`
	PurchaseOrders      []*InvoiceRequestPurchaseOrdersItem     `json:"purchase_orders,omitempty" url:"purchase_orders,omitempty"`
	IntegrationParams   map[string]interface{}                  `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}                  `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest                   `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceRequest) GetType() *InvoiceRequestType {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceRequest) GetContact() *InvoiceRequestContact {
	if i == nil {
		return nil
	}
	return i.Contact
}

func (i *InvoiceRequest) GetNumber() *string {
	if i == nil {
		return nil
	}
	return i.Number
}

func (i *InvoiceRequest) GetIssueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.IssueDate
}

func (i *InvoiceRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceRequest) GetPaidOnDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.PaidOnDate
}

func (i *InvoiceRequest) GetEmployee() *InvoiceRequestEmployee {
	if i == nil {
		return nil
	}
	return i.Employee
}

func (i *InvoiceRequest) GetMemo() *string {
	if i == nil {
		return nil
	}
	return i.Memo
}

func (i *InvoiceRequest) GetStatus() *InvoiceRequestStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceRequest) GetCompany() *InvoiceRequestCompany {
	if i == nil {
		return nil
	}
	return i.Company
}

func (i *InvoiceRequest) GetCurrency() *InvoiceRequestCurrency {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceRequest) GetExchangeRate() *string {
	if i == nil {
		return nil
	}
	return i.ExchangeRate
}

func (i *InvoiceRequest) GetTotalDiscount() *float64 {
	if i == nil {
		return nil
	}
	return i.TotalDiscount
}

func (i *InvoiceRequest) GetSubTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.SubTotal
}

func (i *InvoiceRequest) GetPaymentTerm() *InvoiceRequestPaymentTerm {
	if i == nil {
		return nil
	}
	return i.PaymentTerm
}

func (i *InvoiceRequest) GetTotalTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TotalTaxAmount
}

func (i *InvoiceRequest) GetInclusiveOfTax() *bool {
	if i == nil {
		return nil
	}
	return i.InclusiveOfTax
}

func (i *InvoiceRequest) GetTotalAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TotalAmount
}

func (i *InvoiceRequest) GetBalance() *float64 {
	if i == nil {
		return nil
	}
	return i.Balance
}

func (i *InvoiceRequest) GetPayments() []*InvoiceRequestPaymentsItem {
	if i == nil {
		return nil
	}
	return i.Payments
}

func (i *InvoiceRequest) GetTrackingCategories() []*InvoiceRequestTrackingCategoriesItem {
	if i == nil {
		return nil
	}
	return i.TrackingCategories
}

func (i *InvoiceRequest) GetLineItems() []*InvoiceLineItemRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceRequest) GetPurchaseOrders() []*InvoiceRequestPurchaseOrdersItem {
	if i == nil {
		return nil
	}
	return i.PurchaseOrders
}

func (i *InvoiceRequest) GetIntegrationParams() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.IntegrationParams
}

func (i *InvoiceRequest) GetLinkedAccountParams() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.LinkedAccountParams
}

func (i *InvoiceRequest) GetRemoteFields() []*RemoteFieldRequest {
	if i == nil {
		return nil
	}
	return i.RemoteFields
}

func (i *InvoiceRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetType(type_ *InvoiceRequestType) {
	i.Type = type_
	i.require(invoiceRequestFieldType)
}

// SetContact sets the Contact field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetContact(contact *InvoiceRequestContact) {
	i.Contact = contact
	i.require(invoiceRequestFieldContact)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetNumber(number *string) {
	i.Number = number
	i.require(invoiceRequestFieldNumber)
}

// SetIssueDate sets the IssueDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetIssueDate(issueDate *time.Time) {
	i.IssueDate = issueDate
	i.require(invoiceRequestFieldIssueDate)
}

// SetDueDate sets the DueDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetDueDate(dueDate *time.Time) {
	i.DueDate = dueDate
	i.require(invoiceRequestFieldDueDate)
}

// SetPaidOnDate sets the PaidOnDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetPaidOnDate(paidOnDate *time.Time) {
	i.PaidOnDate = paidOnDate
	i.require(invoiceRequestFieldPaidOnDate)
}

// SetEmployee sets the Employee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetEmployee(employee *InvoiceRequestEmployee) {
	i.Employee = employee
	i.require(invoiceRequestFieldEmployee)
}

// SetMemo sets the Memo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetMemo(memo *string) {
	i.Memo = memo
	i.require(invoiceRequestFieldMemo)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetStatus(status *InvoiceRequestStatus) {
	i.Status = status
	i.require(invoiceRequestFieldStatus)
}

// SetCompany sets the Company field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetCompany(company *InvoiceRequestCompany) {
	i.Company = company
	i.require(invoiceRequestFieldCompany)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetCurrency(currency *InvoiceRequestCurrency) {
	i.Currency = currency
	i.require(invoiceRequestFieldCurrency)
}

// SetExchangeRate sets the ExchangeRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetExchangeRate(exchangeRate *string) {
	i.ExchangeRate = exchangeRate
	i.require(invoiceRequestFieldExchangeRate)
}

// SetTotalDiscount sets the TotalDiscount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetTotalDiscount(totalDiscount *float64) {
	i.TotalDiscount = totalDiscount
	i.require(invoiceRequestFieldTotalDiscount)
}

// SetSubTotal sets the SubTotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetSubTotal(subTotal *float64) {
	i.SubTotal = subTotal
	i.require(invoiceRequestFieldSubTotal)
}

// SetPaymentTerm sets the PaymentTerm field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetPaymentTerm(paymentTerm *InvoiceRequestPaymentTerm) {
	i.PaymentTerm = paymentTerm
	i.require(invoiceRequestFieldPaymentTerm)
}

// SetTotalTaxAmount sets the TotalTaxAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetTotalTaxAmount(totalTaxAmount *float64) {
	i.TotalTaxAmount = totalTaxAmount
	i.require(invoiceRequestFieldTotalTaxAmount)
}

// SetInclusiveOfTax sets the InclusiveOfTax field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetInclusiveOfTax(inclusiveOfTax *bool) {
	i.InclusiveOfTax = inclusiveOfTax
	i.require(invoiceRequestFieldInclusiveOfTax)
}

// SetTotalAmount sets the TotalAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetTotalAmount(totalAmount *float64) {
	i.TotalAmount = totalAmount
	i.require(invoiceRequestFieldTotalAmount)
}

// SetBalance sets the Balance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetBalance(balance *float64) {
	i.Balance = balance
	i.require(invoiceRequestFieldBalance)
}

// SetPayments sets the Payments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetPayments(payments []*InvoiceRequestPaymentsItem) {
	i.Payments = payments
	i.require(invoiceRequestFieldPayments)
}

// SetTrackingCategories sets the TrackingCategories field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetTrackingCategories(trackingCategories []*InvoiceRequestTrackingCategoriesItem) {
	i.TrackingCategories = trackingCategories
	i.require(invoiceRequestFieldTrackingCategories)
}

// SetLineItems sets the LineItems field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetLineItems(lineItems []*InvoiceLineItemRequest) {
	i.LineItems = lineItems
	i.require(invoiceRequestFieldLineItems)
}

// SetPurchaseOrders sets the PurchaseOrders field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetPurchaseOrders(purchaseOrders []*InvoiceRequestPurchaseOrdersItem) {
	i.PurchaseOrders = purchaseOrders
	i.require(invoiceRequestFieldPurchaseOrders)
}

// SetIntegrationParams sets the IntegrationParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetIntegrationParams(integrationParams map[string]interface{}) {
	i.IntegrationParams = integrationParams
	i.require(invoiceRequestFieldIntegrationParams)
}

// SetLinkedAccountParams sets the LinkedAccountParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetLinkedAccountParams(linkedAccountParams map[string]interface{}) {
	i.LinkedAccountParams = linkedAccountParams
	i.require(invoiceRequestFieldLinkedAccountParams)
}

// SetRemoteFields sets the RemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceRequest) SetRemoteFields(remoteFields []*RemoteFieldRequest) {
	i.RemoteFields = remoteFields
	i.require(invoiceRequestFieldRemoteFields)
}

func (i *InvoiceRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceRequest
	var unmarshaler = struct {
		embed
		IssueDate  *internal.DateTime `json:"issue_date,omitempty"`
		DueDate    *internal.DateTime `json:"due_date,omitempty"`
		PaidOnDate *internal.DateTime `json:"paid_on_date,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceRequest(unmarshaler.embed)
	i.IssueDate = unmarshaler.IssueDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.PaidOnDate = unmarshaler.PaidOnDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceRequest
	var marshaler = struct {
		embed
		IssueDate  *internal.DateTime `json:"issue_date,omitempty"`
		DueDate    *internal.DateTime `json:"due_date,omitempty"`
		PaidOnDate *internal.DateTime `json:"paid_on_date,omitempty"`
	}{
		embed:      embed(*i),
		IssueDate:  internal.NewOptionalDateTime(i.IssueDate),
		DueDate:    internal.NewOptionalDateTime(i.DueDate),
		PaidOnDate: internal.NewOptionalDateTime(i.PaidOnDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InvoiceRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The company the invoice belongs to.
type InvoiceRequestCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (i *InvoiceRequestCompany) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestCompany) GetCompanyInfo() *CompanyInfo {
	if i == nil {
		return nil
	}
	return i.CompanyInfo
}

func (i *InvoiceRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		i.typ = "CompanyInfo"
		i.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestCompany) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "CompanyInfo" || i.CompanyInfo != nil {
		return json.Marshal(i.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (i *InvoiceRequestCompany) Accept(visitor InvoiceRequestCompanyVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "CompanyInfo" || i.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(i.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The invoice's contact.
type InvoiceRequestContact struct {
	String  string
	Contact *Contact

	typ string
}

func (i *InvoiceRequestContact) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestContact) GetContact() *Contact {
	if i == nil {
		return nil
	}
	return i.Contact
}

func (i *InvoiceRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		i.typ = "Contact"
		i.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestContact) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Contact" || i.Contact != nil {
		return json.Marshal(i.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (i *InvoiceRequestContact) Accept(visitor InvoiceRequestContactVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Contact" || i.Contact != nil {
		return visitor.VisitContact(i.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The invoice's currency.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type InvoiceRequestCurrency struct {
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string

	typ string
}

func (i *InvoiceRequestCurrency) GetTransactionCurrencyEnum() TransactionCurrencyEnum {
	if i == nil {
		return ""
	}
	return i.TransactionCurrencyEnum
}

func (i *InvoiceRequestCurrency) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		i.typ = "TransactionCurrencyEnum"
		i.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestCurrency) MarshalJSON() ([]byte, error) {
	if i.typ == "TransactionCurrencyEnum" || i.TransactionCurrencyEnum != "" {
		return json.Marshal(i.TransactionCurrencyEnum)
	}
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (i *InvoiceRequestCurrency) Accept(visitor InvoiceRequestCurrencyVisitor) error {
	if i.typ == "TransactionCurrencyEnum" || i.TransactionCurrencyEnum != "" {
		return visitor.VisitTransactionCurrencyEnum(i.TransactionCurrencyEnum)
	}
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The employee this overall transaction relates to.
type InvoiceRequestEmployee struct {
	String   string
	Employee *Employee

	typ string
}

func (i *InvoiceRequestEmployee) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestEmployee) GetEmployee() *Employee {
	if i == nil {
		return nil
	}
	return i.Employee
}

func (i *InvoiceRequestEmployee) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueEmployee := new(Employee)
	if err := json.Unmarshal(data, &valueEmployee); err == nil {
		i.typ = "Employee"
		i.Employee = valueEmployee
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestEmployee) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Employee" || i.Employee != nil {
		return json.Marshal(i.Employee)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestEmployeeVisitor interface {
	VisitString(string) error
	VisitEmployee(*Employee) error
}

func (i *InvoiceRequestEmployee) Accept(visitor InvoiceRequestEmployeeVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Employee" || i.Employee != nil {
		return visitor.VisitEmployee(i.Employee)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The payment term that applies to this transaction.
type InvoiceRequestPaymentTerm struct {
	String      string
	PaymentTerm *PaymentTerm

	typ string
}

func (i *InvoiceRequestPaymentTerm) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestPaymentTerm) GetPaymentTerm() *PaymentTerm {
	if i == nil {
		return nil
	}
	return i.PaymentTerm
}

func (i *InvoiceRequestPaymentTerm) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valuePaymentTerm := new(PaymentTerm)
	if err := json.Unmarshal(data, &valuePaymentTerm); err == nil {
		i.typ = "PaymentTerm"
		i.PaymentTerm = valuePaymentTerm
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestPaymentTerm) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "PaymentTerm" || i.PaymentTerm != nil {
		return json.Marshal(i.PaymentTerm)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestPaymentTermVisitor interface {
	VisitString(string) error
	VisitPaymentTerm(*PaymentTerm) error
}

func (i *InvoiceRequestPaymentTerm) Accept(visitor InvoiceRequestPaymentTermVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "PaymentTerm" || i.PaymentTerm != nil {
		return visitor.VisitPaymentTerm(i.PaymentTerm)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestPaymentsItem struct {
	String  string
	Payment *Payment

	typ string
}

func (i *InvoiceRequestPaymentsItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestPaymentsItem) GetPayment() *Payment {
	if i == nil {
		return nil
	}
	return i.Payment
}

func (i *InvoiceRequestPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		i.typ = "Payment"
		i.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestPaymentsItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "Payment" || i.Payment != nil {
		return json.Marshal(i.Payment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (i *InvoiceRequestPaymentsItem) Accept(visitor InvoiceRequestPaymentsItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "Payment" || i.Payment != nil {
		return visitor.VisitPayment(i.Payment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestPurchaseOrdersItem struct {
	String        string
	PurchaseOrder *PurchaseOrder

	typ string
}

func (i *InvoiceRequestPurchaseOrdersItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestPurchaseOrdersItem) GetPurchaseOrder() *PurchaseOrder {
	if i == nil {
		return nil
	}
	return i.PurchaseOrder
}

func (i *InvoiceRequestPurchaseOrdersItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valuePurchaseOrder := new(PurchaseOrder)
	if err := json.Unmarshal(data, &valuePurchaseOrder); err == nil {
		i.typ = "PurchaseOrder"
		i.PurchaseOrder = valuePurchaseOrder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestPurchaseOrdersItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "PurchaseOrder" || i.PurchaseOrder != nil {
		return json.Marshal(i.PurchaseOrder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestPurchaseOrdersItemVisitor interface {
	VisitString(string) error
	VisitPurchaseOrder(*PurchaseOrder) error
}

func (i *InvoiceRequestPurchaseOrdersItem) Accept(visitor InvoiceRequestPurchaseOrdersItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "PurchaseOrder" || i.PurchaseOrder != nil {
		return visitor.VisitPurchaseOrder(i.PurchaseOrder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// The status of the invoice.
//
// * `PAID` - PAID
// * `DRAFT` - DRAFT
// * `SUBMITTED` - SUBMITTED
// * `PARTIALLY_PAID` - PARTIALLY_PAID
// * `OPEN` - OPEN
// * `VOID` - VOID
type InvoiceRequestStatus struct {
	InvoiceStatusEnum InvoiceStatusEnum
	String            string

	typ string
}

func (i *InvoiceRequestStatus) GetInvoiceStatusEnum() InvoiceStatusEnum {
	if i == nil {
		return ""
	}
	return i.InvoiceStatusEnum
}

func (i *InvoiceRequestStatus) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestStatus) UnmarshalJSON(data []byte) error {
	var valueInvoiceStatusEnum InvoiceStatusEnum
	if err := json.Unmarshal(data, &valueInvoiceStatusEnum); err == nil {
		i.typ = "InvoiceStatusEnum"
		i.InvoiceStatusEnum = valueInvoiceStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestStatus) MarshalJSON() ([]byte, error) {
	if i.typ == "InvoiceStatusEnum" || i.InvoiceStatusEnum != "" {
		return json.Marshal(i.InvoiceStatusEnum)
	}
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestStatusVisitor interface {
	VisitInvoiceStatusEnum(InvoiceStatusEnum) error
	VisitString(string) error
}

func (i *InvoiceRequestStatus) Accept(visitor InvoiceRequestStatusVisitor) error {
	if i.typ == "InvoiceStatusEnum" || i.InvoiceStatusEnum != "" {
		return visitor.VisitInvoiceStatusEnum(i.InvoiceStatusEnum)
	}
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (i *InvoiceRequestTrackingCategoriesItem) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if i == nil {
		return nil
	}
	return i.TrackingCategory
}

func (i *InvoiceRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		i.typ = "TrackingCategory"
		i.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return json.Marshal(i.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (i *InvoiceRequestTrackingCategoriesItem) Accept(visitor InvoiceRequestTrackingCategoriesItemVisitor) error {
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	if i.typ == "TrackingCategory" || i.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(i.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

// Whether the invoice is an accounts receivable or accounts payable. If `type` is `ACCOUNTS_PAYABLE`, the invoice is a bill. If `type` is `ACCOUNTS_RECEIVABLE`, it is an invoice.
//
// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
type InvoiceRequestType struct {
	InvoiceTypeEnum InvoiceTypeEnum
	String          string

	typ string
}

func (i *InvoiceRequestType) GetInvoiceTypeEnum() InvoiceTypeEnum {
	if i == nil {
		return ""
	}
	return i.InvoiceTypeEnum
}

func (i *InvoiceRequestType) GetString() string {
	if i == nil {
		return ""
	}
	return i.String
}

func (i *InvoiceRequestType) UnmarshalJSON(data []byte) error {
	var valueInvoiceTypeEnum InvoiceTypeEnum
	if err := json.Unmarshal(data, &valueInvoiceTypeEnum); err == nil {
		i.typ = "InvoiceTypeEnum"
		i.InvoiceTypeEnum = valueInvoiceTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typ = "String"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceRequestType) MarshalJSON() ([]byte, error) {
	if i.typ == "InvoiceTypeEnum" || i.InvoiceTypeEnum != "" {
		return json.Marshal(i.InvoiceTypeEnum)
	}
	if i.typ == "String" || i.String != "" {
		return json.Marshal(i.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceRequestTypeVisitor interface {
	VisitInvoiceTypeEnum(InvoiceTypeEnum) error
	VisitString(string) error
}

func (i *InvoiceRequestType) Accept(visitor InvoiceRequestTypeVisitor) error {
	if i.typ == "InvoiceTypeEnum" || i.InvoiceTypeEnum != "" {
		return visitor.VisitInvoiceTypeEnum(i.InvoiceTypeEnum)
	}
	if i.typ == "String" || i.String != "" {
		return visitor.VisitString(i.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

var (
	invoiceResponseFieldModel    = big.NewInt(1 << 0)
	invoiceResponseFieldWarnings = big.NewInt(1 << 1)
	invoiceResponseFieldErrors   = big.NewInt(1 << 2)
	invoiceResponseFieldLogs     = big.NewInt(1 << 3)
)

type InvoiceResponse struct {
	Model    *Invoice                    `json:"model" url:"model"`
	Warnings []*WarningValidationProblem `json:"warnings" url:"warnings"`
	Errors   []*ErrorValidationProblem   `json:"errors" url:"errors"`
	Logs     []*DebugModeLog             `json:"logs,omitempty" url:"logs,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceResponse) GetModel() *Invoice {
	if i == nil {
		return nil
	}
	return i.Model
}

func (i *InvoiceResponse) GetWarnings() []*WarningValidationProblem {
	if i == nil {
		return nil
	}
	return i.Warnings
}

func (i *InvoiceResponse) GetErrors() []*ErrorValidationProblem {
	if i == nil {
		return nil
	}
	return i.Errors
}

func (i *InvoiceResponse) GetLogs() []*DebugModeLog {
	if i == nil {
		return nil
	}
	return i.Logs
}

func (i *InvoiceResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceResponse) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceResponse) SetModel(model *Invoice) {
	i.Model = model
	i.require(invoiceResponseFieldModel)
}

// SetWarnings sets the Warnings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceResponse) SetWarnings(warnings []*WarningValidationProblem) {
	i.Warnings = warnings
	i.require(invoiceResponseFieldWarnings)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceResponse) SetErrors(errors []*ErrorValidationProblem) {
	i.Errors = errors
	i.require(invoiceResponseFieldErrors)
}

// SetLogs sets the Logs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InvoiceResponse) SetLogs(logs []*DebugModeLog) {
	i.Logs = logs
	i.require(invoiceResponseFieldLogs)
}

func (i *InvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InvoiceResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	paginatedInvoiceListFieldNext     = big.NewInt(1 << 0)
	paginatedInvoiceListFieldPrevious = big.NewInt(1 << 1)
	paginatedInvoiceListFieldResults  = big.NewInt(1 << 2)
)

type PaginatedInvoiceList struct {
	Next     *string    `json:"next,omitempty" url:"next,omitempty"`
	Previous *string    `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*Invoice `json:"results,omitempty" url:"results,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedInvoiceList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedInvoiceList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedInvoiceList) GetResults() []*Invoice {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedInvoiceList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedInvoiceList) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedInvoiceList) SetNext(next *string) {
	p.Next = next
	p.require(paginatedInvoiceListFieldNext)
}

// SetPrevious sets the Previous field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedInvoiceList) SetPrevious(previous *string) {
	p.Previous = previous
	p.require(paginatedInvoiceListFieldPrevious)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedInvoiceList) SetResults(results []*Invoice) {
	p.Results = results
	p.require(paginatedInvoiceListFieldResults)
}

func (p *PaginatedInvoiceList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedInvoiceList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedInvoiceList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedInvoiceList) MarshalJSON() ([]byte, error) {
	type embed PaginatedInvoiceList
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedInvoiceList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
