// Code generated by Fern. DO NOT EDIT.

package accounting

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	big "math/big"
	time "time"
)

var (
	journalEntryEndpointRequestFieldIsDebugMode = big.NewInt(1 << 0)
	journalEntryEndpointRequestFieldRunAsync    = big.NewInt(1 << 1)
	journalEntryEndpointRequestFieldModel       = big.NewInt(1 << 2)
)

type JournalEntryEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool                `json:"-" url:"run_async,omitempty"`
	Model    *JournalEntryRequest `json:"model,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (j *JournalEntryEndpointRequest) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetIsDebugMode sets the IsDebugMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryEndpointRequest) SetIsDebugMode(isDebugMode *bool) {
	j.IsDebugMode = isDebugMode
	j.require(journalEntryEndpointRequestFieldIsDebugMode)
}

// SetRunAsync sets the RunAsync field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryEndpointRequest) SetRunAsync(runAsync *bool) {
	j.RunAsync = runAsync
	j.require(journalEntryEndpointRequestFieldRunAsync)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryEndpointRequest) SetModel(model *JournalEntryRequest) {
	j.Model = model
	j.require(journalEntryEndpointRequestFieldModel)
}

var (
	journalEntriesLinesRemoteFieldClassesListRequestFieldCursor             = big.NewInt(1 << 0)
	journalEntriesLinesRemoteFieldClassesListRequestFieldIncludeDeletedData = big.NewInt(1 << 1)
	journalEntriesLinesRemoteFieldClassesListRequestFieldIncludeRemoteData  = big.NewInt(1 << 2)
	journalEntriesLinesRemoteFieldClassesListRequestFieldIncludeShellData   = big.NewInt(1 << 3)
	journalEntriesLinesRemoteFieldClassesListRequestFieldIsCommonModelField = big.NewInt(1 << 4)
	journalEntriesLinesRemoteFieldClassesListRequestFieldIsCustom           = big.NewInt(1 << 5)
	journalEntriesLinesRemoteFieldClassesListRequestFieldPageSize           = big.NewInt(1 << 6)
)

type JournalEntriesLinesRemoteFieldClassesListRequest struct {
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return remote field classes with this is_common_model_field value
	IsCommonModelField *bool `json:"-" url:"is_common_model_field,omitempty"`
	// If provided, will only return remote fields classes with this is_custom value
	IsCustom *bool `json:"-" url:"is_custom,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (j *JournalEntriesLinesRemoteFieldClassesListRequest) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesLinesRemoteFieldClassesListRequest) SetCursor(cursor *string) {
	j.Cursor = cursor
	j.require(journalEntriesLinesRemoteFieldClassesListRequestFieldCursor)
}

// SetIncludeDeletedData sets the IncludeDeletedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesLinesRemoteFieldClassesListRequest) SetIncludeDeletedData(includeDeletedData *bool) {
	j.IncludeDeletedData = includeDeletedData
	j.require(journalEntriesLinesRemoteFieldClassesListRequestFieldIncludeDeletedData)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesLinesRemoteFieldClassesListRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	j.IncludeRemoteData = includeRemoteData
	j.require(journalEntriesLinesRemoteFieldClassesListRequestFieldIncludeRemoteData)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesLinesRemoteFieldClassesListRequest) SetIncludeShellData(includeShellData *bool) {
	j.IncludeShellData = includeShellData
	j.require(journalEntriesLinesRemoteFieldClassesListRequestFieldIncludeShellData)
}

// SetIsCommonModelField sets the IsCommonModelField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesLinesRemoteFieldClassesListRequest) SetIsCommonModelField(isCommonModelField *bool) {
	j.IsCommonModelField = isCommonModelField
	j.require(journalEntriesLinesRemoteFieldClassesListRequestFieldIsCommonModelField)
}

// SetIsCustom sets the IsCustom field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesLinesRemoteFieldClassesListRequest) SetIsCustom(isCustom *bool) {
	j.IsCustom = isCustom
	j.require(journalEntriesLinesRemoteFieldClassesListRequestFieldIsCustom)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesLinesRemoteFieldClassesListRequest) SetPageSize(pageSize *int) {
	j.PageSize = pageSize
	j.require(journalEntriesLinesRemoteFieldClassesListRequestFieldPageSize)
}

var (
	journalEntriesListRequestFieldCompanyId             = big.NewInt(1 << 0)
	journalEntriesListRequestFieldCreatedAfter          = big.NewInt(1 << 1)
	journalEntriesListRequestFieldCreatedBefore         = big.NewInt(1 << 2)
	journalEntriesListRequestFieldCursor                = big.NewInt(1 << 3)
	journalEntriesListRequestFieldExpand                = big.NewInt(1 << 4)
	journalEntriesListRequestFieldIncludeDeletedData    = big.NewInt(1 << 5)
	journalEntriesListRequestFieldIncludeRemoteData     = big.NewInt(1 << 6)
	journalEntriesListRequestFieldIncludeRemoteFields   = big.NewInt(1 << 7)
	journalEntriesListRequestFieldIncludeShellData      = big.NewInt(1 << 8)
	journalEntriesListRequestFieldModifiedAfter         = big.NewInt(1 << 9)
	journalEntriesListRequestFieldModifiedBefore        = big.NewInt(1 << 10)
	journalEntriesListRequestFieldPageSize              = big.NewInt(1 << 11)
	journalEntriesListRequestFieldRemoteId              = big.NewInt(1 << 12)
	journalEntriesListRequestFieldTransactionDateAfter  = big.NewInt(1 << 13)
	journalEntriesListRequestFieldTransactionDateBefore = big.NewInt(1 << 14)
)

type JournalEntriesListRequest struct {
	// If provided, will only return journal entries for this company.
	CompanyId *string `json:"-" url:"company_id,omitempty"`
	// If provided, will only return objects created after this datetime.
	CreatedAfter *time.Time `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *time.Time `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*JournalEntriesListRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, only objects synced by Merge after this date time will be returned.
	ModifiedAfter *time.Time `json:"-" url:"modified_after,omitempty"`
	// If provided, only objects synced by Merge before this date time will be returned.
	ModifiedBefore *time.Time `json:"-" url:"modified_before,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// The API provider's ID for the given object.
	RemoteId *string `json:"-" url:"remote_id,omitempty"`
	// If provided, will only return objects created after this datetime.
	TransactionDateAfter *time.Time `json:"-" url:"transaction_date_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	TransactionDateBefore *time.Time `json:"-" url:"transaction_date_before,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (j *JournalEntriesListRequest) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetCompanyId sets the CompanyId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetCompanyId(companyId *string) {
	j.CompanyId = companyId
	j.require(journalEntriesListRequestFieldCompanyId)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetCreatedAfter(createdAfter *time.Time) {
	j.CreatedAfter = createdAfter
	j.require(journalEntriesListRequestFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetCreatedBefore(createdBefore *time.Time) {
	j.CreatedBefore = createdBefore
	j.require(journalEntriesListRequestFieldCreatedBefore)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetCursor(cursor *string) {
	j.Cursor = cursor
	j.require(journalEntriesListRequestFieldCursor)
}

// SetExpand sets the Expand field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetExpand(expand []*JournalEntriesListRequestExpandItem) {
	j.Expand = expand
	j.require(journalEntriesListRequestFieldExpand)
}

// SetIncludeDeletedData sets the IncludeDeletedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetIncludeDeletedData(includeDeletedData *bool) {
	j.IncludeDeletedData = includeDeletedData
	j.require(journalEntriesListRequestFieldIncludeDeletedData)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	j.IncludeRemoteData = includeRemoteData
	j.require(journalEntriesListRequestFieldIncludeRemoteData)
}

// SetIncludeRemoteFields sets the IncludeRemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetIncludeRemoteFields(includeRemoteFields *bool) {
	j.IncludeRemoteFields = includeRemoteFields
	j.require(journalEntriesListRequestFieldIncludeRemoteFields)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetIncludeShellData(includeShellData *bool) {
	j.IncludeShellData = includeShellData
	j.require(journalEntriesListRequestFieldIncludeShellData)
}

// SetModifiedAfter sets the ModifiedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetModifiedAfter(modifiedAfter *time.Time) {
	j.ModifiedAfter = modifiedAfter
	j.require(journalEntriesListRequestFieldModifiedAfter)
}

// SetModifiedBefore sets the ModifiedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetModifiedBefore(modifiedBefore *time.Time) {
	j.ModifiedBefore = modifiedBefore
	j.require(journalEntriesListRequestFieldModifiedBefore)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetPageSize(pageSize *int) {
	j.PageSize = pageSize
	j.require(journalEntriesListRequestFieldPageSize)
}

// SetRemoteId sets the RemoteId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetRemoteId(remoteId *string) {
	j.RemoteId = remoteId
	j.require(journalEntriesListRequestFieldRemoteId)
}

// SetTransactionDateAfter sets the TransactionDateAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetTransactionDateAfter(transactionDateAfter *time.Time) {
	j.TransactionDateAfter = transactionDateAfter
	j.require(journalEntriesListRequestFieldTransactionDateAfter)
}

// SetTransactionDateBefore sets the TransactionDateBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesListRequest) SetTransactionDateBefore(transactionDateBefore *time.Time) {
	j.TransactionDateBefore = transactionDateBefore
	j.require(journalEntriesListRequestFieldTransactionDateBefore)
}

var (
	journalEntriesRemoteFieldClassesListRequestFieldCursor             = big.NewInt(1 << 0)
	journalEntriesRemoteFieldClassesListRequestFieldIncludeDeletedData = big.NewInt(1 << 1)
	journalEntriesRemoteFieldClassesListRequestFieldIncludeRemoteData  = big.NewInt(1 << 2)
	journalEntriesRemoteFieldClassesListRequestFieldIncludeShellData   = big.NewInt(1 << 3)
	journalEntriesRemoteFieldClassesListRequestFieldIsCommonModelField = big.NewInt(1 << 4)
	journalEntriesRemoteFieldClassesListRequestFieldIsCustom           = big.NewInt(1 << 5)
	journalEntriesRemoteFieldClassesListRequestFieldPageSize           = big.NewInt(1 << 6)
)

type JournalEntriesRemoteFieldClassesListRequest struct {
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return remote field classes with this is_common_model_field value
	IsCommonModelField *bool `json:"-" url:"is_common_model_field,omitempty"`
	// If provided, will only return remote fields classes with this is_custom value
	IsCustom *bool `json:"-" url:"is_custom,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (j *JournalEntriesRemoteFieldClassesListRequest) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRemoteFieldClassesListRequest) SetCursor(cursor *string) {
	j.Cursor = cursor
	j.require(journalEntriesRemoteFieldClassesListRequestFieldCursor)
}

// SetIncludeDeletedData sets the IncludeDeletedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRemoteFieldClassesListRequest) SetIncludeDeletedData(includeDeletedData *bool) {
	j.IncludeDeletedData = includeDeletedData
	j.require(journalEntriesRemoteFieldClassesListRequestFieldIncludeDeletedData)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRemoteFieldClassesListRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	j.IncludeRemoteData = includeRemoteData
	j.require(journalEntriesRemoteFieldClassesListRequestFieldIncludeRemoteData)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRemoteFieldClassesListRequest) SetIncludeShellData(includeShellData *bool) {
	j.IncludeShellData = includeShellData
	j.require(journalEntriesRemoteFieldClassesListRequestFieldIncludeShellData)
}

// SetIsCommonModelField sets the IsCommonModelField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRemoteFieldClassesListRequest) SetIsCommonModelField(isCommonModelField *bool) {
	j.IsCommonModelField = isCommonModelField
	j.require(journalEntriesRemoteFieldClassesListRequestFieldIsCommonModelField)
}

// SetIsCustom sets the IsCustom field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRemoteFieldClassesListRequest) SetIsCustom(isCustom *bool) {
	j.IsCustom = isCustom
	j.require(journalEntriesRemoteFieldClassesListRequestFieldIsCustom)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRemoteFieldClassesListRequest) SetPageSize(pageSize *int) {
	j.PageSize = pageSize
	j.require(journalEntriesRemoteFieldClassesListRequestFieldPageSize)
}

var (
	journalEntriesRetrieveRequestFieldExpand              = big.NewInt(1 << 0)
	journalEntriesRetrieveRequestFieldIncludeRemoteData   = big.NewInt(1 << 1)
	journalEntriesRetrieveRequestFieldIncludeRemoteFields = big.NewInt(1 << 2)
	journalEntriesRetrieveRequestFieldIncludeShellData    = big.NewInt(1 << 3)
)

type JournalEntriesRetrieveRequest struct {
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*JournalEntriesRetrieveRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (j *JournalEntriesRetrieveRequest) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetExpand sets the Expand field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRetrieveRequest) SetExpand(expand []*JournalEntriesRetrieveRequestExpandItem) {
	j.Expand = expand
	j.require(journalEntriesRetrieveRequestFieldExpand)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRetrieveRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	j.IncludeRemoteData = includeRemoteData
	j.require(journalEntriesRetrieveRequestFieldIncludeRemoteData)
}

// SetIncludeRemoteFields sets the IncludeRemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRetrieveRequest) SetIncludeRemoteFields(includeRemoteFields *bool) {
	j.IncludeRemoteFields = includeRemoteFields
	j.require(journalEntriesRetrieveRequestFieldIncludeRemoteFields)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntriesRetrieveRequest) SetIncludeShellData(includeShellData *bool) {
	j.IncludeShellData = includeShellData
	j.require(journalEntriesRetrieveRequestFieldIncludeShellData)
}

type JournalEntriesListRequestExpandItem string

const (
	JournalEntriesListRequestExpandItemAccountingPeriod   JournalEntriesListRequestExpandItem = "accounting_period"
	JournalEntriesListRequestExpandItemAppliedPayments    JournalEntriesListRequestExpandItem = "applied_payments"
	JournalEntriesListRequestExpandItemCompany            JournalEntriesListRequestExpandItem = "company"
	JournalEntriesListRequestExpandItemLines              JournalEntriesListRequestExpandItem = "lines"
	JournalEntriesListRequestExpandItemPayments           JournalEntriesListRequestExpandItem = "payments"
	JournalEntriesListRequestExpandItemTrackingCategories JournalEntriesListRequestExpandItem = "tracking_categories"
)

func NewJournalEntriesListRequestExpandItemFromString(s string) (JournalEntriesListRequestExpandItem, error) {
	switch s {
	case "accounting_period":
		return JournalEntriesListRequestExpandItemAccountingPeriod, nil
	case "applied_payments":
		return JournalEntriesListRequestExpandItemAppliedPayments, nil
	case "company":
		return JournalEntriesListRequestExpandItemCompany, nil
	case "lines":
		return JournalEntriesListRequestExpandItemLines, nil
	case "payments":
		return JournalEntriesListRequestExpandItemPayments, nil
	case "tracking_categories":
		return JournalEntriesListRequestExpandItemTrackingCategories, nil
	}
	var t JournalEntriesListRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JournalEntriesListRequestExpandItem) Ptr() *JournalEntriesListRequestExpandItem {
	return &j
}

type JournalEntriesRetrieveRequestExpandItem string

const (
	JournalEntriesRetrieveRequestExpandItemAccountingPeriod   JournalEntriesRetrieveRequestExpandItem = "accounting_period"
	JournalEntriesRetrieveRequestExpandItemAppliedPayments    JournalEntriesRetrieveRequestExpandItem = "applied_payments"
	JournalEntriesRetrieveRequestExpandItemCompany            JournalEntriesRetrieveRequestExpandItem = "company"
	JournalEntriesRetrieveRequestExpandItemLines              JournalEntriesRetrieveRequestExpandItem = "lines"
	JournalEntriesRetrieveRequestExpandItemPayments           JournalEntriesRetrieveRequestExpandItem = "payments"
	JournalEntriesRetrieveRequestExpandItemTrackingCategories JournalEntriesRetrieveRequestExpandItem = "tracking_categories"
)

func NewJournalEntriesRetrieveRequestExpandItemFromString(s string) (JournalEntriesRetrieveRequestExpandItem, error) {
	switch s {
	case "accounting_period":
		return JournalEntriesRetrieveRequestExpandItemAccountingPeriod, nil
	case "applied_payments":
		return JournalEntriesRetrieveRequestExpandItemAppliedPayments, nil
	case "company":
		return JournalEntriesRetrieveRequestExpandItemCompany, nil
	case "lines":
		return JournalEntriesRetrieveRequestExpandItemLines, nil
	case "payments":
		return JournalEntriesRetrieveRequestExpandItemPayments, nil
	case "tracking_categories":
		return JournalEntriesRetrieveRequestExpandItemTrackingCategories, nil
	}
	var t JournalEntriesRetrieveRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JournalEntriesRetrieveRequestExpandItem) Ptr() *JournalEntriesRetrieveRequestExpandItem {
	return &j
}

// # The JournalEntry Object
// ### Description
// A `JournalEntry` is a record of a transaction or event that is entered into a company's accounting system.
//
// The `JournalEntry` common model contains records that are automatically created as a result of a certain type of transaction, like an Invoice, and records that are manually created against a company’s ledger.
//
// The lines of a given `JournalEntry` object should always sum to 0. A positive `net_amount` means the line represents a debit and a negative net_amount represents a credit.
//
// ### Usage Example
// Fetch from the `GET JournalEntry` endpoint and view a company's journey entry.
var (
	journalEntryFieldId                 = big.NewInt(1 << 0)
	journalEntryFieldRemoteId           = big.NewInt(1 << 1)
	journalEntryFieldCreatedAt          = big.NewInt(1 << 2)
	journalEntryFieldModifiedAt         = big.NewInt(1 << 3)
	journalEntryFieldTransactionDate    = big.NewInt(1 << 4)
	journalEntryFieldPayments           = big.NewInt(1 << 5)
	journalEntryFieldAppliedPayments    = big.NewInt(1 << 6)
	journalEntryFieldMemo               = big.NewInt(1 << 7)
	journalEntryFieldCurrency           = big.NewInt(1 << 8)
	journalEntryFieldExchangeRate       = big.NewInt(1 << 9)
	journalEntryFieldCompany            = big.NewInt(1 << 10)
	journalEntryFieldInclusiveOfTax     = big.NewInt(1 << 11)
	journalEntryFieldLines              = big.NewInt(1 << 12)
	journalEntryFieldJournalNumber      = big.NewInt(1 << 13)
	journalEntryFieldTrackingCategories = big.NewInt(1 << 14)
	journalEntryFieldRemoteWasDeleted   = big.NewInt(1 << 15)
	journalEntryFieldPostingStatus      = big.NewInt(1 << 16)
	journalEntryFieldAccountingPeriod   = big.NewInt(1 << 17)
	journalEntryFieldRemoteCreatedAt    = big.NewInt(1 << 18)
	journalEntryFieldRemoteUpdatedAt    = big.NewInt(1 << 19)
	journalEntryFieldFieldMappings      = big.NewInt(1 << 20)
	journalEntryFieldRemoteData         = big.NewInt(1 << 21)
	journalEntryFieldRemoteFields       = big.NewInt(1 << 22)
)

type JournalEntry struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The journal entry's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty" url:"transaction_date,omitempty"`
	// Array of `Payment` object IDs.
	Payments []*JournalEntryPaymentsItem `json:"payments,omitempty" url:"payments,omitempty"`
	// A list of the Payment Applied to Lines common models related to a given Invoice, Credit Note, or Journal Entry.
	AppliedPayments []*JournalEntryAppliedPaymentsItem `json:"applied_payments,omitempty" url:"applied_payments,omitempty"`
	// The journal entry's private note.
	Memo *string `json:"memo,omitempty" url:"memo,omitempty"`
	// The journal's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *JournalEntryCurrency `json:"currency,omitempty" url:"currency,omitempty"`
	// The journal entry's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The company the journal entry belongs to.
	Company *JournalEntryCompany `json:"company,omitempty" url:"company,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool          `json:"inclusive_of_tax,omitempty" url:"inclusive_of_tax,omitempty"`
	Lines          []*JournalLine `json:"lines,omitempty" url:"lines,omitempty"`
	// Reference number for identifying journal entries.
	JournalNumber      *string                               `json:"journal_number,omitempty" url:"journal_number,omitempty"`
	TrackingCategories []*JournalEntryTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	// The journal's posting status.
	//
	// * `UNPOSTED` - UNPOSTED
	// * `POSTED` - POSTED
	PostingStatus *JournalEntryPostingStatus `json:"posting_status,omitempty" url:"posting_status,omitempty"`
	// The accounting period that the JournalEntry was generated in.
	AccountingPeriod *JournalEntryAccountingPeriod `json:"accounting_period,omitempty" url:"accounting_period,omitempty"`
	// When the third party's journal entry was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's journal entry was updated.
	RemoteUpdatedAt *time.Time             `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	FieldMappings   map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData      []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`
	RemoteFields    []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JournalEntry) GetId() *string {
	if j == nil {
		return nil
	}
	return j.Id
}

func (j *JournalEntry) GetRemoteId() *string {
	if j == nil {
		return nil
	}
	return j.RemoteId
}

func (j *JournalEntry) GetCreatedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.CreatedAt
}

func (j *JournalEntry) GetModifiedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.ModifiedAt
}

func (j *JournalEntry) GetTransactionDate() *time.Time {
	if j == nil {
		return nil
	}
	return j.TransactionDate
}

func (j *JournalEntry) GetPayments() []*JournalEntryPaymentsItem {
	if j == nil {
		return nil
	}
	return j.Payments
}

func (j *JournalEntry) GetAppliedPayments() []*JournalEntryAppliedPaymentsItem {
	if j == nil {
		return nil
	}
	return j.AppliedPayments
}

func (j *JournalEntry) GetMemo() *string {
	if j == nil {
		return nil
	}
	return j.Memo
}

func (j *JournalEntry) GetCurrency() *JournalEntryCurrency {
	if j == nil {
		return nil
	}
	return j.Currency
}

func (j *JournalEntry) GetExchangeRate() *string {
	if j == nil {
		return nil
	}
	return j.ExchangeRate
}

func (j *JournalEntry) GetCompany() *JournalEntryCompany {
	if j == nil {
		return nil
	}
	return j.Company
}

func (j *JournalEntry) GetInclusiveOfTax() *bool {
	if j == nil {
		return nil
	}
	return j.InclusiveOfTax
}

func (j *JournalEntry) GetLines() []*JournalLine {
	if j == nil {
		return nil
	}
	return j.Lines
}

func (j *JournalEntry) GetJournalNumber() *string {
	if j == nil {
		return nil
	}
	return j.JournalNumber
}

func (j *JournalEntry) GetTrackingCategories() []*JournalEntryTrackingCategoriesItem {
	if j == nil {
		return nil
	}
	return j.TrackingCategories
}

func (j *JournalEntry) GetRemoteWasDeleted() *bool {
	if j == nil {
		return nil
	}
	return j.RemoteWasDeleted
}

func (j *JournalEntry) GetPostingStatus() *JournalEntryPostingStatus {
	if j == nil {
		return nil
	}
	return j.PostingStatus
}

func (j *JournalEntry) GetAccountingPeriod() *JournalEntryAccountingPeriod {
	if j == nil {
		return nil
	}
	return j.AccountingPeriod
}

func (j *JournalEntry) GetRemoteCreatedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.RemoteCreatedAt
}

func (j *JournalEntry) GetRemoteUpdatedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.RemoteUpdatedAt
}

func (j *JournalEntry) GetFieldMappings() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.FieldMappings
}

func (j *JournalEntry) GetRemoteData() []*RemoteData {
	if j == nil {
		return nil
	}
	return j.RemoteData
}

func (j *JournalEntry) GetRemoteFields() []*RemoteField {
	if j == nil {
		return nil
	}
	return j.RemoteFields
}

func (j *JournalEntry) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JournalEntry) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetId(id *string) {
	j.Id = id
	j.require(journalEntryFieldId)
}

// SetRemoteId sets the RemoteId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetRemoteId(remoteId *string) {
	j.RemoteId = remoteId
	j.require(journalEntryFieldRemoteId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetCreatedAt(createdAt *time.Time) {
	j.CreatedAt = createdAt
	j.require(journalEntryFieldCreatedAt)
}

// SetModifiedAt sets the ModifiedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetModifiedAt(modifiedAt *time.Time) {
	j.ModifiedAt = modifiedAt
	j.require(journalEntryFieldModifiedAt)
}

// SetTransactionDate sets the TransactionDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetTransactionDate(transactionDate *time.Time) {
	j.TransactionDate = transactionDate
	j.require(journalEntryFieldTransactionDate)
}

// SetPayments sets the Payments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetPayments(payments []*JournalEntryPaymentsItem) {
	j.Payments = payments
	j.require(journalEntryFieldPayments)
}

// SetAppliedPayments sets the AppliedPayments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetAppliedPayments(appliedPayments []*JournalEntryAppliedPaymentsItem) {
	j.AppliedPayments = appliedPayments
	j.require(journalEntryFieldAppliedPayments)
}

// SetMemo sets the Memo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetMemo(memo *string) {
	j.Memo = memo
	j.require(journalEntryFieldMemo)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetCurrency(currency *JournalEntryCurrency) {
	j.Currency = currency
	j.require(journalEntryFieldCurrency)
}

// SetExchangeRate sets the ExchangeRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetExchangeRate(exchangeRate *string) {
	j.ExchangeRate = exchangeRate
	j.require(journalEntryFieldExchangeRate)
}

// SetCompany sets the Company field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetCompany(company *JournalEntryCompany) {
	j.Company = company
	j.require(journalEntryFieldCompany)
}

// SetInclusiveOfTax sets the InclusiveOfTax field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetInclusiveOfTax(inclusiveOfTax *bool) {
	j.InclusiveOfTax = inclusiveOfTax
	j.require(journalEntryFieldInclusiveOfTax)
}

// SetLines sets the Lines field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetLines(lines []*JournalLine) {
	j.Lines = lines
	j.require(journalEntryFieldLines)
}

// SetJournalNumber sets the JournalNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetJournalNumber(journalNumber *string) {
	j.JournalNumber = journalNumber
	j.require(journalEntryFieldJournalNumber)
}

// SetTrackingCategories sets the TrackingCategories field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetTrackingCategories(trackingCategories []*JournalEntryTrackingCategoriesItem) {
	j.TrackingCategories = trackingCategories
	j.require(journalEntryFieldTrackingCategories)
}

// SetRemoteWasDeleted sets the RemoteWasDeleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetRemoteWasDeleted(remoteWasDeleted *bool) {
	j.RemoteWasDeleted = remoteWasDeleted
	j.require(journalEntryFieldRemoteWasDeleted)
}

// SetPostingStatus sets the PostingStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetPostingStatus(postingStatus *JournalEntryPostingStatus) {
	j.PostingStatus = postingStatus
	j.require(journalEntryFieldPostingStatus)
}

// SetAccountingPeriod sets the AccountingPeriod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetAccountingPeriod(accountingPeriod *JournalEntryAccountingPeriod) {
	j.AccountingPeriod = accountingPeriod
	j.require(journalEntryFieldAccountingPeriod)
}

// SetRemoteCreatedAt sets the RemoteCreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetRemoteCreatedAt(remoteCreatedAt *time.Time) {
	j.RemoteCreatedAt = remoteCreatedAt
	j.require(journalEntryFieldRemoteCreatedAt)
}

// SetRemoteUpdatedAt sets the RemoteUpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetRemoteUpdatedAt(remoteUpdatedAt *time.Time) {
	j.RemoteUpdatedAt = remoteUpdatedAt
	j.require(journalEntryFieldRemoteUpdatedAt)
}

// SetFieldMappings sets the FieldMappings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetFieldMappings(fieldMappings map[string]interface{}) {
	j.FieldMappings = fieldMappings
	j.require(journalEntryFieldFieldMappings)
}

// SetRemoteData sets the RemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetRemoteData(remoteData []*RemoteData) {
	j.RemoteData = remoteData
	j.require(journalEntryFieldRemoteData)
}

// SetRemoteFields sets the RemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntry) SetRemoteFields(remoteFields []*RemoteField) {
	j.RemoteFields = remoteFields
	j.require(journalEntryFieldRemoteFields)
}

func (j *JournalEntry) UnmarshalJSON(data []byte) error {
	type embed JournalEntry
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = JournalEntry(unmarshaler.embed)
	j.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	j.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	j.TransactionDate = unmarshaler.TransactionDate.TimePtr()
	j.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	j.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalEntry) MarshalJSON() ([]byte, error) {
	type embed JournalEntry
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*j),
		CreatedAt:       internal.NewOptionalDateTime(j.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(j.ModifiedAt),
		TransactionDate: internal.NewOptionalDateTime(j.TransactionDate),
		RemoteCreatedAt: internal.NewOptionalDateTime(j.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(j.RemoteUpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JournalEntry) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The accounting period that the JournalEntry was generated in.
type JournalEntryAccountingPeriod struct {
	String           string
	AccountingPeriod *AccountingPeriod

	typ string
}

func (j *JournalEntryAccountingPeriod) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryAccountingPeriod) GetAccountingPeriod() *AccountingPeriod {
	if j == nil {
		return nil
	}
	return j.AccountingPeriod
}

func (j *JournalEntryAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		j.typ = "AccountingPeriod"
		j.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryAccountingPeriod) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "AccountingPeriod" || j.AccountingPeriod != nil {
		return json.Marshal(j.AccountingPeriod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (j *JournalEntryAccountingPeriod) Accept(visitor JournalEntryAccountingPeriodVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "AccountingPeriod" || j.AccountingPeriod != nil {
		return visitor.VisitAccountingPeriod(j.AccountingPeriod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryAppliedPaymentsItem struct {
	String          string
	PaymentLineItem *PaymentLineItem

	typ string
}

func (j *JournalEntryAppliedPaymentsItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryAppliedPaymentsItem) GetPaymentLineItem() *PaymentLineItem {
	if j == nil {
		return nil
	}
	return j.PaymentLineItem
}

func (j *JournalEntryAppliedPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valuePaymentLineItem := new(PaymentLineItem)
	if err := json.Unmarshal(data, &valuePaymentLineItem); err == nil {
		j.typ = "PaymentLineItem"
		j.PaymentLineItem = valuePaymentLineItem
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryAppliedPaymentsItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "PaymentLineItem" || j.PaymentLineItem != nil {
		return json.Marshal(j.PaymentLineItem)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryAppliedPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItem(*PaymentLineItem) error
}

func (j *JournalEntryAppliedPaymentsItem) Accept(visitor JournalEntryAppliedPaymentsItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "PaymentLineItem" || j.PaymentLineItem != nil {
		return visitor.VisitPaymentLineItem(j.PaymentLineItem)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// The company the journal entry belongs to.
type JournalEntryCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (j *JournalEntryCompany) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryCompany) GetCompanyInfo() *CompanyInfo {
	if j == nil {
		return nil
	}
	return j.CompanyInfo
}

func (j *JournalEntryCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		j.typ = "CompanyInfo"
		j.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryCompany) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "CompanyInfo" || j.CompanyInfo != nil {
		return json.Marshal(j.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (j *JournalEntryCompany) Accept(visitor JournalEntryCompanyVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "CompanyInfo" || j.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(j.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// The journal's currency.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type JournalEntryCurrency struct {
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string

	typ string
}

func (j *JournalEntryCurrency) GetTransactionCurrencyEnum() TransactionCurrencyEnum {
	if j == nil {
		return ""
	}
	return j.TransactionCurrencyEnum
}

func (j *JournalEntryCurrency) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		j.typ = "TransactionCurrencyEnum"
		j.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryCurrency) MarshalJSON() ([]byte, error) {
	if j.typ == "TransactionCurrencyEnum" || j.TransactionCurrencyEnum != "" {
		return json.Marshal(j.TransactionCurrencyEnum)
	}
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (j *JournalEntryCurrency) Accept(visitor JournalEntryCurrencyVisitor) error {
	if j.typ == "TransactionCurrencyEnum" || j.TransactionCurrencyEnum != "" {
		return visitor.VisitTransactionCurrencyEnum(j.TransactionCurrencyEnum)
	}
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryPaymentsItem struct {
	String  string
	Payment *Payment

	typ string
}

func (j *JournalEntryPaymentsItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryPaymentsItem) GetPayment() *Payment {
	if j == nil {
		return nil
	}
	return j.Payment
}

func (j *JournalEntryPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		j.typ = "Payment"
		j.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryPaymentsItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Payment" || j.Payment != nil {
		return json.Marshal(j.Payment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (j *JournalEntryPaymentsItem) Accept(visitor JournalEntryPaymentsItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Payment" || j.Payment != nil {
		return visitor.VisitPayment(j.Payment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// The journal's posting status.
//
// * `UNPOSTED` - UNPOSTED
// * `POSTED` - POSTED
type JournalEntryPostingStatus struct {
	PostingStatusEnum PostingStatusEnum
	String            string

	typ string
}

func (j *JournalEntryPostingStatus) GetPostingStatusEnum() PostingStatusEnum {
	if j == nil {
		return ""
	}
	return j.PostingStatusEnum
}

func (j *JournalEntryPostingStatus) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryPostingStatus) UnmarshalJSON(data []byte) error {
	var valuePostingStatusEnum PostingStatusEnum
	if err := json.Unmarshal(data, &valuePostingStatusEnum); err == nil {
		j.typ = "PostingStatusEnum"
		j.PostingStatusEnum = valuePostingStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryPostingStatus) MarshalJSON() ([]byte, error) {
	if j.typ == "PostingStatusEnum" || j.PostingStatusEnum != "" {
		return json.Marshal(j.PostingStatusEnum)
	}
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryPostingStatusVisitor interface {
	VisitPostingStatusEnum(PostingStatusEnum) error
	VisitString(string) error
}

func (j *JournalEntryPostingStatus) Accept(visitor JournalEntryPostingStatusVisitor) error {
	if j.typ == "PostingStatusEnum" || j.PostingStatusEnum != "" {
		return visitor.VisitPostingStatusEnum(j.PostingStatusEnum)
	}
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// # The JournalEntry Object
// ### Description
// The `JournalEntry` object is used to get a record of all manually created entries made in a company’s general ledger. The journal line items for each journal entry should sum to zero.
//
// ### Usage Example
// Fetch from the `GET JournalEntry` endpoint and view a company's journey entry.
var (
	journalEntryRequestFieldTransactionDate     = big.NewInt(1 << 0)
	journalEntryRequestFieldPayments            = big.NewInt(1 << 1)
	journalEntryRequestFieldMemo                = big.NewInt(1 << 2)
	journalEntryRequestFieldCurrency            = big.NewInt(1 << 3)
	journalEntryRequestFieldExchangeRate        = big.NewInt(1 << 4)
	journalEntryRequestFieldCompany             = big.NewInt(1 << 5)
	journalEntryRequestFieldTrackingCategories  = big.NewInt(1 << 6)
	journalEntryRequestFieldInclusiveOfTax      = big.NewInt(1 << 7)
	journalEntryRequestFieldLines               = big.NewInt(1 << 8)
	journalEntryRequestFieldJournalNumber       = big.NewInt(1 << 9)
	journalEntryRequestFieldPostingStatus       = big.NewInt(1 << 10)
	journalEntryRequestFieldIntegrationParams   = big.NewInt(1 << 11)
	journalEntryRequestFieldLinkedAccountParams = big.NewInt(1 << 12)
	journalEntryRequestFieldRemoteFields        = big.NewInt(1 << 13)
)

type JournalEntryRequest struct {
	// The journal entry's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty" url:"transaction_date,omitempty"`
	// Array of `Payment` object IDs.
	Payments []*JournalEntryRequestPaymentsItem `json:"payments,omitempty" url:"payments,omitempty"`
	// The journal entry's private note.
	Memo *string `json:"memo,omitempty" url:"memo,omitempty"`
	// The journal's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *JournalEntryRequestCurrency `json:"currency,omitempty" url:"currency,omitempty"`
	// The journal entry's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The company the journal entry belongs to.
	Company            *JournalEntryRequestCompany                  `json:"company,omitempty" url:"company,omitempty"`
	TrackingCategories []*JournalEntryRequestTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// If the transaction is inclusive or exclusive of tax. `True` if inclusive, `False` if exclusive.
	InclusiveOfTax *bool                 `json:"inclusive_of_tax,omitempty" url:"inclusive_of_tax,omitempty"`
	Lines          []*JournalLineRequest `json:"lines,omitempty" url:"lines,omitempty"`
	// Reference number for identifying journal entries.
	JournalNumber *string `json:"journal_number,omitempty" url:"journal_number,omitempty"`
	// The journal's posting status.
	//
	// * `UNPOSTED` - UNPOSTED
	// * `POSTED` - POSTED
	PostingStatus       *JournalEntryRequestPostingStatus `json:"posting_status,omitempty" url:"posting_status,omitempty"`
	IntegrationParams   map[string]interface{}            `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}            `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest             `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JournalEntryRequest) GetTransactionDate() *time.Time {
	if j == nil {
		return nil
	}
	return j.TransactionDate
}

func (j *JournalEntryRequest) GetPayments() []*JournalEntryRequestPaymentsItem {
	if j == nil {
		return nil
	}
	return j.Payments
}

func (j *JournalEntryRequest) GetMemo() *string {
	if j == nil {
		return nil
	}
	return j.Memo
}

func (j *JournalEntryRequest) GetCurrency() *JournalEntryRequestCurrency {
	if j == nil {
		return nil
	}
	return j.Currency
}

func (j *JournalEntryRequest) GetExchangeRate() *string {
	if j == nil {
		return nil
	}
	return j.ExchangeRate
}

func (j *JournalEntryRequest) GetCompany() *JournalEntryRequestCompany {
	if j == nil {
		return nil
	}
	return j.Company
}

func (j *JournalEntryRequest) GetTrackingCategories() []*JournalEntryRequestTrackingCategoriesItem {
	if j == nil {
		return nil
	}
	return j.TrackingCategories
}

func (j *JournalEntryRequest) GetInclusiveOfTax() *bool {
	if j == nil {
		return nil
	}
	return j.InclusiveOfTax
}

func (j *JournalEntryRequest) GetLines() []*JournalLineRequest {
	if j == nil {
		return nil
	}
	return j.Lines
}

func (j *JournalEntryRequest) GetJournalNumber() *string {
	if j == nil {
		return nil
	}
	return j.JournalNumber
}

func (j *JournalEntryRequest) GetPostingStatus() *JournalEntryRequestPostingStatus {
	if j == nil {
		return nil
	}
	return j.PostingStatus
}

func (j *JournalEntryRequest) GetIntegrationParams() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.IntegrationParams
}

func (j *JournalEntryRequest) GetLinkedAccountParams() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.LinkedAccountParams
}

func (j *JournalEntryRequest) GetRemoteFields() []*RemoteFieldRequest {
	if j == nil {
		return nil
	}
	return j.RemoteFields
}

func (j *JournalEntryRequest) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JournalEntryRequest) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetTransactionDate sets the TransactionDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetTransactionDate(transactionDate *time.Time) {
	j.TransactionDate = transactionDate
	j.require(journalEntryRequestFieldTransactionDate)
}

// SetPayments sets the Payments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetPayments(payments []*JournalEntryRequestPaymentsItem) {
	j.Payments = payments
	j.require(journalEntryRequestFieldPayments)
}

// SetMemo sets the Memo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetMemo(memo *string) {
	j.Memo = memo
	j.require(journalEntryRequestFieldMemo)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetCurrency(currency *JournalEntryRequestCurrency) {
	j.Currency = currency
	j.require(journalEntryRequestFieldCurrency)
}

// SetExchangeRate sets the ExchangeRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetExchangeRate(exchangeRate *string) {
	j.ExchangeRate = exchangeRate
	j.require(journalEntryRequestFieldExchangeRate)
}

// SetCompany sets the Company field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetCompany(company *JournalEntryRequestCompany) {
	j.Company = company
	j.require(journalEntryRequestFieldCompany)
}

// SetTrackingCategories sets the TrackingCategories field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetTrackingCategories(trackingCategories []*JournalEntryRequestTrackingCategoriesItem) {
	j.TrackingCategories = trackingCategories
	j.require(journalEntryRequestFieldTrackingCategories)
}

// SetInclusiveOfTax sets the InclusiveOfTax field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetInclusiveOfTax(inclusiveOfTax *bool) {
	j.InclusiveOfTax = inclusiveOfTax
	j.require(journalEntryRequestFieldInclusiveOfTax)
}

// SetLines sets the Lines field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetLines(lines []*JournalLineRequest) {
	j.Lines = lines
	j.require(journalEntryRequestFieldLines)
}

// SetJournalNumber sets the JournalNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetJournalNumber(journalNumber *string) {
	j.JournalNumber = journalNumber
	j.require(journalEntryRequestFieldJournalNumber)
}

// SetPostingStatus sets the PostingStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetPostingStatus(postingStatus *JournalEntryRequestPostingStatus) {
	j.PostingStatus = postingStatus
	j.require(journalEntryRequestFieldPostingStatus)
}

// SetIntegrationParams sets the IntegrationParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetIntegrationParams(integrationParams map[string]interface{}) {
	j.IntegrationParams = integrationParams
	j.require(journalEntryRequestFieldIntegrationParams)
}

// SetLinkedAccountParams sets the LinkedAccountParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetLinkedAccountParams(linkedAccountParams map[string]interface{}) {
	j.LinkedAccountParams = linkedAccountParams
	j.require(journalEntryRequestFieldLinkedAccountParams)
}

// SetRemoteFields sets the RemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryRequest) SetRemoteFields(remoteFields []*RemoteFieldRequest) {
	j.RemoteFields = remoteFields
	j.require(journalEntryRequestFieldRemoteFields)
}

func (j *JournalEntryRequest) UnmarshalJSON(data []byte) error {
	type embed JournalEntryRequest
	var unmarshaler = struct {
		embed
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = JournalEntryRequest(unmarshaler.embed)
	j.TransactionDate = unmarshaler.TransactionDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalEntryRequest) MarshalJSON() ([]byte, error) {
	type embed JournalEntryRequest
	var marshaler = struct {
		embed
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
	}{
		embed:           embed(*j),
		TransactionDate: internal.NewOptionalDateTime(j.TransactionDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JournalEntryRequest) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// The company the journal entry belongs to.
type JournalEntryRequestCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (j *JournalEntryRequestCompany) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryRequestCompany) GetCompanyInfo() *CompanyInfo {
	if j == nil {
		return nil
	}
	return j.CompanyInfo
}

func (j *JournalEntryRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		j.typ = "CompanyInfo"
		j.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestCompany) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "CompanyInfo" || j.CompanyInfo != nil {
		return json.Marshal(j.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (j *JournalEntryRequestCompany) Accept(visitor JournalEntryRequestCompanyVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "CompanyInfo" || j.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(j.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// The journal's currency.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type JournalEntryRequestCurrency struct {
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string

	typ string
}

func (j *JournalEntryRequestCurrency) GetTransactionCurrencyEnum() TransactionCurrencyEnum {
	if j == nil {
		return ""
	}
	return j.TransactionCurrencyEnum
}

func (j *JournalEntryRequestCurrency) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		j.typ = "TransactionCurrencyEnum"
		j.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestCurrency) MarshalJSON() ([]byte, error) {
	if j.typ == "TransactionCurrencyEnum" || j.TransactionCurrencyEnum != "" {
		return json.Marshal(j.TransactionCurrencyEnum)
	}
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (j *JournalEntryRequestCurrency) Accept(visitor JournalEntryRequestCurrencyVisitor) error {
	if j.typ == "TransactionCurrencyEnum" || j.TransactionCurrencyEnum != "" {
		return visitor.VisitTransactionCurrencyEnum(j.TransactionCurrencyEnum)
	}
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryRequestPaymentsItem struct {
	String  string
	Payment *Payment

	typ string
}

func (j *JournalEntryRequestPaymentsItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryRequestPaymentsItem) GetPayment() *Payment {
	if j == nil {
		return nil
	}
	return j.Payment
}

func (j *JournalEntryRequestPaymentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valuePayment := new(Payment)
	if err := json.Unmarshal(data, &valuePayment); err == nil {
		j.typ = "Payment"
		j.Payment = valuePayment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestPaymentsItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Payment" || j.Payment != nil {
		return json.Marshal(j.Payment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryRequestPaymentsItemVisitor interface {
	VisitString(string) error
	VisitPayment(*Payment) error
}

func (j *JournalEntryRequestPaymentsItem) Accept(visitor JournalEntryRequestPaymentsItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Payment" || j.Payment != nil {
		return visitor.VisitPayment(j.Payment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// The journal's posting status.
//
// * `UNPOSTED` - UNPOSTED
// * `POSTED` - POSTED
type JournalEntryRequestPostingStatus struct {
	PostingStatusEnum PostingStatusEnum
	String            string

	typ string
}

func (j *JournalEntryRequestPostingStatus) GetPostingStatusEnum() PostingStatusEnum {
	if j == nil {
		return ""
	}
	return j.PostingStatusEnum
}

func (j *JournalEntryRequestPostingStatus) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryRequestPostingStatus) UnmarshalJSON(data []byte) error {
	var valuePostingStatusEnum PostingStatusEnum
	if err := json.Unmarshal(data, &valuePostingStatusEnum); err == nil {
		j.typ = "PostingStatusEnum"
		j.PostingStatusEnum = valuePostingStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestPostingStatus) MarshalJSON() ([]byte, error) {
	if j.typ == "PostingStatusEnum" || j.PostingStatusEnum != "" {
		return json.Marshal(j.PostingStatusEnum)
	}
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryRequestPostingStatusVisitor interface {
	VisitPostingStatusEnum(PostingStatusEnum) error
	VisitString(string) error
}

func (j *JournalEntryRequestPostingStatus) Accept(visitor JournalEntryRequestPostingStatusVisitor) error {
	if j.typ == "PostingStatusEnum" || j.PostingStatusEnum != "" {
		return visitor.VisitPostingStatusEnum(j.PostingStatusEnum)
	}
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryRequestTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (j *JournalEntryRequestTrackingCategoriesItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryRequestTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if j == nil {
		return nil
	}
	return j.TrackingCategory
}

func (j *JournalEntryRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typ = "TrackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return json.Marshal(j.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalEntryRequestTrackingCategoriesItem) Accept(visitor JournalEntryRequestTrackingCategoriesItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

var (
	journalEntryResponseFieldModel    = big.NewInt(1 << 0)
	journalEntryResponseFieldWarnings = big.NewInt(1 << 1)
	journalEntryResponseFieldErrors   = big.NewInt(1 << 2)
	journalEntryResponseFieldLogs     = big.NewInt(1 << 3)
)

type JournalEntryResponse struct {
	Model    *JournalEntry               `json:"model" url:"model"`
	Warnings []*WarningValidationProblem `json:"warnings" url:"warnings"`
	Errors   []*ErrorValidationProblem   `json:"errors" url:"errors"`
	Logs     []*DebugModeLog             `json:"logs,omitempty" url:"logs,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JournalEntryResponse) GetModel() *JournalEntry {
	if j == nil {
		return nil
	}
	return j.Model
}

func (j *JournalEntryResponse) GetWarnings() []*WarningValidationProblem {
	if j == nil {
		return nil
	}
	return j.Warnings
}

func (j *JournalEntryResponse) GetErrors() []*ErrorValidationProblem {
	if j == nil {
		return nil
	}
	return j.Errors
}

func (j *JournalEntryResponse) GetLogs() []*DebugModeLog {
	if j == nil {
		return nil
	}
	return j.Logs
}

func (j *JournalEntryResponse) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JournalEntryResponse) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryResponse) SetModel(model *JournalEntry) {
	j.Model = model
	j.require(journalEntryResponseFieldModel)
}

// SetWarnings sets the Warnings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryResponse) SetWarnings(warnings []*WarningValidationProblem) {
	j.Warnings = warnings
	j.require(journalEntryResponseFieldWarnings)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryResponse) SetErrors(errors []*ErrorValidationProblem) {
	j.Errors = errors
	j.require(journalEntryResponseFieldErrors)
}

// SetLogs sets the Logs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalEntryResponse) SetLogs(logs []*DebugModeLog) {
	j.Logs = logs
	j.require(journalEntryResponseFieldLogs)
}

func (j *JournalEntryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler JournalEntryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JournalEntryResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalEntryResponse) MarshalJSON() ([]byte, error) {
	type embed JournalEntryResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*j),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JournalEntryResponse) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JournalEntryTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (j *JournalEntryTrackingCategoriesItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalEntryTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if j == nil {
		return nil
	}
	return j.TrackingCategory
}

func (j *JournalEntryTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typ = "TrackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalEntryTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return json.Marshal(j.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalEntryTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalEntryTrackingCategoriesItem) Accept(visitor JournalEntryTrackingCategoriesItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// # The JournalLine Object
// ### Description
// The `JournalLine` object is used to represent a journal entry's line items.
//
// ### Usage Example
// Fetch from the `GET JournalEntry` endpoint and view the journal entry's line items.
var (
	journalLineFieldId                 = big.NewInt(1 << 0)
	journalLineFieldRemoteId           = big.NewInt(1 << 1)
	journalLineFieldCreatedAt          = big.NewInt(1 << 2)
	journalLineFieldModifiedAt         = big.NewInt(1 << 3)
	journalLineFieldAccount            = big.NewInt(1 << 4)
	journalLineFieldNetAmount          = big.NewInt(1 << 5)
	journalLineFieldTrackingCategory   = big.NewInt(1 << 6)
	journalLineFieldTrackingCategories = big.NewInt(1 << 7)
	journalLineFieldCurrency           = big.NewInt(1 << 8)
	journalLineFieldCompany            = big.NewInt(1 << 9)
	journalLineFieldEmployee           = big.NewInt(1 << 10)
	journalLineFieldProject            = big.NewInt(1 << 11)
	journalLineFieldContact            = big.NewInt(1 << 12)
	journalLineFieldTaxRate            = big.NewInt(1 << 13)
	journalLineFieldDescription        = big.NewInt(1 << 14)
	journalLineFieldExchangeRate       = big.NewInt(1 << 15)
	journalLineFieldRemoteWasDeleted   = big.NewInt(1 << 16)
	journalLineFieldRemoteFields       = big.NewInt(1 << 17)
)

type JournalLine struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time          `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	Account    *JournalLineAccount `json:"account,omitempty" url:"account,omitempty"`
	// The value of the line item including taxes and other fees.
	NetAmount        *float64                     `json:"net_amount,omitempty" url:"net_amount,omitempty"`
	TrackingCategory *JournalLineTrackingCategory `json:"tracking_category,omitempty" url:"tracking_category,omitempty"`
	// The journal line item's associated tracking categories.
	TrackingCategories []*JournalLineTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The journal line item's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *JournalLineCurrency `json:"currency,omitempty" url:"currency,omitempty"`
	// The company the journal entry belongs to.
	Company  *string             `json:"company,omitempty" url:"company,omitempty"`
	Employee *string             `json:"employee,omitempty" url:"employee,omitempty"`
	Project  *JournalLineProject `json:"project,omitempty" url:"project,omitempty"`
	Contact  *string             `json:"contact,omitempty" url:"contact,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty" url:"tax_rate,omitempty"`
	// The line's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The journal line item's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool          `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	RemoteFields     []*RemoteField `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JournalLine) GetId() *string {
	if j == nil {
		return nil
	}
	return j.Id
}

func (j *JournalLine) GetRemoteId() *string {
	if j == nil {
		return nil
	}
	return j.RemoteId
}

func (j *JournalLine) GetCreatedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.CreatedAt
}

func (j *JournalLine) GetModifiedAt() *time.Time {
	if j == nil {
		return nil
	}
	return j.ModifiedAt
}

func (j *JournalLine) GetAccount() *JournalLineAccount {
	if j == nil {
		return nil
	}
	return j.Account
}

func (j *JournalLine) GetNetAmount() *float64 {
	if j == nil {
		return nil
	}
	return j.NetAmount
}

func (j *JournalLine) GetTrackingCategory() *JournalLineTrackingCategory {
	if j == nil {
		return nil
	}
	return j.TrackingCategory
}

func (j *JournalLine) GetTrackingCategories() []*JournalLineTrackingCategoriesItem {
	if j == nil {
		return nil
	}
	return j.TrackingCategories
}

func (j *JournalLine) GetCurrency() *JournalLineCurrency {
	if j == nil {
		return nil
	}
	return j.Currency
}

func (j *JournalLine) GetCompany() *string {
	if j == nil {
		return nil
	}
	return j.Company
}

func (j *JournalLine) GetEmployee() *string {
	if j == nil {
		return nil
	}
	return j.Employee
}

func (j *JournalLine) GetProject() *JournalLineProject {
	if j == nil {
		return nil
	}
	return j.Project
}

func (j *JournalLine) GetContact() *string {
	if j == nil {
		return nil
	}
	return j.Contact
}

func (j *JournalLine) GetTaxRate() *string {
	if j == nil {
		return nil
	}
	return j.TaxRate
}

func (j *JournalLine) GetDescription() *string {
	if j == nil {
		return nil
	}
	return j.Description
}

func (j *JournalLine) GetExchangeRate() *string {
	if j == nil {
		return nil
	}
	return j.ExchangeRate
}

func (j *JournalLine) GetRemoteWasDeleted() *bool {
	if j == nil {
		return nil
	}
	return j.RemoteWasDeleted
}

func (j *JournalLine) GetRemoteFields() []*RemoteField {
	if j == nil {
		return nil
	}
	return j.RemoteFields
}

func (j *JournalLine) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JournalLine) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetId(id *string) {
	j.Id = id
	j.require(journalLineFieldId)
}

// SetRemoteId sets the RemoteId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetRemoteId(remoteId *string) {
	j.RemoteId = remoteId
	j.require(journalLineFieldRemoteId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetCreatedAt(createdAt *time.Time) {
	j.CreatedAt = createdAt
	j.require(journalLineFieldCreatedAt)
}

// SetModifiedAt sets the ModifiedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetModifiedAt(modifiedAt *time.Time) {
	j.ModifiedAt = modifiedAt
	j.require(journalLineFieldModifiedAt)
}

// SetAccount sets the Account field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetAccount(account *JournalLineAccount) {
	j.Account = account
	j.require(journalLineFieldAccount)
}

// SetNetAmount sets the NetAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetNetAmount(netAmount *float64) {
	j.NetAmount = netAmount
	j.require(journalLineFieldNetAmount)
}

// SetTrackingCategory sets the TrackingCategory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetTrackingCategory(trackingCategory *JournalLineTrackingCategory) {
	j.TrackingCategory = trackingCategory
	j.require(journalLineFieldTrackingCategory)
}

// SetTrackingCategories sets the TrackingCategories field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetTrackingCategories(trackingCategories []*JournalLineTrackingCategoriesItem) {
	j.TrackingCategories = trackingCategories
	j.require(journalLineFieldTrackingCategories)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetCurrency(currency *JournalLineCurrency) {
	j.Currency = currency
	j.require(journalLineFieldCurrency)
}

// SetCompany sets the Company field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetCompany(company *string) {
	j.Company = company
	j.require(journalLineFieldCompany)
}

// SetEmployee sets the Employee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetEmployee(employee *string) {
	j.Employee = employee
	j.require(journalLineFieldEmployee)
}

// SetProject sets the Project field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetProject(project *JournalLineProject) {
	j.Project = project
	j.require(journalLineFieldProject)
}

// SetContact sets the Contact field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetContact(contact *string) {
	j.Contact = contact
	j.require(journalLineFieldContact)
}

// SetTaxRate sets the TaxRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetTaxRate(taxRate *string) {
	j.TaxRate = taxRate
	j.require(journalLineFieldTaxRate)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetDescription(description *string) {
	j.Description = description
	j.require(journalLineFieldDescription)
}

// SetExchangeRate sets the ExchangeRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetExchangeRate(exchangeRate *string) {
	j.ExchangeRate = exchangeRate
	j.require(journalLineFieldExchangeRate)
}

// SetRemoteWasDeleted sets the RemoteWasDeleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetRemoteWasDeleted(remoteWasDeleted *bool) {
	j.RemoteWasDeleted = remoteWasDeleted
	j.require(journalLineFieldRemoteWasDeleted)
}

// SetRemoteFields sets the RemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLine) SetRemoteFields(remoteFields []*RemoteField) {
	j.RemoteFields = remoteFields
	j.require(journalLineFieldRemoteFields)
}

func (j *JournalLine) UnmarshalJSON(data []byte) error {
	type embed JournalLine
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = JournalLine(unmarshaler.embed)
	j.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	j.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalLine) MarshalJSON() ([]byte, error) {
	type embed JournalLine
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*j),
		CreatedAt:  internal.NewOptionalDateTime(j.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(j.ModifiedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JournalLine) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JournalLineAccount struct {
	String  string
	Account *Account

	typ string
}

func (j *JournalLineAccount) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineAccount) GetAccount() *Account {
	if j == nil {
		return nil
	}
	return j.Account
}

func (j *JournalLineAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		j.typ = "Account"
		j.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineAccount) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Account" || j.Account != nil {
		return json.Marshal(j.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (j *JournalLineAccount) Accept(visitor JournalLineAccountVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Account" || j.Account != nil {
		return visitor.VisitAccount(j.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// The journal line item's currency.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type JournalLineCurrency struct {
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string

	typ string
}

func (j *JournalLineCurrency) GetTransactionCurrencyEnum() TransactionCurrencyEnum {
	if j == nil {
		return ""
	}
	return j.TransactionCurrencyEnum
}

func (j *JournalLineCurrency) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		j.typ = "TransactionCurrencyEnum"
		j.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineCurrency) MarshalJSON() ([]byte, error) {
	if j.typ == "TransactionCurrencyEnum" || j.TransactionCurrencyEnum != "" {
		return json.Marshal(j.TransactionCurrencyEnum)
	}
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (j *JournalLineCurrency) Accept(visitor JournalLineCurrencyVisitor) error {
	if j.typ == "TransactionCurrencyEnum" || j.TransactionCurrencyEnum != "" {
		return visitor.VisitTransactionCurrencyEnum(j.TransactionCurrencyEnum)
	}
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineProject struct {
	String  string
	Project *Project

	typ string
}

func (j *JournalLineProject) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineProject) GetProject() *Project {
	if j == nil {
		return nil
	}
	return j.Project
}

func (j *JournalLineProject) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueProject := new(Project)
	if err := json.Unmarshal(data, &valueProject); err == nil {
		j.typ = "Project"
		j.Project = valueProject
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineProject) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Project" || j.Project != nil {
		return json.Marshal(j.Project)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineProjectVisitor interface {
	VisitString(string) error
	VisitProject(*Project) error
}

func (j *JournalLineProject) Accept(visitor JournalLineProjectVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Project" || j.Project != nil {
		return visitor.VisitProject(j.Project)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// # The JournalLine Object
// ### Description
// The `JournalLine` object is used to represent a journal entry's line items.
//
// ### Usage Example
// Fetch from the `GET JournalEntry` endpoint and view the journal entry's line items.
var (
	journalLineRequestFieldRemoteId            = big.NewInt(1 << 0)
	journalLineRequestFieldAccount             = big.NewInt(1 << 1)
	journalLineRequestFieldNetAmount           = big.NewInt(1 << 2)
	journalLineRequestFieldTrackingCategory    = big.NewInt(1 << 3)
	journalLineRequestFieldTrackingCategories  = big.NewInt(1 << 4)
	journalLineRequestFieldCurrency            = big.NewInt(1 << 5)
	journalLineRequestFieldCompany             = big.NewInt(1 << 6)
	journalLineRequestFieldEmployee            = big.NewInt(1 << 7)
	journalLineRequestFieldProject             = big.NewInt(1 << 8)
	journalLineRequestFieldContact             = big.NewInt(1 << 9)
	journalLineRequestFieldTaxRate             = big.NewInt(1 << 10)
	journalLineRequestFieldDescription         = big.NewInt(1 << 11)
	journalLineRequestFieldExchangeRate        = big.NewInt(1 << 12)
	journalLineRequestFieldIntegrationParams   = big.NewInt(1 << 13)
	journalLineRequestFieldLinkedAccountParams = big.NewInt(1 << 14)
	journalLineRequestFieldRemoteFields        = big.NewInt(1 << 15)
)

type JournalLineRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string                    `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	Account  *JournalLineRequestAccount `json:"account,omitempty" url:"account,omitempty"`
	// The value of the line item including taxes and other fees.
	NetAmount        *float64                            `json:"net_amount,omitempty" url:"net_amount,omitempty"`
	TrackingCategory *JournalLineRequestTrackingCategory `json:"tracking_category,omitempty" url:"tracking_category,omitempty"`
	// The journal line item's associated tracking categories.
	TrackingCategories []*JournalLineRequestTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The journal line item's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *JournalLineRequestCurrency `json:"currency,omitempty" url:"currency,omitempty"`
	// The company the journal entry belongs to.
	Company  *string                    `json:"company,omitempty" url:"company,omitempty"`
	Employee *string                    `json:"employee,omitempty" url:"employee,omitempty"`
	Project  *JournalLineRequestProject `json:"project,omitempty" url:"project,omitempty"`
	Contact  *string                    `json:"contact,omitempty" url:"contact,omitempty"`
	// The tax rate that applies to this line item.
	TaxRate *string `json:"tax_rate,omitempty" url:"tax_rate,omitempty"`
	// The line's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The journal line item's exchange rate.
	ExchangeRate        *string                `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JournalLineRequest) GetRemoteId() *string {
	if j == nil {
		return nil
	}
	return j.RemoteId
}

func (j *JournalLineRequest) GetAccount() *JournalLineRequestAccount {
	if j == nil {
		return nil
	}
	return j.Account
}

func (j *JournalLineRequest) GetNetAmount() *float64 {
	if j == nil {
		return nil
	}
	return j.NetAmount
}

func (j *JournalLineRequest) GetTrackingCategory() *JournalLineRequestTrackingCategory {
	if j == nil {
		return nil
	}
	return j.TrackingCategory
}

func (j *JournalLineRequest) GetTrackingCategories() []*JournalLineRequestTrackingCategoriesItem {
	if j == nil {
		return nil
	}
	return j.TrackingCategories
}

func (j *JournalLineRequest) GetCurrency() *JournalLineRequestCurrency {
	if j == nil {
		return nil
	}
	return j.Currency
}

func (j *JournalLineRequest) GetCompany() *string {
	if j == nil {
		return nil
	}
	return j.Company
}

func (j *JournalLineRequest) GetEmployee() *string {
	if j == nil {
		return nil
	}
	return j.Employee
}

func (j *JournalLineRequest) GetProject() *JournalLineRequestProject {
	if j == nil {
		return nil
	}
	return j.Project
}

func (j *JournalLineRequest) GetContact() *string {
	if j == nil {
		return nil
	}
	return j.Contact
}

func (j *JournalLineRequest) GetTaxRate() *string {
	if j == nil {
		return nil
	}
	return j.TaxRate
}

func (j *JournalLineRequest) GetDescription() *string {
	if j == nil {
		return nil
	}
	return j.Description
}

func (j *JournalLineRequest) GetExchangeRate() *string {
	if j == nil {
		return nil
	}
	return j.ExchangeRate
}

func (j *JournalLineRequest) GetIntegrationParams() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.IntegrationParams
}

func (j *JournalLineRequest) GetLinkedAccountParams() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.LinkedAccountParams
}

func (j *JournalLineRequest) GetRemoteFields() []*RemoteFieldRequest {
	if j == nil {
		return nil
	}
	return j.RemoteFields
}

func (j *JournalLineRequest) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JournalLineRequest) require(field *big.Int) {
	if j.explicitFields == nil {
		j.explicitFields = big.NewInt(0)
	}
	j.explicitFields.Or(j.explicitFields, field)
}

// SetRemoteId sets the RemoteId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetRemoteId(remoteId *string) {
	j.RemoteId = remoteId
	j.require(journalLineRequestFieldRemoteId)
}

// SetAccount sets the Account field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetAccount(account *JournalLineRequestAccount) {
	j.Account = account
	j.require(journalLineRequestFieldAccount)
}

// SetNetAmount sets the NetAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetNetAmount(netAmount *float64) {
	j.NetAmount = netAmount
	j.require(journalLineRequestFieldNetAmount)
}

// SetTrackingCategory sets the TrackingCategory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetTrackingCategory(trackingCategory *JournalLineRequestTrackingCategory) {
	j.TrackingCategory = trackingCategory
	j.require(journalLineRequestFieldTrackingCategory)
}

// SetTrackingCategories sets the TrackingCategories field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetTrackingCategories(trackingCategories []*JournalLineRequestTrackingCategoriesItem) {
	j.TrackingCategories = trackingCategories
	j.require(journalLineRequestFieldTrackingCategories)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetCurrency(currency *JournalLineRequestCurrency) {
	j.Currency = currency
	j.require(journalLineRequestFieldCurrency)
}

// SetCompany sets the Company field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetCompany(company *string) {
	j.Company = company
	j.require(journalLineRequestFieldCompany)
}

// SetEmployee sets the Employee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetEmployee(employee *string) {
	j.Employee = employee
	j.require(journalLineRequestFieldEmployee)
}

// SetProject sets the Project field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetProject(project *JournalLineRequestProject) {
	j.Project = project
	j.require(journalLineRequestFieldProject)
}

// SetContact sets the Contact field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetContact(contact *string) {
	j.Contact = contact
	j.require(journalLineRequestFieldContact)
}

// SetTaxRate sets the TaxRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetTaxRate(taxRate *string) {
	j.TaxRate = taxRate
	j.require(journalLineRequestFieldTaxRate)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetDescription(description *string) {
	j.Description = description
	j.require(journalLineRequestFieldDescription)
}

// SetExchangeRate sets the ExchangeRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetExchangeRate(exchangeRate *string) {
	j.ExchangeRate = exchangeRate
	j.require(journalLineRequestFieldExchangeRate)
}

// SetIntegrationParams sets the IntegrationParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetIntegrationParams(integrationParams map[string]interface{}) {
	j.IntegrationParams = integrationParams
	j.require(journalLineRequestFieldIntegrationParams)
}

// SetLinkedAccountParams sets the LinkedAccountParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetLinkedAccountParams(linkedAccountParams map[string]interface{}) {
	j.LinkedAccountParams = linkedAccountParams
	j.require(journalLineRequestFieldLinkedAccountParams)
}

// SetRemoteFields sets the RemoteFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (j *JournalLineRequest) SetRemoteFields(remoteFields []*RemoteFieldRequest) {
	j.RemoteFields = remoteFields
	j.require(journalLineRequestFieldRemoteFields)
}

func (j *JournalLineRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler JournalLineRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JournalLineRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JournalLineRequest) MarshalJSON() ([]byte, error) {
	type embed JournalLineRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*j),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, j.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (j *JournalLineRequest) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JournalLineRequestAccount struct {
	String  string
	Account *Account

	typ string
}

func (j *JournalLineRequestAccount) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineRequestAccount) GetAccount() *Account {
	if j == nil {
		return nil
	}
	return j.Account
}

func (j *JournalLineRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		j.typ = "Account"
		j.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestAccount) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Account" || j.Account != nil {
		return json.Marshal(j.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (j *JournalLineRequestAccount) Accept(visitor JournalLineRequestAccountVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Account" || j.Account != nil {
		return visitor.VisitAccount(j.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// The journal line item's currency.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type JournalLineRequestCurrency struct {
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string

	typ string
}

func (j *JournalLineRequestCurrency) GetTransactionCurrencyEnum() TransactionCurrencyEnum {
	if j == nil {
		return ""
	}
	return j.TransactionCurrencyEnum
}

func (j *JournalLineRequestCurrency) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		j.typ = "TransactionCurrencyEnum"
		j.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestCurrency) MarshalJSON() ([]byte, error) {
	if j.typ == "TransactionCurrencyEnum" || j.TransactionCurrencyEnum != "" {
		return json.Marshal(j.TransactionCurrencyEnum)
	}
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (j *JournalLineRequestCurrency) Accept(visitor JournalLineRequestCurrencyVisitor) error {
	if j.typ == "TransactionCurrencyEnum" || j.TransactionCurrencyEnum != "" {
		return visitor.VisitTransactionCurrencyEnum(j.TransactionCurrencyEnum)
	}
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineRequestProject struct {
	String  string
	Project *Project

	typ string
}

func (j *JournalLineRequestProject) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineRequestProject) GetProject() *Project {
	if j == nil {
		return nil
	}
	return j.Project
}

func (j *JournalLineRequestProject) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueProject := new(Project)
	if err := json.Unmarshal(data, &valueProject); err == nil {
		j.typ = "Project"
		j.Project = valueProject
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestProject) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "Project" || j.Project != nil {
		return json.Marshal(j.Project)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineRequestProjectVisitor interface {
	VisitString(string) error
	VisitProject(*Project) error
}

func (j *JournalLineRequestProject) Accept(visitor JournalLineRequestProjectVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "Project" || j.Project != nil {
		return visitor.VisitProject(j.Project)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineRequestTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (j *JournalLineRequestTrackingCategoriesItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineRequestTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if j == nil {
		return nil
	}
	return j.TrackingCategory
}

func (j *JournalLineRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typ = "TrackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return json.Marshal(j.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalLineRequestTrackingCategoriesItem) Accept(visitor JournalLineRequestTrackingCategoriesItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineRequestTrackingCategory struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (j *JournalLineRequestTrackingCategory) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineRequestTrackingCategory) GetTrackingCategory() *TrackingCategory {
	if j == nil {
		return nil
	}
	return j.TrackingCategory
}

func (j *JournalLineRequestTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typ = "TrackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineRequestTrackingCategory) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return json.Marshal(j.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineRequestTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalLineRequestTrackingCategory) Accept(visitor JournalLineRequestTrackingCategoryVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (j *JournalLineTrackingCategoriesItem) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if j == nil {
		return nil
	}
	return j.TrackingCategory
}

func (j *JournalLineTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typ = "TrackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return json.Marshal(j.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalLineTrackingCategoriesItem) Accept(visitor JournalLineTrackingCategoriesItemVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineTrackingCategory struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (j *JournalLineTrackingCategory) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *JournalLineTrackingCategory) GetTrackingCategory() *TrackingCategory {
	if j == nil {
		return nil
	}
	return j.TrackingCategory
}

func (j *JournalLineTrackingCategory) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		j.typ = "TrackingCategory"
		j.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j JournalLineTrackingCategory) MarshalJSON() ([]byte, error) {
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return json.Marshal(j.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalLineTrackingCategoryVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (j *JournalLineTrackingCategory) Accept(visitor JournalLineTrackingCategoryVisitor) error {
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	if j.typ == "TrackingCategory" || j.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(j.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

var (
	paginatedJournalEntryListFieldNext     = big.NewInt(1 << 0)
	paginatedJournalEntryListFieldPrevious = big.NewInt(1 << 1)
	paginatedJournalEntryListFieldResults  = big.NewInt(1 << 2)
)

type PaginatedJournalEntryList struct {
	Next     *string         `json:"next,omitempty" url:"next,omitempty"`
	Previous *string         `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*JournalEntry `json:"results,omitempty" url:"results,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedJournalEntryList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedJournalEntryList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedJournalEntryList) GetResults() []*JournalEntry {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedJournalEntryList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedJournalEntryList) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedJournalEntryList) SetNext(next *string) {
	p.Next = next
	p.require(paginatedJournalEntryListFieldNext)
}

// SetPrevious sets the Previous field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedJournalEntryList) SetPrevious(previous *string) {
	p.Previous = previous
	p.require(paginatedJournalEntryListFieldPrevious)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedJournalEntryList) SetResults(results []*JournalEntry) {
	p.Results = results
	p.require(paginatedJournalEntryListFieldResults)
}

func (p *PaginatedJournalEntryList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedJournalEntryList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedJournalEntryList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedJournalEntryList) MarshalJSON() ([]byte, error) {
	type embed PaginatedJournalEntryList
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedJournalEntryList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// * `UNPOSTED` - UNPOSTED
// * `POSTED` - POSTED
type PostingStatusEnum string

const (
	PostingStatusEnumUnposted PostingStatusEnum = "UNPOSTED"
	PostingStatusEnumPosted   PostingStatusEnum = "POSTED"
)

func NewPostingStatusEnumFromString(s string) (PostingStatusEnum, error) {
	switch s {
	case "UNPOSTED":
		return PostingStatusEnumUnposted, nil
	case "POSTED":
		return PostingStatusEnumPosted, nil
	}
	var t PostingStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PostingStatusEnum) Ptr() *PostingStatusEnum {
	return &p
}
