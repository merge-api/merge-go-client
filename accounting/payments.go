// Code generated by Fern. DO NOT EDIT.

package accounting

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type PaymentEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool           `json:"-" url:"run_async,omitempty"`
	Model    *PaymentRequest `json:"model,omitempty" url:"-"`
}

type PaymentsLineItemsRemoteFieldClassesListRequest struct {
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return remote field classes with this is_common_model_field value
	IsCommonModelField *bool `json:"-" url:"is_common_model_field,omitempty"`
	// If provided, will only return remote fields classes with this is_custom value
	IsCustom *bool `json:"-" url:"is_custom,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
}

type PaymentsListRequest struct {
	// If provided, will only return payments for this account.
	AccountId *string `json:"-" url:"account_id,omitempty"`
	// If provided, will only return payments for this company.
	CompanyId *string `json:"-" url:"company_id,omitempty"`
	// If provided, will only return payments for this contact.
	ContactId *string `json:"-" url:"contact_id,omitempty"`
	// If provided, will only return objects created after this datetime.
	CreatedAfter *time.Time `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *time.Time `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*PaymentsListRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, only objects synced by Merge after this date time will be returned.
	ModifiedAfter *time.Time `json:"-" url:"modified_after,omitempty"`
	// If provided, only objects synced by Merge before this date time will be returned.
	ModifiedBefore *time.Time `json:"-" url:"modified_before,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// The API provider's ID for the given object.
	RemoteId *string `json:"-" url:"remote_id,omitempty"`
	// If provided, will only return objects created after this datetime.
	TransactionDateAfter *time.Time `json:"-" url:"transaction_date_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	TransactionDateBefore *time.Time `json:"-" url:"transaction_date_before,omitempty"`
}

type PatchedPaymentEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool                  `json:"-" url:"run_async,omitempty"`
	Model    *PatchedPaymentRequest `json:"model,omitempty" url:"-"`
}

type PaymentsRemoteFieldClassesListRequest struct {
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return remote field classes with this is_common_model_field value
	IsCommonModelField *bool `json:"-" url:"is_common_model_field,omitempty"`
	// If provided, will only return remote fields classes with this is_custom value
	IsCustom *bool `json:"-" url:"is_custom,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
}

type PaymentsRetrieveRequest struct {
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*PaymentsRetrieveRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
}

type PaymentsListRequestExpandItem string

const (
	PaymentsListRequestExpandItemAccount            PaymentsListRequestExpandItem = "account"
	PaymentsListRequestExpandItemAccountingPeriod   PaymentsListRequestExpandItem = "accounting_period"
	PaymentsListRequestExpandItemAppliedToLines     PaymentsListRequestExpandItem = "applied_to_lines"
	PaymentsListRequestExpandItemCompany            PaymentsListRequestExpandItem = "company"
	PaymentsListRequestExpandItemContact            PaymentsListRequestExpandItem = "contact"
	PaymentsListRequestExpandItemPaymentMethod      PaymentsListRequestExpandItem = "payment_method"
	PaymentsListRequestExpandItemTrackingCategories PaymentsListRequestExpandItem = "tracking_categories"
)

func NewPaymentsListRequestExpandItemFromString(s string) (PaymentsListRequestExpandItem, error) {
	switch s {
	case "account":
		return PaymentsListRequestExpandItemAccount, nil
	case "accounting_period":
		return PaymentsListRequestExpandItemAccountingPeriod, nil
	case "applied_to_lines":
		return PaymentsListRequestExpandItemAppliedToLines, nil
	case "company":
		return PaymentsListRequestExpandItemCompany, nil
	case "contact":
		return PaymentsListRequestExpandItemContact, nil
	case "payment_method":
		return PaymentsListRequestExpandItemPaymentMethod, nil
	case "tracking_categories":
		return PaymentsListRequestExpandItemTrackingCategories, nil
	}
	var t PaymentsListRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentsListRequestExpandItem) Ptr() *PaymentsListRequestExpandItem {
	return &p
}

type PaymentsRetrieveRequestExpandItem string

const (
	PaymentsRetrieveRequestExpandItemAccount            PaymentsRetrieveRequestExpandItem = "account"
	PaymentsRetrieveRequestExpandItemAccountingPeriod   PaymentsRetrieveRequestExpandItem = "accounting_period"
	PaymentsRetrieveRequestExpandItemAppliedToLines     PaymentsRetrieveRequestExpandItem = "applied_to_lines"
	PaymentsRetrieveRequestExpandItemCompany            PaymentsRetrieveRequestExpandItem = "company"
	PaymentsRetrieveRequestExpandItemContact            PaymentsRetrieveRequestExpandItem = "contact"
	PaymentsRetrieveRequestExpandItemPaymentMethod      PaymentsRetrieveRequestExpandItem = "payment_method"
	PaymentsRetrieveRequestExpandItemTrackingCategories PaymentsRetrieveRequestExpandItem = "tracking_categories"
)

func NewPaymentsRetrieveRequestExpandItemFromString(s string) (PaymentsRetrieveRequestExpandItem, error) {
	switch s {
	case "account":
		return PaymentsRetrieveRequestExpandItemAccount, nil
	case "accounting_period":
		return PaymentsRetrieveRequestExpandItemAccountingPeriod, nil
	case "applied_to_lines":
		return PaymentsRetrieveRequestExpandItemAppliedToLines, nil
	case "company":
		return PaymentsRetrieveRequestExpandItemCompany, nil
	case "contact":
		return PaymentsRetrieveRequestExpandItemContact, nil
	case "payment_method":
		return PaymentsRetrieveRequestExpandItemPaymentMethod, nil
	case "tracking_categories":
		return PaymentsRetrieveRequestExpandItemTrackingCategories, nil
	}
	var t PaymentsRetrieveRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentsRetrieveRequestExpandItem) Ptr() *PaymentsRetrieveRequestExpandItem {
	return &p
}

type PaginatedPaymentList struct {
	Next     *string    `json:"next,omitempty" url:"next,omitempty"`
	Previous *string    `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*Payment `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedPaymentList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedPaymentList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedPaymentList) GetResults() []*Payment {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedPaymentList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedPaymentList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedPaymentList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedPaymentList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedPaymentList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The Payment Object
// ### Description
// The `Payment` object represents general payments made towards a specific transaction.
//
// ### Usage Example
// Fetch from the `GET Payment` endpoint and view an invoice's payment.
type PatchedPaymentRequest struct {
	// The payment's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty" url:"transaction_date,omitempty"`
	// The supplier, or customer involved in the payment.
	Contact *PatchedPaymentRequestContact `json:"contact,omitempty" url:"contact,omitempty"`
	// The supplier’s or customer’s account in which the payment is made.
	Account *PatchedPaymentRequestAccount `json:"account,omitempty" url:"account,omitempty"`
	// The method which this payment was made by.
	PaymentMethod *PatchedPaymentRequestPaymentMethod `json:"payment_method,omitempty" url:"payment_method,omitempty"`
	// The payment's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *PatchedPaymentRequestCurrency `json:"currency,omitempty" url:"currency,omitempty"`
	// The payment's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The company the payment belongs to.
	Company *PatchedPaymentRequestCompany `json:"company,omitempty" url:"company,omitempty"`
	// The total amount of money being paid to the supplier, or customer, after taxes.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The type of the invoice.
	//
	// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	Type               *PatchedPaymentRequestType                     `json:"type,omitempty" url:"type,omitempty"`
	TrackingCategories []*PatchedPaymentRequestTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The accounting period that the Payment was generated in.
	AccountingPeriod *PatchedPaymentRequestAccountingPeriod `json:"accounting_period,omitempty" url:"accounting_period,omitempty"`
	// A list of “Payment Applied to Lines” objects.
	AppliedToLines      []*PatchedPaymentRequestAppliedToLinesItem `json:"applied_to_lines,omitempty" url:"applied_to_lines,omitempty"`
	IntegrationParams   map[string]interface{}                     `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}                     `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest                      `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchedPaymentRequest) GetTransactionDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.TransactionDate
}

func (p *PatchedPaymentRequest) GetContact() *PatchedPaymentRequestContact {
	if p == nil {
		return nil
	}
	return p.Contact
}

func (p *PatchedPaymentRequest) GetAccount() *PatchedPaymentRequestAccount {
	if p == nil {
		return nil
	}
	return p.Account
}

func (p *PatchedPaymentRequest) GetPaymentMethod() *PatchedPaymentRequestPaymentMethod {
	if p == nil {
		return nil
	}
	return p.PaymentMethod
}

func (p *PatchedPaymentRequest) GetCurrency() *PatchedPaymentRequestCurrency {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PatchedPaymentRequest) GetExchangeRate() *string {
	if p == nil {
		return nil
	}
	return p.ExchangeRate
}

func (p *PatchedPaymentRequest) GetCompany() *PatchedPaymentRequestCompany {
	if p == nil {
		return nil
	}
	return p.Company
}

func (p *PatchedPaymentRequest) GetTotalAmount() *float64 {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *PatchedPaymentRequest) GetType() *PatchedPaymentRequestType {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PatchedPaymentRequest) GetTrackingCategories() []*PatchedPaymentRequestTrackingCategoriesItem {
	if p == nil {
		return nil
	}
	return p.TrackingCategories
}

func (p *PatchedPaymentRequest) GetAccountingPeriod() *PatchedPaymentRequestAccountingPeriod {
	if p == nil {
		return nil
	}
	return p.AccountingPeriod
}

func (p *PatchedPaymentRequest) GetAppliedToLines() []*PatchedPaymentRequestAppliedToLinesItem {
	if p == nil {
		return nil
	}
	return p.AppliedToLines
}

func (p *PatchedPaymentRequest) GetIntegrationParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.IntegrationParams
}

func (p *PatchedPaymentRequest) GetLinkedAccountParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.LinkedAccountParams
}

func (p *PatchedPaymentRequest) GetRemoteFields() []*RemoteFieldRequest {
	if p == nil {
		return nil
	}
	return p.RemoteFields
}

func (p *PatchedPaymentRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchedPaymentRequest) UnmarshalJSON(data []byte) error {
	type embed PatchedPaymentRequest
	var unmarshaler = struct {
		embed
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PatchedPaymentRequest(unmarshaler.embed)
	p.TransactionDate = unmarshaler.TransactionDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchedPaymentRequest) MarshalJSON() ([]byte, error) {
	type embed PatchedPaymentRequest
	var marshaler = struct {
		embed
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
	}{
		embed:           embed(*p),
		TransactionDate: internal.NewOptionalDateTime(p.TransactionDate),
	}
	return json.Marshal(marshaler)
}

func (p *PatchedPaymentRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The supplier’s or customer’s account in which the payment is made.
type PatchedPaymentRequestAccount struct {
	String  string
	Account *Account

	typ string
}

func (p *PatchedPaymentRequestAccount) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestAccount) GetAccount() *Account {
	if p == nil {
		return nil
	}
	return p.Account
}

func (p *PatchedPaymentRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		p.typ = "Account"
		p.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestAccount) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Account" || p.Account != nil {
		return json.Marshal(p.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (p *PatchedPaymentRequestAccount) Accept(visitor PatchedPaymentRequestAccountVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Account" || p.Account != nil {
		return visitor.VisitAccount(p.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The accounting period that the Payment was generated in.
type PatchedPaymentRequestAccountingPeriod struct {
	String           string
	AccountingPeriod *AccountingPeriod

	typ string
}

func (p *PatchedPaymentRequestAccountingPeriod) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestAccountingPeriod) GetAccountingPeriod() *AccountingPeriod {
	if p == nil {
		return nil
	}
	return p.AccountingPeriod
}

func (p *PatchedPaymentRequestAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		p.typ = "AccountingPeriod"
		p.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestAccountingPeriod) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "AccountingPeriod" || p.AccountingPeriod != nil {
		return json.Marshal(p.AccountingPeriod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (p *PatchedPaymentRequestAccountingPeriod) Accept(visitor PatchedPaymentRequestAccountingPeriodVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "AccountingPeriod" || p.AccountingPeriod != nil {
		return visitor.VisitAccountingPeriod(p.AccountingPeriod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestAppliedToLinesItem struct {
	String                 string
	PaymentLineItemRequest *PaymentLineItemRequest

	typ string
}

func (p *PatchedPaymentRequestAppliedToLinesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestAppliedToLinesItem) GetPaymentLineItemRequest() *PaymentLineItemRequest {
	if p == nil {
		return nil
	}
	return p.PaymentLineItemRequest
}

func (p *PatchedPaymentRequestAppliedToLinesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valuePaymentLineItemRequest := new(PaymentLineItemRequest)
	if err := json.Unmarshal(data, &valuePaymentLineItemRequest); err == nil {
		p.typ = "PaymentLineItemRequest"
		p.PaymentLineItemRequest = valuePaymentLineItemRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestAppliedToLinesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "PaymentLineItemRequest" || p.PaymentLineItemRequest != nil {
		return json.Marshal(p.PaymentLineItemRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestAppliedToLinesItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItemRequest(*PaymentLineItemRequest) error
}

func (p *PatchedPaymentRequestAppliedToLinesItem) Accept(visitor PatchedPaymentRequestAppliedToLinesItemVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "PaymentLineItemRequest" || p.PaymentLineItemRequest != nil {
		return visitor.VisitPaymentLineItemRequest(p.PaymentLineItemRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The company the payment belongs to.
type PatchedPaymentRequestCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (p *PatchedPaymentRequestCompany) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestCompany) GetCompanyInfo() *CompanyInfo {
	if p == nil {
		return nil
	}
	return p.CompanyInfo
}

func (p *PatchedPaymentRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typ = "CompanyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestCompany) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return json.Marshal(p.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PatchedPaymentRequestCompany) Accept(visitor PatchedPaymentRequestCompanyVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The supplier, or customer involved in the payment.
type PatchedPaymentRequestContact struct {
	String  string
	Contact *Contact

	typ string
}

func (p *PatchedPaymentRequestContact) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestContact) GetContact() *Contact {
	if p == nil {
		return nil
	}
	return p.Contact
}

func (p *PatchedPaymentRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typ = "Contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestContact) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Contact" || p.Contact != nil {
		return json.Marshal(p.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PatchedPaymentRequestContact) Accept(visitor PatchedPaymentRequestContactVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Contact" || p.Contact != nil {
		return visitor.VisitContact(p.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The payment's currency.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type PatchedPaymentRequestCurrency struct {
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string

	typ string
}

func (p *PatchedPaymentRequestCurrency) GetTransactionCurrencyEnum() TransactionCurrencyEnum {
	if p == nil {
		return ""
	}
	return p.TransactionCurrencyEnum
}

func (p *PatchedPaymentRequestCurrency) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typ = "TransactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestCurrency) MarshalJSON() ([]byte, error) {
	if p.typ == "TransactionCurrencyEnum" || p.TransactionCurrencyEnum != "" {
		return json.Marshal(p.TransactionCurrencyEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PatchedPaymentRequestCurrency) Accept(visitor PatchedPaymentRequestCurrencyVisitor) error {
	if p.typ == "TransactionCurrencyEnum" || p.TransactionCurrencyEnum != "" {
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The method which this payment was made by.
type PatchedPaymentRequestPaymentMethod struct {
	String        string
	PaymentMethod *PaymentMethod

	typ string
}

func (p *PatchedPaymentRequestPaymentMethod) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestPaymentMethod) GetPaymentMethod() *PaymentMethod {
	if p == nil {
		return nil
	}
	return p.PaymentMethod
}

func (p *PatchedPaymentRequestPaymentMethod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valuePaymentMethod := new(PaymentMethod)
	if err := json.Unmarshal(data, &valuePaymentMethod); err == nil {
		p.typ = "PaymentMethod"
		p.PaymentMethod = valuePaymentMethod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestPaymentMethod) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "PaymentMethod" || p.PaymentMethod != nil {
		return json.Marshal(p.PaymentMethod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestPaymentMethodVisitor interface {
	VisitString(string) error
	VisitPaymentMethod(*PaymentMethod) error
}

func (p *PatchedPaymentRequestPaymentMethod) Accept(visitor PatchedPaymentRequestPaymentMethodVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "PaymentMethod" || p.PaymentMethod != nil {
		return visitor.VisitPaymentMethod(p.PaymentMethod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (p *PatchedPaymentRequestTrackingCategoriesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if p == nil {
		return nil
	}
	return p.TrackingCategory
}

func (p *PatchedPaymentRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typ = "TrackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "TrackingCategory" || p.TrackingCategory != nil {
		return json.Marshal(p.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PatchedPaymentRequestTrackingCategoriesItem) Accept(visitor PatchedPaymentRequestTrackingCategoriesItemVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "TrackingCategory" || p.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The type of the invoice.
//
// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
type PatchedPaymentRequestType struct {
	PaymentTypeEnum PaymentTypeEnum
	String          string

	typ string
}

func (p *PatchedPaymentRequestType) GetPaymentTypeEnum() PaymentTypeEnum {
	if p == nil {
		return ""
	}
	return p.PaymentTypeEnum
}

func (p *PatchedPaymentRequestType) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PatchedPaymentRequestType) UnmarshalJSON(data []byte) error {
	var valuePaymentTypeEnum PaymentTypeEnum
	if err := json.Unmarshal(data, &valuePaymentTypeEnum); err == nil {
		p.typ = "PaymentTypeEnum"
		p.PaymentTypeEnum = valuePaymentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedPaymentRequestType) MarshalJSON() ([]byte, error) {
	if p.typ == "PaymentTypeEnum" || p.PaymentTypeEnum != "" {
		return json.Marshal(p.PaymentTypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PatchedPaymentRequestTypeVisitor interface {
	VisitPaymentTypeEnum(PaymentTypeEnum) error
	VisitString(string) error
}

func (p *PatchedPaymentRequestType) Accept(visitor PatchedPaymentRequestTypeVisitor) error {
	if p.typ == "PaymentTypeEnum" || p.PaymentTypeEnum != "" {
		return visitor.VisitPaymentTypeEnum(p.PaymentTypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// # The PaymentLineItem Object
// ### Description
// The `PaymentLineItem` object is an applied-to-line on a `Payment` that can either be a `Invoice`, `CreditNote`, or `JournalEntry`.
//
// ### Usage Example
// `Payment` will have a field called `applied-to-lines` which will be an array of `PaymentLineItemInternalMappingSerializer` objects that can either be a `Invoice`, `CreditNote`, or `JournalEntry`.
type PaymentLineItemRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The amount being applied to the transaction.
	AppliedAmount *string `json:"applied_amount,omitempty" url:"applied_amount,omitempty"`
	// The date the payment portion is applied.
	AppliedDate *time.Time `json:"applied_date,omitempty" url:"applied_date,omitempty"`
	// The Merge ID of the transaction the payment portion is being applied to.
	RelatedObjectId *string `json:"related_object_id,omitempty" url:"related_object_id,omitempty"`
	// The type of transaction the payment portion is being applied to. Possible values include: INVOICE, JOURNAL_ENTRY, or CREDIT_NOTE.
	RelatedObjectType   *string                `json:"related_object_type,omitempty" url:"related_object_type,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentLineItemRequest) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PaymentLineItemRequest) GetAppliedAmount() *string {
	if p == nil {
		return nil
	}
	return p.AppliedAmount
}

func (p *PaymentLineItemRequest) GetAppliedDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.AppliedDate
}

func (p *PaymentLineItemRequest) GetRelatedObjectId() *string {
	if p == nil {
		return nil
	}
	return p.RelatedObjectId
}

func (p *PaymentLineItemRequest) GetRelatedObjectType() *string {
	if p == nil {
		return nil
	}
	return p.RelatedObjectType
}

func (p *PaymentLineItemRequest) GetIntegrationParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.IntegrationParams
}

func (p *PaymentLineItemRequest) GetLinkedAccountParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.LinkedAccountParams
}

func (p *PaymentLineItemRequest) GetRemoteFields() []*RemoteFieldRequest {
	if p == nil {
		return nil
	}
	return p.RemoteFields
}

func (p *PaymentLineItemRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLineItemRequest) UnmarshalJSON(data []byte) error {
	type embed PaymentLineItemRequest
	var unmarshaler = struct {
		embed
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentLineItemRequest(unmarshaler.embed)
	p.AppliedDate = unmarshaler.AppliedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLineItemRequest) MarshalJSON() ([]byte, error) {
	type embed PaymentLineItemRequest
	var marshaler = struct {
		embed
		AppliedDate *internal.DateTime `json:"applied_date,omitempty"`
	}{
		embed:       embed(*p),
		AppliedDate: internal.NewOptionalDateTime(p.AppliedDate),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentLineItemRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The Payment Object
// ### Description
// The `Payment` object represents general payments made towards a specific transaction.
//
// ### Usage Example
// Fetch from the `GET Payment` endpoint and view an invoice's payment.
type PaymentRequest struct {
	// The payment's transaction date.
	TransactionDate *time.Time `json:"transaction_date,omitempty" url:"transaction_date,omitempty"`
	// The supplier, or customer involved in the payment.
	Contact *PaymentRequestContact `json:"contact,omitempty" url:"contact,omitempty"`
	// The supplier’s or customer’s account in which the payment is made.
	Account *PaymentRequestAccount `json:"account,omitempty" url:"account,omitempty"`
	// The method which this payment was made by.
	PaymentMethod *PaymentRequestPaymentMethod `json:"payment_method,omitempty" url:"payment_method,omitempty"`
	// The payment's currency.
	//
	// * `XUA` - ADB Unit of Account
	// * `AFN` - Afghan Afghani
	// * `AFA` - Afghan Afghani (1927–2002)
	// * `ALL` - Albanian Lek
	// * `ALK` - Albanian Lek (1946–1965)
	// * `DZD` - Algerian Dinar
	// * `ADP` - Andorran Peseta
	// * `AOA` - Angolan Kwanza
	// * `AOK` - Angolan Kwanza (1977–1991)
	// * `AON` - Angolan New Kwanza (1990–2000)
	// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
	// * `ARA` - Argentine Austral
	// * `ARS` - Argentine Peso
	// * `ARM` - Argentine Peso (1881–1970)
	// * `ARP` - Argentine Peso (1983–1985)
	// * `ARL` - Argentine Peso Ley (1970–1983)
	// * `AMD` - Armenian Dram
	// * `AWG` - Aruban Florin
	// * `AUD` - Australian Dollar
	// * `ATS` - Austrian Schilling
	// * `AZN` - Azerbaijani Manat
	// * `AZM` - Azerbaijani Manat (1993–2006)
	// * `BSD` - Bahamian Dollar
	// * `BHD` - Bahraini Dinar
	// * `BDT` - Bangladeshi Taka
	// * `BBD` - Barbadian Dollar
	// * `BYN` - Belarusian Ruble
	// * `BYB` - Belarusian Ruble (1994–1999)
	// * `BYR` - Belarusian Ruble (2000–2016)
	// * `BEF` - Belgian Franc
	// * `BEC` - Belgian Franc (convertible)
	// * `BEL` - Belgian Franc (financial)
	// * `BZD` - Belize Dollar
	// * `BMD` - Bermudan Dollar
	// * `BTN` - Bhutanese Ngultrum
	// * `BOB` - Bolivian Boliviano
	// * `BOL` - Bolivian Boliviano (1863–1963)
	// * `BOV` - Bolivian Mvdol
	// * `BOP` - Bolivian Peso
	// * `BAM` - Bosnia-Herzegovina Convertible Mark
	// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
	// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
	// * `BWP` - Botswanan Pula
	// * `BRC` - Brazilian Cruzado (1986–1989)
	// * `BRZ` - Brazilian Cruzeiro (1942–1967)
	// * `BRE` - Brazilian Cruzeiro (1990–1993)
	// * `BRR` - Brazilian Cruzeiro (1993–1994)
	// * `BRN` - Brazilian New Cruzado (1989–1990)
	// * `BRB` - Brazilian New Cruzeiro (1967–1986)
	// * `BRL` - Brazilian Real
	// * `GBP` - British Pound
	// * `BND` - Brunei Dollar
	// * `BGL` - Bulgarian Hard Lev
	// * `BGN` - Bulgarian Lev
	// * `BGO` - Bulgarian Lev (1879–1952)
	// * `BGM` - Bulgarian Socialist Lev
	// * `BUK` - Burmese Kyat
	// * `BIF` - Burundian Franc
	// * `XPF` - CFP Franc
	// * `KHR` - Cambodian Riel
	// * `CAD` - Canadian Dollar
	// * `CVE` - Cape Verdean Escudo
	// * `KYD` - Cayman Islands Dollar
	// * `XAF` - Central African CFA Franc
	// * `CLE` - Chilean Escudo
	// * `CLP` - Chilean Peso
	// * `CLF` - Chilean Unit of Account (UF)
	// * `CNX` - Chinese People’s Bank Dollar
	// * `CNY` - Chinese Yuan
	// * `CNH` - Chinese Yuan (offshore)
	// * `COP` - Colombian Peso
	// * `COU` - Colombian Real Value Unit
	// * `KMF` - Comorian Franc
	// * `CDF` - Congolese Franc
	// * `CRC` - Costa Rican Colón
	// * `HRD` - Croatian Dinar
	// * `HRK` - Croatian Kuna
	// * `CUC` - Cuban Convertible Peso
	// * `CUP` - Cuban Peso
	// * `CYP` - Cypriot Pound
	// * `CZK` - Czech Koruna
	// * `CSK` - Czechoslovak Hard Koruna
	// * `DKK` - Danish Krone
	// * `DJF` - Djiboutian Franc
	// * `DOP` - Dominican Peso
	// * `NLG` - Dutch Guilder
	// * `XCD` - East Caribbean Dollar
	// * `DDM` - East German Mark
	// * `ECS` - Ecuadorian Sucre
	// * `ECV` - Ecuadorian Unit of Constant Value
	// * `EGP` - Egyptian Pound
	// * `GQE` - Equatorial Guinean Ekwele
	// * `ERN` - Eritrean Nakfa
	// * `EEK` - Estonian Kroon
	// * `ETB` - Ethiopian Birr
	// * `EUR` - Euro
	// * `XBA` - European Composite Unit
	// * `XEU` - European Currency Unit
	// * `XBB` - European Monetary Unit
	// * `XBC` - European Unit of Account (XBC)
	// * `XBD` - European Unit of Account (XBD)
	// * `FKP` - Falkland Islands Pound
	// * `FJD` - Fijian Dollar
	// * `FIM` - Finnish Markka
	// * `FRF` - French Franc
	// * `XFO` - French Gold Franc
	// * `XFU` - French UIC-Franc
	// * `GMD` - Gambian Dalasi
	// * `GEK` - Georgian Kupon Larit
	// * `GEL` - Georgian Lari
	// * `DEM` - German Mark
	// * `GHS` - Ghanaian Cedi
	// * `GHC` - Ghanaian Cedi (1979–2007)
	// * `GIP` - Gibraltar Pound
	// * `XAU` - Gold
	// * `GRD` - Greek Drachma
	// * `GTQ` - Guatemalan Quetzal
	// * `GWP` - Guinea-Bissau Peso
	// * `GNF` - Guinean Franc
	// * `GNS` - Guinean Syli
	// * `GYD` - Guyanaese Dollar
	// * `HTG` - Haitian Gourde
	// * `HNL` - Honduran Lempira
	// * `HKD` - Hong Kong Dollar
	// * `HUF` - Hungarian Forint
	// * `IMP` - IMP
	// * `ISK` - Icelandic Króna
	// * `ISJ` - Icelandic Króna (1918–1981)
	// * `INR` - Indian Rupee
	// * `IDR` - Indonesian Rupiah
	// * `IRR` - Iranian Rial
	// * `IQD` - Iraqi Dinar
	// * `IEP` - Irish Pound
	// * `ILS` - Israeli New Shekel
	// * `ILP` - Israeli Pound
	// * `ILR` - Israeli Shekel (1980–1985)
	// * `ITL` - Italian Lira
	// * `JMD` - Jamaican Dollar
	// * `JPY` - Japanese Yen
	// * `JOD` - Jordanian Dinar
	// * `KZT` - Kazakhstani Tenge
	// * `KES` - Kenyan Shilling
	// * `KWD` - Kuwaiti Dinar
	// * `KGS` - Kyrgystani Som
	// * `LAK` - Laotian Kip
	// * `LVL` - Latvian Lats
	// * `LVR` - Latvian Ruble
	// * `LBP` - Lebanese Pound
	// * `LSL` - Lesotho Loti
	// * `LRD` - Liberian Dollar
	// * `LYD` - Libyan Dinar
	// * `LTL` - Lithuanian Litas
	// * `LTT` - Lithuanian Talonas
	// * `LUL` - Luxembourg Financial Franc
	// * `LUC` - Luxembourgian Convertible Franc
	// * `LUF` - Luxembourgian Franc
	// * `MOP` - Macanese Pataca
	// * `MKD` - Macedonian Denar
	// * `MKN` - Macedonian Denar (1992–1993)
	// * `MGA` - Malagasy Ariary
	// * `MGF` - Malagasy Franc
	// * `MWK` - Malawian Kwacha
	// * `MYR` - Malaysian Ringgit
	// * `MVR` - Maldivian Rufiyaa
	// * `MVP` - Maldivian Rupee (1947–1981)
	// * `MLF` - Malian Franc
	// * `MTL` - Maltese Lira
	// * `MTP` - Maltese Pound
	// * `MRU` - Mauritanian Ouguiya
	// * `MRO` - Mauritanian Ouguiya (1973–2017)
	// * `MUR` - Mauritian Rupee
	// * `MXV` - Mexican Investment Unit
	// * `MXN` - Mexican Peso
	// * `MXP` - Mexican Silver Peso (1861–1992)
	// * `MDC` - Moldovan Cupon
	// * `MDL` - Moldovan Leu
	// * `MCF` - Monegasque Franc
	// * `MNT` - Mongolian Tugrik
	// * `MAD` - Moroccan Dirham
	// * `MAF` - Moroccan Franc
	// * `MZE` - Mozambican Escudo
	// * `MZN` - Mozambican Metical
	// * `MZM` - Mozambican Metical (1980–2006)
	// * `MMK` - Myanmar Kyat
	// * `NAD` - Namibian Dollar
	// * `NPR` - Nepalese Rupee
	// * `ANG` - Netherlands Antillean Guilder
	// * `TWD` - New Taiwan Dollar
	// * `NZD` - New Zealand Dollar
	// * `NIO` - Nicaraguan Córdoba
	// * `NIC` - Nicaraguan Córdoba (1988–1991)
	// * `NGN` - Nigerian Naira
	// * `KPW` - North Korean Won
	// * `NOK` - Norwegian Krone
	// * `OMR` - Omani Rial
	// * `PKR` - Pakistani Rupee
	// * `XPD` - Palladium
	// * `PAB` - Panamanian Balboa
	// * `PGK` - Papua New Guinean Kina
	// * `PYG` - Paraguayan Guarani
	// * `PEI` - Peruvian Inti
	// * `PEN` - Peruvian Sol
	// * `PES` - Peruvian Sol (1863–1965)
	// * `PHP` - Philippine Peso
	// * `XPT` - Platinum
	// * `PLN` - Polish Zloty
	// * `PLZ` - Polish Zloty (1950–1995)
	// * `PTE` - Portuguese Escudo
	// * `GWE` - Portuguese Guinea Escudo
	// * `QAR` - Qatari Rial
	// * `XRE` - RINET Funds
	// * `RHD` - Rhodesian Dollar
	// * `RON` - Romanian Leu
	// * `ROL` - Romanian Leu (1952–2006)
	// * `RUB` - Russian Ruble
	// * `RUR` - Russian Ruble (1991–1998)
	// * `RWF` - Rwandan Franc
	// * `SVC` - Salvadoran Colón
	// * `WST` - Samoan Tala
	// * `SAR` - Saudi Riyal
	// * `RSD` - Serbian Dinar
	// * `CSD` - Serbian Dinar (2002–2006)
	// * `SCR` - Seychellois Rupee
	// * `SLL` - Sierra Leonean Leone
	// * `XAG` - Silver
	// * `SGD` - Singapore Dollar
	// * `SKK` - Slovak Koruna
	// * `SIT` - Slovenian Tolar
	// * `SBD` - Solomon Islands Dollar
	// * `SOS` - Somali Shilling
	// * `ZAR` - South African Rand
	// * `ZAL` - South African Rand (financial)
	// * `KRH` - South Korean Hwan (1953–1962)
	// * `KRW` - South Korean Won
	// * `KRO` - South Korean Won (1945–1953)
	// * `SSP` - South Sudanese Pound
	// * `SUR` - Soviet Rouble
	// * `ESP` - Spanish Peseta
	// * `ESA` - Spanish Peseta (A account)
	// * `ESB` - Spanish Peseta (convertible account)
	// * `XDR` - Special Drawing Rights
	// * `LKR` - Sri Lankan Rupee
	// * `SHP` - St. Helena Pound
	// * `XSU` - Sucre
	// * `SDD` - Sudanese Dinar (1992–2007)
	// * `SDG` - Sudanese Pound
	// * `SDP` - Sudanese Pound (1957–1998)
	// * `SRD` - Surinamese Dollar
	// * `SRG` - Surinamese Guilder
	// * `SZL` - Swazi Lilangeni
	// * `SEK` - Swedish Krona
	// * `CHF` - Swiss Franc
	// * `SYP` - Syrian Pound
	// * `STN` - São Tomé & Príncipe Dobra
	// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
	// * `TVD` - TVD
	// * `TJR` - Tajikistani Ruble
	// * `TJS` - Tajikistani Somoni
	// * `TZS` - Tanzanian Shilling
	// * `XTS` - Testing Currency Code
	// * `THB` - Thai Baht
	// * `XXX` - The codes assigned for transactions where no currency is involved
	// * `TPE` - Timorese Escudo
	// * `TOP` - Tongan Paʻanga
	// * `TTD` - Trinidad & Tobago Dollar
	// * `TND` - Tunisian Dinar
	// * `TRY` - Turkish Lira
	// * `TRL` - Turkish Lira (1922–2005)
	// * `TMT` - Turkmenistani Manat
	// * `TMM` - Turkmenistani Manat (1993–2009)
	// * `USD` - US Dollar
	// * `USN` - US Dollar (Next day)
	// * `USS` - US Dollar (Same day)
	// * `UGX` - Ugandan Shilling
	// * `UGS` - Ugandan Shilling (1966–1987)
	// * `UAH` - Ukrainian Hryvnia
	// * `UAK` - Ukrainian Karbovanets
	// * `AED` - United Arab Emirates Dirham
	// * `UYW` - Uruguayan Nominal Wage Index Unit
	// * `UYU` - Uruguayan Peso
	// * `UYP` - Uruguayan Peso (1975–1993)
	// * `UYI` - Uruguayan Peso (Indexed Units)
	// * `UZS` - Uzbekistani Som
	// * `VUV` - Vanuatu Vatu
	// * `VES` - Venezuelan Bolívar
	// * `VEB` - Venezuelan Bolívar (1871–2008)
	// * `VEF` - Venezuelan Bolívar (2008–2018)
	// * `VND` - Vietnamese Dong
	// * `VNN` - Vietnamese Dong (1978–1985)
	// * `CHE` - WIR Euro
	// * `CHW` - WIR Franc
	// * `XOF` - West African CFA Franc
	// * `YDD` - Yemeni Dinar
	// * `YER` - Yemeni Rial
	// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
	// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
	// * `YUM` - Yugoslavian New Dinar (1994–2002)
	// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
	// * `ZWN` - ZWN
	// * `ZRN` - Zairean New Zaire (1993–1998)
	// * `ZRZ` - Zairean Zaire (1971–1993)
	// * `ZMW` - Zambian Kwacha
	// * `ZMK` - Zambian Kwacha (1968–2012)
	// * `ZWD` - Zimbabwean Dollar (1980–2008)
	// * `ZWR` - Zimbabwean Dollar (2008)
	// * `ZWL` - Zimbabwean Dollar (2009)
	Currency *PaymentRequestCurrency `json:"currency,omitempty" url:"currency,omitempty"`
	// The payment's exchange rate.
	ExchangeRate *string `json:"exchange_rate,omitempty" url:"exchange_rate,omitempty"`
	// The company the payment belongs to.
	Company *PaymentRequestCompany `json:"company,omitempty" url:"company,omitempty"`
	// The total amount of money being paid to the supplier, or customer, after taxes.
	TotalAmount *float64 `json:"total_amount,omitempty" url:"total_amount,omitempty"`
	// The type of the invoice.
	//
	// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
	// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
	Type               *PaymentRequestType                     `json:"type,omitempty" url:"type,omitempty"`
	TrackingCategories []*PaymentRequestTrackingCategoriesItem `json:"tracking_categories,omitempty" url:"tracking_categories,omitempty"`
	// The accounting period that the Payment was generated in.
	AccountingPeriod *PaymentRequestAccountingPeriod `json:"accounting_period,omitempty" url:"accounting_period,omitempty"`
	// A list of “Payment Applied to Lines” objects.
	AppliedToLines      []*PaymentRequestAppliedToLinesItem `json:"applied_to_lines,omitempty" url:"applied_to_lines,omitempty"`
	IntegrationParams   map[string]interface{}              `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}              `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest               `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentRequest) GetTransactionDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.TransactionDate
}

func (p *PaymentRequest) GetContact() *PaymentRequestContact {
	if p == nil {
		return nil
	}
	return p.Contact
}

func (p *PaymentRequest) GetAccount() *PaymentRequestAccount {
	if p == nil {
		return nil
	}
	return p.Account
}

func (p *PaymentRequest) GetPaymentMethod() *PaymentRequestPaymentMethod {
	if p == nil {
		return nil
	}
	return p.PaymentMethod
}

func (p *PaymentRequest) GetCurrency() *PaymentRequestCurrency {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PaymentRequest) GetExchangeRate() *string {
	if p == nil {
		return nil
	}
	return p.ExchangeRate
}

func (p *PaymentRequest) GetCompany() *PaymentRequestCompany {
	if p == nil {
		return nil
	}
	return p.Company
}

func (p *PaymentRequest) GetTotalAmount() *float64 {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *PaymentRequest) GetType() *PaymentRequestType {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PaymentRequest) GetTrackingCategories() []*PaymentRequestTrackingCategoriesItem {
	if p == nil {
		return nil
	}
	return p.TrackingCategories
}

func (p *PaymentRequest) GetAccountingPeriod() *PaymentRequestAccountingPeriod {
	if p == nil {
		return nil
	}
	return p.AccountingPeriod
}

func (p *PaymentRequest) GetAppliedToLines() []*PaymentRequestAppliedToLinesItem {
	if p == nil {
		return nil
	}
	return p.AppliedToLines
}

func (p *PaymentRequest) GetIntegrationParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.IntegrationParams
}

func (p *PaymentRequest) GetLinkedAccountParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.LinkedAccountParams
}

func (p *PaymentRequest) GetRemoteFields() []*RemoteFieldRequest {
	if p == nil {
		return nil
	}
	return p.RemoteFields
}

func (p *PaymentRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRequest) UnmarshalJSON(data []byte) error {
	type embed PaymentRequest
	var unmarshaler = struct {
		embed
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentRequest(unmarshaler.embed)
	p.TransactionDate = unmarshaler.TransactionDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRequest) MarshalJSON() ([]byte, error) {
	type embed PaymentRequest
	var marshaler = struct {
		embed
		TransactionDate *internal.DateTime `json:"transaction_date,omitempty"`
	}{
		embed:           embed(*p),
		TransactionDate: internal.NewOptionalDateTime(p.TransactionDate),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The supplier’s or customer’s account in which the payment is made.
type PaymentRequestAccount struct {
	String  string
	Account *Account

	typ string
}

func (p *PaymentRequestAccount) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestAccount) GetAccount() *Account {
	if p == nil {
		return nil
	}
	return p.Account
}

func (p *PaymentRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		p.typ = "Account"
		p.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestAccount) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Account" || p.Account != nil {
		return json.Marshal(p.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (p *PaymentRequestAccount) Accept(visitor PaymentRequestAccountVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Account" || p.Account != nil {
		return visitor.VisitAccount(p.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The accounting period that the Payment was generated in.
type PaymentRequestAccountingPeriod struct {
	String           string
	AccountingPeriod *AccountingPeriod

	typ string
}

func (p *PaymentRequestAccountingPeriod) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestAccountingPeriod) GetAccountingPeriod() *AccountingPeriod {
	if p == nil {
		return nil
	}
	return p.AccountingPeriod
}

func (p *PaymentRequestAccountingPeriod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueAccountingPeriod := new(AccountingPeriod)
	if err := json.Unmarshal(data, &valueAccountingPeriod); err == nil {
		p.typ = "AccountingPeriod"
		p.AccountingPeriod = valueAccountingPeriod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestAccountingPeriod) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "AccountingPeriod" || p.AccountingPeriod != nil {
		return json.Marshal(p.AccountingPeriod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestAccountingPeriodVisitor interface {
	VisitString(string) error
	VisitAccountingPeriod(*AccountingPeriod) error
}

func (p *PaymentRequestAccountingPeriod) Accept(visitor PaymentRequestAccountingPeriodVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "AccountingPeriod" || p.AccountingPeriod != nil {
		return visitor.VisitAccountingPeriod(p.AccountingPeriod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestAppliedToLinesItem struct {
	String                 string
	PaymentLineItemRequest *PaymentLineItemRequest

	typ string
}

func (p *PaymentRequestAppliedToLinesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestAppliedToLinesItem) GetPaymentLineItemRequest() *PaymentLineItemRequest {
	if p == nil {
		return nil
	}
	return p.PaymentLineItemRequest
}

func (p *PaymentRequestAppliedToLinesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valuePaymentLineItemRequest := new(PaymentLineItemRequest)
	if err := json.Unmarshal(data, &valuePaymentLineItemRequest); err == nil {
		p.typ = "PaymentLineItemRequest"
		p.PaymentLineItemRequest = valuePaymentLineItemRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestAppliedToLinesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "PaymentLineItemRequest" || p.PaymentLineItemRequest != nil {
		return json.Marshal(p.PaymentLineItemRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestAppliedToLinesItemVisitor interface {
	VisitString(string) error
	VisitPaymentLineItemRequest(*PaymentLineItemRequest) error
}

func (p *PaymentRequestAppliedToLinesItem) Accept(visitor PaymentRequestAppliedToLinesItemVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "PaymentLineItemRequest" || p.PaymentLineItemRequest != nil {
		return visitor.VisitPaymentLineItemRequest(p.PaymentLineItemRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The company the payment belongs to.
type PaymentRequestCompany struct {
	String      string
	CompanyInfo *CompanyInfo

	typ string
}

func (p *PaymentRequestCompany) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestCompany) GetCompanyInfo() *CompanyInfo {
	if p == nil {
		return nil
	}
	return p.CompanyInfo
}

func (p *PaymentRequestCompany) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueCompanyInfo := new(CompanyInfo)
	if err := json.Unmarshal(data, &valueCompanyInfo); err == nil {
		p.typ = "CompanyInfo"
		p.CompanyInfo = valueCompanyInfo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestCompany) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return json.Marshal(p.CompanyInfo)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestCompanyVisitor interface {
	VisitString(string) error
	VisitCompanyInfo(*CompanyInfo) error
}

func (p *PaymentRequestCompany) Accept(visitor PaymentRequestCompanyVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "CompanyInfo" || p.CompanyInfo != nil {
		return visitor.VisitCompanyInfo(p.CompanyInfo)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The supplier, or customer involved in the payment.
type PaymentRequestContact struct {
	String  string
	Contact *Contact

	typ string
}

func (p *PaymentRequestContact) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestContact) GetContact() *Contact {
	if p == nil {
		return nil
	}
	return p.Contact
}

func (p *PaymentRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		p.typ = "Contact"
		p.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestContact) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Contact" || p.Contact != nil {
		return json.Marshal(p.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (p *PaymentRequestContact) Accept(visitor PaymentRequestContactVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Contact" || p.Contact != nil {
		return visitor.VisitContact(p.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The payment's currency.
//
// * `XUA` - ADB Unit of Account
// * `AFN` - Afghan Afghani
// * `AFA` - Afghan Afghani (1927–2002)
// * `ALL` - Albanian Lek
// * `ALK` - Albanian Lek (1946–1965)
// * `DZD` - Algerian Dinar
// * `ADP` - Andorran Peseta
// * `AOA` - Angolan Kwanza
// * `AOK` - Angolan Kwanza (1977–1991)
// * `AON` - Angolan New Kwanza (1990–2000)
// * `AOR` - Angolan Readjusted Kwanza (1995–1999)
// * `ARA` - Argentine Austral
// * `ARS` - Argentine Peso
// * `ARM` - Argentine Peso (1881–1970)
// * `ARP` - Argentine Peso (1983–1985)
// * `ARL` - Argentine Peso Ley (1970–1983)
// * `AMD` - Armenian Dram
// * `AWG` - Aruban Florin
// * `AUD` - Australian Dollar
// * `ATS` - Austrian Schilling
// * `AZN` - Azerbaijani Manat
// * `AZM` - Azerbaijani Manat (1993–2006)
// * `BSD` - Bahamian Dollar
// * `BHD` - Bahraini Dinar
// * `BDT` - Bangladeshi Taka
// * `BBD` - Barbadian Dollar
// * `BYN` - Belarusian Ruble
// * `BYB` - Belarusian Ruble (1994–1999)
// * `BYR` - Belarusian Ruble (2000–2016)
// * `BEF` - Belgian Franc
// * `BEC` - Belgian Franc (convertible)
// * `BEL` - Belgian Franc (financial)
// * `BZD` - Belize Dollar
// * `BMD` - Bermudan Dollar
// * `BTN` - Bhutanese Ngultrum
// * `BOB` - Bolivian Boliviano
// * `BOL` - Bolivian Boliviano (1863–1963)
// * `BOV` - Bolivian Mvdol
// * `BOP` - Bolivian Peso
// * `BAM` - Bosnia-Herzegovina Convertible Mark
// * `BAD` - Bosnia-Herzegovina Dinar (1992–1994)
// * `BAN` - Bosnia-Herzegovina New Dinar (1994–1997)
// * `BWP` - Botswanan Pula
// * `BRC` - Brazilian Cruzado (1986–1989)
// * `BRZ` - Brazilian Cruzeiro (1942–1967)
// * `BRE` - Brazilian Cruzeiro (1990–1993)
// * `BRR` - Brazilian Cruzeiro (1993–1994)
// * `BRN` - Brazilian New Cruzado (1989–1990)
// * `BRB` - Brazilian New Cruzeiro (1967–1986)
// * `BRL` - Brazilian Real
// * `GBP` - British Pound
// * `BND` - Brunei Dollar
// * `BGL` - Bulgarian Hard Lev
// * `BGN` - Bulgarian Lev
// * `BGO` - Bulgarian Lev (1879–1952)
// * `BGM` - Bulgarian Socialist Lev
// * `BUK` - Burmese Kyat
// * `BIF` - Burundian Franc
// * `XPF` - CFP Franc
// * `KHR` - Cambodian Riel
// * `CAD` - Canadian Dollar
// * `CVE` - Cape Verdean Escudo
// * `KYD` - Cayman Islands Dollar
// * `XAF` - Central African CFA Franc
// * `CLE` - Chilean Escudo
// * `CLP` - Chilean Peso
// * `CLF` - Chilean Unit of Account (UF)
// * `CNX` - Chinese People’s Bank Dollar
// * `CNY` - Chinese Yuan
// * `CNH` - Chinese Yuan (offshore)
// * `COP` - Colombian Peso
// * `COU` - Colombian Real Value Unit
// * `KMF` - Comorian Franc
// * `CDF` - Congolese Franc
// * `CRC` - Costa Rican Colón
// * `HRD` - Croatian Dinar
// * `HRK` - Croatian Kuna
// * `CUC` - Cuban Convertible Peso
// * `CUP` - Cuban Peso
// * `CYP` - Cypriot Pound
// * `CZK` - Czech Koruna
// * `CSK` - Czechoslovak Hard Koruna
// * `DKK` - Danish Krone
// * `DJF` - Djiboutian Franc
// * `DOP` - Dominican Peso
// * `NLG` - Dutch Guilder
// * `XCD` - East Caribbean Dollar
// * `DDM` - East German Mark
// * `ECS` - Ecuadorian Sucre
// * `ECV` - Ecuadorian Unit of Constant Value
// * `EGP` - Egyptian Pound
// * `GQE` - Equatorial Guinean Ekwele
// * `ERN` - Eritrean Nakfa
// * `EEK` - Estonian Kroon
// * `ETB` - Ethiopian Birr
// * `EUR` - Euro
// * `XBA` - European Composite Unit
// * `XEU` - European Currency Unit
// * `XBB` - European Monetary Unit
// * `XBC` - European Unit of Account (XBC)
// * `XBD` - European Unit of Account (XBD)
// * `FKP` - Falkland Islands Pound
// * `FJD` - Fijian Dollar
// * `FIM` - Finnish Markka
// * `FRF` - French Franc
// * `XFO` - French Gold Franc
// * `XFU` - French UIC-Franc
// * `GMD` - Gambian Dalasi
// * `GEK` - Georgian Kupon Larit
// * `GEL` - Georgian Lari
// * `DEM` - German Mark
// * `GHS` - Ghanaian Cedi
// * `GHC` - Ghanaian Cedi (1979–2007)
// * `GIP` - Gibraltar Pound
// * `XAU` - Gold
// * `GRD` - Greek Drachma
// * `GTQ` - Guatemalan Quetzal
// * `GWP` - Guinea-Bissau Peso
// * `GNF` - Guinean Franc
// * `GNS` - Guinean Syli
// * `GYD` - Guyanaese Dollar
// * `HTG` - Haitian Gourde
// * `HNL` - Honduran Lempira
// * `HKD` - Hong Kong Dollar
// * `HUF` - Hungarian Forint
// * `IMP` - IMP
// * `ISK` - Icelandic Króna
// * `ISJ` - Icelandic Króna (1918–1981)
// * `INR` - Indian Rupee
// * `IDR` - Indonesian Rupiah
// * `IRR` - Iranian Rial
// * `IQD` - Iraqi Dinar
// * `IEP` - Irish Pound
// * `ILS` - Israeli New Shekel
// * `ILP` - Israeli Pound
// * `ILR` - Israeli Shekel (1980–1985)
// * `ITL` - Italian Lira
// * `JMD` - Jamaican Dollar
// * `JPY` - Japanese Yen
// * `JOD` - Jordanian Dinar
// * `KZT` - Kazakhstani Tenge
// * `KES` - Kenyan Shilling
// * `KWD` - Kuwaiti Dinar
// * `KGS` - Kyrgystani Som
// * `LAK` - Laotian Kip
// * `LVL` - Latvian Lats
// * `LVR` - Latvian Ruble
// * `LBP` - Lebanese Pound
// * `LSL` - Lesotho Loti
// * `LRD` - Liberian Dollar
// * `LYD` - Libyan Dinar
// * `LTL` - Lithuanian Litas
// * `LTT` - Lithuanian Talonas
// * `LUL` - Luxembourg Financial Franc
// * `LUC` - Luxembourgian Convertible Franc
// * `LUF` - Luxembourgian Franc
// * `MOP` - Macanese Pataca
// * `MKD` - Macedonian Denar
// * `MKN` - Macedonian Denar (1992–1993)
// * `MGA` - Malagasy Ariary
// * `MGF` - Malagasy Franc
// * `MWK` - Malawian Kwacha
// * `MYR` - Malaysian Ringgit
// * `MVR` - Maldivian Rufiyaa
// * `MVP` - Maldivian Rupee (1947–1981)
// * `MLF` - Malian Franc
// * `MTL` - Maltese Lira
// * `MTP` - Maltese Pound
// * `MRU` - Mauritanian Ouguiya
// * `MRO` - Mauritanian Ouguiya (1973–2017)
// * `MUR` - Mauritian Rupee
// * `MXV` - Mexican Investment Unit
// * `MXN` - Mexican Peso
// * `MXP` - Mexican Silver Peso (1861–1992)
// * `MDC` - Moldovan Cupon
// * `MDL` - Moldovan Leu
// * `MCF` - Monegasque Franc
// * `MNT` - Mongolian Tugrik
// * `MAD` - Moroccan Dirham
// * `MAF` - Moroccan Franc
// * `MZE` - Mozambican Escudo
// * `MZN` - Mozambican Metical
// * `MZM` - Mozambican Metical (1980–2006)
// * `MMK` - Myanmar Kyat
// * `NAD` - Namibian Dollar
// * `NPR` - Nepalese Rupee
// * `ANG` - Netherlands Antillean Guilder
// * `TWD` - New Taiwan Dollar
// * `NZD` - New Zealand Dollar
// * `NIO` - Nicaraguan Córdoba
// * `NIC` - Nicaraguan Córdoba (1988–1991)
// * `NGN` - Nigerian Naira
// * `KPW` - North Korean Won
// * `NOK` - Norwegian Krone
// * `OMR` - Omani Rial
// * `PKR` - Pakistani Rupee
// * `XPD` - Palladium
// * `PAB` - Panamanian Balboa
// * `PGK` - Papua New Guinean Kina
// * `PYG` - Paraguayan Guarani
// * `PEI` - Peruvian Inti
// * `PEN` - Peruvian Sol
// * `PES` - Peruvian Sol (1863–1965)
// * `PHP` - Philippine Peso
// * `XPT` - Platinum
// * `PLN` - Polish Zloty
// * `PLZ` - Polish Zloty (1950–1995)
// * `PTE` - Portuguese Escudo
// * `GWE` - Portuguese Guinea Escudo
// * `QAR` - Qatari Rial
// * `XRE` - RINET Funds
// * `RHD` - Rhodesian Dollar
// * `RON` - Romanian Leu
// * `ROL` - Romanian Leu (1952–2006)
// * `RUB` - Russian Ruble
// * `RUR` - Russian Ruble (1991–1998)
// * `RWF` - Rwandan Franc
// * `SVC` - Salvadoran Colón
// * `WST` - Samoan Tala
// * `SAR` - Saudi Riyal
// * `RSD` - Serbian Dinar
// * `CSD` - Serbian Dinar (2002–2006)
// * `SCR` - Seychellois Rupee
// * `SLL` - Sierra Leonean Leone
// * `XAG` - Silver
// * `SGD` - Singapore Dollar
// * `SKK` - Slovak Koruna
// * `SIT` - Slovenian Tolar
// * `SBD` - Solomon Islands Dollar
// * `SOS` - Somali Shilling
// * `ZAR` - South African Rand
// * `ZAL` - South African Rand (financial)
// * `KRH` - South Korean Hwan (1953–1962)
// * `KRW` - South Korean Won
// * `KRO` - South Korean Won (1945–1953)
// * `SSP` - South Sudanese Pound
// * `SUR` - Soviet Rouble
// * `ESP` - Spanish Peseta
// * `ESA` - Spanish Peseta (A account)
// * `ESB` - Spanish Peseta (convertible account)
// * `XDR` - Special Drawing Rights
// * `LKR` - Sri Lankan Rupee
// * `SHP` - St. Helena Pound
// * `XSU` - Sucre
// * `SDD` - Sudanese Dinar (1992–2007)
// * `SDG` - Sudanese Pound
// * `SDP` - Sudanese Pound (1957–1998)
// * `SRD` - Surinamese Dollar
// * `SRG` - Surinamese Guilder
// * `SZL` - Swazi Lilangeni
// * `SEK` - Swedish Krona
// * `CHF` - Swiss Franc
// * `SYP` - Syrian Pound
// * `STN` - São Tomé & Príncipe Dobra
// * `STD` - São Tomé & Príncipe Dobra (1977–2017)
// * `TVD` - TVD
// * `TJR` - Tajikistani Ruble
// * `TJS` - Tajikistani Somoni
// * `TZS` - Tanzanian Shilling
// * `XTS` - Testing Currency Code
// * `THB` - Thai Baht
// * `XXX` - The codes assigned for transactions where no currency is involved
// * `TPE` - Timorese Escudo
// * `TOP` - Tongan Paʻanga
// * `TTD` - Trinidad & Tobago Dollar
// * `TND` - Tunisian Dinar
// * `TRY` - Turkish Lira
// * `TRL` - Turkish Lira (1922–2005)
// * `TMT` - Turkmenistani Manat
// * `TMM` - Turkmenistani Manat (1993–2009)
// * `USD` - US Dollar
// * `USN` - US Dollar (Next day)
// * `USS` - US Dollar (Same day)
// * `UGX` - Ugandan Shilling
// * `UGS` - Ugandan Shilling (1966–1987)
// * `UAH` - Ukrainian Hryvnia
// * `UAK` - Ukrainian Karbovanets
// * `AED` - United Arab Emirates Dirham
// * `UYW` - Uruguayan Nominal Wage Index Unit
// * `UYU` - Uruguayan Peso
// * `UYP` - Uruguayan Peso (1975–1993)
// * `UYI` - Uruguayan Peso (Indexed Units)
// * `UZS` - Uzbekistani Som
// * `VUV` - Vanuatu Vatu
// * `VES` - Venezuelan Bolívar
// * `VEB` - Venezuelan Bolívar (1871–2008)
// * `VEF` - Venezuelan Bolívar (2008–2018)
// * `VND` - Vietnamese Dong
// * `VNN` - Vietnamese Dong (1978–1985)
// * `CHE` - WIR Euro
// * `CHW` - WIR Franc
// * `XOF` - West African CFA Franc
// * `YDD` - Yemeni Dinar
// * `YER` - Yemeni Rial
// * `YUN` - Yugoslavian Convertible Dinar (1990–1992)
// * `YUD` - Yugoslavian Hard Dinar (1966–1990)
// * `YUM` - Yugoslavian New Dinar (1994–2002)
// * `YUR` - Yugoslavian Reformed Dinar (1992–1993)
// * `ZWN` - ZWN
// * `ZRN` - Zairean New Zaire (1993–1998)
// * `ZRZ` - Zairean Zaire (1971–1993)
// * `ZMW` - Zambian Kwacha
// * `ZMK` - Zambian Kwacha (1968–2012)
// * `ZWD` - Zimbabwean Dollar (1980–2008)
// * `ZWR` - Zimbabwean Dollar (2008)
// * `ZWL` - Zimbabwean Dollar (2009)
type PaymentRequestCurrency struct {
	TransactionCurrencyEnum TransactionCurrencyEnum
	String                  string

	typ string
}

func (p *PaymentRequestCurrency) GetTransactionCurrencyEnum() TransactionCurrencyEnum {
	if p == nil {
		return ""
	}
	return p.TransactionCurrencyEnum
}

func (p *PaymentRequestCurrency) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestCurrency) UnmarshalJSON(data []byte) error {
	var valueTransactionCurrencyEnum TransactionCurrencyEnum
	if err := json.Unmarshal(data, &valueTransactionCurrencyEnum); err == nil {
		p.typ = "TransactionCurrencyEnum"
		p.TransactionCurrencyEnum = valueTransactionCurrencyEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestCurrency) MarshalJSON() ([]byte, error) {
	if p.typ == "TransactionCurrencyEnum" || p.TransactionCurrencyEnum != "" {
		return json.Marshal(p.TransactionCurrencyEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestCurrencyVisitor interface {
	VisitTransactionCurrencyEnum(TransactionCurrencyEnum) error
	VisitString(string) error
}

func (p *PaymentRequestCurrency) Accept(visitor PaymentRequestCurrencyVisitor) error {
	if p.typ == "TransactionCurrencyEnum" || p.TransactionCurrencyEnum != "" {
		return visitor.VisitTransactionCurrencyEnum(p.TransactionCurrencyEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The method which this payment was made by.
type PaymentRequestPaymentMethod struct {
	String        string
	PaymentMethod *PaymentMethod

	typ string
}

func (p *PaymentRequestPaymentMethod) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestPaymentMethod) GetPaymentMethod() *PaymentMethod {
	if p == nil {
		return nil
	}
	return p.PaymentMethod
}

func (p *PaymentRequestPaymentMethod) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valuePaymentMethod := new(PaymentMethod)
	if err := json.Unmarshal(data, &valuePaymentMethod); err == nil {
		p.typ = "PaymentMethod"
		p.PaymentMethod = valuePaymentMethod
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestPaymentMethod) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "PaymentMethod" || p.PaymentMethod != nil {
		return json.Marshal(p.PaymentMethod)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestPaymentMethodVisitor interface {
	VisitString(string) error
	VisitPaymentMethod(*PaymentMethod) error
}

func (p *PaymentRequestPaymentMethod) Accept(visitor PaymentRequestPaymentMethodVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "PaymentMethod" || p.PaymentMethod != nil {
		return visitor.VisitPaymentMethod(p.PaymentMethod)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestTrackingCategoriesItem struct {
	String           string
	TrackingCategory *TrackingCategory

	typ string
}

func (p *PaymentRequestTrackingCategoriesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestTrackingCategoriesItem) GetTrackingCategory() *TrackingCategory {
	if p == nil {
		return nil
	}
	return p.TrackingCategory
}

func (p *PaymentRequestTrackingCategoriesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueTrackingCategory := new(TrackingCategory)
	if err := json.Unmarshal(data, &valueTrackingCategory); err == nil {
		p.typ = "TrackingCategory"
		p.TrackingCategory = valueTrackingCategory
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestTrackingCategoriesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "TrackingCategory" || p.TrackingCategory != nil {
		return json.Marshal(p.TrackingCategory)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestTrackingCategoriesItemVisitor interface {
	VisitString(string) error
	VisitTrackingCategory(*TrackingCategory) error
}

func (p *PaymentRequestTrackingCategoriesItem) Accept(visitor PaymentRequestTrackingCategoriesItemVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "TrackingCategory" || p.TrackingCategory != nil {
		return visitor.VisitTrackingCategory(p.TrackingCategory)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The type of the invoice.
//
// * `ACCOUNTS_PAYABLE` - ACCOUNTS_PAYABLE
// * `ACCOUNTS_RECEIVABLE` - ACCOUNTS_RECEIVABLE
type PaymentRequestType struct {
	PaymentTypeEnum PaymentTypeEnum
	String          string

	typ string
}

func (p *PaymentRequestType) GetPaymentTypeEnum() PaymentTypeEnum {
	if p == nil {
		return ""
	}
	return p.PaymentTypeEnum
}

func (p *PaymentRequestType) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PaymentRequestType) UnmarshalJSON(data []byte) error {
	var valuePaymentTypeEnum PaymentTypeEnum
	if err := json.Unmarshal(data, &valuePaymentTypeEnum); err == nil {
		p.typ = "PaymentTypeEnum"
		p.PaymentTypeEnum = valuePaymentTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentRequestType) MarshalJSON() ([]byte, error) {
	if p.typ == "PaymentTypeEnum" || p.PaymentTypeEnum != "" {
		return json.Marshal(p.PaymentTypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentRequestTypeVisitor interface {
	VisitPaymentTypeEnum(PaymentTypeEnum) error
	VisitString(string) error
}

func (p *PaymentRequestType) Accept(visitor PaymentRequestTypeVisitor) error {
	if p.typ == "PaymentTypeEnum" || p.PaymentTypeEnum != "" {
		return visitor.VisitPaymentTypeEnum(p.PaymentTypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentResponse struct {
	Model    *Payment                    `json:"model" url:"model"`
	Warnings []*WarningValidationProblem `json:"warnings" url:"warnings"`
	Errors   []*ErrorValidationProblem   `json:"errors" url:"errors"`
	Logs     []*DebugModeLog             `json:"logs,omitempty" url:"logs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentResponse) GetModel() *Payment {
	if p == nil {
		return nil
	}
	return p.Model
}

func (p *PaymentResponse) GetWarnings() []*WarningValidationProblem {
	if p == nil {
		return nil
	}
	return p.Warnings
}

func (p *PaymentResponse) GetErrors() []*ErrorValidationProblem {
	if p == nil {
		return nil
	}
	return p.Errors
}

func (p *PaymentResponse) GetLogs() []*DebugModeLog {
	if p == nil {
		return nil
	}
	return p.Logs
}

func (p *PaymentResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
