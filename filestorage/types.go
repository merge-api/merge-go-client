// Code generated by Fern. DO NOT EDIT.

package filestorage

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type AccountIntegration struct {
	// Company name.
	Name string `json:"name" url:"name"`
	// Optional. This shortened name appears in places with limited space, usually in conjunction with the platform's logo (e.g., Merge Link menu).<br><br>Example: <i>Workforce Now (in lieu of ADP Workforce Now), SuccessFactors (in lieu of SAP SuccessFactors)</i>
	AbbreviatedName *string `json:"abbreviated_name,omitempty" url:"abbreviated_name,omitempty"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty" url:"categories,omitempty"`
	// Company logo in rectangular shape.
	Image *string `json:"image,omitempty" url:"image,omitempty"`
	// Company logo in square shape.
	SquareImage *string `json:"square_image,omitempty" url:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	Slug  *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]interface{} `json:"api_endpoints_to_documentation_urls,omitempty" url:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty" url:"webhook_setup_guide_url,omitempty"`
	// Category or categories this integration is in beta status for.
	CategoryBetaStatus map[string]interface{} `json:"category_beta_status,omitempty" url:"category_beta_status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountIntegration) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AccountIntegration) GetAbbreviatedName() *string {
	if a == nil {
		return nil
	}
	return a.AbbreviatedName
}

func (a *AccountIntegration) GetCategories() []CategoriesEnum {
	if a == nil {
		return nil
	}
	return a.Categories
}

func (a *AccountIntegration) GetImage() *string {
	if a == nil {
		return nil
	}
	return a.Image
}

func (a *AccountIntegration) GetSquareImage() *string {
	if a == nil {
		return nil
	}
	return a.SquareImage
}

func (a *AccountIntegration) GetColor() *string {
	if a == nil {
		return nil
	}
	return a.Color
}

func (a *AccountIntegration) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *AccountIntegration) GetApiEndpointsToDocumentationUrls() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.ApiEndpointsToDocumentationUrls
}

func (a *AccountIntegration) GetWebhookSetupGuideUrl() *string {
	if a == nil {
		return nil
	}
	return a.WebhookSetupGuideUrl
}

func (a *AccountIntegration) GetCategoryBetaStatus() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.CategoryBetaStatus
}

func (a *AccountIntegration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountIntegration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountIntegration) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoriesEnum string

const (
	CategoriesEnumHris        CategoriesEnum = "hris"
	CategoriesEnumAts         CategoriesEnum = "ats"
	CategoriesEnumAccounting  CategoriesEnum = "accounting"
	CategoriesEnumTicketing   CategoriesEnum = "ticketing"
	CategoriesEnumCrm         CategoriesEnum = "crm"
	CategoriesEnumMktg        CategoriesEnum = "mktg"
	CategoriesEnumFilestorage CategoriesEnum = "filestorage"
)

func NewCategoriesEnumFromString(s string) (CategoriesEnum, error) {
	switch s {
	case "hris":
		return CategoriesEnumHris, nil
	case "ats":
		return CategoriesEnumAts, nil
	case "accounting":
		return CategoriesEnumAccounting, nil
	case "ticketing":
		return CategoriesEnumTicketing, nil
	case "crm":
		return CategoriesEnumCrm, nil
	case "mktg":
		return CategoriesEnumMktg, nil
	case "filestorage":
		return CategoriesEnumFilestorage, nil
	}
	var t CategoriesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoriesEnum) Ptr() *CategoriesEnum {
	return &c
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoryEnum string

const (
	CategoryEnumHris        CategoryEnum = "hris"
	CategoryEnumAts         CategoryEnum = "ats"
	CategoryEnumAccounting  CategoryEnum = "accounting"
	CategoryEnumTicketing   CategoryEnum = "ticketing"
	CategoryEnumCrm         CategoryEnum = "crm"
	CategoryEnumMktg        CategoryEnum = "mktg"
	CategoryEnumFilestorage CategoryEnum = "filestorage"
)

func NewCategoryEnumFromString(s string) (CategoryEnum, error) {
	switch s {
	case "hris":
		return CategoryEnumHris, nil
	case "ats":
		return CategoryEnumAts, nil
	case "accounting":
		return CategoryEnumAccounting, nil
	case "ticketing":
		return CategoryEnumTicketing, nil
	case "crm":
		return CategoryEnumCrm, nil
	case "mktg":
		return CategoryEnumMktg, nil
	case "filestorage":
		return CategoryEnumFilestorage, nil
	}
	var t CategoryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryEnum) Ptr() *CategoryEnum {
	return &c
}

// # The DataPassthrough Object
// ### Description
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method" url:"method"`
	// The path of the request in the third party's platform.
	Path string `json:"path" url:"path"`
	// An optional override of the third party's base url for the request.
	BaseUrlOverride *string `json:"base_url_override,omitempty" url:"base_url_override,omitempty"`
	// The data with the request. You must include a `request_format` parameter matching the data's format
	Data *string `json:"data,omitempty" url:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty" url:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`
	RequestFormat *RequestFormatEnum     `json:"request_format,omitempty" url:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty" url:"normalize_response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DataPassthroughRequest) GetMethod() MethodEnum {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DataPassthroughRequest) GetPath() string {
	if d == nil {
		return ""
	}
	return d.Path
}

func (d *DataPassthroughRequest) GetBaseUrlOverride() *string {
	if d == nil {
		return nil
	}
	return d.BaseUrlOverride
}

func (d *DataPassthroughRequest) GetData() *string {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DataPassthroughRequest) GetMultipartFormData() []*MultipartFormFieldRequest {
	if d == nil {
		return nil
	}
	return d.MultipartFormData
}

func (d *DataPassthroughRequest) GetHeaders() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DataPassthroughRequest) GetRequestFormat() *RequestFormatEnum {
	if d == nil {
		return nil
	}
	return d.RequestFormat
}

func (d *DataPassthroughRequest) GetNormalizeResponse() *bool {
	if d == nil {
		return nil
	}
	return d.NormalizeResponse
}

func (d *DataPassthroughRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DataPassthroughRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DataPassthroughRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataPassthroughRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataPassthroughRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModeLog struct {
	LogId         string                `json:"log_id" url:"log_id"`
	DashboardView string                `json:"dashboard_view" url:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary" url:"log_summary"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModeLog) GetLogId() string {
	if d == nil {
		return ""
	}
	return d.LogId
}

func (d *DebugModeLog) GetDashboardView() string {
	if d == nil {
		return ""
	}
	return d.DashboardView
}

func (d *DebugModeLog) GetLogSummary() *DebugModelLogSummary {
	if d == nil {
		return nil
	}
	return d.LogSummary
}

func (d *DebugModeLog) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModeLog) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModeLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModeLog(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModeLog) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModelLogSummary struct {
	Url        string `json:"url" url:"url"`
	Method     string `json:"method" url:"method"`
	StatusCode int    `json:"status_code" url:"status_code"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModelLogSummary) GetUrl() string {
	if d == nil {
		return ""
	}
	return d.Url
}

func (d *DebugModelLogSummary) GetMethod() string {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DebugModelLogSummary) GetStatusCode() int {
	if d == nil {
		return 0
	}
	return d.StatusCode
}

func (d *DebugModelLogSummary) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModelLogSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModelLogSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModelLogSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModelLogSummary) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The Drive Object
// ### Description
// The `Drive` object is used to represent a drive that contains the folders and files in the user's workspace.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/drives` endpoint and view their drives.
type Drive struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The drive's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// When the third party's drive was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// The drive's url.
	DriveUrl *string `json:"drive_url,omitempty" url:"drive_url,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Drive) GetId() *string {
	if d == nil {
		return nil
	}
	return d.Id
}

func (d *Drive) GetRemoteId() *string {
	if d == nil {
		return nil
	}
	return d.RemoteId
}

func (d *Drive) GetCreatedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *Drive) GetModifiedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.ModifiedAt
}

func (d *Drive) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *Drive) GetRemoteCreatedAt() *time.Time {
	if d == nil {
		return nil
	}
	return d.RemoteCreatedAt
}

func (d *Drive) GetDriveUrl() *string {
	if d == nil {
		return nil
	}
	return d.DriveUrl
}

func (d *Drive) GetRemoteWasDeleted() *bool {
	if d == nil {
		return nil
	}
	return d.RemoteWasDeleted
}

func (d *Drive) GetFieldMappings() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.FieldMappings
}

func (d *Drive) GetRemoteData() []*RemoteData {
	if d == nil {
		return nil
	}
	return d.RemoteData
}

func (d *Drive) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Drive) UnmarshalJSON(data []byte) error {
	type embed Drive
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Drive(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	d.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	d.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Drive) MarshalJSON() ([]byte, error) {
	type embed Drive
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
	}{
		embed:           embed(*d),
		CreatedAt:       internal.NewOptionalDateTime(d.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(d.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(d.RemoteCreatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *Drive) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum string

const (
	EncodingEnumRaw        EncodingEnum = "RAW"
	EncodingEnumBase64     EncodingEnum = "BASE64"
	EncodingEnumGzipBase64 EncodingEnum = "GZIP_BASE64"
)

func NewEncodingEnumFromString(s string) (EncodingEnum, error) {
	switch s {
	case "RAW":
		return EncodingEnumRaw, nil
	case "BASE64":
		return EncodingEnumBase64, nil
	case "GZIP_BASE64":
		return EncodingEnumGzipBase64, nil
	}
	var t EncodingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncodingEnum) Ptr() *EncodingEnum {
	return &e
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorValidationProblem) GetSource() *ValidationProblemSource {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *ErrorValidationProblem) GetTitle() string {
	if e == nil {
		return ""
	}
	return e.Title
}

func (e *ErrorValidationProblem) GetDetail() string {
	if e == nil {
		return ""
	}
	return e.Detail
}

func (e *ErrorValidationProblem) GetProblemType() string {
	if e == nil {
		return ""
	}
	return e.ProblemType
}

func (e *ErrorValidationProblem) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorValidationProblem) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FieldPermissionDeserializerRequest struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty" url:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty" url:"disabled_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FieldPermissionDeserializerRequest) GetEnabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.EnabledFields
}

func (f *FieldPermissionDeserializerRequest) GetDisabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.DisabledFields
}

func (f *FieldPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializerRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// # The Folder Object
// ### Description
// The `Folder` object is used to represent a collection of files and/or folders in the workspace. Could be within a drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/folders` endpoint and view their folders.
type Folder struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The folder's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL to access the folder.
	FolderUrl *string `json:"folder_url,omitempty" url:"folder_url,omitempty"`
	// The folder's size, in bytes.
	Size *int64 `json:"size,omitempty" url:"size,omitempty"`
	// The folder's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The folder that the folder belongs to.
	ParentFolder *FolderParentFolder `json:"parent_folder,omitempty" url:"parent_folder,omitempty"`
	// The drive that the folder belongs to.
	Drive *FolderDrive `json:"drive,omitempty" url:"drive,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
	Permissions *FolderPermissions `json:"permissions,omitempty" url:"permissions,omitempty"`
	// When the third party's folder was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's folder was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Folder) GetId() *string {
	if f == nil {
		return nil
	}
	return f.Id
}

func (f *Folder) GetRemoteId() *string {
	if f == nil {
		return nil
	}
	return f.RemoteId
}

func (f *Folder) GetCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedAt
}

func (f *Folder) GetModifiedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.ModifiedAt
}

func (f *Folder) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *Folder) GetFolderUrl() *string {
	if f == nil {
		return nil
	}
	return f.FolderUrl
}

func (f *Folder) GetSize() *int64 {
	if f == nil {
		return nil
	}
	return f.Size
}

func (f *Folder) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *Folder) GetParentFolder() *FolderParentFolder {
	if f == nil {
		return nil
	}
	return f.ParentFolder
}

func (f *Folder) GetDrive() *FolderDrive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *Folder) GetPermissions() *FolderPermissions {
	if f == nil {
		return nil
	}
	return f.Permissions
}

func (f *Folder) GetRemoteCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.RemoteCreatedAt
}

func (f *Folder) GetRemoteUpdatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.RemoteUpdatedAt
}

func (f *Folder) GetRemoteWasDeleted() *bool {
	if f == nil {
		return nil
	}
	return f.RemoteWasDeleted
}

func (f *Folder) GetFieldMappings() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.FieldMappings
}

func (f *Folder) GetRemoteData() []*RemoteData {
	if f == nil {
		return nil
	}
	return f.RemoteData
}

func (f *Folder) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Folder) UnmarshalJSON(data []byte) error {
	type embed Folder
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = Folder(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	f.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	f.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	f.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Folder) MarshalJSON() ([]byte, error) {
	type embed Folder
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*f),
		CreatedAt:       internal.NewOptionalDateTime(f.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(f.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(f.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(f.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (f *Folder) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the folder belongs to.
type FolderDrive struct {
	String string
	Drive  *Drive

	typ string
}

func (f *FolderDrive) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FolderDrive) GetDrive() *Drive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *FolderDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typ = "Drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderDrive) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return json.Marshal(f.Drive)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FolderDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FolderDrive) Accept(visitor FolderDriveVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return visitor.VisitDrive(f.Drive)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The folder that the folder belongs to.
type FolderParentFolder struct {
	String string
	Folder *Folder

	typ string
}

func (f *FolderParentFolder) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FolderParentFolder) GetFolder() *Folder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *FolderParentFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typ = "Folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderParentFolder) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return json.Marshal(f.Folder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FolderParentFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FolderParentFolder) Accept(visitor FolderParentFolderVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return visitor.VisitFolder(f.Folder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
type FolderPermissions struct {
	String                    string
	Permission                *Permission
	FolderPermissionsItemList []*FolderPermissionsItem

	typ string
}

func (f *FolderPermissions) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FolderPermissions) GetPermission() *Permission {
	if f == nil {
		return nil
	}
	return f.Permission
}

func (f *FolderPermissions) GetFolderPermissionsItemList() []*FolderPermissionsItem {
	if f == nil {
		return nil
	}
	return f.FolderPermissionsItemList
}

func (f *FolderPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermission := new(Permission)
	if err := json.Unmarshal(data, &valuePermission); err == nil {
		f.typ = "Permission"
		f.Permission = valuePermission
		return nil
	}
	var valueFolderPermissionsItemList []*FolderPermissionsItem
	if err := json.Unmarshal(data, &valueFolderPermissionsItemList); err == nil {
		f.typ = "FolderPermissionsItemList"
		f.FolderPermissionsItemList = valueFolderPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderPermissions) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return json.Marshal(f.Permission)
	}
	if f.typ == "FolderPermissionsItemList" || f.FolderPermissionsItemList != nil {
		return json.Marshal(f.FolderPermissionsItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FolderPermissionsVisitor interface {
	VisitString(string) error
	VisitPermission(*Permission) error
	VisitFolderPermissionsItemList([]*FolderPermissionsItem) error
}

func (f *FolderPermissions) Accept(visitor FolderPermissionsVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return visitor.VisitPermission(f.Permission)
	}
	if f.typ == "FolderPermissionsItemList" || f.FolderPermissionsItemList != nil {
		return visitor.VisitFolderPermissionsItemList(f.FolderPermissionsItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FolderPermissionsItem struct {
	String     string
	Permission *Permission

	typ string
}

func (f *FolderPermissionsItem) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FolderPermissionsItem) GetPermission() *Permission {
	if f == nil {
		return nil
	}
	return f.Permission
}

func (f *FolderPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermission := new(Permission)
	if err := json.Unmarshal(data, &valuePermission); err == nil {
		f.typ = "Permission"
		f.Permission = valuePermission
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderPermissionsItem) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return json.Marshal(f.Permission)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FolderPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermission(*Permission) error
}

func (f *FolderPermissionsItem) Accept(visitor FolderPermissionsItemVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return visitor.VisitPermission(f.Permission)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// # The Group Object
// ### Description
// The `Group` object is used to represent any subset of `Users`. This can extend to company domains as well.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/groups` endpoint and view their groups.
type Group struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The group's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The users that belong in the group. If null, this typically means it's either a domain or the third-party platform does not surface this information.
	Users []string `json:"users" url:"users"`
	// Groups that inherit the permissions of the parent group.
	ChildGroups []*GroupChildGroupsItem `json:"child_groups,omitempty" url:"child_groups,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *Group) GetId() *string {
	if g == nil {
		return nil
	}
	return g.Id
}

func (g *Group) GetRemoteId() *string {
	if g == nil {
		return nil
	}
	return g.RemoteId
}

func (g *Group) GetCreatedAt() *time.Time {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *Group) GetModifiedAt() *time.Time {
	if g == nil {
		return nil
	}
	return g.ModifiedAt
}

func (g *Group) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *Group) GetUsers() []string {
	if g == nil {
		return nil
	}
	return g.Users
}

func (g *Group) GetChildGroups() []*GroupChildGroupsItem {
	if g == nil {
		return nil
	}
	return g.ChildGroups
}

func (g *Group) GetRemoteWasDeleted() *bool {
	if g == nil {
		return nil
	}
	return g.RemoteWasDeleted
}

func (g *Group) GetFieldMappings() map[string]interface{} {
	if g == nil {
		return nil
	}
	return g.FieldMappings
}

func (g *Group) GetRemoteData() []*RemoteData {
	if g == nil {
		return nil
	}
	return g.RemoteData
}

func (g *Group) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Group) UnmarshalJSON(data []byte) error {
	type embed Group
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = Group(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	g.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *Group) MarshalJSON() ([]byte, error) {
	type embed Group
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*g),
		CreatedAt:  internal.NewOptionalDateTime(g.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(g.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (g *Group) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupChildGroupsItem struct {
	String string
	Group  *Group

	typ string
}

func (g *GroupChildGroupsItem) GetString() string {
	if g == nil {
		return ""
	}
	return g.String
}

func (g *GroupChildGroupsItem) GetGroup() *Group {
	if g == nil {
		return nil
	}
	return g.Group
}

func (g *GroupChildGroupsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typ = "String"
		g.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		g.typ = "Group"
		g.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroupChildGroupsItem) MarshalJSON() ([]byte, error) {
	if g.typ == "String" || g.String != "" {
		return json.Marshal(g.String)
	}
	if g.typ == "Group" || g.Group != nil {
		return json.Marshal(g.Group)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroupChildGroupsItemVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (g *GroupChildGroupsItem) Accept(visitor GroupChildGroupsItemVisitor) error {
	if g.typ == "String" || g.String != "" {
		return visitor.VisitString(g.String)
	}
	if g.typ == "Group" || g.Group != nil {
		return visitor.VisitGroup(g.Group)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type IndividualCommonModelScopeDeserializerRequest struct {
	ModelName        string                                         `json:"model_name" url:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializerRequest `json:"model_permissions,omitempty" url:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializerRequest            `json:"field_permissions,omitempty" url:"field_permissions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelName() string {
	if i == nil {
		return ""
	}
	return i.ModelName
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelPermissions() map[string]*ModelPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.ModelPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetFieldPermissions() *FieldPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.FieldPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualCommonModelScopeDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializerRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type LastSyncResultEnum string

const (
	LastSyncResultEnumSyncing         LastSyncResultEnum = "SYNCING"
	LastSyncResultEnumDone            LastSyncResultEnum = "DONE"
	LastSyncResultEnumFailed          LastSyncResultEnum = "FAILED"
	LastSyncResultEnumDisabled        LastSyncResultEnum = "DISABLED"
	LastSyncResultEnumPaused          LastSyncResultEnum = "PAUSED"
	LastSyncResultEnumPartiallySynced LastSyncResultEnum = "PARTIALLY_SYNCED"
)

func NewLastSyncResultEnumFromString(s string) (LastSyncResultEnum, error) {
	switch s {
	case "SYNCING":
		return LastSyncResultEnumSyncing, nil
	case "DONE":
		return LastSyncResultEnumDone, nil
	case "FAILED":
		return LastSyncResultEnumFailed, nil
	case "DISABLED":
		return LastSyncResultEnumDisabled, nil
	case "PAUSED":
		return LastSyncResultEnumPaused, nil
	case "PARTIALLY_SYNCED":
		return LastSyncResultEnumPartiallySynced, nil
	}
	var t LastSyncResultEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LastSyncResultEnum) Ptr() *LastSyncResultEnum {
	return &l
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status" url:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request" url:"can_make_request"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LinkedAccountStatus) GetLinkedAccountStatus() string {
	if l == nil {
		return ""
	}
	return l.LinkedAccountStatus
}

func (l *LinkedAccountStatus) GetCanMakeRequest() bool {
	if l == nil {
		return false
	}
	return l.CanMakeRequest
}

func (l *LinkedAccountStatus) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkedAccountStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedAccountStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedAccountStatus(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedAccountStatus) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MetaResponse struct {
	RequestSchema                  map[string]interface{} `json:"request_schema" url:"request_schema"`
	RemoteFieldClasses             map[string]interface{} `json:"remote_field_classes,omitempty" url:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus   `json:"status,omitempty" url:"status,omitempty"`
	HasConditionalParams           bool                   `json:"has_conditional_params" url:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                   `json:"has_required_linked_account_params" url:"has_required_linked_account_params"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetaResponse) GetRequestSchema() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RequestSchema
}

func (m *MetaResponse) GetRemoteFieldClasses() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RemoteFieldClasses
}

func (m *MetaResponse) GetStatus() *LinkedAccountStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

func (m *MetaResponse) GetHasConditionalParams() bool {
	if m == nil {
		return false
	}
	return m.HasConditionalParams
}

func (m *MetaResponse) GetHasRequiredLinkedAccountParams() bool {
	if m == nil {
		return false
	}
	return m.HasRequiredLinkedAccountParams
}

func (m *MetaResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetaResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// * `GET` - GET
// * `OPTIONS` - OPTIONS
// * `HEAD` - HEAD
// * `POST` - POST
// * `PUT` - PUT
// * `PATCH` - PATCH
// * `DELETE` - DELETE
type MethodEnum string

const (
	MethodEnumGet     MethodEnum = "GET"
	MethodEnumOptions MethodEnum = "OPTIONS"
	MethodEnumHead    MethodEnum = "HEAD"
	MethodEnumPost    MethodEnum = "POST"
	MethodEnumPut     MethodEnum = "PUT"
	MethodEnumPatch   MethodEnum = "PATCH"
	MethodEnumDelete  MethodEnum = "DELETE"
)

func NewMethodEnumFromString(s string) (MethodEnum, error) {
	switch s {
	case "GET":
		return MethodEnumGet, nil
	case "OPTIONS":
		return MethodEnumOptions, nil
	case "HEAD":
		return MethodEnumHead, nil
	case "POST":
		return MethodEnumPost, nil
	case "PUT":
		return MethodEnumPut, nil
	case "PATCH":
		return MethodEnumPatch, nil
	case "DELETE":
		return MethodEnumDelete, nil
	}
	var t MethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodEnum) Ptr() *MethodEnum {
	return &m
}

// # The ModelOperation Object
// ### Description
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name" url:"model_name"`
	AvailableOperations    []string `json:"available_operations" url:"available_operations"`
	RequiredPostParameters []string `json:"required_post_parameters" url:"required_post_parameters"`
	SupportedFields        []string `json:"supported_fields" url:"supported_fields"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelOperation) GetModelName() string {
	if m == nil {
		return ""
	}
	return m.ModelName
}

func (m *ModelOperation) GetAvailableOperations() []string {
	if m == nil {
		return nil
	}
	return m.AvailableOperations
}

func (m *ModelOperation) GetRequiredPostParameters() []string {
	if m == nil {
		return nil
	}
	return m.RequiredPostParameters
}

func (m *ModelOperation) GetSupportedFields() []string {
	if m == nil {
		return nil
	}
	return m.SupportedFields
}

func (m *ModelOperation) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelOperation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelOperation) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializerRequest struct {
	IsEnabled *bool `json:"is_enabled,omitempty" url:"is_enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelPermissionDeserializerRequest) GetIsEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.IsEnabled
}

func (m *ModelPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializerRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The MultipartFormField Object
// ### Description
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name" url:"name"`
	// The data for the form field.
	Data string `json:"data" url:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// * `RAW` - RAW
	// * `BASE64` - BASE64
	// * `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty" url:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MultipartFormFieldRequest) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MultipartFormFieldRequest) GetData() string {
	if m == nil {
		return ""
	}
	return m.Data
}

func (m *MultipartFormFieldRequest) GetEncoding() *MultipartFormFieldRequestEncoding {
	if m == nil {
		return nil
	}
	return m.Encoding
}

func (m *MultipartFormFieldRequest) GetFileName() *string {
	if m == nil {
		return nil
	}
	return m.FileName
}

func (m *MultipartFormFieldRequest) GetContentType() *string {
	if m == nil {
		return nil
	}
	return m.ContentType
}

func (m *MultipartFormFieldRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipartFormFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipartFormFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipartFormFieldRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipartFormFieldRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	EncodingEnum EncodingEnum
	String       string

	typ string
}

func (m *MultipartFormFieldRequestEncoding) GetEncodingEnum() EncodingEnum {
	if m == nil {
		return ""
	}
	return m.EncodingEnum
}

func (m *MultipartFormFieldRequestEncoding) GetString() string {
	if m == nil {
		return ""
	}
	return m.String
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typ = "EncodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typ = "String"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	if m.typ == "EncodingEnum" || m.EncodingEnum != "" {
		return json.Marshal(m.EncodingEnum)
	}
	if m.typ == "String" || m.String != "" {
		return json.Marshal(m.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	if m.typ == "EncodingEnum" || m.EncodingEnum != "" {
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	}
	if m.typ == "String" || m.String != "" {
		return visitor.VisitString(m.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

// # The Permission Object
// ### Description
// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default.
//
// ### Usage Example
// Fetch from the `GET Files` or `GET Folders` endpoint. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details.
type Permission struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The user that is granted this permission. This will only be populated if the type is `USER`.
	User *PermissionUser `json:"user,omitempty" url:"user,omitempty"`
	// The group that is granted this permission. This will only be populated if the type is `GROUP`.
	Group *PermissionGroup `json:"group,omitempty" url:"group,omitempty"`
	// Denotes what type of people have access to the file.
	//
	// * `USER` - USER
	// * `GROUP` - GROUP
	// * `COMPANY` - COMPANY
	// * `ANYONE` - ANYONE
	Type *PermissionType `json:"type,omitempty" url:"type,omitempty"`
	// The permissions that the user or group has for the File or Folder. It is possible for a user or group to have multiple roles, such as viewing & uploading. Possible values include: `READ`, `WRITE`, `OWNER`. In cases where there is no clear mapping, the original value passed through will be returned.
	Roles []*PermissionRolesItem `json:"roles,omitempty" url:"roles,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Permission) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *Permission) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *Permission) GetCreatedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *Permission) GetModifiedAt() *time.Time {
	if p == nil {
		return nil
	}
	return p.ModifiedAt
}

func (p *Permission) GetUser() *PermissionUser {
	if p == nil {
		return nil
	}
	return p.User
}

func (p *Permission) GetGroup() *PermissionGroup {
	if p == nil {
		return nil
	}
	return p.Group
}

func (p *Permission) GetType() *PermissionType {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *Permission) GetRoles() []*PermissionRolesItem {
	if p == nil {
		return nil
	}
	return p.Roles
}

func (p *Permission) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Permission) UnmarshalJSON(data []byte) error {
	type embed Permission
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Permission(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	p.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Permission) MarshalJSON() ([]byte, error) {
	type embed Permission
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*p),
		CreatedAt:  internal.NewOptionalDateTime(p.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(p.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (p *Permission) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The group that is granted this permission. This will only be populated if the type is `GROUP`.
type PermissionGroup struct {
	String string
	Group  *Group

	typ string
}

func (p *PermissionGroup) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PermissionGroup) GetGroup() *Group {
	if p == nil {
		return nil
	}
	return p.Group
}

func (p *PermissionGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		p.typ = "Group"
		p.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionGroup) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Group" || p.Group != nil {
		return json.Marshal(p.Group)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PermissionGroupVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (p *PermissionGroup) Accept(visitor PermissionGroupVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Group" || p.Group != nil {
		return visitor.VisitGroup(p.Group)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// # The Permission Object
// ### Description
// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default.
//
// ### Usage Example
// Fetch from the `GET Files` or `GET Folders` endpoint. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details.
type PermissionRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The user that is granted this permission. This will only be populated if the type is `USER`.
	User *PermissionRequestUser `json:"user,omitempty" url:"user,omitempty"`
	// The group that is granted this permission. This will only be populated if the type is `GROUP`.
	Group *PermissionRequestGroup `json:"group,omitempty" url:"group,omitempty"`
	// Denotes what type of people have access to the file.
	//
	// * `USER` - USER
	// * `GROUP` - GROUP
	// * `COMPANY` - COMPANY
	// * `ANYONE` - ANYONE
	Type *PermissionRequestType `json:"type,omitempty" url:"type,omitempty"`
	// The permissions that the user or group has for the File or Folder. It is possible for a user or group to have multiple roles, such as viewing & uploading. Possible values include: `READ`, `WRITE`, `OWNER`. In cases where there is no clear mapping, the original value passed through will be returned.
	Roles               []*PermissionRequestRolesItem `json:"roles,omitempty" url:"roles,omitempty"`
	IntegrationParams   map[string]interface{}        `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}        `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PermissionRequest) GetRemoteId() *string {
	if p == nil {
		return nil
	}
	return p.RemoteId
}

func (p *PermissionRequest) GetUser() *PermissionRequestUser {
	if p == nil {
		return nil
	}
	return p.User
}

func (p *PermissionRequest) GetGroup() *PermissionRequestGroup {
	if p == nil {
		return nil
	}
	return p.Group
}

func (p *PermissionRequest) GetType() *PermissionRequestType {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PermissionRequest) GetRoles() []*PermissionRequestRolesItem {
	if p == nil {
		return nil
	}
	return p.Roles
}

func (p *PermissionRequest) GetIntegrationParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.IntegrationParams
}

func (p *PermissionRequest) GetLinkedAccountParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.LinkedAccountParams
}

func (p *PermissionRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PermissionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PermissionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PermissionRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PermissionRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The group that is granted this permission. This will only be populated if the type is `GROUP`.
type PermissionRequestGroup struct {
	String string
	Group  *Group

	typ string
}

func (p *PermissionRequestGroup) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PermissionRequestGroup) GetGroup() *Group {
	if p == nil {
		return nil
	}
	return p.Group
}

func (p *PermissionRequestGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		p.typ = "Group"
		p.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestGroup) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "Group" || p.Group != nil {
		return json.Marshal(p.Group)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PermissionRequestGroupVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (p *PermissionRequestGroup) Accept(visitor PermissionRequestGroupVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "Group" || p.Group != nil {
		return visitor.VisitGroup(p.Group)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The permissions that the user or group has for the File or Folder.
//
// * `READ` - READ
// * `WRITE` - WRITE
// * `OWNER` - OWNER
type PermissionRequestRolesItem struct {
	RolesEnum RolesEnum
	String    string

	typ string
}

func (p *PermissionRequestRolesItem) GetRolesEnum() RolesEnum {
	if p == nil {
		return ""
	}
	return p.RolesEnum
}

func (p *PermissionRequestRolesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PermissionRequestRolesItem) UnmarshalJSON(data []byte) error {
	var valueRolesEnum RolesEnum
	if err := json.Unmarshal(data, &valueRolesEnum); err == nil {
		p.typ = "RolesEnum"
		p.RolesEnum = valueRolesEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestRolesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "RolesEnum" || p.RolesEnum != "" {
		return json.Marshal(p.RolesEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PermissionRequestRolesItemVisitor interface {
	VisitRolesEnum(RolesEnum) error
	VisitString(string) error
}

func (p *PermissionRequestRolesItem) Accept(visitor PermissionRequestRolesItemVisitor) error {
	if p.typ == "RolesEnum" || p.RolesEnum != "" {
		return visitor.VisitRolesEnum(p.RolesEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// Denotes what type of people have access to the file.
//
// * `USER` - USER
// * `GROUP` - GROUP
// * `COMPANY` - COMPANY
// * `ANYONE` - ANYONE
type PermissionRequestType struct {
	TypeEnum TypeEnum
	String   string

	typ string
}

func (p *PermissionRequestType) GetTypeEnum() TypeEnum {
	if p == nil {
		return ""
	}
	return p.TypeEnum
}

func (p *PermissionRequestType) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PermissionRequestType) UnmarshalJSON(data []byte) error {
	var valueTypeEnum TypeEnum
	if err := json.Unmarshal(data, &valueTypeEnum); err == nil {
		p.typ = "TypeEnum"
		p.TypeEnum = valueTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestType) MarshalJSON() ([]byte, error) {
	if p.typ == "TypeEnum" || p.TypeEnum != "" {
		return json.Marshal(p.TypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PermissionRequestTypeVisitor interface {
	VisitTypeEnum(TypeEnum) error
	VisitString(string) error
}

func (p *PermissionRequestType) Accept(visitor PermissionRequestTypeVisitor) error {
	if p.typ == "TypeEnum" || p.TypeEnum != "" {
		return visitor.VisitTypeEnum(p.TypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The user that is granted this permission. This will only be populated if the type is `USER`.
type PermissionRequestUser struct {
	String string
	User   *User

	typ string
}

func (p *PermissionRequestUser) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PermissionRequestUser) GetUser() *User {
	if p == nil {
		return nil
	}
	return p.User
}

func (p *PermissionRequestUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		p.typ = "User"
		p.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestUser) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "User" || p.User != nil {
		return json.Marshal(p.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PermissionRequestUserVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (p *PermissionRequestUser) Accept(visitor PermissionRequestUserVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "User" || p.User != nil {
		return visitor.VisitUser(p.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The permissions that the user or group has for the File or Folder.
//
// * `READ` - READ
// * `WRITE` - WRITE
// * `OWNER` - OWNER
type PermissionRolesItem struct {
	RolesEnum RolesEnum
	String    string

	typ string
}

func (p *PermissionRolesItem) GetRolesEnum() RolesEnum {
	if p == nil {
		return ""
	}
	return p.RolesEnum
}

func (p *PermissionRolesItem) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PermissionRolesItem) UnmarshalJSON(data []byte) error {
	var valueRolesEnum RolesEnum
	if err := json.Unmarshal(data, &valueRolesEnum); err == nil {
		p.typ = "RolesEnum"
		p.RolesEnum = valueRolesEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRolesItem) MarshalJSON() ([]byte, error) {
	if p.typ == "RolesEnum" || p.RolesEnum != "" {
		return json.Marshal(p.RolesEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PermissionRolesItemVisitor interface {
	VisitRolesEnum(RolesEnum) error
	VisitString(string) error
}

func (p *PermissionRolesItem) Accept(visitor PermissionRolesItemVisitor) error {
	if p.typ == "RolesEnum" || p.RolesEnum != "" {
		return visitor.VisitRolesEnum(p.RolesEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// Denotes what type of people have access to the file.
//
// * `USER` - USER
// * `GROUP` - GROUP
// * `COMPANY` - COMPANY
// * `ANYONE` - ANYONE
type PermissionType struct {
	TypeEnum TypeEnum
	String   string

	typ string
}

func (p *PermissionType) GetTypeEnum() TypeEnum {
	if p == nil {
		return ""
	}
	return p.TypeEnum
}

func (p *PermissionType) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PermissionType) UnmarshalJSON(data []byte) error {
	var valueTypeEnum TypeEnum
	if err := json.Unmarshal(data, &valueTypeEnum); err == nil {
		p.typ = "TypeEnum"
		p.TypeEnum = valueTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionType) MarshalJSON() ([]byte, error) {
	if p.typ == "TypeEnum" || p.TypeEnum != "" {
		return json.Marshal(p.TypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PermissionTypeVisitor interface {
	VisitTypeEnum(TypeEnum) error
	VisitString(string) error
}

func (p *PermissionType) Accept(visitor PermissionTypeVisitor) error {
	if p.typ == "TypeEnum" || p.TypeEnum != "" {
		return visitor.VisitTypeEnum(p.TypeEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// The user that is granted this permission. This will only be populated if the type is `USER`.
type PermissionUser struct {
	String string
	User   *User

	typ string
}

func (p *PermissionUser) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PermissionUser) GetUser() *User {
	if p == nil {
		return nil
	}
	return p.User
}

func (p *PermissionUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		p.typ = "User"
		p.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionUser) MarshalJSON() ([]byte, error) {
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	if p.typ == "User" || p.User != nil {
		return json.Marshal(p.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PermissionUserVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (p *PermissionUser) Accept(visitor PermissionUserVisitor) error {
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	if p.typ == "User" || p.User != nil {
		return visitor.VisitUser(p.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// # The RemoteData Object
// ### Description
// The `RemoteData` object is used to represent the full data pulled from the third-party API for an object.
//
// ### Usage Example
// TODO
type RemoteData struct {
	// The third-party API path that is being called.
	Path string      `json:"path" url:"path"`
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteData) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteData) GetData() interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RemoteData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteData) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteKey Object
// ### Description
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name" url:"name"`
	Key  string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteKey) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

func (r *RemoteKey) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *RemoteKey) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteKey) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteResponse Object
// ### Description
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                      `json:"method" url:"method"`
	Path            string                      `json:"path" url:"path"`
	Status          int                         `json:"status" url:"status"`
	Response        interface{}                 `json:"response" url:"response"`
	ResponseHeaders map[string]interface{}      `json:"response_headers,omitempty" url:"response_headers,omitempty"`
	ResponseType    *RemoteResponseResponseType `json:"response_type,omitempty" url:"response_type,omitempty"`
	Headers         map[string]interface{}      `json:"headers,omitempty" url:"headers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteResponse) GetMethod() string {
	if r == nil {
		return ""
	}
	return r.Method
}

func (r *RemoteResponse) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteResponse) GetStatus() int {
	if r == nil {
		return 0
	}
	return r.Status
}

func (r *RemoteResponse) GetResponse() interface{} {
	if r == nil {
		return nil
	}
	return r.Response
}

func (r *RemoteResponse) GetResponseHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.ResponseHeaders
}

func (r *RemoteResponse) GetResponseType() *RemoteResponseResponseType {
	if r == nil {
		return nil
	}
	return r.ResponseType
}

func (r *RemoteResponse) GetHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Headers
}

func (r *RemoteResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteResponseResponseType struct {
	ResponseTypeEnum ResponseTypeEnum
	String           string

	typ string
}

func (r *RemoteResponseResponseType) GetResponseTypeEnum() ResponseTypeEnum {
	if r == nil {
		return ""
	}
	return r.ResponseTypeEnum
}

func (r *RemoteResponseResponseType) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *RemoteResponseResponseType) UnmarshalJSON(data []byte) error {
	var valueResponseTypeEnum ResponseTypeEnum
	if err := json.Unmarshal(data, &valueResponseTypeEnum); err == nil {
		r.typ = "ResponseTypeEnum"
		r.ResponseTypeEnum = valueResponseTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteResponseResponseType) MarshalJSON() ([]byte, error) {
	if r.typ == "ResponseTypeEnum" || r.ResponseTypeEnum != "" {
		return json.Marshal(r.ResponseTypeEnum)
	}
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RemoteResponseResponseTypeVisitor interface {
	VisitResponseTypeEnum(ResponseTypeEnum) error
	VisitString(string) error
}

func (r *RemoteResponseResponseType) Accept(visitor RemoteResponseResponseTypeVisitor) error {
	if r.typ == "ResponseTypeEnum" || r.ResponseTypeEnum != "" {
		return visitor.VisitResponseTypeEnum(r.ResponseTypeEnum)
	}
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

// * `JSON` - JSON
// * `XML` - XML
// * `MULTIPART` - MULTIPART
type RequestFormatEnum string

const (
	RequestFormatEnumJson      RequestFormatEnum = "JSON"
	RequestFormatEnumXml       RequestFormatEnum = "XML"
	RequestFormatEnumMultipart RequestFormatEnum = "MULTIPART"
)

func NewRequestFormatEnumFromString(s string) (RequestFormatEnum, error) {
	switch s {
	case "JSON":
		return RequestFormatEnumJson, nil
	case "XML":
		return RequestFormatEnumXml, nil
	case "MULTIPART":
		return RequestFormatEnumMultipart, nil
	}
	var t RequestFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestFormatEnum) Ptr() *RequestFormatEnum {
	return &r
}

// * `JSON` - JSON
// * `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum string

const (
	ResponseTypeEnumJson       ResponseTypeEnum = "JSON"
	ResponseTypeEnumBase64Gzip ResponseTypeEnum = "BASE64_GZIP"
)

func NewResponseTypeEnumFromString(s string) (ResponseTypeEnum, error) {
	switch s {
	case "JSON":
		return ResponseTypeEnumJson, nil
	case "BASE64_GZIP":
		return ResponseTypeEnumBase64Gzip, nil
	}
	var t ResponseTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTypeEnum) Ptr() *ResponseTypeEnum {
	return &r
}

// * `READ` - READ
// * `WRITE` - WRITE
// * `OWNER` - OWNER
type RolesEnum string

const (
	RolesEnumRead  RolesEnum = "READ"
	RolesEnumWrite RolesEnum = "WRITE"
	RolesEnumOwner RolesEnum = "OWNER"
)

func NewRolesEnumFromString(s string) (RolesEnum, error) {
	switch s {
	case "READ":
		return RolesEnumRead, nil
	case "WRITE":
		return RolesEnumWrite, nil
	case "OWNER":
		return RolesEnumOwner, nil
	}
	var t RolesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RolesEnum) Ptr() *RolesEnum {
	return &r
}

// * `IN_NEXT_SYNC` - IN_NEXT_SYNC
// * `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum string

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = "IN_NEXT_SYNC"
	SelectiveSyncConfigurationsUsageEnumInLastSync SelectiveSyncConfigurationsUsageEnum = "IN_LAST_SYNC"
)

func NewSelectiveSyncConfigurationsUsageEnumFromString(s string) (SelectiveSyncConfigurationsUsageEnum, error) {
	switch s {
	case "IN_NEXT_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInNextSync, nil
	case "IN_LAST_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInLastSync, nil
	}
	var t SelectiveSyncConfigurationsUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SelectiveSyncConfigurationsUsageEnum) Ptr() *SelectiveSyncConfigurationsUsageEnum {
	return &s
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type StatusFd5Enum string

const (
	StatusFd5EnumSyncing         StatusFd5Enum = "SYNCING"
	StatusFd5EnumDone            StatusFd5Enum = "DONE"
	StatusFd5EnumFailed          StatusFd5Enum = "FAILED"
	StatusFd5EnumDisabled        StatusFd5Enum = "DISABLED"
	StatusFd5EnumPaused          StatusFd5Enum = "PAUSED"
	StatusFd5EnumPartiallySynced StatusFd5Enum = "PARTIALLY_SYNCED"
)

func NewStatusFd5EnumFromString(s string) (StatusFd5Enum, error) {
	switch s {
	case "SYNCING":
		return StatusFd5EnumSyncing, nil
	case "DONE":
		return StatusFd5EnumDone, nil
	case "FAILED":
		return StatusFd5EnumFailed, nil
	case "DISABLED":
		return StatusFd5EnumDisabled, nil
	case "PAUSED":
		return StatusFd5EnumPaused, nil
	case "PARTIALLY_SYNCED":
		return StatusFd5EnumPartiallySynced, nil
	}
	var t StatusFd5Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusFd5Enum) Ptr() *StatusFd5Enum {
	return &s
}

// # The SyncStatus Object
// ### Description
// The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name" url:"model_name"`
	ModelId                          string                                `json:"model_id" url:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty" url:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty" url:"next_sync_start,omitempty"`
	LastSyncResult                   *SyncStatusLastSyncResult             `json:"last_sync_result,omitempty" url:"last_sync_result,omitempty"`
	LastSyncFinished                 *time.Time                            `json:"last_sync_finished,omitempty" url:"last_sync_finished,omitempty"`
	Status                           *SyncStatusStatus                     `json:"status" url:"status"`
	IsInitialSync                    bool                                  `json:"is_initial_sync" url:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty" url:"selective_sync_configurations_usage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncStatus) GetModelName() string {
	if s == nil {
		return ""
	}
	return s.ModelName
}

func (s *SyncStatus) GetModelId() string {
	if s == nil {
		return ""
	}
	return s.ModelId
}

func (s *SyncStatus) GetLastSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncStart
}

func (s *SyncStatus) GetNextSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.NextSyncStart
}

func (s *SyncStatus) GetLastSyncResult() *SyncStatusLastSyncResult {
	if s == nil {
		return nil
	}
	return s.LastSyncResult
}

func (s *SyncStatus) GetLastSyncFinished() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncFinished
}

func (s *SyncStatus) GetStatus() *SyncStatusStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SyncStatus) GetIsInitialSync() bool {
	if s == nil {
		return false
	}
	return s.IsInitialSync
}

func (s *SyncStatus) GetSelectiveSyncConfigurationsUsage() *SelectiveSyncConfigurationsUsageEnum {
	if s == nil {
		return nil
	}
	return s.SelectiveSyncConfigurationsUsage
}

func (s *SyncStatus) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncStatus) UnmarshalJSON(data []byte) error {
	type embed SyncStatus
	var unmarshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SyncStatus(unmarshaler.embed)
	s.LastSyncStart = unmarshaler.LastSyncStart.TimePtr()
	s.NextSyncStart = unmarshaler.NextSyncStart.TimePtr()
	s.LastSyncFinished = unmarshaler.LastSyncFinished.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatus) MarshalJSON() ([]byte, error) {
	type embed SyncStatus
	var marshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed:            embed(*s),
		LastSyncStart:    internal.NewOptionalDateTime(s.LastSyncStart),
		NextSyncStart:    internal.NewOptionalDateTime(s.NextSyncStart),
		LastSyncFinished: internal.NewOptionalDateTime(s.LastSyncFinished),
	}
	return json.Marshal(marshaler)
}

func (s *SyncStatus) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncStatusLastSyncResult struct {
	LastSyncResultEnum LastSyncResultEnum
	String             string

	typ string
}

func (s *SyncStatusLastSyncResult) GetLastSyncResultEnum() LastSyncResultEnum {
	if s == nil {
		return ""
	}
	return s.LastSyncResultEnum
}

func (s *SyncStatusLastSyncResult) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SyncStatusLastSyncResult) UnmarshalJSON(data []byte) error {
	var valueLastSyncResultEnum LastSyncResultEnum
	if err := json.Unmarshal(data, &valueLastSyncResultEnum); err == nil {
		s.typ = "LastSyncResultEnum"
		s.LastSyncResultEnum = valueLastSyncResultEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SyncStatusLastSyncResult) MarshalJSON() ([]byte, error) {
	if s.typ == "LastSyncResultEnum" || s.LastSyncResultEnum != "" {
		return json.Marshal(s.LastSyncResultEnum)
	}
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SyncStatusLastSyncResultVisitor interface {
	VisitLastSyncResultEnum(LastSyncResultEnum) error
	VisitString(string) error
}

func (s *SyncStatusLastSyncResult) Accept(visitor SyncStatusLastSyncResultVisitor) error {
	if s.typ == "LastSyncResultEnum" || s.LastSyncResultEnum != "" {
		return visitor.VisitLastSyncResultEnum(s.LastSyncResultEnum)
	}
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SyncStatusStatus struct {
	StatusFd5Enum StatusFd5Enum
	String        string

	typ string
}

func (s *SyncStatusStatus) GetStatusFd5Enum() StatusFd5Enum {
	if s == nil {
		return ""
	}
	return s.StatusFd5Enum
}

func (s *SyncStatusStatus) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SyncStatusStatus) UnmarshalJSON(data []byte) error {
	var valueStatusFd5Enum StatusFd5Enum
	if err := json.Unmarshal(data, &valueStatusFd5Enum); err == nil {
		s.typ = "StatusFd5Enum"
		s.StatusFd5Enum = valueStatusFd5Enum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SyncStatusStatus) MarshalJSON() ([]byte, error) {
	if s.typ == "StatusFd5Enum" || s.StatusFd5Enum != "" {
		return json.Marshal(s.StatusFd5Enum)
	}
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SyncStatusStatusVisitor interface {
	VisitStatusFd5Enum(StatusFd5Enum) error
	VisitString(string) error
}

func (s *SyncStatusStatus) Accept(visitor SyncStatusStatusVisitor) error {
	if s.typ == "StatusFd5Enum" || s.StatusFd5Enum != "" {
		return visitor.VisitStatusFd5Enum(s.StatusFd5Enum)
	}
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// * `USER` - USER
// * `GROUP` - GROUP
// * `COMPANY` - COMPANY
// * `ANYONE` - ANYONE
type TypeEnum string

const (
	TypeEnumUser    TypeEnum = "USER"
	TypeEnumGroup   TypeEnum = "GROUP"
	TypeEnumCompany TypeEnum = "COMPANY"
	TypeEnumAnyone  TypeEnum = "ANYONE"
)

func NewTypeEnumFromString(s string) (TypeEnum, error) {
	switch s {
	case "USER":
		return TypeEnumUser, nil
	case "GROUP":
		return TypeEnumGroup, nil
	case "COMPANY":
		return TypeEnumCompany, nil
	case "ANYONE":
		return TypeEnumAnyone, nil
	}
	var t TypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TypeEnum) Ptr() *TypeEnum {
	return &t
}

// # The User Object
// ### Description
// The `User` object is used to represent a user within the File Storage account.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/users` endpoint and view their users.
type User struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The user's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The user's email address. This is typically used to identify a user across linked accounts.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// Whether the user is the one who linked this account.
	IsMe *bool `json:"is_me,omitempty" url:"is_me,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *User) GetId() *string {
	if u == nil {
		return nil
	}
	return u.Id
}

func (u *User) GetRemoteId() *string {
	if u == nil {
		return nil
	}
	return u.RemoteId
}

func (u *User) GetCreatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *User) GetModifiedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.ModifiedAt
}

func (u *User) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *User) GetEmailAddress() *string {
	if u == nil {
		return nil
	}
	return u.EmailAddress
}

func (u *User) GetIsMe() *bool {
	if u == nil {
		return nil
	}
	return u.IsMe
}

func (u *User) GetRemoteWasDeleted() *bool {
	if u == nil {
		return nil
	}
	return u.RemoteWasDeleted
}

func (u *User) GetFieldMappings() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.FieldMappings
}

func (u *User) GetRemoteData() []*RemoteData {
	if u == nil {
		return nil
	}
	return u.RemoteData
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type embed User
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = User(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	u.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*u),
		CreatedAt:  internal.NewOptionalDateTime(u.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(u.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (u *User) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer" url:"pointer"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValidationProblemSource) GetPointer() string {
	if v == nil {
		return ""
	}
	return v.Pointer
}

func (v *ValidationProblemSource) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationProblemSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationProblemSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationProblemSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationProblemSource) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WarningValidationProblem) GetSource() *ValidationProblemSource {
	if w == nil {
		return nil
	}
	return w.Source
}

func (w *WarningValidationProblem) GetTitle() string {
	if w == nil {
		return ""
	}
	return w.Title
}

func (w *WarningValidationProblem) GetDetail() string {
	if w == nil {
		return ""
	}
	return w.Detail
}

func (w *WarningValidationProblem) GetProblemType() string {
	if w == nil {
		return ""
	}
	return w.ProblemType
}

func (w *WarningValidationProblem) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WarningValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler WarningValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WarningValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WarningValidationProblem) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
