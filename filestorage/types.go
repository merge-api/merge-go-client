// This file was auto-generated by Fern from our API Definition.

package filestorage

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/merge-api/merge-go-client/core"
	time "time"
)

type AccountDetails struct {
	Id                      *string       `json:"id,omitempty"`
	Integration             *string       `json:"integration,omitempty"`
	IntegrationSlug         *string       `json:"integration_slug,omitempty"`
	Category                *CategoryEnum `json:"category,omitempty"`
	EndUserOriginId         *string       `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName *string       `json:"end_user_organization_name,omitempty"`
	EndUserEmailAddress     *string       `json:"end_user_email_address,omitempty"`
	Status                  *string       `json:"status,omitempty"`
	WebhookListenerUrl      *string       `json:"webhook_listener_url,omitempty"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool   `json:"is_duplicate,omitempty"`
	AccountType *string `json:"account_type,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetails(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The LinkedAccount Object
//
// ### Description
//
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
//
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                             `json:"id"`
	Category                *CategoryEnum                      `json:"category,omitempty"`
	Status                  AccountDetailsAndActionsStatusEnum `json:"status,omitempty"`
	StatusDetail            *string                            `json:"status_detail,omitempty"`
	EndUserOriginId         *string                            `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                             `json:"end_user_organization_name"`
	EndUserEmailAddress     string                             `json:"end_user_email_address"`
	// The tenant or domain the customer has provided access to.
	Subdomain          *string `json:"subdomain,omitempty"`
	WebhookListenerUrl string  `json:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty"`
	AccountType string                               `json:"account_type"`

	_rawJSON json.RawMessage
}

func (a *AccountDetailsAndActions) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetailsAndActions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetailsAndActions(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetailsAndActions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name"`
	Categories               []CategoriesEnum  `json:"categories,omitempty"`
	Image                    *string           `json:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty"`
	Color                    string            `json:"color"`
	Slug                     string            `json:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountDetailsAndActionsIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetailsAndActionsIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetailsAndActionsIntegration(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetailsAndActionsIntegration) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// - `COMPLETE` - COMPLETE
// - `INCOMPLETE` - INCOMPLETE
// - `RELINK_NEEDED` - RELINK_NEEDED
type AccountDetailsAndActionsStatusEnum string

const (
	AccountDetailsAndActionsStatusEnumComplete     AccountDetailsAndActionsStatusEnum = "COMPLETE"
	AccountDetailsAndActionsStatusEnumIncomplete   AccountDetailsAndActionsStatusEnum = "INCOMPLETE"
	AccountDetailsAndActionsStatusEnumRelinkNeeded AccountDetailsAndActionsStatusEnum = "RELINK_NEEDED"
)

func NewAccountDetailsAndActionsStatusEnumFromString(s string) (AccountDetailsAndActionsStatusEnum, error) {
	switch s {
	case "COMPLETE":
		return AccountDetailsAndActionsStatusEnumComplete, nil
	case "INCOMPLETE":
		return AccountDetailsAndActionsStatusEnumIncomplete, nil
	case "RELINK_NEEDED":
		return AccountDetailsAndActionsStatusEnumRelinkNeeded, nil
	}
	var t AccountDetailsAndActionsStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountDetailsAndActionsStatusEnum) Ptr() *AccountDetailsAndActionsStatusEnum {
	return &a
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty"`
	// Company logo in rectangular shape. <b>Upload an image with a clear background.</b>
	Image *string `json:"image,omitempty"`
	// Company logo in square shape. <b>Upload an image with a white background.</b>
	SquareImage *string `json:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]interface{} `json:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty"`
	// Category or categories this integration is in beta status for.
	CategoryBetaStatus map[string]interface{} `json:"category_beta_status,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountIntegration(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountIntegration) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountToken struct {
	AccountToken string              `json:"account_token"`
	Integration  *AccountIntegration `json:"integration,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AccountToken) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountToken(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountToken) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AdvancedMetadata struct {
	Id           string        `json:"id"`
	DisplayName  *string       `json:"display_name,omitempty"`
	Description  *string       `json:"description,omitempty"`
	IsRequired   *bool         `json:"is_required,omitempty"`
	IsCustom     *bool         `json:"is_custom,omitempty"`
	FieldChoices []interface{} `json:"field_choices,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AdvancedMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler AdvancedMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdvancedMetadata(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdvancedMetadata) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AsyncPassthroughReciept struct {
	AsyncPassthroughReceiptId string `json:"async_passthrough_receipt_id"`

	_rawJSON json.RawMessage
}

func (a *AsyncPassthroughReciept) UnmarshalJSON(data []byte) error {
	type unmarshaler AsyncPassthroughReciept
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AsyncPassthroughReciept(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AsyncPassthroughReciept) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuditLogEvent struct {
	Id *string `json:"id,omitempty"`
	// The User's full name at the time of this Event occurring.
	UserName *string `json:"user_name,omitempty"`
	// The User's email at the time of this Event occurring.
	UserEmail *string `json:"user_email,omitempty"`
	// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
	//
	// - `ADMIN` - ADMIN
	// - `DEVELOPER` - DEVELOPER
	// - `MEMBER` - MEMBER
	// - `API` - API
	// - `SYSTEM` - SYSTEM
	// - `MERGE_TEAM` - MERGE_TEAM
	Role      *AuditLogEventRole `json:"role,omitempty"`
	IpAddress string             `json:"ip_address"`
	// Designates the type of event that occurred.
	//
	// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
	// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
	// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
	// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
	// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
	// - `INVITED_USER` - INVITED_USER
	// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
	// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
	// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
	// - `CREATED_DESTINATION` - CREATED_DESTINATION
	// - `DELETED_DESTINATION` - DELETED_DESTINATION
	// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
	// - `CHANGED_SCOPES` - CHANGED_SCOPES
	// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
	// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
	// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
	// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
	// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
	// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
	// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
	// - `RESET_PASSWORD` - RESET_PASSWORD
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
	// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
	// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
	// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
	// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
	// - `MUTED_ISSUE` - MUTED_ISSUE
	// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
	// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
	// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
	// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
	EventType        *AuditLogEventEventType `json:"event_type,omitempty"`
	EventDescription string                  `json:"event_description"`
	CreatedAt        *time.Time              `json:"created_at,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AuditLogEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AuditLogEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuditLogEvent(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuditLogEvent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Designates the type of event that occurred.
//
// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
// - `MUTED_ISSUE` - MUTED_ISSUE
// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
type AuditLogEventEventType struct {
	typeName      string
	EventTypeEnum EventTypeEnum
	String        string
}

func NewAuditLogEventEventTypeFromEventTypeEnum(value EventTypeEnum) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "eventTypeEnum", EventTypeEnum: value}
}

func NewAuditLogEventEventTypeFromString(value string) *AuditLogEventEventType {
	return &AuditLogEventEventType{typeName: "string", String: value}
}

func (a *AuditLogEventEventType) UnmarshalJSON(data []byte) error {
	var valueEventTypeEnum EventTypeEnum
	if err := json.Unmarshal(data, &valueEventTypeEnum); err == nil {
		a.typeName = "eventTypeEnum"
		a.EventTypeEnum = valueEventTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventEventType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return json.Marshal(a.EventTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventEventTypeVisitor interface {
	VisitEventTypeEnum(EventTypeEnum) error
	VisitString(string) error
}

func (a *AuditLogEventEventType) Accept(visitor AuditLogEventEventTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "eventTypeEnum":
		return visitor.VisitEventTypeEnum(a.EventTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// Designates the role of the user (or SYSTEM/API if action not taken by a user) at the time of this Event occurring.
//
// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type AuditLogEventRole struct {
	typeName string
	RoleEnum RoleEnum
	String   string
}

func NewAuditLogEventRoleFromRoleEnum(value RoleEnum) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "roleEnum", RoleEnum: value}
}

func NewAuditLogEventRoleFromString(value string) *AuditLogEventRole {
	return &AuditLogEventRole{typeName: "string", String: value}
}

func (a *AuditLogEventRole) UnmarshalJSON(data []byte) error {
	var valueRoleEnum RoleEnum
	if err := json.Unmarshal(data, &valueRoleEnum); err == nil {
		a.typeName = "roleEnum"
		a.RoleEnum = valueRoleEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuditLogEventRole) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return json.Marshal(a.RoleEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AuditLogEventRoleVisitor interface {
	VisitRoleEnum(RoleEnum) error
	VisitString(string) error
}

func (a *AuditLogEventRole) Accept(visitor AuditLogEventRoleVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "roleEnum":
		return visitor.VisitRoleEnum(a.RoleEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The AvailableActions Object
//
// ### Description
//
// The `Activity` object is used to see all available model/operation combinations for an integration.
//
// ### Usage Example
//
// Fetch all the actions available for the `Zenefits` integration.
type AvailableActions struct {
	Integration              *AccountIntegration `json:"integration,omitempty"`
	PassthroughAvailable     bool                `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation   `json:"available_model_operations,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AvailableActions) UnmarshalJSON(data []byte) error {
	type unmarshaler AvailableActions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AvailableActions(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AvailableActions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoriesEnum string

const (
	CategoriesEnumHris        CategoriesEnum = "hris"
	CategoriesEnumAts         CategoriesEnum = "ats"
	CategoriesEnumAccounting  CategoriesEnum = "accounting"
	CategoriesEnumTicketing   CategoriesEnum = "ticketing"
	CategoriesEnumCrm         CategoriesEnum = "crm"
	CategoriesEnumMktg        CategoriesEnum = "mktg"
	CategoriesEnumFilestorage CategoriesEnum = "filestorage"
)

func NewCategoriesEnumFromString(s string) (CategoriesEnum, error) {
	switch s {
	case "hris":
		return CategoriesEnumHris, nil
	case "ats":
		return CategoriesEnumAts, nil
	case "accounting":
		return CategoriesEnumAccounting, nil
	case "ticketing":
		return CategoriesEnumTicketing, nil
	case "crm":
		return CategoriesEnumCrm, nil
	case "mktg":
		return CategoriesEnumMktg, nil
	case "filestorage":
		return CategoriesEnumFilestorage, nil
	}
	var t CategoriesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoriesEnum) Ptr() *CategoriesEnum {
	return &c
}

// - `hris` - hris
// - `ats` - ats
// - `accounting` - accounting
// - `ticketing` - ticketing
// - `crm` - crm
// - `mktg` - mktg
// - `filestorage` - filestorage
type CategoryEnum string

const (
	CategoryEnumHris        CategoryEnum = "hris"
	CategoryEnumAts         CategoryEnum = "ats"
	CategoryEnumAccounting  CategoryEnum = "accounting"
	CategoryEnumTicketing   CategoryEnum = "ticketing"
	CategoryEnumCrm         CategoryEnum = "crm"
	CategoryEnumMktg        CategoryEnum = "mktg"
	CategoryEnumFilestorage CategoryEnum = "filestorage"
)

func NewCategoryEnumFromString(s string) (CategoryEnum, error) {
	switch s {
	case "hris":
		return CategoryEnumHris, nil
	case "ats":
		return CategoryEnumAts, nil
	case "accounting":
		return CategoryEnumAccounting, nil
	case "ticketing":
		return CategoryEnumTicketing, nil
	case "crm":
		return CategoryEnumCrm, nil
	case "mktg":
		return CategoryEnumMktg, nil
	case "filestorage":
		return CategoryEnumFilestorage, nil
	}
	var t CategoryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryEnum) Ptr() *CategoryEnum {
	return &c
}

type CommonModelScopeApi struct {
	// The common models you want to update the scopes for
	CommonModels []*IndividualCommonModelScopeDeserializer `json:"common_models,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommonModelScopeApi) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonModelScopeApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonModelScopeApi(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonModelScopeApi) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommonModelScopesBodyRequest struct {
	ModelId        string               `json:"model_id"`
	EnabledActions []EnabledActionsEnum `json:"enabled_actions,omitempty"`
	DisabledFields []string             `json:"disabled_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommonModelScopesBodyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonModelScopesBodyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonModelScopesBodyRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonModelScopesBodyRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// # The DataPassthrough Object
//
// ### Description
//
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
//
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method,omitempty"`
	// The path of the request in the third party's platform.
	Path string `json:"path"`
	// An optional override of the third party's base url for the request.
	BaseUrlOverride *string `json:"base_url_override,omitempty"`
	// The data with the request. You must include a `request_format` parameter matching the data's format
	Data *string `json:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]interface{} `json:"headers,omitempty"`
	RequestFormat *RequestFormatEnum     `json:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DataPassthroughRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DataPassthroughRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataPassthroughRequest(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataPassthroughRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModeLog struct {
	LogId         string                `json:"log_id"`
	DashboardView string                `json:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DebugModeLog) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModeLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModeLog(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModeLog) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModelLogSummary struct {
	Url        string `json:"url"`
	Method     string `json:"method"`
	StatusCode int    `json:"status_code"`

	_rawJSON json.RawMessage
}

func (d *DebugModelLogSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModelLogSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModelLogSummary(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModelLogSummary) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The Drive Object
//
// ### Description
//
// The `Drive` object is used to represent a drive that contains the folders and files in the user's workspace.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/drives` endpoint and view their drives.
type Drive struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The drive's name.
	Name *string `json:"name,omitempty"`
	// When the third party's drive was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// The drive's url.
	DriveUrl *string `json:"drive_url,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool                    `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{}   `json:"field_mappings,omitempty"`
	RemoteData       []map[string]interface{} `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (d *Drive) UnmarshalJSON(data []byte) error {
	type unmarshaler Drive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Drive(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Drive) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// - `READ` - READ
// - `WRITE` - WRITE
type EnabledActionsEnum string

const (
	EnabledActionsEnumRead  EnabledActionsEnum = "READ"
	EnabledActionsEnumWrite EnabledActionsEnum = "WRITE"
)

func NewEnabledActionsEnumFromString(s string) (EnabledActionsEnum, error) {
	switch s {
	case "READ":
		return EnabledActionsEnumRead, nil
	case "WRITE":
		return EnabledActionsEnumWrite, nil
	}
	var t EnabledActionsEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EnabledActionsEnum) Ptr() *EnabledActionsEnum {
	return &e
}

// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum string

const (
	EncodingEnumRaw        EncodingEnum = "RAW"
	EncodingEnumBase64     EncodingEnum = "BASE64"
	EncodingEnumGzipBase64 EncodingEnum = "GZIP_BASE64"
)

func NewEncodingEnumFromString(s string) (EncodingEnum, error) {
	switch s {
	case "RAW":
		return EncodingEnumRaw, nil
	case "BASE64":
		return EncodingEnumBase64, nil
	case "GZIP_BASE64":
		return EncodingEnumGzipBase64, nil
	}
	var t EncodingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncodingEnum) Ptr() *EncodingEnum {
	return &e
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`

	_rawJSON json.RawMessage
}

func (e *ErrorValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorValidationProblem(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorValidationProblem) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// - `CREATED_REMOTE_PRODUCTION_API_KEY` - CREATED_REMOTE_PRODUCTION_API_KEY
// - `DELETED_REMOTE_PRODUCTION_API_KEY` - DELETED_REMOTE_PRODUCTION_API_KEY
// - `CREATED_TEST_API_KEY` - CREATED_TEST_API_KEY
// - `DELETED_TEST_API_KEY` - DELETED_TEST_API_KEY
// - `REGENERATED_PRODUCTION_API_KEY` - REGENERATED_PRODUCTION_API_KEY
// - `INVITED_USER` - INVITED_USER
// - `TWO_FACTOR_AUTH_ENABLED` - TWO_FACTOR_AUTH_ENABLED
// - `TWO_FACTOR_AUTH_DISABLED` - TWO_FACTOR_AUTH_DISABLED
// - `DELETED_LINKED_ACCOUNT` - DELETED_LINKED_ACCOUNT
// - `CREATED_DESTINATION` - CREATED_DESTINATION
// - `DELETED_DESTINATION` - DELETED_DESTINATION
// - `CHANGED_DESTINATION` - CHANGED_DESTINATION
// - `CHANGED_SCOPES` - CHANGED_SCOPES
// - `CHANGED_PERSONAL_INFORMATION` - CHANGED_PERSONAL_INFORMATION
// - `CHANGED_ORGANIZATION_SETTINGS` - CHANGED_ORGANIZATION_SETTINGS
// - `ENABLED_INTEGRATION` - ENABLED_INTEGRATION
// - `DISABLED_INTEGRATION` - DISABLED_INTEGRATION
// - `ENABLED_CATEGORY` - ENABLED_CATEGORY
// - `DISABLED_CATEGORY` - DISABLED_CATEGORY
// - `CHANGED_PASSWORD` - CHANGED_PASSWORD
// - `RESET_PASSWORD` - RESET_PASSWORD
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION` - DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION
// - `DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT` - DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT
// - `CREATED_INTEGRATION_WIDE_FIELD_MAPPING` - CREATED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CREATED_LINKED_ACCOUNT_FIELD_MAPPING` - CREATED_LINKED_ACCOUNT_FIELD_MAPPING
// - `CHANGED_INTEGRATION_WIDE_FIELD_MAPPING` - CHANGED_INTEGRATION_WIDE_FIELD_MAPPING
// - `CHANGED_LINKED_ACCOUNT_FIELD_MAPPING` - CHANGED_LINKED_ACCOUNT_FIELD_MAPPING
// - `DELETED_INTEGRATION_WIDE_FIELD_MAPPING` - DELETED_INTEGRATION_WIDE_FIELD_MAPPING
// - `DELETED_LINKED_ACCOUNT_FIELD_MAPPING` - DELETED_LINKED_ACCOUNT_FIELD_MAPPING
// - `FORCED_LINKED_ACCOUNT_RESYNC` - FORCED_LINKED_ACCOUNT_RESYNC
// - `MUTED_ISSUE` - MUTED_ISSUE
// - `GENERATED_MAGIC_LINK` - GENERATED_MAGIC_LINK
// - `ENABLED_MERGE_WEBHOOK` - ENABLED_MERGE_WEBHOOK
// - `DISABLED_MERGE_WEBHOOK` - DISABLED_MERGE_WEBHOOK
// - `MERGE_WEBHOOK_TARGET_CHANGED` - MERGE_WEBHOOK_TARGET_CHANGED
type EventTypeEnum string

const (
	EventTypeEnumCreatedRemoteProductionApiKey              EventTypeEnum = "CREATED_REMOTE_PRODUCTION_API_KEY"
	EventTypeEnumDeletedRemoteProductionApiKey              EventTypeEnum = "DELETED_REMOTE_PRODUCTION_API_KEY"
	EventTypeEnumCreatedTestApiKey                          EventTypeEnum = "CREATED_TEST_API_KEY"
	EventTypeEnumDeletedTestApiKey                          EventTypeEnum = "DELETED_TEST_API_KEY"
	EventTypeEnumRegeneratedProductionApiKey                EventTypeEnum = "REGENERATED_PRODUCTION_API_KEY"
	EventTypeEnumInvitedUser                                EventTypeEnum = "INVITED_USER"
	EventTypeEnumTwoFactorAuthEnabled                       EventTypeEnum = "TWO_FACTOR_AUTH_ENABLED"
	EventTypeEnumTwoFactorAuthDisabled                      EventTypeEnum = "TWO_FACTOR_AUTH_DISABLED"
	EventTypeEnumDeletedLinkedAccount                       EventTypeEnum = "DELETED_LINKED_ACCOUNT"
	EventTypeEnumCreatedDestination                         EventTypeEnum = "CREATED_DESTINATION"
	EventTypeEnumDeletedDestination                         EventTypeEnum = "DELETED_DESTINATION"
	EventTypeEnumChangedDestination                         EventTypeEnum = "CHANGED_DESTINATION"
	EventTypeEnumChangedScopes                              EventTypeEnum = "CHANGED_SCOPES"
	EventTypeEnumChangedPersonalInformation                 EventTypeEnum = "CHANGED_PERSONAL_INFORMATION"
	EventTypeEnumChangedOrganizationSettings                EventTypeEnum = "CHANGED_ORGANIZATION_SETTINGS"
	EventTypeEnumEnabledIntegration                         EventTypeEnum = "ENABLED_INTEGRATION"
	EventTypeEnumDisabledIntegration                        EventTypeEnum = "DISABLED_INTEGRATION"
	EventTypeEnumEnabledCategory                            EventTypeEnum = "ENABLED_CATEGORY"
	EventTypeEnumDisabledCategory                           EventTypeEnum = "DISABLED_CATEGORY"
	EventTypeEnumChangedPassword                            EventTypeEnum = "CHANGED_PASSWORD"
	EventTypeEnumResetPassword                              EventTypeEnum = "RESET_PASSWORD"
	EventTypeEnumEnabledRedactUnmappedDataForOrganization   EventTypeEnum = "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount  EventTypeEnum = "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	EventTypeEnumDisabledRedactUnmappedDataForOrganization  EventTypeEnum = "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION"
	EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount EventTypeEnum = "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT"
	EventTypeEnumCreatedIntegrationWideFieldMapping         EventTypeEnum = "CREATED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumCreatedLinkedAccountFieldMapping           EventTypeEnum = "CREATED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumChangedIntegrationWideFieldMapping         EventTypeEnum = "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumChangedLinkedAccountFieldMapping           EventTypeEnum = "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumDeletedIntegrationWideFieldMapping         EventTypeEnum = "DELETED_INTEGRATION_WIDE_FIELD_MAPPING"
	EventTypeEnumDeletedLinkedAccountFieldMapping           EventTypeEnum = "DELETED_LINKED_ACCOUNT_FIELD_MAPPING"
	EventTypeEnumForcedLinkedAccountResync                  EventTypeEnum = "FORCED_LINKED_ACCOUNT_RESYNC"
	EventTypeEnumMutedIssue                                 EventTypeEnum = "MUTED_ISSUE"
	EventTypeEnumGeneratedMagicLink                         EventTypeEnum = "GENERATED_MAGIC_LINK"
	EventTypeEnumEnabledMergeWebhook                        EventTypeEnum = "ENABLED_MERGE_WEBHOOK"
	EventTypeEnumDisabledMergeWebhook                       EventTypeEnum = "DISABLED_MERGE_WEBHOOK"
	EventTypeEnumMergeWebhookTargetChanged                  EventTypeEnum = "MERGE_WEBHOOK_TARGET_CHANGED"
)

func NewEventTypeEnumFromString(s string) (EventTypeEnum, error) {
	switch s {
	case "CREATED_REMOTE_PRODUCTION_API_KEY":
		return EventTypeEnumCreatedRemoteProductionApiKey, nil
	case "DELETED_REMOTE_PRODUCTION_API_KEY":
		return EventTypeEnumDeletedRemoteProductionApiKey, nil
	case "CREATED_TEST_API_KEY":
		return EventTypeEnumCreatedTestApiKey, nil
	case "DELETED_TEST_API_KEY":
		return EventTypeEnumDeletedTestApiKey, nil
	case "REGENERATED_PRODUCTION_API_KEY":
		return EventTypeEnumRegeneratedProductionApiKey, nil
	case "INVITED_USER":
		return EventTypeEnumInvitedUser, nil
	case "TWO_FACTOR_AUTH_ENABLED":
		return EventTypeEnumTwoFactorAuthEnabled, nil
	case "TWO_FACTOR_AUTH_DISABLED":
		return EventTypeEnumTwoFactorAuthDisabled, nil
	case "DELETED_LINKED_ACCOUNT":
		return EventTypeEnumDeletedLinkedAccount, nil
	case "CREATED_DESTINATION":
		return EventTypeEnumCreatedDestination, nil
	case "DELETED_DESTINATION":
		return EventTypeEnumDeletedDestination, nil
	case "CHANGED_DESTINATION":
		return EventTypeEnumChangedDestination, nil
	case "CHANGED_SCOPES":
		return EventTypeEnumChangedScopes, nil
	case "CHANGED_PERSONAL_INFORMATION":
		return EventTypeEnumChangedPersonalInformation, nil
	case "CHANGED_ORGANIZATION_SETTINGS":
		return EventTypeEnumChangedOrganizationSettings, nil
	case "ENABLED_INTEGRATION":
		return EventTypeEnumEnabledIntegration, nil
	case "DISABLED_INTEGRATION":
		return EventTypeEnumDisabledIntegration, nil
	case "ENABLED_CATEGORY":
		return EventTypeEnumEnabledCategory, nil
	case "DISABLED_CATEGORY":
		return EventTypeEnumDisabledCategory, nil
	case "CHANGED_PASSWORD":
		return EventTypeEnumChangedPassword, nil
	case "RESET_PASSWORD":
		return EventTypeEnumResetPassword, nil
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		return EventTypeEnumEnabledRedactUnmappedDataForOrganization, nil
	case "ENABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		return EventTypeEnumEnabledRedactUnmappedDataForLinkedAccount, nil
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_ORGANIZATION":
		return EventTypeEnumDisabledRedactUnmappedDataForOrganization, nil
	case "DISABLED_REDACT_UNMAPPED_DATA_FOR_LINKED_ACCOUNT":
		return EventTypeEnumDisabledRedactUnmappedDataForLinkedAccount, nil
	case "CREATED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumCreatedIntegrationWideFieldMapping, nil
	case "CREATED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumCreatedLinkedAccountFieldMapping, nil
	case "CHANGED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumChangedIntegrationWideFieldMapping, nil
	case "CHANGED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumChangedLinkedAccountFieldMapping, nil
	case "DELETED_INTEGRATION_WIDE_FIELD_MAPPING":
		return EventTypeEnumDeletedIntegrationWideFieldMapping, nil
	case "DELETED_LINKED_ACCOUNT_FIELD_MAPPING":
		return EventTypeEnumDeletedLinkedAccountFieldMapping, nil
	case "FORCED_LINKED_ACCOUNT_RESYNC":
		return EventTypeEnumForcedLinkedAccountResync, nil
	case "MUTED_ISSUE":
		return EventTypeEnumMutedIssue, nil
	case "GENERATED_MAGIC_LINK":
		return EventTypeEnumGeneratedMagicLink, nil
	case "ENABLED_MERGE_WEBHOOK":
		return EventTypeEnumEnabledMergeWebhook, nil
	case "DISABLED_MERGE_WEBHOOK":
		return EventTypeEnumDisabledMergeWebhook, nil
	case "MERGE_WEBHOOK_TARGET_CHANGED":
		return EventTypeEnumMergeWebhookTargetChanged, nil
	}
	var t EventTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventTypeEnum) Ptr() *EventTypeEnum {
	return &e
}

type ExternalTargetFieldApi struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	IsMapped    *string `json:"is_mapped,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExternalTargetFieldApi) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalTargetFieldApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalTargetFieldApi(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalTargetFieldApi) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalTargetFieldApiResponse struct {
	File   []*ExternalTargetFieldApi `json:"File,omitempty"`
	Folder []*ExternalTargetFieldApi `json:"Folder,omitempty"`
	Drive  []*ExternalTargetFieldApi `json:"Drive,omitempty"`
	Group  []*ExternalTargetFieldApi `json:"Group,omitempty"`
	User   []*ExternalTargetFieldApi `json:"User,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExternalTargetFieldApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalTargetFieldApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalTargetFieldApiResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalTargetFieldApiResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FieldMappingApiInstance struct {
	Id                *string                             `json:"id,omitempty"`
	IsIntegrationWide *bool                               `json:"is_integration_wide,omitempty"`
	TargetField       *FieldMappingApiInstanceTargetField `json:"target_field,omitempty"`
	RemoteField       *FieldMappingApiInstanceRemoteField `json:"remote_field,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstance) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstance(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstance) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceRemoteField struct {
	RemoteKeyName      string                                                `json:"remote_key_name"`
	Schema             map[string]interface{}                                `json:"schema,omitempty"`
	RemoteEndpointInfo *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo `json:"remote_endpoint_info,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceRemoteField) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceRemoteField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceRemoteField(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceRemoteField) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo struct {
	Method             *string  `json:"method,omitempty"`
	UrlPath            *string  `json:"url_path,omitempty"`
	FieldTraversalPath []string `json:"field_traversal_path,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceRemoteFieldRemoteEndpointInfo) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceResponse struct {
	File   []*FieldMappingApiInstance `json:"File,omitempty"`
	Folder []*FieldMappingApiInstance `json:"Folder,omitempty"`
	Drive  []*FieldMappingApiInstance `json:"Drive,omitempty"`
	Group  []*FieldMappingApiInstance `json:"Group,omitempty"`
	User   []*FieldMappingApiInstance `json:"User,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingApiInstanceTargetField struct {
	Name               string `json:"name"`
	Description        string `json:"description"`
	IsOrganizationWide bool   `json:"is_organization_wide"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingApiInstanceTargetField) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingApiInstanceTargetField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingApiInstanceTargetField(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingApiInstanceTargetField) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldMappingInstanceResponse struct {
	Model    *FieldMappingApiInstance    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldMappingInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldMappingInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldMappingInstanceResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldMappingInstanceResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldPermissionDeserializer struct {
	Enabled  []interface{} `json:"enabled,omitempty"`
	Disabled []interface{} `json:"disabled,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldPermissionDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializer(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializer) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldPermissionDeserializerRequest struct {
	Enabled  []interface{} `json:"enabled,omitempty"`
	Disabled []interface{} `json:"disabled,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FieldPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializerRequest(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializerRequest) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// # The File Object
//
// ### Description
//
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
type File struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The file's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *FileFolder `json:"folder,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FilePermissions `json:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive *FileDrive `json:"drive,omitempty"`
	// When the third party's file was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's file was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool                    `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{}   `json:"field_mappings,omitempty"`
	RemoteData       []map[string]interface{} `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (f *File) UnmarshalJSON(data []byte) error {
	type unmarshaler File
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = File(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *File) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the file belongs to.
type FileDrive struct {
	typeName string
	String   string
	Drive    *Drive
}

func NewFileDriveFromString(value string) *FileDrive {
	return &FileDrive{typeName: "string", String: value}
}

func NewFileDriveFromDrive(value *Drive) *FileDrive {
	return &FileDrive{typeName: "drive", Drive: value}
}

func (f *FileDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typeName = "drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileDrive) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "drive":
		return json.Marshal(f.Drive)
	}
}

type FileDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FileDrive) Accept(visitor FileDriveVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "drive":
		return visitor.VisitDrive(f.Drive)
	}
}

// The folder that the file belongs to.
type FileFolder struct {
	typeName string
	String   string
	Folder   *Folder
}

func NewFileFolderFromString(value string) *FileFolder {
	return &FileFolder{typeName: "string", String: value}
}

func NewFileFolderFromFolder(value *Folder) *FileFolder {
	return &FileFolder{typeName: "folder", Folder: value}
}

func (f *FileFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typeName = "folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileFolder) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "folder":
		return json.Marshal(f.Folder)
	}
}

type FileFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FileFolder) Accept(visitor FileFolderVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "folder":
		return visitor.VisitFolder(f.Folder)
	}
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FilePermissions struct {
	typeName                string
	String                  string
	PermissionRequest       *PermissionRequest
	FilePermissionsItemList []*FilePermissionsItem
}

func NewFilePermissionsFromString(value string) *FilePermissions {
	return &FilePermissions{typeName: "string", String: value}
}

func NewFilePermissionsFromPermissionRequest(value *PermissionRequest) *FilePermissions {
	return &FilePermissions{typeName: "permissionRequest", PermissionRequest: value}
}

func NewFilePermissionsFromFilePermissionsItemList(value []*FilePermissionsItem) *FilePermissions {
	return &FilePermissions{typeName: "filePermissionsItemList", FilePermissionsItemList: value}
}

func (f *FilePermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	var valueFilePermissionsItemList []*FilePermissionsItem
	if err := json.Unmarshal(data, &valueFilePermissionsItemList); err == nil {
		f.typeName = "filePermissionsItemList"
		f.FilePermissionsItemList = valueFilePermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	case "filePermissionsItemList":
		return json.Marshal(f.FilePermissionsItemList)
	}
}

type FilePermissionsVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
	VisitFilePermissionsItemList([]*FilePermissionsItem) error
}

func (f *FilePermissions) Accept(visitor FilePermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	case "filePermissionsItemList":
		return visitor.VisitFilePermissionsItemList(f.FilePermissionsItemList)
	}
}

type FilePermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFilePermissionsItemFromString(value string) *FilePermissionsItem {
	return &FilePermissionsItem{typeName: "string", String: value}
}

func NewFilePermissionsItemFromPermissionRequest(value *PermissionRequest) *FilePermissionsItem {
	return &FilePermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FilePermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FilePermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FilePermissionsItem) Accept(visitor FilePermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

// # The File Object
//
// ### Description
//
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
type FileRequest struct {
	// The file's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *FileRequestFolder `json:"folder,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FileRequestPermissions `json:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive               *FileRequestDrive      `json:"drive,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileRequest(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileRequest) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the file belongs to.
type FileRequestDrive struct {
	typeName string
	String   string
	Drive    *Drive
}

func NewFileRequestDriveFromString(value string) *FileRequestDrive {
	return &FileRequestDrive{typeName: "string", String: value}
}

func NewFileRequestDriveFromDrive(value *Drive) *FileRequestDrive {
	return &FileRequestDrive{typeName: "drive", Drive: value}
}

func (f *FileRequestDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typeName = "drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestDrive) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "drive":
		return json.Marshal(f.Drive)
	}
}

type FileRequestDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FileRequestDrive) Accept(visitor FileRequestDriveVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "drive":
		return visitor.VisitDrive(f.Drive)
	}
}

// The folder that the file belongs to.
type FileRequestFolder struct {
	typeName string
	String   string
	Folder   *Folder
}

func NewFileRequestFolderFromString(value string) *FileRequestFolder {
	return &FileRequestFolder{typeName: "string", String: value}
}

func NewFileRequestFolderFromFolder(value *Folder) *FileRequestFolder {
	return &FileRequestFolder{typeName: "folder", Folder: value}
}

func (f *FileRequestFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typeName = "folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestFolder) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "folder":
		return json.Marshal(f.Folder)
	}
}

type FileRequestFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FileRequestFolder) Accept(visitor FileRequestFolderVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "folder":
		return visitor.VisitFolder(f.Folder)
	}
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FileRequestPermissions struct {
	typeName                       string
	String                         string
	PermissionRequest              *PermissionRequest
	FileRequestPermissionsItemList []*FileRequestPermissionsItem
}

func NewFileRequestPermissionsFromString(value string) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "string", String: value}
}

func NewFileRequestPermissionsFromPermissionRequest(value *PermissionRequest) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "permissionRequest", PermissionRequest: value}
}

func NewFileRequestPermissionsFromFileRequestPermissionsItemList(value []*FileRequestPermissionsItem) *FileRequestPermissions {
	return &FileRequestPermissions{typeName: "fileRequestPermissionsItemList", FileRequestPermissionsItemList: value}
}

func (f *FileRequestPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	var valueFileRequestPermissionsItemList []*FileRequestPermissionsItem
	if err := json.Unmarshal(data, &valueFileRequestPermissionsItemList); err == nil {
		f.typeName = "fileRequestPermissionsItemList"
		f.FileRequestPermissionsItemList = valueFileRequestPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	case "fileRequestPermissionsItemList":
		return json.Marshal(f.FileRequestPermissionsItemList)
	}
}

type FileRequestPermissionsVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
	VisitFileRequestPermissionsItemList([]*FileRequestPermissionsItem) error
}

func (f *FileRequestPermissions) Accept(visitor FileRequestPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	case "fileRequestPermissionsItemList":
		return visitor.VisitFileRequestPermissionsItemList(f.FileRequestPermissionsItemList)
	}
}

type FileRequestPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFileRequestPermissionsItemFromString(value string) *FileRequestPermissionsItem {
	return &FileRequestPermissionsItem{typeName: "string", String: value}
}

func NewFileRequestPermissionsItemFromPermissionRequest(value *PermissionRequest) *FileRequestPermissionsItem {
	return &FileRequestPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FileRequestPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FileRequestPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FileRequestPermissionsItem) Accept(visitor FileRequestPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

type FileStorageFileResponse struct {
	Model    *File                       `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FileStorageFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileStorageFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileStorageFileResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileStorageFileResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileStorageFolderResponse struct {
	Model    *Folder                     `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FileStorageFolderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileStorageFolderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileStorageFolderResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileStorageFolderResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// # The Folder Object
//
// ### Description
//
// The `Folder` object is used to represent a collection of files and/or folders in the workspace. Could be within a drive, if it exists.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/folders` endpoint and view their folders.
type Folder struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The folder's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the folder.
	FolderUrl *string `json:"folder_url,omitempty"`
	// The folder's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The folder's description.
	Description *string `json:"description,omitempty"`
	// The folder that the folder belongs to.
	ParentFolder *FolderParentFolder `json:"parent_folder,omitempty"`
	// The drive that the folder belongs to.
	Drive *FolderDrive `json:"drive,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
	Permissions *FolderPermissions `json:"permissions,omitempty"`
	// When the third party's folder was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the third party's folder was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool                    `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{}   `json:"field_mappings,omitempty"`
	RemoteData       []map[string]interface{} `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (f *Folder) UnmarshalJSON(data []byte) error {
	type unmarshaler Folder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Folder(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *Folder) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the folder belongs to.
type FolderDrive struct {
	typeName string
	String   string
	Drive    *Drive
}

func NewFolderDriveFromString(value string) *FolderDrive {
	return &FolderDrive{typeName: "string", String: value}
}

func NewFolderDriveFromDrive(value *Drive) *FolderDrive {
	return &FolderDrive{typeName: "drive", Drive: value}
}

func (f *FolderDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typeName = "drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderDrive) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "drive":
		return json.Marshal(f.Drive)
	}
}

type FolderDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FolderDrive) Accept(visitor FolderDriveVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "drive":
		return visitor.VisitDrive(f.Drive)
	}
}

// The folder that the folder belongs to.
type FolderParentFolder struct {
	typeName string
	String   string
	Folder   *Folder
}

func NewFolderParentFolderFromString(value string) *FolderParentFolder {
	return &FolderParentFolder{typeName: "string", String: value}
}

func NewFolderParentFolderFromFolder(value *Folder) *FolderParentFolder {
	return &FolderParentFolder{typeName: "folder", Folder: value}
}

func (f *FolderParentFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typeName = "folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderParentFolder) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "folder":
		return json.Marshal(f.Folder)
	}
}

type FolderParentFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FolderParentFolder) Accept(visitor FolderParentFolderVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "folder":
		return visitor.VisitFolder(f.Folder)
	}
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
type FolderPermissions struct {
	typeName                  string
	String                    string
	PermissionRequest         *PermissionRequest
	FolderPermissionsItemList []*FolderPermissionsItem
}

func NewFolderPermissionsFromString(value string) *FolderPermissions {
	return &FolderPermissions{typeName: "string", String: value}
}

func NewFolderPermissionsFromPermissionRequest(value *PermissionRequest) *FolderPermissions {
	return &FolderPermissions{typeName: "permissionRequest", PermissionRequest: value}
}

func NewFolderPermissionsFromFolderPermissionsItemList(value []*FolderPermissionsItem) *FolderPermissions {
	return &FolderPermissions{typeName: "folderPermissionsItemList", FolderPermissionsItemList: value}
}

func (f *FolderPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	var valueFolderPermissionsItemList []*FolderPermissionsItem
	if err := json.Unmarshal(data, &valueFolderPermissionsItemList); err == nil {
		f.typeName = "folderPermissionsItemList"
		f.FolderPermissionsItemList = valueFolderPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	case "folderPermissionsItemList":
		return json.Marshal(f.FolderPermissionsItemList)
	}
}

type FolderPermissionsVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
	VisitFolderPermissionsItemList([]*FolderPermissionsItem) error
}

func (f *FolderPermissions) Accept(visitor FolderPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	case "folderPermissionsItemList":
		return visitor.VisitFolderPermissionsItemList(f.FolderPermissionsItemList)
	}
}

type FolderPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFolderPermissionsItemFromString(value string) *FolderPermissionsItem {
	return &FolderPermissionsItem{typeName: "string", String: value}
}

func NewFolderPermissionsItemFromPermissionRequest(value *PermissionRequest) *FolderPermissionsItem {
	return &FolderPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FolderPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FolderPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FolderPermissionsItem) Accept(visitor FolderPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

// # The Folder Object
//
// ### Description
//
// The `Folder` object is used to represent a collection of files and/or folders in the workspace. Could be within a drive, if it exists.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/folders` endpoint and view their folders.
type FolderRequest struct {
	// The folder's name.
	Name *string `json:"name,omitempty"`
	// The URL to access the folder.
	FolderUrl *string `json:"folder_url,omitempty"`
	// The folder's size, in bytes.
	Size *int `json:"size,omitempty"`
	// The folder's description.
	Description *string `json:"description,omitempty"`
	// The folder that the folder belongs to.
	ParentFolder *FolderRequestParentFolder `json:"parent_folder,omitempty"`
	// The drive that the folder belongs to.
	Drive *FolderRequestDrive `json:"drive,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
	Permissions         *FolderRequestPermissions `json:"permissions,omitempty"`
	IntegrationParams   map[string]interface{}    `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}    `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FolderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FolderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FolderRequest(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FolderRequest) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the folder belongs to.
type FolderRequestDrive struct {
	typeName string
	String   string
	Drive    *Drive
}

func NewFolderRequestDriveFromString(value string) *FolderRequestDrive {
	return &FolderRequestDrive{typeName: "string", String: value}
}

func NewFolderRequestDriveFromDrive(value *Drive) *FolderRequestDrive {
	return &FolderRequestDrive{typeName: "drive", Drive: value}
}

func (f *FolderRequestDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typeName = "drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestDrive) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "drive":
		return json.Marshal(f.Drive)
	}
}

type FolderRequestDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FolderRequestDrive) Accept(visitor FolderRequestDriveVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "drive":
		return visitor.VisitDrive(f.Drive)
	}
}

// The folder that the folder belongs to.
type FolderRequestParentFolder struct {
	typeName string
	String   string
	Folder   *Folder
}

func NewFolderRequestParentFolderFromString(value string) *FolderRequestParentFolder {
	return &FolderRequestParentFolder{typeName: "string", String: value}
}

func NewFolderRequestParentFolderFromFolder(value *Folder) *FolderRequestParentFolder {
	return &FolderRequestParentFolder{typeName: "folder", Folder: value}
}

func (f *FolderRequestParentFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typeName = "folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestParentFolder) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "folder":
		return json.Marshal(f.Folder)
	}
}

type FolderRequestParentFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FolderRequestParentFolder) Accept(visitor FolderRequestParentFolderVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "folder":
		return visitor.VisitFolder(f.Folder)
	}
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /folders`.
type FolderRequestPermissions struct {
	typeName                         string
	String                           string
	PermissionRequest                *PermissionRequest
	FolderRequestPermissionsItemList []*FolderRequestPermissionsItem
}

func NewFolderRequestPermissionsFromString(value string) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "string", String: value}
}

func NewFolderRequestPermissionsFromPermissionRequest(value *PermissionRequest) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "permissionRequest", PermissionRequest: value}
}

func NewFolderRequestPermissionsFromFolderRequestPermissionsItemList(value []*FolderRequestPermissionsItem) *FolderRequestPermissions {
	return &FolderRequestPermissions{typeName: "folderRequestPermissionsItemList", FolderRequestPermissionsItemList: value}
}

func (f *FolderRequestPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	var valueFolderRequestPermissionsItemList []*FolderRequestPermissionsItem
	if err := json.Unmarshal(data, &valueFolderRequestPermissionsItemList); err == nil {
		f.typeName = "folderRequestPermissionsItemList"
		f.FolderRequestPermissionsItemList = valueFolderRequestPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestPermissions) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	case "folderRequestPermissionsItemList":
		return json.Marshal(f.FolderRequestPermissionsItemList)
	}
}

type FolderRequestPermissionsVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
	VisitFolderRequestPermissionsItemList([]*FolderRequestPermissionsItem) error
}

func (f *FolderRequestPermissions) Accept(visitor FolderRequestPermissionsVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	case "folderRequestPermissionsItemList":
		return visitor.VisitFolderRequestPermissionsItemList(f.FolderRequestPermissionsItemList)
	}
}

type FolderRequestPermissionsItem struct {
	typeName          string
	String            string
	PermissionRequest *PermissionRequest
}

func NewFolderRequestPermissionsItemFromString(value string) *FolderRequestPermissionsItem {
	return &FolderRequestPermissionsItem{typeName: "string", String: value}
}

func NewFolderRequestPermissionsItemFromPermissionRequest(value *PermissionRequest) *FolderRequestPermissionsItem {
	return &FolderRequestPermissionsItem{typeName: "permissionRequest", PermissionRequest: value}
}

func (f *FolderRequestPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typeName = "string"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typeName = "permissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FolderRequestPermissionsItem) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return json.Marshal(f.String)
	case "permissionRequest":
		return json.Marshal(f.PermissionRequest)
	}
}

type FolderRequestPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FolderRequestPermissionsItem) Accept(visitor FolderRequestPermissionsItemVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "string":
		return visitor.VisitString(f.String)
	case "permissionRequest":
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
}

// # The Group Object
//
// ### Description
//
// The `Group` object is used to represent any subset of `User`s. This can extend to company domains as well.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/groups` endpoint and view their groups.
type Group struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The group's name.
	Name *string `json:"name,omitempty"`
	// The users that belong in the group. If null, this typically means it's either a domain or the third-party platform does not surface this information.
	Users []string `json:"users,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool                    `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{}   `json:"field_mappings,omitempty"`
	RemoteData       []map[string]interface{} `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *Group) UnmarshalJSON(data []byte) error {
	type unmarshaler Group
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Group(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Group) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type IndividualCommonModelScopeDeserializer struct {
	ModelName        string                                  `json:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializer `json:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializer            `json:"field_permissions,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializer(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializer) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndividualCommonModelScopeDeserializerRequest struct {
	ModelName        string                                         `json:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializerRequest `json:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializerRequest            `json:"field_permissions,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializerRequest(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializerRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Issue struct {
	Id *string `json:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// - `ONGOING` - ONGOING
	// - `RESOLVED` - RESOLVED
	Status            *IssueStatus           `json:"status,omitempty"`
	ErrorDescription  string                 `json:"error_description"`
	EndUser           map[string]interface{} `json:"end_user,omitempty"`
	FirstIncidentTime *time.Time             `json:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time             `json:"last_incident_time,omitempty"`
	IsMuted           *bool                  `json:"is_muted,omitempty"`
	ErrorDetails      []string               `json:"error_details,omitempty"`

	_rawJSON json.RawMessage
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	type unmarshaler Issue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Issue(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Issue) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatus struct {
	typeName        string
	IssueStatusEnum IssueStatusEnum
	String          string
}

func NewIssueStatusFromIssueStatusEnum(value IssueStatusEnum) *IssueStatus {
	return &IssueStatus{typeName: "issueStatusEnum", IssueStatusEnum: value}
}

func NewIssueStatusFromString(value string) *IssueStatus {
	return &IssueStatus{typeName: "string", String: value}
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typeName = "issueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return json.Marshal(i.IssueStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// - `ONGOING` - ONGOING
// - `RESOLVED` - RESOLVED
type IssueStatusEnum string

const (
	IssueStatusEnumOngoing  IssueStatusEnum = "ONGOING"
	IssueStatusEnumResolved IssueStatusEnum = "RESOLVED"
)

func NewIssueStatusEnumFromString(s string) (IssueStatusEnum, error) {
	switch s {
	case "ONGOING":
		return IssueStatusEnumOngoing, nil
	case "RESOLVED":
		return IssueStatusEnumResolved, nil
	}
	var t IssueStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatusEnum) Ptr() *IssueStatusEnum {
	return &i
}

type LinkToken struct {
	LinkToken       string  `json:"link_token"`
	IntegrationName *string `json:"integration_name,omitempty"`
	MagicLinkUrl    *string `json:"magic_link_url,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LinkToken) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkToken(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkToken) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request"`

	_rawJSON json.RawMessage
}

func (l *LinkedAccountStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedAccountStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedAccountStatus(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedAccountStatus) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MetaResponse struct {
	RequestSchema                  map[string]interface{} `json:"request_schema,omitempty"`
	RemoteFieldClasses             map[string]interface{} `json:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus   `json:"status,omitempty"`
	HasConditionalParams           bool                   `json:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                   `json:"has_required_linked_account_params"`

	_rawJSON json.RawMessage
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetaResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// - `GET` - GET
// - `OPTIONS` - OPTIONS
// - `HEAD` - HEAD
// - `POST` - POST
// - `PUT` - PUT
// - `PATCH` - PATCH
// - `DELETE` - DELETE
type MethodEnum string

const (
	MethodEnumGet     MethodEnum = "GET"
	MethodEnumOptions MethodEnum = "OPTIONS"
	MethodEnumHead    MethodEnum = "HEAD"
	MethodEnumPost    MethodEnum = "POST"
	MethodEnumPut     MethodEnum = "PUT"
	MethodEnumPatch   MethodEnum = "PATCH"
	MethodEnumDelete  MethodEnum = "DELETE"
)

func NewMethodEnumFromString(s string) (MethodEnum, error) {
	switch s {
	case "GET":
		return MethodEnumGet, nil
	case "OPTIONS":
		return MethodEnumOptions, nil
	case "HEAD":
		return MethodEnumHead, nil
	case "POST":
		return MethodEnumPost, nil
	case "PUT":
		return MethodEnumPut, nil
	case "PATCH":
		return MethodEnumPatch, nil
	case "DELETE":
		return MethodEnumDelete, nil
	}
	var t MethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodEnum) Ptr() *MethodEnum {
	return &m
}

// # The ModelOperation Object
//
// ### Description
//
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
//
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name"`
	AvailableOperations    []string `json:"available_operations,omitempty"`
	RequiredPostParameters []string `json:"required_post_parameters,omitempty"`
	SupportedFields        []string `json:"supported_fields,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelOperation(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelOperation) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializer struct {
	IsEnabled *bool `json:"is_enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelPermissionDeserializer) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializer(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializer) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializerRequest struct {
	IsEnabled *bool `json:"is_enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializerRequest(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializerRequest) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The MultipartFormField Object
//
// ### Description
//
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
//
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name"`
	// The data for the form field.
	Data string `json:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// - `RAW` - RAW
	// - `BASE64` - BASE64
	// - `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MultipartFormFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipartFormFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipartFormFieldRequest(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipartFormFieldRequest) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// - `RAW` - RAW
// - `BASE64` - BASE64
// - `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	typeName     string
	EncodingEnum EncodingEnum
	String       string
}

func NewMultipartFormFieldRequestEncodingFromEncodingEnum(value EncodingEnum) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "encodingEnum", EncodingEnum: value}
}

func NewMultipartFormFieldRequestEncodingFromString(value string) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "string", String: value}
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typeName = "encodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return json.Marshal(m.EncodingEnum)
	case "string":
		return json.Marshal(m.String)
	}
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	case "string":
		return visitor.VisitString(m.String)
	}
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAccountDetailsAndActionsList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAccountDetailsAndActionsList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAccountDetailsAndActionsList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAccountDetailsAndActionsList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedAuditLogEventList struct {
	Next     *string          `json:"next,omitempty"`
	Previous *string          `json:"previous,omitempty"`
	Results  []*AuditLogEvent `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedAuditLogEventList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAuditLogEventList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAuditLogEventList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAuditLogEventList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedDriveList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Drive `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedDriveList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedDriveList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedDriveList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedDriveList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedFileList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*File `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedFileList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedFileList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedFileList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedFileList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedFolderList struct {
	Next     *string   `json:"next,omitempty"`
	Previous *string   `json:"previous,omitempty"`
	Results  []*Folder `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedFolderList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedFolderList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedFolderList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedFolderList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedGroupList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Group `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedGroupList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedGroupList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedGroupList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedGroupList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedIssueList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedIssueList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedIssueList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedIssueList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedSyncStatusList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*SyncStatus `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedSyncStatusList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedSyncStatusList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedSyncStatusList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedSyncStatusList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedUserList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*User `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginatedUserList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedUserList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedUserList(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedUserList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The Permission Object
//
// ### Description
//
// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default.
//
// ### Usage Example
//
// Fetch from the `GET Files` or `GET Folders` endpoint. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details.
type Permission struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The user that is granted this permission.
	User *PermissionUser `json:"user,omitempty"`
	// The group that is granted this permission.
	Group *PermissionGroup `json:"group,omitempty"`
	// Denotes what type of people have access to the file.
	//
	// - `USER` - USER
	// - `GROUP` - GROUP
	// - `COMPANY` - COMPANY
	// - `ANYONE` - ANYONE
	Type *PermissionType `json:"type,omitempty"`
	// The permissions that the user or group has for the File or Folder. It is possible for a user or group to have multiple roles, such as viewing & uploading. Possible values include: `READ`, `WRITE`, `OWNER`. In cases where there is no clear mapping, the original value passed through will be returned.
	Roles []*PermissionRolesItem `json:"roles,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Permission) UnmarshalJSON(data []byte) error {
	type unmarshaler Permission
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Permission(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Permission) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The group that is granted this permission.
type PermissionGroup struct {
	typeName string
	String   string
	Group    *Group
}

func NewPermissionGroupFromString(value string) *PermissionGroup {
	return &PermissionGroup{typeName: "string", String: value}
}

func NewPermissionGroupFromGroup(value *Group) *PermissionGroup {
	return &PermissionGroup{typeName: "group", Group: value}
}

func (p *PermissionGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		p.typeName = "group"
		p.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionGroup) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "group":
		return json.Marshal(p.Group)
	}
}

type PermissionGroupVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (p *PermissionGroup) Accept(visitor PermissionGroupVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "group":
		return visitor.VisitGroup(p.Group)
	}
}

// # The Permission Object
//
// ### Description
//
// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default.
//
// ### Usage Example
//
// Fetch from the `GET Files` or `GET Folders` endpoint. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details.
type PermissionRequest struct {
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The user that is granted this permission.
	User *PermissionRequestUser `json:"user,omitempty"`
	// The group that is granted this permission.
	Group *PermissionRequestGroup `json:"group,omitempty"`
	// Denotes what type of people have access to the file.
	//
	// - `USER` - USER
	// - `GROUP` - GROUP
	// - `COMPANY` - COMPANY
	// - `ANYONE` - ANYONE
	Type *PermissionRequestType `json:"type,omitempty"`
	// The permissions that the user or group has for the File or Folder. It is possible for a user or group to have multiple roles, such as viewing & uploading. Possible values include: `READ`, `WRITE`, `OWNER`. In cases where there is no clear mapping, the original value passed through will be returned.
	Roles               []*PermissionRequestRolesItem `json:"roles,omitempty"`
	IntegrationParams   map[string]interface{}        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}        `json:"linked_account_params,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PermissionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PermissionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PermissionRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PermissionRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The group that is granted this permission.
type PermissionRequestGroup struct {
	typeName string
	String   string
	Group    *Group
}

func NewPermissionRequestGroupFromString(value string) *PermissionRequestGroup {
	return &PermissionRequestGroup{typeName: "string", String: value}
}

func NewPermissionRequestGroupFromGroup(value *Group) *PermissionRequestGroup {
	return &PermissionRequestGroup{typeName: "group", Group: value}
}

func (p *PermissionRequestGroup) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueGroup := new(Group)
	if err := json.Unmarshal(data, &valueGroup); err == nil {
		p.typeName = "group"
		p.Group = valueGroup
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestGroup) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "group":
		return json.Marshal(p.Group)
	}
}

type PermissionRequestGroupVisitor interface {
	VisitString(string) error
	VisitGroup(*Group) error
}

func (p *PermissionRequestGroup) Accept(visitor PermissionRequestGroupVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "group":
		return visitor.VisitGroup(p.Group)
	}
}

// The permissions that the user or group has for the File or Folder.
//
// - `READ` - READ
// - `WRITE` - WRITE
// - `OWNER` - OWNER
type PermissionRequestRolesItem struct {
	typeName  string
	RolesEnum RolesEnum
	String    string
}

func NewPermissionRequestRolesItemFromRolesEnum(value RolesEnum) *PermissionRequestRolesItem {
	return &PermissionRequestRolesItem{typeName: "rolesEnum", RolesEnum: value}
}

func NewPermissionRequestRolesItemFromString(value string) *PermissionRequestRolesItem {
	return &PermissionRequestRolesItem{typeName: "string", String: value}
}

func (p *PermissionRequestRolesItem) UnmarshalJSON(data []byte) error {
	var valueRolesEnum RolesEnum
	if err := json.Unmarshal(data, &valueRolesEnum); err == nil {
		p.typeName = "rolesEnum"
		p.RolesEnum = valueRolesEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestRolesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "rolesEnum":
		return json.Marshal(p.RolesEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PermissionRequestRolesItemVisitor interface {
	VisitRolesEnum(RolesEnum) error
	VisitString(string) error
}

func (p *PermissionRequestRolesItem) Accept(visitor PermissionRequestRolesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "rolesEnum":
		return visitor.VisitRolesEnum(p.RolesEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// Denotes what type of people have access to the file.
//
// - `USER` - USER
// - `GROUP` - GROUP
// - `COMPANY` - COMPANY
// - `ANYONE` - ANYONE
type PermissionRequestType struct {
	typeName string
	TypeEnum TypeEnum
	String   string
}

func NewPermissionRequestTypeFromTypeEnum(value TypeEnum) *PermissionRequestType {
	return &PermissionRequestType{typeName: "typeEnum", TypeEnum: value}
}

func NewPermissionRequestTypeFromString(value string) *PermissionRequestType {
	return &PermissionRequestType{typeName: "string", String: value}
}

func (p *PermissionRequestType) UnmarshalJSON(data []byte) error {
	var valueTypeEnum TypeEnum
	if err := json.Unmarshal(data, &valueTypeEnum); err == nil {
		p.typeName = "typeEnum"
		p.TypeEnum = valueTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "typeEnum":
		return json.Marshal(p.TypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PermissionRequestTypeVisitor interface {
	VisitTypeEnum(TypeEnum) error
	VisitString(string) error
}

func (p *PermissionRequestType) Accept(visitor PermissionRequestTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "typeEnum":
		return visitor.VisitTypeEnum(p.TypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// The user that is granted this permission.
type PermissionRequestUser struct {
	typeName string
	String   string
	User     *User
}

func NewPermissionRequestUserFromString(value string) *PermissionRequestUser {
	return &PermissionRequestUser{typeName: "string", String: value}
}

func NewPermissionRequestUserFromUser(value *User) *PermissionRequestUser {
	return &PermissionRequestUser{typeName: "user", User: value}
}

func (p *PermissionRequestUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		p.typeName = "user"
		p.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRequestUser) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "user":
		return json.Marshal(p.User)
	}
}

type PermissionRequestUserVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (p *PermissionRequestUser) Accept(visitor PermissionRequestUserVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "user":
		return visitor.VisitUser(p.User)
	}
}

// The permissions that the user or group has for the File or Folder.
//
// - `READ` - READ
// - `WRITE` - WRITE
// - `OWNER` - OWNER
type PermissionRolesItem struct {
	typeName  string
	RolesEnum RolesEnum
	String    string
}

func NewPermissionRolesItemFromRolesEnum(value RolesEnum) *PermissionRolesItem {
	return &PermissionRolesItem{typeName: "rolesEnum", RolesEnum: value}
}

func NewPermissionRolesItemFromString(value string) *PermissionRolesItem {
	return &PermissionRolesItem{typeName: "string", String: value}
}

func (p *PermissionRolesItem) UnmarshalJSON(data []byte) error {
	var valueRolesEnum RolesEnum
	if err := json.Unmarshal(data, &valueRolesEnum); err == nil {
		p.typeName = "rolesEnum"
		p.RolesEnum = valueRolesEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionRolesItem) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "rolesEnum":
		return json.Marshal(p.RolesEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PermissionRolesItemVisitor interface {
	VisitRolesEnum(RolesEnum) error
	VisitString(string) error
}

func (p *PermissionRolesItem) Accept(visitor PermissionRolesItemVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "rolesEnum":
		return visitor.VisitRolesEnum(p.RolesEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// Denotes what type of people have access to the file.
//
// - `USER` - USER
// - `GROUP` - GROUP
// - `COMPANY` - COMPANY
// - `ANYONE` - ANYONE
type PermissionType struct {
	typeName string
	TypeEnum TypeEnum
	String   string
}

func NewPermissionTypeFromTypeEnum(value TypeEnum) *PermissionType {
	return &PermissionType{typeName: "typeEnum", TypeEnum: value}
}

func NewPermissionTypeFromString(value string) *PermissionType {
	return &PermissionType{typeName: "string", String: value}
}

func (p *PermissionType) UnmarshalJSON(data []byte) error {
	var valueTypeEnum TypeEnum
	if err := json.Unmarshal(data, &valueTypeEnum); err == nil {
		p.typeName = "typeEnum"
		p.TypeEnum = valueTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionType) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "typeEnum":
		return json.Marshal(p.TypeEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PermissionTypeVisitor interface {
	VisitTypeEnum(TypeEnum) error
	VisitString(string) error
}

func (p *PermissionType) Accept(visitor PermissionTypeVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "typeEnum":
		return visitor.VisitTypeEnum(p.TypeEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// The user that is granted this permission.
type PermissionUser struct {
	typeName string
	String   string
	User     *User
}

func NewPermissionUserFromString(value string) *PermissionUser {
	return &PermissionUser{typeName: "string", String: value}
}

func NewPermissionUserFromUser(value *User) *PermissionUser {
	return &PermissionUser{typeName: "user", User: value}
}

func (p *PermissionUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		p.typeName = "user"
		p.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PermissionUser) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return json.Marshal(p.String)
	case "user":
		return json.Marshal(p.User)
	}
}

type PermissionUserVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (p *PermissionUser) Accept(visitor PermissionUserVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "string":
		return visitor.VisitString(p.String)
	case "user":
		return visitor.VisitUser(p.User)
	}
}

type RemoteEndpointInfo struct {
	Method             string        `json:"method"`
	UrlPath            string        `json:"url_path"`
	FieldTraversalPath []interface{} `json:"field_traversal_path,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteEndpointInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteEndpointInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteEndpointInfo(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteEndpointInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldApi struct {
	Schema             map[string]interface{}  `json:"schema,omitempty"`
	RemoteKeyName      string                  `json:"remote_key_name"`
	RemoteEndpointInfo *RemoteEndpointInfo     `json:"remote_endpoint_info,omitempty"`
	ExampleValues      []interface{}           `json:"example_values,omitempty"`
	AdvancedMetadata   *AdvancedMetadata       `json:"advanced_metadata,omitempty"`
	Coverage           *RemoteFieldApiCoverage `json:"coverage,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteFieldApi) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldApi(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldApi) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldApiCoverage struct {
	typeName string
	Integer  int
	Double   float64
}

func NewRemoteFieldApiCoverageFromInteger(value int) *RemoteFieldApiCoverage {
	return &RemoteFieldApiCoverage{typeName: "integer", Integer: value}
}

func NewRemoteFieldApiCoverageFromDouble(value float64) *RemoteFieldApiCoverage {
	return &RemoteFieldApiCoverage{typeName: "double", Double: value}
}

func (r *RemoteFieldApiCoverage) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		r.typeName = "double"
		r.Double = valueDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldApiCoverage) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "double":
		return json.Marshal(r.Double)
	}
}

type RemoteFieldApiCoverageVisitor interface {
	VisitInteger(int) error
	VisitDouble(float64) error
}

func (r *RemoteFieldApiCoverage) Accept(visitor RemoteFieldApiCoverageVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "double":
		return visitor.VisitDouble(r.Double)
	}
}

type RemoteFieldApiResponse struct {
	File   []*RemoteFieldApi `json:"File,omitempty"`
	Folder []*RemoteFieldApi `json:"Folder,omitempty"`
	Drive  []*RemoteFieldApi `json:"Drive,omitempty"`
	Group  []*RemoteFieldApi `json:"Group,omitempty"`
	User   []*RemoteFieldApi `json:"User,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteFieldApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldApiResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldApiResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteKey Object
//
// ### Description
//
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
//
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name"`
	Key  string `json:"key"`

	_rawJSON json.RawMessage
}

func (r *RemoteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteKey(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteKey) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteResponse Object
//
// ### Description
//
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
//
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                 `json:"method"`
	Path            string                 `json:"path"`
	Status          int                    `json:"status"`
	Response        interface{}            `json:"response,omitempty"`
	ResponseHeaders map[string]interface{} `json:"response_headers,omitempty"`
	ResponseType    *ResponseTypeEnum      `json:"response_type,omitempty"`
	Headers         map[string]interface{} `json:"headers,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RemoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// - `JSON` - JSON
// - `XML` - XML
// - `MULTIPART` - MULTIPART
type RequestFormatEnum string

const (
	RequestFormatEnumJson      RequestFormatEnum = "JSON"
	RequestFormatEnumXml       RequestFormatEnum = "XML"
	RequestFormatEnumMultipart RequestFormatEnum = "MULTIPART"
)

func NewRequestFormatEnumFromString(s string) (RequestFormatEnum, error) {
	switch s {
	case "JSON":
		return RequestFormatEnumJson, nil
	case "XML":
		return RequestFormatEnumXml, nil
	case "MULTIPART":
		return RequestFormatEnumMultipart, nil
	}
	var t RequestFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestFormatEnum) Ptr() *RequestFormatEnum {
	return &r
}

// - `JSON` - JSON
// - `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum string

const (
	ResponseTypeEnumJson       ResponseTypeEnum = "JSON"
	ResponseTypeEnumBase64Gzip ResponseTypeEnum = "BASE64_GZIP"
)

func NewResponseTypeEnumFromString(s string) (ResponseTypeEnum, error) {
	switch s {
	case "JSON":
		return ResponseTypeEnumJson, nil
	case "BASE64_GZIP":
		return ResponseTypeEnumBase64Gzip, nil
	}
	var t ResponseTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTypeEnum) Ptr() *ResponseTypeEnum {
	return &r
}

// - `ADMIN` - ADMIN
// - `DEVELOPER` - DEVELOPER
// - `MEMBER` - MEMBER
// - `API` - API
// - `SYSTEM` - SYSTEM
// - `MERGE_TEAM` - MERGE_TEAM
type RoleEnum string

const (
	RoleEnumAdmin     RoleEnum = "ADMIN"
	RoleEnumDeveloper RoleEnum = "DEVELOPER"
	RoleEnumMember    RoleEnum = "MEMBER"
	RoleEnumApi       RoleEnum = "API"
	RoleEnumSystem    RoleEnum = "SYSTEM"
	RoleEnumMergeTeam RoleEnum = "MERGE_TEAM"
)

func NewRoleEnumFromString(s string) (RoleEnum, error) {
	switch s {
	case "ADMIN":
		return RoleEnumAdmin, nil
	case "DEVELOPER":
		return RoleEnumDeveloper, nil
	case "MEMBER":
		return RoleEnumMember, nil
	case "API":
		return RoleEnumApi, nil
	case "SYSTEM":
		return RoleEnumSystem, nil
	case "MERGE_TEAM":
		return RoleEnumMergeTeam, nil
	}
	var t RoleEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoleEnum) Ptr() *RoleEnum {
	return &r
}

// - `READ` - READ
// - `WRITE` - WRITE
// - `OWNER` - OWNER
type RolesEnum string

const (
	RolesEnumRead  RolesEnum = "READ"
	RolesEnumWrite RolesEnum = "WRITE"
	RolesEnumOwner RolesEnum = "OWNER"
)

func NewRolesEnumFromString(s string) (RolesEnum, error) {
	switch s {
	case "READ":
		return RolesEnumRead, nil
	case "WRITE":
		return RolesEnumWrite, nil
	case "OWNER":
		return RolesEnumOwner, nil
	}
	var t RolesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RolesEnum) Ptr() *RolesEnum {
	return &r
}

// - `IN_NEXT_SYNC` - IN_NEXT_SYNC
// - `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum string

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = "IN_NEXT_SYNC"
	SelectiveSyncConfigurationsUsageEnumInLastSync SelectiveSyncConfigurationsUsageEnum = "IN_LAST_SYNC"
)

func NewSelectiveSyncConfigurationsUsageEnumFromString(s string) (SelectiveSyncConfigurationsUsageEnum, error) {
	switch s {
	case "IN_NEXT_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInNextSync, nil
	case "IN_LAST_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInLastSync, nil
	}
	var t SelectiveSyncConfigurationsUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SelectiveSyncConfigurationsUsageEnum) Ptr() *SelectiveSyncConfigurationsUsageEnum {
	return &s
}

// # The SyncStatus Object
//
// ### Description
//
// # The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
//
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name"`
	ModelId                          string                                `json:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty"`
	Status                           SyncStatusStatusEnum                  `json:"status,omitempty"`
	IsInitialSync                    bool                                  `json:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SyncStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncStatus(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatus) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// - `SYNCING` - SYNCING
// - `DONE` - DONE
// - `FAILED` - FAILED
// - `DISABLED` - DISABLED
// - `PAUSED` - PAUSED
// - `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type SyncStatusStatusEnum string

const (
	SyncStatusStatusEnumSyncing         SyncStatusStatusEnum = "SYNCING"
	SyncStatusStatusEnumDone            SyncStatusStatusEnum = "DONE"
	SyncStatusStatusEnumFailed          SyncStatusStatusEnum = "FAILED"
	SyncStatusStatusEnumDisabled        SyncStatusStatusEnum = "DISABLED"
	SyncStatusStatusEnumPaused          SyncStatusStatusEnum = "PAUSED"
	SyncStatusStatusEnumPartiallySynced SyncStatusStatusEnum = "PARTIALLY_SYNCED"
)

func NewSyncStatusStatusEnumFromString(s string) (SyncStatusStatusEnum, error) {
	switch s {
	case "SYNCING":
		return SyncStatusStatusEnumSyncing, nil
	case "DONE":
		return SyncStatusStatusEnumDone, nil
	case "FAILED":
		return SyncStatusStatusEnumFailed, nil
	case "DISABLED":
		return SyncStatusStatusEnumDisabled, nil
	case "PAUSED":
		return SyncStatusStatusEnumPaused, nil
	case "PARTIALLY_SYNCED":
		return SyncStatusStatusEnumPartiallySynced, nil
	}
	var t SyncStatusStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SyncStatusStatusEnum) Ptr() *SyncStatusStatusEnum {
	return &s
}

// - `USER` - USER
// - `GROUP` - GROUP
// - `COMPANY` - COMPANY
// - `ANYONE` - ANYONE
type TypeEnum string

const (
	TypeEnumUser    TypeEnum = "USER"
	TypeEnumGroup   TypeEnum = "GROUP"
	TypeEnumCompany TypeEnum = "COMPANY"
	TypeEnumAnyone  TypeEnum = "ANYONE"
)

func NewTypeEnumFromString(s string) (TypeEnum, error) {
	switch s {
	case "USER":
		return TypeEnumUser, nil
	case "GROUP":
		return TypeEnumGroup, nil
	case "COMPANY":
		return TypeEnumCompany, nil
	case "ANYONE":
		return TypeEnumAnyone, nil
	}
	var t TypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TypeEnum) Ptr() *TypeEnum {
	return &t
}

// # The User Object
//
// ### Description
//
// The `User` object is used to represent a user within the File Storage account.
//
// ### Usage Example
//
// Fetch from the `GET /api/filestorage/v1/users` endpoint and view their users.
type User struct {
	Id *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
	// The user's name.
	Name *string `json:"name,omitempty"`
	// The user's email address. This is typically used to identify a user across linked accounts.
	EmailAddress *string `json:"email_address,omitempty"`
	// Whether the user is the one who linked this account.
	IsMe *bool `json:"is_me,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform.
	RemoteWasDeleted *bool                    `json:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{}   `json:"field_mappings,omitempty"`
	RemoteData       []map[string]interface{} `json:"remote_data,omitempty"`

	_rawJSON json.RawMessage
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer"`

	_rawJSON json.RawMessage
}

func (v *ValidationProblemSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationProblemSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationProblemSource(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationProblemSource) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`

	_rawJSON json.RawMessage
}

func (w *WarningValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler WarningValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WarningValidationProblem(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WarningValidationProblem) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookReceiver struct {
	Event    string  `json:"event"`
	IsActive bool    `json:"is_active"`
	Key      *string `json:"key,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WebhookReceiver) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookReceiver
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookReceiver(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookReceiver) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
