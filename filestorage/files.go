// Code generated by Fern. DO NOT EDIT.

package filestorage

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type FileStorageFileEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool        `json:"-" url:"run_async,omitempty"`
	Model    *FileRequest `json:"model,omitempty" url:"-"`
}

type FilesDownloadRequestMetaListRequest struct {
	// If provided, will only return objects created after this datetime.
	CreatedAfter *string `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *string `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// A comma-separated list of preferred MIME types in order of priority. If supported by the third-party provider, the file(s) will be returned in the first supported MIME type from the list. The default MIME type is PDF. To see supported MIME types by file type, refer to our <a href='https://help.merge.dev/en/articles/8615316-file-export-and-download-specification' target='_blank'>export format help center article</a>.
	MimeTypes *string `json:"-" url:"mime_types,omitempty"`
	// If provided, will only return objects modified after this datetime.
	ModifiedAfter *string `json:"-" url:"modified_after,omitempty"`
	// If provided, will only return objects modified before this datetime.
	ModifiedBefore *string `json:"-" url:"modified_before,omitempty"`
	// Overrides the default ordering for this endpoint. Possible values include: created_at, -created_at, modified_at, -modified_at.
	OrderBy *FilesDownloadRequestMetaListRequestOrderBy `json:"-" url:"order_by,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
}

type FilesDownloadRequestMetaRetrieveRequest struct {
	// If provided, specifies the export format of the file to be downloaded. For information on supported export formats, please refer to our <a href='https://help.merge.dev/en/articles/8615316-file-export-and-download-specification' target='_blank'>export format help center article</a>.
	MimeType *string `json:"-" url:"mime_type,omitempty"`
}

type FilesDownloadRetrieveRequest struct {
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, specifies the export format of the file to be downloaded. For information on supported export formats, please refer to our <a href='https://help.merge.dev/en/articles/8615316-file-export-and-download-specification' target='_blank'>export format help center article</a>.
	MimeType *string `json:"-" url:"mime_type,omitempty"`
}

type FilesListRequest struct {
	// If provided, will only return objects created after this datetime.
	CreatedAfter *time.Time `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *time.Time `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Specifying a drive id returns only the files in that drive. Specifying null returns only the files outside the top-level drive.
	DriveId *string `json:"-" url:"drive_id,omitempty"`
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*FilesListRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Specifying a folder id returns only the files in that folder. Specifying null returns only the files in root directory.
	FolderId *string `json:"-" url:"folder_id,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return files with these mime_types. Multiple values can be separated by commas.
	MimeType *string `json:"-" url:"mime_type,omitempty"`
	// If provided, only objects synced by Merge after this date time will be returned.
	ModifiedAfter *time.Time `json:"-" url:"modified_after,omitempty"`
	// If provided, only objects synced by Merge before this date time will be returned.
	ModifiedBefore *time.Time `json:"-" url:"modified_before,omitempty"`
	// If provided, will only return files with this name. This performs an exact match.
	Name *string `json:"-" url:"name,omitempty"`
	// Overrides the default ordering for this endpoint. Possible values include: created_at, -created_at, modified_at, -modified_at.
	OrderBy *FilesListRequestOrderBy `json:"-" url:"order_by,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// The API provider's ID for the given object.
	RemoteId *string `json:"-" url:"remote_id,omitempty"`
}

type FilesRetrieveRequest struct {
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*FilesRetrieveRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
}

type FilesDownloadRequestMetaListRequestOrderBy string

const (
	FilesDownloadRequestMetaListRequestOrderByCreatedAtDescending  FilesDownloadRequestMetaListRequestOrderBy = "-created_at"
	FilesDownloadRequestMetaListRequestOrderByModifiedAtDescending FilesDownloadRequestMetaListRequestOrderBy = "-modified_at"
	FilesDownloadRequestMetaListRequestOrderByCreatedAtAscending   FilesDownloadRequestMetaListRequestOrderBy = "created_at"
	FilesDownloadRequestMetaListRequestOrderByModifiedAtAscending  FilesDownloadRequestMetaListRequestOrderBy = "modified_at"
)

func NewFilesDownloadRequestMetaListRequestOrderByFromString(s string) (FilesDownloadRequestMetaListRequestOrderBy, error) {
	switch s {
	case "-created_at":
		return FilesDownloadRequestMetaListRequestOrderByCreatedAtDescending, nil
	case "-modified_at":
		return FilesDownloadRequestMetaListRequestOrderByModifiedAtDescending, nil
	case "created_at":
		return FilesDownloadRequestMetaListRequestOrderByCreatedAtAscending, nil
	case "modified_at":
		return FilesDownloadRequestMetaListRequestOrderByModifiedAtAscending, nil
	}
	var t FilesDownloadRequestMetaListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilesDownloadRequestMetaListRequestOrderBy) Ptr() *FilesDownloadRequestMetaListRequestOrderBy {
	return &f
}

type FilesListRequestExpandItem string

const (
	FilesListRequestExpandItemDrive       FilesListRequestExpandItem = "drive"
	FilesListRequestExpandItemFolder      FilesListRequestExpandItem = "folder"
	FilesListRequestExpandItemPermissions FilesListRequestExpandItem = "permissions"
)

func NewFilesListRequestExpandItemFromString(s string) (FilesListRequestExpandItem, error) {
	switch s {
	case "drive":
		return FilesListRequestExpandItemDrive, nil
	case "folder":
		return FilesListRequestExpandItemFolder, nil
	case "permissions":
		return FilesListRequestExpandItemPermissions, nil
	}
	var t FilesListRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilesListRequestExpandItem) Ptr() *FilesListRequestExpandItem {
	return &f
}

type FilesListRequestOrderBy string

const (
	FilesListRequestOrderByCreatedAtDescending  FilesListRequestOrderBy = "-created_at"
	FilesListRequestOrderByModifiedAtDescending FilesListRequestOrderBy = "-modified_at"
	FilesListRequestOrderByCreatedAtAscending   FilesListRequestOrderBy = "created_at"
	FilesListRequestOrderByModifiedAtAscending  FilesListRequestOrderBy = "modified_at"
)

func NewFilesListRequestOrderByFromString(s string) (FilesListRequestOrderBy, error) {
	switch s {
	case "-created_at":
		return FilesListRequestOrderByCreatedAtDescending, nil
	case "-modified_at":
		return FilesListRequestOrderByModifiedAtDescending, nil
	case "created_at":
		return FilesListRequestOrderByCreatedAtAscending, nil
	case "modified_at":
		return FilesListRequestOrderByModifiedAtAscending, nil
	}
	var t FilesListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilesListRequestOrderBy) Ptr() *FilesListRequestOrderBy {
	return &f
}

type FilesRetrieveRequestExpandItem string

const (
	FilesRetrieveRequestExpandItemDrive       FilesRetrieveRequestExpandItem = "drive"
	FilesRetrieveRequestExpandItemFolder      FilesRetrieveRequestExpandItem = "folder"
	FilesRetrieveRequestExpandItemPermissions FilesRetrieveRequestExpandItem = "permissions"
)

func NewFilesRetrieveRequestExpandItemFromString(s string) (FilesRetrieveRequestExpandItem, error) {
	switch s {
	case "drive":
		return FilesRetrieveRequestExpandItemDrive, nil
	case "folder":
		return FilesRetrieveRequestExpandItemFolder, nil
	case "permissions":
		return FilesRetrieveRequestExpandItemPermissions, nil
	}
	var t FilesRetrieveRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilesRetrieveRequestExpandItem) Ptr() *FilesRetrieveRequestExpandItem {
	return &f
}

type DownloadRequestMeta struct {
	Id      string                 `json:"id" url:"id"`
	Url     string                 `json:"url" url:"url"`
	Method  string                 `json:"method" url:"method"`
	Headers map[string]interface{} `json:"headers" url:"headers"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DownloadRequestMeta) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DownloadRequestMeta) GetUrl() string {
	if d == nil {
		return ""
	}
	return d.Url
}

func (d *DownloadRequestMeta) GetMethod() string {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DownloadRequestMeta) GetHeaders() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DownloadRequestMeta) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DownloadRequestMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler DownloadRequestMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DownloadRequestMeta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DownloadRequestMeta) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The File Object
// ### Description
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
type File struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The file's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty" url:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty" url:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int64 `json:"size,omitempty" url:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty" url:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *FileFolder `json:"folder,omitempty" url:"folder,omitempty"`
	// This field stores file checksum data. 'type' indicates the algorithm (e.g. crc_32, sha1, sha256, quickXor, or md5), and 'content_hash' is the unique hash used to verify file integrity and detect alterations.
	Checksum map[string]interface{} `json:"checksum,omitempty" url:"checksum,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FilePermissions `json:"permissions,omitempty" url:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive *FileDrive `json:"drive,omitempty" url:"drive,omitempty"`
	// When the third party's file was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's file was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *File) GetId() *string {
	if f == nil {
		return nil
	}
	return f.Id
}

func (f *File) GetRemoteId() *string {
	if f == nil {
		return nil
	}
	return f.RemoteId
}

func (f *File) GetCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedAt
}

func (f *File) GetModifiedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.ModifiedAt
}

func (f *File) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *File) GetFileUrl() *string {
	if f == nil {
		return nil
	}
	return f.FileUrl
}

func (f *File) GetFileThumbnailUrl() *string {
	if f == nil {
		return nil
	}
	return f.FileThumbnailUrl
}

func (f *File) GetSize() *int64 {
	if f == nil {
		return nil
	}
	return f.Size
}

func (f *File) GetMimeType() *string {
	if f == nil {
		return nil
	}
	return f.MimeType
}

func (f *File) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *File) GetFolder() *FileFolder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *File) GetChecksum() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Checksum
}

func (f *File) GetPermissions() *FilePermissions {
	if f == nil {
		return nil
	}
	return f.Permissions
}

func (f *File) GetDrive() *FileDrive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *File) GetRemoteCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.RemoteCreatedAt
}

func (f *File) GetRemoteUpdatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.RemoteUpdatedAt
}

func (f *File) GetRemoteWasDeleted() *bool {
	if f == nil {
		return nil
	}
	return f.RemoteWasDeleted
}

func (f *File) GetFieldMappings() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.FieldMappings
}

func (f *File) GetRemoteData() []*RemoteData {
	if f == nil {
		return nil
	}
	return f.RemoteData
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	f.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	f.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	f.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*f),
		CreatedAt:       internal.NewOptionalDateTime(f.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(f.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(f.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(f.RemoteUpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (f *File) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the file belongs to.
type FileDrive struct {
	String string
	Drive  *Drive

	typ string
}

func (f *FileDrive) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileDrive) GetDrive() *Drive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *FileDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typ = "Drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileDrive) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return json.Marshal(f.Drive)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FileDrive) Accept(visitor FileDriveVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return visitor.VisitDrive(f.Drive)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The folder that the file belongs to.
type FileFolder struct {
	String string
	Folder *Folder

	typ string
}

func (f *FileFolder) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileFolder) GetFolder() *Folder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *FileFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typ = "Folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileFolder) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return json.Marshal(f.Folder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FileFolder) Accept(visitor FileFolderVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return visitor.VisitFolder(f.Folder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FilePermissions struct {
	String                  string
	Permission              *Permission
	FilePermissionsItemList []*FilePermissionsItem

	typ string
}

func (f *FilePermissions) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FilePermissions) GetPermission() *Permission {
	if f == nil {
		return nil
	}
	return f.Permission
}

func (f *FilePermissions) GetFilePermissionsItemList() []*FilePermissionsItem {
	if f == nil {
		return nil
	}
	return f.FilePermissionsItemList
}

func (f *FilePermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermission := new(Permission)
	if err := json.Unmarshal(data, &valuePermission); err == nil {
		f.typ = "Permission"
		f.Permission = valuePermission
		return nil
	}
	var valueFilePermissionsItemList []*FilePermissionsItem
	if err := json.Unmarshal(data, &valueFilePermissionsItemList); err == nil {
		f.typ = "FilePermissionsItemList"
		f.FilePermissionsItemList = valueFilePermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissions) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return json.Marshal(f.Permission)
	}
	if f.typ == "FilePermissionsItemList" || f.FilePermissionsItemList != nil {
		return json.Marshal(f.FilePermissionsItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilePermissionsVisitor interface {
	VisitString(string) error
	VisitPermission(*Permission) error
	VisitFilePermissionsItemList([]*FilePermissionsItem) error
}

func (f *FilePermissions) Accept(visitor FilePermissionsVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return visitor.VisitPermission(f.Permission)
	}
	if f.typ == "FilePermissionsItemList" || f.FilePermissionsItemList != nil {
		return visitor.VisitFilePermissionsItemList(f.FilePermissionsItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilePermissionsItem struct {
	String     string
	Permission *Permission

	typ string
}

func (f *FilePermissionsItem) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FilePermissionsItem) GetPermission() *Permission {
	if f == nil {
		return nil
	}
	return f.Permission
}

func (f *FilePermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermission := new(Permission)
	if err := json.Unmarshal(data, &valuePermission); err == nil {
		f.typ = "Permission"
		f.Permission = valuePermission
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissionsItem) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return json.Marshal(f.Permission)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilePermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermission(*Permission) error
}

func (f *FilePermissionsItem) Accept(visitor FilePermissionsItemVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return visitor.VisitPermission(f.Permission)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// # The File Object
// ### Description
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
type FileRequest struct {
	// The file's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty" url:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty" url:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int64 `json:"size,omitempty" url:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty" url:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *FileRequestFolder `json:"folder,omitempty" url:"folder,omitempty"`
	// This field stores file checksum data. 'type' indicates the algorithm (e.g. crc_32, sha1, sha256, quickXor, or md5), and 'content_hash' is the unique hash used to verify file integrity and detect alterations.
	Checksum map[string]interface{} `json:"checksum,omitempty" url:"checksum,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FileRequestPermissions `json:"permissions,omitempty" url:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive               *FileRequestDrive      `json:"drive,omitempty" url:"drive,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileRequest) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FileRequest) GetFileUrl() *string {
	if f == nil {
		return nil
	}
	return f.FileUrl
}

func (f *FileRequest) GetFileThumbnailUrl() *string {
	if f == nil {
		return nil
	}
	return f.FileThumbnailUrl
}

func (f *FileRequest) GetSize() *int64 {
	if f == nil {
		return nil
	}
	return f.Size
}

func (f *FileRequest) GetMimeType() *string {
	if f == nil {
		return nil
	}
	return f.MimeType
}

func (f *FileRequest) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *FileRequest) GetFolder() *FileRequestFolder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *FileRequest) GetChecksum() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Checksum
}

func (f *FileRequest) GetPermissions() *FileRequestPermissions {
	if f == nil {
		return nil
	}
	return f.Permissions
}

func (f *FileRequest) GetDrive() *FileRequestDrive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *FileRequest) GetIntegrationParams() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.IntegrationParams
}

func (f *FileRequest) GetLinkedAccountParams() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.LinkedAccountParams
}

func (f *FileRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the file belongs to.
type FileRequestDrive struct {
	String string
	Drive  *Drive

	typ string
}

func (f *FileRequestDrive) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileRequestDrive) GetDrive() *Drive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *FileRequestDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typ = "Drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestDrive) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return json.Marshal(f.Drive)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FileRequestDrive) Accept(visitor FileRequestDriveVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return visitor.VisitDrive(f.Drive)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The folder that the file belongs to.
type FileRequestFolder struct {
	String string
	Folder *Folder

	typ string
}

func (f *FileRequestFolder) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileRequestFolder) GetFolder() *Folder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *FileRequestFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typ = "Folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestFolder) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return json.Marshal(f.Folder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FileRequestFolder) Accept(visitor FileRequestFolderVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return visitor.VisitFolder(f.Folder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FileRequestPermissions struct {
	String                         string
	PermissionRequest              *PermissionRequest
	FileRequestPermissionsItemList []*FileRequestPermissionsItem

	typ string
}

func (f *FileRequestPermissions) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileRequestPermissions) GetPermissionRequest() *PermissionRequest {
	if f == nil {
		return nil
	}
	return f.PermissionRequest
}

func (f *FileRequestPermissions) GetFileRequestPermissionsItemList() []*FileRequestPermissionsItem {
	if f == nil {
		return nil
	}
	return f.FileRequestPermissionsItemList
}

func (f *FileRequestPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typ = "PermissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	var valueFileRequestPermissionsItemList []*FileRequestPermissionsItem
	if err := json.Unmarshal(data, &valueFileRequestPermissionsItemList); err == nil {
		f.typ = "FileRequestPermissionsItemList"
		f.FileRequestPermissionsItemList = valueFileRequestPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissions) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "PermissionRequest" || f.PermissionRequest != nil {
		return json.Marshal(f.PermissionRequest)
	}
	if f.typ == "FileRequestPermissionsItemList" || f.FileRequestPermissionsItemList != nil {
		return json.Marshal(f.FileRequestPermissionsItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestPermissionsVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
	VisitFileRequestPermissionsItemList([]*FileRequestPermissionsItem) error
}

func (f *FileRequestPermissions) Accept(visitor FileRequestPermissionsVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "PermissionRequest" || f.PermissionRequest != nil {
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
	if f.typ == "FileRequestPermissionsItemList" || f.FileRequestPermissionsItemList != nil {
		return visitor.VisitFileRequestPermissionsItemList(f.FileRequestPermissionsItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestPermissionsItem struct {
	String            string
	PermissionRequest *PermissionRequest

	typ string
}

func (f *FileRequestPermissionsItem) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileRequestPermissionsItem) GetPermissionRequest() *PermissionRequest {
	if f == nil {
		return nil
	}
	return f.PermissionRequest
}

func (f *FileRequestPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typ = "PermissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissionsItem) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "PermissionRequest" || f.PermissionRequest != nil {
		return json.Marshal(f.PermissionRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FileRequestPermissionsItem) Accept(visitor FileRequestPermissionsItemVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "PermissionRequest" || f.PermissionRequest != nil {
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileStorageFileResponse struct {
	Model    *File                       `json:"model" url:"model"`
	Warnings []*WarningValidationProblem `json:"warnings" url:"warnings"`
	Errors   []*ErrorValidationProblem   `json:"errors" url:"errors"`
	Logs     []*DebugModeLog             `json:"logs,omitempty" url:"logs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileStorageFileResponse) GetModel() *File {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FileStorageFileResponse) GetWarnings() []*WarningValidationProblem {
	if f == nil {
		return nil
	}
	return f.Warnings
}

func (f *FileStorageFileResponse) GetErrors() []*ErrorValidationProblem {
	if f == nil {
		return nil
	}
	return f.Errors
}

func (f *FileStorageFileResponse) GetLogs() []*DebugModeLog {
	if f == nil {
		return nil
	}
	return f.Logs
}

func (f *FileStorageFileResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileStorageFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileStorageFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileStorageFileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileStorageFileResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type PaginatedDownloadRequestMetaList struct {
	Next     *string                `json:"next,omitempty" url:"next,omitempty"`
	Previous *string                `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*DownloadRequestMeta `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedDownloadRequestMetaList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedDownloadRequestMetaList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedDownloadRequestMetaList) GetResults() []*DownloadRequestMeta {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedDownloadRequestMetaList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedDownloadRequestMetaList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedDownloadRequestMetaList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedDownloadRequestMetaList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedDownloadRequestMetaList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedFileList struct {
	Next     *string `json:"next,omitempty" url:"next,omitempty"`
	Previous *string `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*File `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedFileList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedFileList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedFileList) GetResults() []*File {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedFileList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedFileList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedFileList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedFileList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedFileList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
