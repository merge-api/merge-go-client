// Code generated by Fern. DO NOT EDIT.

package filestorage

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	big "math/big"
	time "time"
)

var (
	fileStorageFileEndpointRequestFieldIsDebugMode = big.NewInt(1 << 0)
	fileStorageFileEndpointRequestFieldRunAsync    = big.NewInt(1 << 1)
	fileStorageFileEndpointRequestFieldModel       = big.NewInt(1 << 2)
)

type FileStorageFileEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool        `json:"-" url:"run_async,omitempty"`
	Model    *FileRequest `json:"model,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FileStorageFileEndpointRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetIsDebugMode sets the IsDebugMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileStorageFileEndpointRequest) SetIsDebugMode(isDebugMode *bool) {
	f.IsDebugMode = isDebugMode
	f.require(fileStorageFileEndpointRequestFieldIsDebugMode)
}

// SetRunAsync sets the RunAsync field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileStorageFileEndpointRequest) SetRunAsync(runAsync *bool) {
	f.RunAsync = runAsync
	f.require(fileStorageFileEndpointRequestFieldRunAsync)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileStorageFileEndpointRequest) SetModel(model *FileRequest) {
	f.Model = model
	f.require(fileStorageFileEndpointRequestFieldModel)
}

var (
	filesDownloadRequestMetaListRequestFieldCreatedAfter       = big.NewInt(1 << 0)
	filesDownloadRequestMetaListRequestFieldCreatedBefore      = big.NewInt(1 << 1)
	filesDownloadRequestMetaListRequestFieldCursor             = big.NewInt(1 << 2)
	filesDownloadRequestMetaListRequestFieldIncludeDeletedData = big.NewInt(1 << 3)
	filesDownloadRequestMetaListRequestFieldMimeTypes          = big.NewInt(1 << 4)
	filesDownloadRequestMetaListRequestFieldModifiedAfter      = big.NewInt(1 << 5)
	filesDownloadRequestMetaListRequestFieldModifiedBefore     = big.NewInt(1 << 6)
	filesDownloadRequestMetaListRequestFieldOrderBy            = big.NewInt(1 << 7)
	filesDownloadRequestMetaListRequestFieldPageSize           = big.NewInt(1 << 8)
)

type FilesDownloadRequestMetaListRequest struct {
	// If provided, will only return objects created after this datetime.
	CreatedAfter *string `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *string `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// A comma-separated list of preferred MIME types in order of priority. If supported by the third-party provider, the file(s) will be returned in the first supported MIME type from the list. The default MIME type is PDF. To see supported MIME types by file type, refer to our <a href='https://help.merge.dev/en/articles/8615316-file-export-and-download-specification' target='_blank'>export format help center article</a>.
	MimeTypes *string `json:"-" url:"mime_types,omitempty"`
	// If provided, will only return objects modified after this datetime.
	ModifiedAfter *string `json:"-" url:"modified_after,omitempty"`
	// If provided, will only return objects modified before this datetime.
	ModifiedBefore *string `json:"-" url:"modified_before,omitempty"`
	// Overrides the default ordering for this endpoint. Possible values include: created_at, -created_at, modified_at, -modified_at.
	OrderBy *FilesDownloadRequestMetaListRequestOrderBy `json:"-" url:"order_by,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FilesDownloadRequestMetaListRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetCreatedAfter(createdAfter *string) {
	f.CreatedAfter = createdAfter
	f.require(filesDownloadRequestMetaListRequestFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetCreatedBefore(createdBefore *string) {
	f.CreatedBefore = createdBefore
	f.require(filesDownloadRequestMetaListRequestFieldCreatedBefore)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetCursor(cursor *string) {
	f.Cursor = cursor
	f.require(filesDownloadRequestMetaListRequestFieldCursor)
}

// SetIncludeDeletedData sets the IncludeDeletedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetIncludeDeletedData(includeDeletedData *bool) {
	f.IncludeDeletedData = includeDeletedData
	f.require(filesDownloadRequestMetaListRequestFieldIncludeDeletedData)
}

// SetMimeTypes sets the MimeTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetMimeTypes(mimeTypes *string) {
	f.MimeTypes = mimeTypes
	f.require(filesDownloadRequestMetaListRequestFieldMimeTypes)
}

// SetModifiedAfter sets the ModifiedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetModifiedAfter(modifiedAfter *string) {
	f.ModifiedAfter = modifiedAfter
	f.require(filesDownloadRequestMetaListRequestFieldModifiedAfter)
}

// SetModifiedBefore sets the ModifiedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetModifiedBefore(modifiedBefore *string) {
	f.ModifiedBefore = modifiedBefore
	f.require(filesDownloadRequestMetaListRequestFieldModifiedBefore)
}

// SetOrderBy sets the OrderBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetOrderBy(orderBy *FilesDownloadRequestMetaListRequestOrderBy) {
	f.OrderBy = orderBy
	f.require(filesDownloadRequestMetaListRequestFieldOrderBy)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaListRequest) SetPageSize(pageSize *int) {
	f.PageSize = pageSize
	f.require(filesDownloadRequestMetaListRequestFieldPageSize)
}

var (
	filesDownloadRequestMetaRetrieveRequestFieldMimeType = big.NewInt(1 << 0)
)

type FilesDownloadRequestMetaRetrieveRequest struct {
	// If provided, specifies the export format of the file to be downloaded. For information on supported export formats, please refer to our <a href='https://help.merge.dev/en/articles/8615316-file-export-and-download-specification' target='_blank'>export format help center article</a>.
	MimeType *string `json:"-" url:"mime_type,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FilesDownloadRequestMetaRetrieveRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRequestMetaRetrieveRequest) SetMimeType(mimeType *string) {
	f.MimeType = mimeType
	f.require(filesDownloadRequestMetaRetrieveRequestFieldMimeType)
}

var (
	filesDownloadRetrieveRequestFieldIncludeShellData = big.NewInt(1 << 0)
	filesDownloadRetrieveRequestFieldMimeType         = big.NewInt(1 << 1)
)

type FilesDownloadRetrieveRequest struct {
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, specifies the export format of the file to be downloaded. For information on supported export formats, please refer to our <a href='https://help.merge.dev/en/articles/8615316-file-export-and-download-specification' target='_blank'>export format help center article</a>.
	MimeType *string `json:"-" url:"mime_type,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FilesDownloadRetrieveRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRetrieveRequest) SetIncludeShellData(includeShellData *bool) {
	f.IncludeShellData = includeShellData
	f.require(filesDownloadRetrieveRequestFieldIncludeShellData)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesDownloadRetrieveRequest) SetMimeType(mimeType *string) {
	f.MimeType = mimeType
	f.require(filesDownloadRetrieveRequestFieldMimeType)
}

var (
	filesListRequestFieldCreatedAfter       = big.NewInt(1 << 0)
	filesListRequestFieldCreatedBefore      = big.NewInt(1 << 1)
	filesListRequestFieldCursor             = big.NewInt(1 << 2)
	filesListRequestFieldDriveId            = big.NewInt(1 << 3)
	filesListRequestFieldExpand             = big.NewInt(1 << 4)
	filesListRequestFieldFolderId           = big.NewInt(1 << 5)
	filesListRequestFieldIncludeDeletedData = big.NewInt(1 << 6)
	filesListRequestFieldIncludeRemoteData  = big.NewInt(1 << 7)
	filesListRequestFieldIncludeShellData   = big.NewInt(1 << 8)
	filesListRequestFieldMimeType           = big.NewInt(1 << 9)
	filesListRequestFieldModifiedAfter      = big.NewInt(1 << 10)
	filesListRequestFieldModifiedBefore     = big.NewInt(1 << 11)
	filesListRequestFieldName               = big.NewInt(1 << 12)
	filesListRequestFieldOrderBy            = big.NewInt(1 << 13)
	filesListRequestFieldPageSize           = big.NewInt(1 << 14)
	filesListRequestFieldRemoteId           = big.NewInt(1 << 15)
)

type FilesListRequest struct {
	// If provided, will only return objects created after this datetime.
	CreatedAfter *time.Time `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *time.Time `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Specifying a drive id returns only the files in that drive. Specifying null returns only the files outside the top-level drive.
	DriveId *string `json:"-" url:"drive_id,omitempty"`
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*FilesListRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Specifying a folder id returns only the files in that folder. Specifying null returns only the files in root directory.
	FolderId *string `json:"-" url:"folder_id,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return files with these mime_types. Multiple values can be separated by commas.
	MimeType *string `json:"-" url:"mime_type,omitempty"`
	// If provided, only objects synced by Merge after this date time will be returned.
	ModifiedAfter *time.Time `json:"-" url:"modified_after,omitempty"`
	// If provided, only objects synced by Merge before this date time will be returned.
	ModifiedBefore *time.Time `json:"-" url:"modified_before,omitempty"`
	// If provided, will only return files with this name. This performs an exact match.
	Name *string `json:"-" url:"name,omitempty"`
	// Overrides the default ordering for this endpoint. Possible values include: created_at, -created_at, modified_at, -modified_at.
	OrderBy *FilesListRequestOrderBy `json:"-" url:"order_by,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// The API provider's ID for the given object.
	RemoteId *string `json:"-" url:"remote_id,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FilesListRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetCreatedAfter(createdAfter *time.Time) {
	f.CreatedAfter = createdAfter
	f.require(filesListRequestFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetCreatedBefore(createdBefore *time.Time) {
	f.CreatedBefore = createdBefore
	f.require(filesListRequestFieldCreatedBefore)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetCursor(cursor *string) {
	f.Cursor = cursor
	f.require(filesListRequestFieldCursor)
}

// SetDriveId sets the DriveId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetDriveId(driveId *string) {
	f.DriveId = driveId
	f.require(filesListRequestFieldDriveId)
}

// SetExpand sets the Expand field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetExpand(expand []*FilesListRequestExpandItem) {
	f.Expand = expand
	f.require(filesListRequestFieldExpand)
}

// SetFolderId sets the FolderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetFolderId(folderId *string) {
	f.FolderId = folderId
	f.require(filesListRequestFieldFolderId)
}

// SetIncludeDeletedData sets the IncludeDeletedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetIncludeDeletedData(includeDeletedData *bool) {
	f.IncludeDeletedData = includeDeletedData
	f.require(filesListRequestFieldIncludeDeletedData)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	f.IncludeRemoteData = includeRemoteData
	f.require(filesListRequestFieldIncludeRemoteData)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetIncludeShellData(includeShellData *bool) {
	f.IncludeShellData = includeShellData
	f.require(filesListRequestFieldIncludeShellData)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetMimeType(mimeType *string) {
	f.MimeType = mimeType
	f.require(filesListRequestFieldMimeType)
}

// SetModifiedAfter sets the ModifiedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetModifiedAfter(modifiedAfter *time.Time) {
	f.ModifiedAfter = modifiedAfter
	f.require(filesListRequestFieldModifiedAfter)
}

// SetModifiedBefore sets the ModifiedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetModifiedBefore(modifiedBefore *time.Time) {
	f.ModifiedBefore = modifiedBefore
	f.require(filesListRequestFieldModifiedBefore)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetName(name *string) {
	f.Name = name
	f.require(filesListRequestFieldName)
}

// SetOrderBy sets the OrderBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetOrderBy(orderBy *FilesListRequestOrderBy) {
	f.OrderBy = orderBy
	f.require(filesListRequestFieldOrderBy)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetPageSize(pageSize *int) {
	f.PageSize = pageSize
	f.require(filesListRequestFieldPageSize)
}

// SetRemoteId sets the RemoteId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesListRequest) SetRemoteId(remoteId *string) {
	f.RemoteId = remoteId
	f.require(filesListRequestFieldRemoteId)
}

var (
	filesRetrieveRequestFieldExpand            = big.NewInt(1 << 0)
	filesRetrieveRequestFieldIncludeRemoteData = big.NewInt(1 << 1)
	filesRetrieveRequestFieldIncludeShellData  = big.NewInt(1 << 2)
)

type FilesRetrieveRequest struct {
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*FilesRetrieveRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FilesRetrieveRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetExpand sets the Expand field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesRetrieveRequest) SetExpand(expand []*FilesRetrieveRequestExpandItem) {
	f.Expand = expand
	f.require(filesRetrieveRequestFieldExpand)
}

// SetIncludeRemoteData sets the IncludeRemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesRetrieveRequest) SetIncludeRemoteData(includeRemoteData *bool) {
	f.IncludeRemoteData = includeRemoteData
	f.require(filesRetrieveRequestFieldIncludeRemoteData)
}

// SetIncludeShellData sets the IncludeShellData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FilesRetrieveRequest) SetIncludeShellData(includeShellData *bool) {
	f.IncludeShellData = includeShellData
	f.require(filesRetrieveRequestFieldIncludeShellData)
}

type FilesDownloadRequestMetaListRequestOrderBy string

const (
	FilesDownloadRequestMetaListRequestOrderByCreatedAtDescending  FilesDownloadRequestMetaListRequestOrderBy = "-created_at"
	FilesDownloadRequestMetaListRequestOrderByModifiedAtDescending FilesDownloadRequestMetaListRequestOrderBy = "-modified_at"
	FilesDownloadRequestMetaListRequestOrderByCreatedAtAscending   FilesDownloadRequestMetaListRequestOrderBy = "created_at"
	FilesDownloadRequestMetaListRequestOrderByModifiedAtAscending  FilesDownloadRequestMetaListRequestOrderBy = "modified_at"
)

func NewFilesDownloadRequestMetaListRequestOrderByFromString(s string) (FilesDownloadRequestMetaListRequestOrderBy, error) {
	switch s {
	case "-created_at":
		return FilesDownloadRequestMetaListRequestOrderByCreatedAtDescending, nil
	case "-modified_at":
		return FilesDownloadRequestMetaListRequestOrderByModifiedAtDescending, nil
	case "created_at":
		return FilesDownloadRequestMetaListRequestOrderByCreatedAtAscending, nil
	case "modified_at":
		return FilesDownloadRequestMetaListRequestOrderByModifiedAtAscending, nil
	}
	var t FilesDownloadRequestMetaListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilesDownloadRequestMetaListRequestOrderBy) Ptr() *FilesDownloadRequestMetaListRequestOrderBy {
	return &f
}

type FilesListRequestExpandItem string

const (
	FilesListRequestExpandItemDrive       FilesListRequestExpandItem = "drive"
	FilesListRequestExpandItemFolder      FilesListRequestExpandItem = "folder"
	FilesListRequestExpandItemPermissions FilesListRequestExpandItem = "permissions"
)

func NewFilesListRequestExpandItemFromString(s string) (FilesListRequestExpandItem, error) {
	switch s {
	case "drive":
		return FilesListRequestExpandItemDrive, nil
	case "folder":
		return FilesListRequestExpandItemFolder, nil
	case "permissions":
		return FilesListRequestExpandItemPermissions, nil
	}
	var t FilesListRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilesListRequestExpandItem) Ptr() *FilesListRequestExpandItem {
	return &f
}

type FilesListRequestOrderBy string

const (
	FilesListRequestOrderByCreatedAtDescending  FilesListRequestOrderBy = "-created_at"
	FilesListRequestOrderByModifiedAtDescending FilesListRequestOrderBy = "-modified_at"
	FilesListRequestOrderByCreatedAtAscending   FilesListRequestOrderBy = "created_at"
	FilesListRequestOrderByModifiedAtAscending  FilesListRequestOrderBy = "modified_at"
)

func NewFilesListRequestOrderByFromString(s string) (FilesListRequestOrderBy, error) {
	switch s {
	case "-created_at":
		return FilesListRequestOrderByCreatedAtDescending, nil
	case "-modified_at":
		return FilesListRequestOrderByModifiedAtDescending, nil
	case "created_at":
		return FilesListRequestOrderByCreatedAtAscending, nil
	case "modified_at":
		return FilesListRequestOrderByModifiedAtAscending, nil
	}
	var t FilesListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilesListRequestOrderBy) Ptr() *FilesListRequestOrderBy {
	return &f
}

type FilesRetrieveRequestExpandItem string

const (
	FilesRetrieveRequestExpandItemDrive       FilesRetrieveRequestExpandItem = "drive"
	FilesRetrieveRequestExpandItemFolder      FilesRetrieveRequestExpandItem = "folder"
	FilesRetrieveRequestExpandItemPermissions FilesRetrieveRequestExpandItem = "permissions"
)

func NewFilesRetrieveRequestExpandItemFromString(s string) (FilesRetrieveRequestExpandItem, error) {
	switch s {
	case "drive":
		return FilesRetrieveRequestExpandItemDrive, nil
	case "folder":
		return FilesRetrieveRequestExpandItemFolder, nil
	case "permissions":
		return FilesRetrieveRequestExpandItemPermissions, nil
	}
	var t FilesRetrieveRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilesRetrieveRequestExpandItem) Ptr() *FilesRetrieveRequestExpandItem {
	return &f
}

var (
	downloadRequestMetaFieldId      = big.NewInt(1 << 0)
	downloadRequestMetaFieldUrl     = big.NewInt(1 << 1)
	downloadRequestMetaFieldMethod  = big.NewInt(1 << 2)
	downloadRequestMetaFieldHeaders = big.NewInt(1 << 3)
)

type DownloadRequestMeta struct {
	Id      string                 `json:"id" url:"id"`
	Url     string                 `json:"url" url:"url"`
	Method  string                 `json:"method" url:"method"`
	Headers map[string]interface{} `json:"headers" url:"headers"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DownloadRequestMeta) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DownloadRequestMeta) GetUrl() string {
	if d == nil {
		return ""
	}
	return d.Url
}

func (d *DownloadRequestMeta) GetMethod() string {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DownloadRequestMeta) GetHeaders() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DownloadRequestMeta) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DownloadRequestMeta) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DownloadRequestMeta) SetId(id string) {
	d.Id = id
	d.require(downloadRequestMetaFieldId)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DownloadRequestMeta) SetUrl(url string) {
	d.Url = url
	d.require(downloadRequestMetaFieldUrl)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DownloadRequestMeta) SetMethod(method string) {
	d.Method = method
	d.require(downloadRequestMetaFieldMethod)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DownloadRequestMeta) SetHeaders(headers map[string]interface{}) {
	d.Headers = headers
	d.require(downloadRequestMetaFieldHeaders)
}

func (d *DownloadRequestMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler DownloadRequestMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DownloadRequestMeta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DownloadRequestMeta) MarshalJSON() ([]byte, error) {
	type embed DownloadRequestMeta
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DownloadRequestMeta) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// # The File Object
// ### Description
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
var (
	fileFieldId               = big.NewInt(1 << 0)
	fileFieldRemoteId         = big.NewInt(1 << 1)
	fileFieldCreatedAt        = big.NewInt(1 << 2)
	fileFieldModifiedAt       = big.NewInt(1 << 3)
	fileFieldName             = big.NewInt(1 << 4)
	fileFieldFileUrl          = big.NewInt(1 << 5)
	fileFieldFileThumbnailUrl = big.NewInt(1 << 6)
	fileFieldSize             = big.NewInt(1 << 7)
	fileFieldMimeType         = big.NewInt(1 << 8)
	fileFieldDescription      = big.NewInt(1 << 9)
	fileFieldFolder           = big.NewInt(1 << 10)
	fileFieldChecksum         = big.NewInt(1 << 11)
	fileFieldPermissions      = big.NewInt(1 << 12)
	fileFieldDrive            = big.NewInt(1 << 13)
	fileFieldRemoteCreatedAt  = big.NewInt(1 << 14)
	fileFieldRemoteUpdatedAt  = big.NewInt(1 << 15)
	fileFieldRemoteWasDeleted = big.NewInt(1 << 16)
	fileFieldFieldMappings    = big.NewInt(1 << 17)
	fileFieldRemoteData       = big.NewInt(1 << 18)
)

type File struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The file's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty" url:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty" url:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int64 `json:"size,omitempty" url:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty" url:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *FileFolder `json:"folder,omitempty" url:"folder,omitempty"`
	// This field stores file checksum data. 'type' indicates the algorithm (e.g. crc_32, sha1, sha256, quickXor, or md5), and 'content_hash' is the unique hash used to verify file integrity and detect alterations.
	Checksum map[string]interface{} `json:"checksum,omitempty" url:"checksum,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FilePermissions `json:"permissions,omitempty" url:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive *FileDrive `json:"drive,omitempty" url:"drive,omitempty"`
	// When the third party's file was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's file was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *File) GetId() *string {
	if f == nil {
		return nil
	}
	return f.Id
}

func (f *File) GetRemoteId() *string {
	if f == nil {
		return nil
	}
	return f.RemoteId
}

func (f *File) GetCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedAt
}

func (f *File) GetModifiedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.ModifiedAt
}

func (f *File) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *File) GetFileUrl() *string {
	if f == nil {
		return nil
	}
	return f.FileUrl
}

func (f *File) GetFileThumbnailUrl() *string {
	if f == nil {
		return nil
	}
	return f.FileThumbnailUrl
}

func (f *File) GetSize() *int64 {
	if f == nil {
		return nil
	}
	return f.Size
}

func (f *File) GetMimeType() *string {
	if f == nil {
		return nil
	}
	return f.MimeType
}

func (f *File) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *File) GetFolder() *FileFolder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *File) GetChecksum() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Checksum
}

func (f *File) GetPermissions() *FilePermissions {
	if f == nil {
		return nil
	}
	return f.Permissions
}

func (f *File) GetDrive() *FileDrive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *File) GetRemoteCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.RemoteCreatedAt
}

func (f *File) GetRemoteUpdatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.RemoteUpdatedAt
}

func (f *File) GetRemoteWasDeleted() *bool {
	if f == nil {
		return nil
	}
	return f.RemoteWasDeleted
}

func (f *File) GetFieldMappings() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.FieldMappings
}

func (f *File) GetRemoteData() []*RemoteData {
	if f == nil {
		return nil
	}
	return f.RemoteData
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetId(id *string) {
	f.Id = id
	f.require(fileFieldId)
}

// SetRemoteId sets the RemoteId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetRemoteId(remoteId *string) {
	f.RemoteId = remoteId
	f.require(fileFieldRemoteId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetCreatedAt(createdAt *time.Time) {
	f.CreatedAt = createdAt
	f.require(fileFieldCreatedAt)
}

// SetModifiedAt sets the ModifiedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetModifiedAt(modifiedAt *time.Time) {
	f.ModifiedAt = modifiedAt
	f.require(fileFieldModifiedAt)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetName(name *string) {
	f.Name = name
	f.require(fileFieldName)
}

// SetFileUrl sets the FileUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetFileUrl(fileUrl *string) {
	f.FileUrl = fileUrl
	f.require(fileFieldFileUrl)
}

// SetFileThumbnailUrl sets the FileThumbnailUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetFileThumbnailUrl(fileThumbnailUrl *string) {
	f.FileThumbnailUrl = fileThumbnailUrl
	f.require(fileFieldFileThumbnailUrl)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetSize(size *int64) {
	f.Size = size
	f.require(fileFieldSize)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetMimeType(mimeType *string) {
	f.MimeType = mimeType
	f.require(fileFieldMimeType)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetDescription(description *string) {
	f.Description = description
	f.require(fileFieldDescription)
}

// SetFolder sets the Folder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetFolder(folder *FileFolder) {
	f.Folder = folder
	f.require(fileFieldFolder)
}

// SetChecksum sets the Checksum field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetChecksum(checksum map[string]interface{}) {
	f.Checksum = checksum
	f.require(fileFieldChecksum)
}

// SetPermissions sets the Permissions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetPermissions(permissions *FilePermissions) {
	f.Permissions = permissions
	f.require(fileFieldPermissions)
}

// SetDrive sets the Drive field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetDrive(drive *FileDrive) {
	f.Drive = drive
	f.require(fileFieldDrive)
}

// SetRemoteCreatedAt sets the RemoteCreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetRemoteCreatedAt(remoteCreatedAt *time.Time) {
	f.RemoteCreatedAt = remoteCreatedAt
	f.require(fileFieldRemoteCreatedAt)
}

// SetRemoteUpdatedAt sets the RemoteUpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetRemoteUpdatedAt(remoteUpdatedAt *time.Time) {
	f.RemoteUpdatedAt = remoteUpdatedAt
	f.require(fileFieldRemoteUpdatedAt)
}

// SetRemoteWasDeleted sets the RemoteWasDeleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetRemoteWasDeleted(remoteWasDeleted *bool) {
	f.RemoteWasDeleted = remoteWasDeleted
	f.require(fileFieldRemoteWasDeleted)
}

// SetFieldMappings sets the FieldMappings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetFieldMappings(fieldMappings map[string]interface{}) {
	f.FieldMappings = fieldMappings
	f.require(fileFieldFieldMappings)
}

// SetRemoteData sets the RemoteData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *File) SetRemoteData(remoteData []*RemoteData) {
	f.RemoteData = remoteData
	f.require(fileFieldRemoteData)
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	f.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	f.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	f.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
	}{
		embed:           embed(*f),
		CreatedAt:       internal.NewOptionalDateTime(f.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(f.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(f.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(f.RemoteUpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *File) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the file belongs to.
type FileDrive struct {
	String string
	Drive  *Drive

	typ string
}

func (f *FileDrive) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileDrive) GetDrive() *Drive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *FileDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typ = "Drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileDrive) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return json.Marshal(f.Drive)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FileDrive) Accept(visitor FileDriveVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return visitor.VisitDrive(f.Drive)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The folder that the file belongs to.
type FileFolder struct {
	String string
	Folder *Folder

	typ string
}

func (f *FileFolder) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileFolder) GetFolder() *Folder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *FileFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typ = "Folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileFolder) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return json.Marshal(f.Folder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FileFolder) Accept(visitor FileFolderVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return visitor.VisitFolder(f.Folder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FilePermissions struct {
	String                  string
	Permission              *Permission
	FilePermissionsItemList []*FilePermissionsItem

	typ string
}

func (f *FilePermissions) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FilePermissions) GetPermission() *Permission {
	if f == nil {
		return nil
	}
	return f.Permission
}

func (f *FilePermissions) GetFilePermissionsItemList() []*FilePermissionsItem {
	if f == nil {
		return nil
	}
	return f.FilePermissionsItemList
}

func (f *FilePermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermission := new(Permission)
	if err := json.Unmarshal(data, &valuePermission); err == nil {
		f.typ = "Permission"
		f.Permission = valuePermission
		return nil
	}
	var valueFilePermissionsItemList []*FilePermissionsItem
	if err := json.Unmarshal(data, &valueFilePermissionsItemList); err == nil {
		f.typ = "FilePermissionsItemList"
		f.FilePermissionsItemList = valueFilePermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissions) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return json.Marshal(f.Permission)
	}
	if f.typ == "FilePermissionsItemList" || f.FilePermissionsItemList != nil {
		return json.Marshal(f.FilePermissionsItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilePermissionsVisitor interface {
	VisitString(string) error
	VisitPermission(*Permission) error
	VisitFilePermissionsItemList([]*FilePermissionsItem) error
}

func (f *FilePermissions) Accept(visitor FilePermissionsVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return visitor.VisitPermission(f.Permission)
	}
	if f.typ == "FilePermissionsItemList" || f.FilePermissionsItemList != nil {
		return visitor.VisitFilePermissionsItemList(f.FilePermissionsItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilePermissionsItem struct {
	String     string
	Permission *Permission

	typ string
}

func (f *FilePermissionsItem) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FilePermissionsItem) GetPermission() *Permission {
	if f == nil {
		return nil
	}
	return f.Permission
}

func (f *FilePermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermission := new(Permission)
	if err := json.Unmarshal(data, &valuePermission); err == nil {
		f.typ = "Permission"
		f.Permission = valuePermission
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilePermissionsItem) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return json.Marshal(f.Permission)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FilePermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermission(*Permission) error
}

func (f *FilePermissionsItem) Accept(visitor FilePermissionsItemVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Permission" || f.Permission != nil {
		return visitor.VisitPermission(f.Permission)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// # The File Object
// ### Description
// The `File` object is used to represent a file in the workspace. The Object typically exists under a folder or drive, if it exists.
// ### Usage Example
// Fetch from the `GET /api/filestorage/v1/files` endpoint and view their files.
var (
	fileRequestFieldName                = big.NewInt(1 << 0)
	fileRequestFieldFileUrl             = big.NewInt(1 << 1)
	fileRequestFieldFileThumbnailUrl    = big.NewInt(1 << 2)
	fileRequestFieldSize                = big.NewInt(1 << 3)
	fileRequestFieldMimeType            = big.NewInt(1 << 4)
	fileRequestFieldDescription         = big.NewInt(1 << 5)
	fileRequestFieldFolder              = big.NewInt(1 << 6)
	fileRequestFieldChecksum            = big.NewInt(1 << 7)
	fileRequestFieldPermissions         = big.NewInt(1 << 8)
	fileRequestFieldDrive               = big.NewInt(1 << 9)
	fileRequestFieldIntegrationParams   = big.NewInt(1 << 10)
	fileRequestFieldLinkedAccountParams = big.NewInt(1 << 11)
)

type FileRequest struct {
	// The file's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL to access the file.
	FileUrl *string `json:"file_url,omitempty" url:"file_url,omitempty"`
	// The URL that produces a thumbnail preview of the file. Typically an image.
	FileThumbnailUrl *string `json:"file_thumbnail_url,omitempty" url:"file_thumbnail_url,omitempty"`
	// The file's size, in bytes.
	Size *int64 `json:"size,omitempty" url:"size,omitempty"`
	// The file's mime type.
	MimeType *string `json:"mime_type,omitempty" url:"mime_type,omitempty"`
	// The file's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The folder that the file belongs to.
	Folder *FileRequestFolder `json:"folder,omitempty" url:"folder,omitempty"`
	// This field stores file checksum data. 'type' indicates the algorithm (e.g. crc_32, sha1, sha256, quickXor, or md5), and 'content_hash' is the unique hash used to verify file integrity and detect alterations.
	Checksum map[string]interface{} `json:"checksum,omitempty" url:"checksum,omitempty"`
	// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
	Permissions *FileRequestPermissions `json:"permissions,omitempty" url:"permissions,omitempty"`
	// The drive that the file belongs to.
	Drive               *FileRequestDrive      `json:"drive,omitempty" url:"drive,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileRequest) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FileRequest) GetFileUrl() *string {
	if f == nil {
		return nil
	}
	return f.FileUrl
}

func (f *FileRequest) GetFileThumbnailUrl() *string {
	if f == nil {
		return nil
	}
	return f.FileThumbnailUrl
}

func (f *FileRequest) GetSize() *int64 {
	if f == nil {
		return nil
	}
	return f.Size
}

func (f *FileRequest) GetMimeType() *string {
	if f == nil {
		return nil
	}
	return f.MimeType
}

func (f *FileRequest) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *FileRequest) GetFolder() *FileRequestFolder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *FileRequest) GetChecksum() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Checksum
}

func (f *FileRequest) GetPermissions() *FileRequestPermissions {
	if f == nil {
		return nil
	}
	return f.Permissions
}

func (f *FileRequest) GetDrive() *FileRequestDrive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *FileRequest) GetIntegrationParams() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.IntegrationParams
}

func (f *FileRequest) GetLinkedAccountParams() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.LinkedAccountParams
}

func (f *FileRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetName(name *string) {
	f.Name = name
	f.require(fileRequestFieldName)
}

// SetFileUrl sets the FileUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetFileUrl(fileUrl *string) {
	f.FileUrl = fileUrl
	f.require(fileRequestFieldFileUrl)
}

// SetFileThumbnailUrl sets the FileThumbnailUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetFileThumbnailUrl(fileThumbnailUrl *string) {
	f.FileThumbnailUrl = fileThumbnailUrl
	f.require(fileRequestFieldFileThumbnailUrl)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetSize(size *int64) {
	f.Size = size
	f.require(fileRequestFieldSize)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetMimeType(mimeType *string) {
	f.MimeType = mimeType
	f.require(fileRequestFieldMimeType)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetDescription(description *string) {
	f.Description = description
	f.require(fileRequestFieldDescription)
}

// SetFolder sets the Folder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetFolder(folder *FileRequestFolder) {
	f.Folder = folder
	f.require(fileRequestFieldFolder)
}

// SetChecksum sets the Checksum field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetChecksum(checksum map[string]interface{}) {
	f.Checksum = checksum
	f.require(fileRequestFieldChecksum)
}

// SetPermissions sets the Permissions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetPermissions(permissions *FileRequestPermissions) {
	f.Permissions = permissions
	f.require(fileRequestFieldPermissions)
}

// SetDrive sets the Drive field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetDrive(drive *FileRequestDrive) {
	f.Drive = drive
	f.require(fileRequestFieldDrive)
}

// SetIntegrationParams sets the IntegrationParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetIntegrationParams(integrationParams map[string]interface{}) {
	f.IntegrationParams = integrationParams
	f.require(fileRequestFieldIntegrationParams)
}

// SetLinkedAccountParams sets the LinkedAccountParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileRequest) SetLinkedAccountParams(linkedAccountParams map[string]interface{}) {
	f.LinkedAccountParams = linkedAccountParams
	f.require(fileRequestFieldLinkedAccountParams)
}

func (f *FileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileRequest) MarshalJSON() ([]byte, error) {
	type embed FileRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The drive that the file belongs to.
type FileRequestDrive struct {
	String string
	Drive  *Drive

	typ string
}

func (f *FileRequestDrive) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileRequestDrive) GetDrive() *Drive {
	if f == nil {
		return nil
	}
	return f.Drive
}

func (f *FileRequestDrive) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueDrive := new(Drive)
	if err := json.Unmarshal(data, &valueDrive); err == nil {
		f.typ = "Drive"
		f.Drive = valueDrive
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestDrive) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return json.Marshal(f.Drive)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestDriveVisitor interface {
	VisitString(string) error
	VisitDrive(*Drive) error
}

func (f *FileRequestDrive) Accept(visitor FileRequestDriveVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Drive" || f.Drive != nil {
		return visitor.VisitDrive(f.Drive)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The folder that the file belongs to.
type FileRequestFolder struct {
	String string
	Folder *Folder

	typ string
}

func (f *FileRequestFolder) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileRequestFolder) GetFolder() *Folder {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *FileRequestFolder) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valueFolder := new(Folder)
	if err := json.Unmarshal(data, &valueFolder); err == nil {
		f.typ = "Folder"
		f.Folder = valueFolder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestFolder) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return json.Marshal(f.Folder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestFolderVisitor interface {
	VisitString(string) error
	VisitFolder(*Folder) error
}

func (f *FileRequestFolder) Accept(visitor FileRequestFolderVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "Folder" || f.Folder != nil {
		return visitor.VisitFolder(f.Folder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// The Permission object is used to represent a user's or group's access to a File or Folder. Permissions are unexpanded by default. Use the query param `expand=permissions` to see more details under `GET /files`.
type FileRequestPermissions struct {
	String                         string
	PermissionRequest              *PermissionRequest
	FileRequestPermissionsItemList []*FileRequestPermissionsItem

	typ string
}

func (f *FileRequestPermissions) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileRequestPermissions) GetPermissionRequest() *PermissionRequest {
	if f == nil {
		return nil
	}
	return f.PermissionRequest
}

func (f *FileRequestPermissions) GetFileRequestPermissionsItemList() []*FileRequestPermissionsItem {
	if f == nil {
		return nil
	}
	return f.FileRequestPermissionsItemList
}

func (f *FileRequestPermissions) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typ = "PermissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	var valueFileRequestPermissionsItemList []*FileRequestPermissionsItem
	if err := json.Unmarshal(data, &valueFileRequestPermissionsItemList); err == nil {
		f.typ = "FileRequestPermissionsItemList"
		f.FileRequestPermissionsItemList = valueFileRequestPermissionsItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissions) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "PermissionRequest" || f.PermissionRequest != nil {
		return json.Marshal(f.PermissionRequest)
	}
	if f.typ == "FileRequestPermissionsItemList" || f.FileRequestPermissionsItemList != nil {
		return json.Marshal(f.FileRequestPermissionsItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestPermissionsVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
	VisitFileRequestPermissionsItemList([]*FileRequestPermissionsItem) error
}

func (f *FileRequestPermissions) Accept(visitor FileRequestPermissionsVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "PermissionRequest" || f.PermissionRequest != nil {
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
	if f.typ == "FileRequestPermissionsItemList" || f.FileRequestPermissionsItemList != nil {
		return visitor.VisitFileRequestPermissionsItemList(f.FileRequestPermissionsItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestPermissionsItem struct {
	String            string
	PermissionRequest *PermissionRequest

	typ string
}

func (f *FileRequestPermissionsItem) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FileRequestPermissionsItem) GetPermissionRequest() *PermissionRequest {
	if f == nil {
		return nil
	}
	return f.PermissionRequest
}

func (f *FileRequestPermissionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	valuePermissionRequest := new(PermissionRequest)
	if err := json.Unmarshal(data, &valuePermissionRequest); err == nil {
		f.typ = "PermissionRequest"
		f.PermissionRequest = valuePermissionRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FileRequestPermissionsItem) MarshalJSON() ([]byte, error) {
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	if f.typ == "PermissionRequest" || f.PermissionRequest != nil {
		return json.Marshal(f.PermissionRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FileRequestPermissionsItemVisitor interface {
	VisitString(string) error
	VisitPermissionRequest(*PermissionRequest) error
}

func (f *FileRequestPermissionsItem) Accept(visitor FileRequestPermissionsItemVisitor) error {
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.typ == "PermissionRequest" || f.PermissionRequest != nil {
		return visitor.VisitPermissionRequest(f.PermissionRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

var (
	fileStorageFileResponseFieldModel    = big.NewInt(1 << 0)
	fileStorageFileResponseFieldWarnings = big.NewInt(1 << 1)
	fileStorageFileResponseFieldErrors   = big.NewInt(1 << 2)
	fileStorageFileResponseFieldLogs     = big.NewInt(1 << 3)
)

type FileStorageFileResponse struct {
	Model    *File                       `json:"model" url:"model"`
	Warnings []*WarningValidationProblem `json:"warnings" url:"warnings"`
	Errors   []*ErrorValidationProblem   `json:"errors" url:"errors"`
	Logs     []*DebugModeLog             `json:"logs,omitempty" url:"logs,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileStorageFileResponse) GetModel() *File {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FileStorageFileResponse) GetWarnings() []*WarningValidationProblem {
	if f == nil {
		return nil
	}
	return f.Warnings
}

func (f *FileStorageFileResponse) GetErrors() []*ErrorValidationProblem {
	if f == nil {
		return nil
	}
	return f.Errors
}

func (f *FileStorageFileResponse) GetLogs() []*DebugModeLog {
	if f == nil {
		return nil
	}
	return f.Logs
}

func (f *FileStorageFileResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileStorageFileResponse) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileStorageFileResponse) SetModel(model *File) {
	f.Model = model
	f.require(fileStorageFileResponseFieldModel)
}

// SetWarnings sets the Warnings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileStorageFileResponse) SetWarnings(warnings []*WarningValidationProblem) {
	f.Warnings = warnings
	f.require(fileStorageFileResponseFieldWarnings)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileStorageFileResponse) SetErrors(errors []*ErrorValidationProblem) {
	f.Errors = errors
	f.require(fileStorageFileResponseFieldErrors)
}

// SetLogs sets the Logs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileStorageFileResponse) SetLogs(logs []*DebugModeLog) {
	f.Logs = logs
	f.require(fileStorageFileResponseFieldLogs)
}

func (f *FileStorageFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileStorageFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileStorageFileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileStorageFileResponse) MarshalJSON() ([]byte, error) {
	type embed FileStorageFileResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileStorageFileResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	paginatedDownloadRequestMetaListFieldNext     = big.NewInt(1 << 0)
	paginatedDownloadRequestMetaListFieldPrevious = big.NewInt(1 << 1)
	paginatedDownloadRequestMetaListFieldResults  = big.NewInt(1 << 2)
)

type PaginatedDownloadRequestMetaList struct {
	Next     *string                `json:"next,omitempty" url:"next,omitempty"`
	Previous *string                `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*DownloadRequestMeta `json:"results,omitempty" url:"results,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedDownloadRequestMetaList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedDownloadRequestMetaList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedDownloadRequestMetaList) GetResults() []*DownloadRequestMeta {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedDownloadRequestMetaList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedDownloadRequestMetaList) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedDownloadRequestMetaList) SetNext(next *string) {
	p.Next = next
	p.require(paginatedDownloadRequestMetaListFieldNext)
}

// SetPrevious sets the Previous field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedDownloadRequestMetaList) SetPrevious(previous *string) {
	p.Previous = previous
	p.require(paginatedDownloadRequestMetaListFieldPrevious)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedDownloadRequestMetaList) SetResults(results []*DownloadRequestMeta) {
	p.Results = results
	p.require(paginatedDownloadRequestMetaListFieldResults)
}

func (p *PaginatedDownloadRequestMetaList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedDownloadRequestMetaList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedDownloadRequestMetaList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedDownloadRequestMetaList) MarshalJSON() ([]byte, error) {
	type embed PaginatedDownloadRequestMetaList
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedDownloadRequestMetaList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paginatedFileListFieldNext     = big.NewInt(1 << 0)
	paginatedFileListFieldPrevious = big.NewInt(1 << 1)
	paginatedFileListFieldResults  = big.NewInt(1 << 2)
)

type PaginatedFileList struct {
	Next     *string `json:"next,omitempty" url:"next,omitempty"`
	Previous *string `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*File `json:"results,omitempty" url:"results,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedFileList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedFileList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedFileList) GetResults() []*File {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedFileList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedFileList) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedFileList) SetNext(next *string) {
	p.Next = next
	p.require(paginatedFileListFieldNext)
}

// SetPrevious sets the Previous field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedFileList) SetPrevious(previous *string) {
	p.Previous = previous
	p.require(paginatedFileListFieldPrevious)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedFileList) SetResults(results []*File) {
	p.Results = results
	p.require(paginatedFileListFieldResults)
}

func (p *PaginatedFileList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedFileList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedFileList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedFileList) MarshalJSON() ([]byte, error) {
	type embed PaginatedFileList
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedFileList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
