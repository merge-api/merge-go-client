// Code generated by Fern. DO NOT EDIT.

package ticketing

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

// * `PRIVATE` - PRIVATE
// * `COMPANY` - COMPANY
// * `PUBLIC` - PUBLIC
type AccessLevelEnum string

const (
	AccessLevelEnumPrivate AccessLevelEnum = "PRIVATE"
	AccessLevelEnumCompany AccessLevelEnum = "COMPANY"
	AccessLevelEnumPublic  AccessLevelEnum = "PUBLIC"
)

func NewAccessLevelEnumFromString(s string) (AccessLevelEnum, error) {
	switch s {
	case "PRIVATE":
		return AccessLevelEnumPrivate, nil
	case "COMPANY":
		return AccessLevelEnumCompany, nil
	case "PUBLIC":
		return AccessLevelEnumPublic, nil
	}
	var t AccessLevelEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccessLevelEnum) Ptr() *AccessLevelEnum {
	return &a
}

// # The Account Object
// ### Description
// The `Account` object is used to represent the account that a ticket is associated with.
//
// The account is a company that may be a customer. This does not represent the company that is receiving the ticket.
//
// ### Usage Example
// TODO
type Account struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The account's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The account's domain names.
	Domains []*string `json:"domains,omitempty" url:"domains,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Account) GetId() *string {
	if a == nil {
		return nil
	}
	return a.Id
}

func (a *Account) GetRemoteId() *string {
	if a == nil {
		return nil
	}
	return a.RemoteId
}

func (a *Account) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *Account) GetModifiedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.ModifiedAt
}

func (a *Account) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *Account) GetDomains() []*string {
	if a == nil {
		return nil
	}
	return a.Domains
}

func (a *Account) GetRemoteWasDeleted() *bool {
	if a == nil {
		return nil
	}
	return a.RemoteWasDeleted
}

func (a *Account) GetFieldMappings() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.FieldMappings
}

func (a *Account) GetRemoteData() []*RemoteData {
	if a == nil {
		return nil
	}
	return a.RemoteData
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type embed Account
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Account(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	a.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Account) MarshalJSON() ([]byte, error) {
	type embed Account
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*a),
		CreatedAt:  internal.NewOptionalDateTime(a.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(a.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Account) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name" url:"name"`
	// Optional. This shortened name appears in places with limited space, usually in conjunction with the platform's logo (e.g., Merge Link menu).<br><br>Example: <i>Workforce Now (in lieu of ADP Workforce Now), SuccessFactors (in lieu of SAP SuccessFactors)</i>
	AbbreviatedName *string `json:"abbreviated_name,omitempty" url:"abbreviated_name,omitempty"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty" url:"categories,omitempty"`
	// Company logo in rectangular shape.
	Image *string `json:"image,omitempty" url:"image,omitempty"`
	// Company logo in square shape.
	SquareImage *string `json:"square_image,omitempty" url:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b>
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	Slug  *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]interface{} `json:"api_endpoints_to_documentation_urls,omitempty" url:"api_endpoints_to_documentation_urls,omitempty"`
	// Setup guide URL for third party webhook creation. Exposed in Merge Docs.
	WebhookSetupGuideUrl *string `json:"webhook_setup_guide_url,omitempty" url:"webhook_setup_guide_url,omitempty"`
	// Category or categories this integration is in beta status for.
	CategoryBetaStatus map[string]interface{} `json:"category_beta_status,omitempty" url:"category_beta_status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountIntegration) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AccountIntegration) GetAbbreviatedName() *string {
	if a == nil {
		return nil
	}
	return a.AbbreviatedName
}

func (a *AccountIntegration) GetCategories() []CategoriesEnum {
	if a == nil {
		return nil
	}
	return a.Categories
}

func (a *AccountIntegration) GetImage() *string {
	if a == nil {
		return nil
	}
	return a.Image
}

func (a *AccountIntegration) GetSquareImage() *string {
	if a == nil {
		return nil
	}
	return a.SquareImage
}

func (a *AccountIntegration) GetColor() *string {
	if a == nil {
		return nil
	}
	return a.Color
}

func (a *AccountIntegration) GetSlug() *string {
	if a == nil {
		return nil
	}
	return a.Slug
}

func (a *AccountIntegration) GetApiEndpointsToDocumentationUrls() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.ApiEndpointsToDocumentationUrls
}

func (a *AccountIntegration) GetWebhookSetupGuideUrl() *string {
	if a == nil {
		return nil
	}
	return a.WebhookSetupGuideUrl
}

func (a *AccountIntegration) GetCategoryBetaStatus() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.CategoryBetaStatus
}

func (a *AccountIntegration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountIntegration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountIntegration) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// # The Attachment Object
// ### Description
// The `Attachment` object is used to represent an attachment for a ticket.
//
// ### Usage Example
// TODO
type Attachment struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The attachment's name. It is required to include the file extension in the attachment's name.
	FileName *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	// The ticket associated with the attachment.
	Ticket *AttachmentTicket `json:"ticket,omitempty" url:"ticket,omitempty"`
	// The attachment's url. It is required to include the file extension in the file's URL.
	FileUrl *string `json:"file_url,omitempty" url:"file_url,omitempty"`
	// The attachment's file format.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`
	// The user who uploaded the attachment.
	UploadedBy *string `json:"uploaded_by,omitempty" url:"uploaded_by,omitempty"`
	// When the third party's attachment was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Attachment) GetId() *string {
	if a == nil {
		return nil
	}
	return a.Id
}

func (a *Attachment) GetRemoteId() *string {
	if a == nil {
		return nil
	}
	return a.RemoteId
}

func (a *Attachment) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *Attachment) GetModifiedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.ModifiedAt
}

func (a *Attachment) GetFileName() *string {
	if a == nil {
		return nil
	}
	return a.FileName
}

func (a *Attachment) GetTicket() *AttachmentTicket {
	if a == nil {
		return nil
	}
	return a.Ticket
}

func (a *Attachment) GetFileUrl() *string {
	if a == nil {
		return nil
	}
	return a.FileUrl
}

func (a *Attachment) GetContentType() *string {
	if a == nil {
		return nil
	}
	return a.ContentType
}

func (a *Attachment) GetUploadedBy() *string {
	if a == nil {
		return nil
	}
	return a.UploadedBy
}

func (a *Attachment) GetRemoteCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.RemoteCreatedAt
}

func (a *Attachment) GetRemoteWasDeleted() *bool {
	if a == nil {
		return nil
	}
	return a.RemoteWasDeleted
}

func (a *Attachment) GetFieldMappings() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.FieldMappings
}

func (a *Attachment) GetRemoteData() []*RemoteData {
	if a == nil {
		return nil
	}
	return a.RemoteData
}

func (a *Attachment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Attachment) UnmarshalJSON(data []byte) error {
	type embed Attachment
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Attachment(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	a.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	a.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Attachment) MarshalJSON() ([]byte, error) {
	type embed Attachment
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
	}{
		embed:           embed(*a),
		CreatedAt:       internal.NewOptionalDateTime(a.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(a.ModifiedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(a.RemoteCreatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Attachment) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The ticket associated with the attachment.
type AttachmentTicket struct {
	String string
	Ticket *Ticket

	typ string
}

func (a *AttachmentTicket) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *AttachmentTicket) GetTicket() *Ticket {
	if a == nil {
		return nil
	}
	return a.Ticket
}

func (a *AttachmentTicket) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	valueTicket := new(Ticket)
	if err := json.Unmarshal(data, &valueTicket); err == nil {
		a.typ = "Ticket"
		a.Ticket = valueTicket
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AttachmentTicket) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "Ticket" || a.Ticket != nil {
		return json.Marshal(a.Ticket)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AttachmentTicketVisitor interface {
	VisitString(string) error
	VisitTicket(*Ticket) error
}

func (a *AttachmentTicket) Accept(visitor AttachmentTicketVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "Ticket" || a.Ticket != nil {
		return visitor.VisitTicket(a.Ticket)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoriesEnum string

const (
	CategoriesEnumHris        CategoriesEnum = "hris"
	CategoriesEnumAts         CategoriesEnum = "ats"
	CategoriesEnumAccounting  CategoriesEnum = "accounting"
	CategoriesEnumTicketing   CategoriesEnum = "ticketing"
	CategoriesEnumCrm         CategoriesEnum = "crm"
	CategoriesEnumMktg        CategoriesEnum = "mktg"
	CategoriesEnumFilestorage CategoriesEnum = "filestorage"
)

func NewCategoriesEnumFromString(s string) (CategoriesEnum, error) {
	switch s {
	case "hris":
		return CategoriesEnumHris, nil
	case "ats":
		return CategoriesEnumAts, nil
	case "accounting":
		return CategoriesEnumAccounting, nil
	case "ticketing":
		return CategoriesEnumTicketing, nil
	case "crm":
		return CategoriesEnumCrm, nil
	case "mktg":
		return CategoriesEnumMktg, nil
	case "filestorage":
		return CategoriesEnumFilestorage, nil
	}
	var t CategoriesEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoriesEnum) Ptr() *CategoriesEnum {
	return &c
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoryEnum string

const (
	CategoryEnumHris        CategoryEnum = "hris"
	CategoryEnumAts         CategoryEnum = "ats"
	CategoryEnumAccounting  CategoryEnum = "accounting"
	CategoryEnumTicketing   CategoryEnum = "ticketing"
	CategoryEnumCrm         CategoryEnum = "crm"
	CategoryEnumMktg        CategoryEnum = "mktg"
	CategoryEnumFilestorage CategoryEnum = "filestorage"
)

func NewCategoryEnumFromString(s string) (CategoryEnum, error) {
	switch s {
	case "hris":
		return CategoryEnumHris, nil
	case "ats":
		return CategoryEnumAts, nil
	case "accounting":
		return CategoryEnumAccounting, nil
	case "ticketing":
		return CategoryEnumTicketing, nil
	case "crm":
		return CategoryEnumCrm, nil
	case "mktg":
		return CategoryEnumMktg, nil
	case "filestorage":
		return CategoryEnumFilestorage, nil
	}
	var t CategoryEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryEnum) Ptr() *CategoryEnum {
	return &c
}

// # The Collection Object
// ### Description
// The `Collection` object is used to represent one or more `Tickets`. There can be a hierarchy of `Collections`, in which a sub-collection belongs to a parent-collection.
//
// ### Usage Example
// TODO
type Collection struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The collection's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The collection's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The collection's type.
	//
	// * `LIST` - LIST
	// * `PROJECT` - PROJECT
	CollectionType *CollectionTypeEnum `json:"collection_type,omitempty" url:"collection_type,omitempty"`
	// The parent collection for this collection.
	ParentCollection *CollectionParentCollection `json:"parent_collection,omitempty" url:"parent_collection,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	// The level of access a User has to the Collection and its sub-objects.
	//
	// * `PRIVATE` - PRIVATE
	// * `COMPANY` - COMPANY
	// * `PUBLIC` - PUBLIC
	AccessLevel   *AccessLevelEnum       `json:"access_level,omitempty" url:"access_level,omitempty"`
	FieldMappings map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData    []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Collection) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *Collection) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *Collection) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *Collection) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *Collection) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *Collection) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *Collection) GetCollectionType() *CollectionTypeEnum {
	if c == nil {
		return nil
	}
	return c.CollectionType
}

func (c *Collection) GetParentCollection() *CollectionParentCollection {
	if c == nil {
		return nil
	}
	return c.ParentCollection
}

func (c *Collection) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *Collection) GetAccessLevel() *AccessLevelEnum {
	if c == nil {
		return nil
	}
	return c.AccessLevel
}

func (c *Collection) GetFieldMappings() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FieldMappings
}

func (c *Collection) GetRemoteData() []*RemoteData {
	if c == nil {
		return nil
	}
	return c.RemoteData
}

func (c *Collection) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Collection) UnmarshalJSON(data []byte) error {
	type embed Collection
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Collection(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Collection) MarshalJSON() ([]byte, error) {
	type embed Collection
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*c),
		CreatedAt:  internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(c.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Collection) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The parent collection for this collection.
type CollectionParentCollection struct {
	String     string
	Collection *Collection

	typ string
}

func (c *CollectionParentCollection) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CollectionParentCollection) GetCollection() *Collection {
	if c == nil {
		return nil
	}
	return c.Collection
}

func (c *CollectionParentCollection) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueCollection := new(Collection)
	if err := json.Unmarshal(data, &valueCollection); err == nil {
		c.typ = "Collection"
		c.Collection = valueCollection
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CollectionParentCollection) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Collection" || c.Collection != nil {
		return json.Marshal(c.Collection)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CollectionParentCollectionVisitor interface {
	VisitString(string) error
	VisitCollection(*Collection) error
}

func (c *CollectionParentCollection) Accept(visitor CollectionParentCollectionVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Collection" || c.Collection != nil {
		return visitor.VisitCollection(c.Collection)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// * `LIST` - LIST
// * `PROJECT` - PROJECT
type CollectionTypeEnum string

const (
	CollectionTypeEnumList    CollectionTypeEnum = "LIST"
	CollectionTypeEnumProject CollectionTypeEnum = "PROJECT"
)

func NewCollectionTypeEnumFromString(s string) (CollectionTypeEnum, error) {
	switch s {
	case "LIST":
		return CollectionTypeEnumList, nil
	case "PROJECT":
		return CollectionTypeEnumProject, nil
	}
	var t CollectionTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CollectionTypeEnum) Ptr() *CollectionTypeEnum {
	return &c
}

// # The Contact Object
// ### Description
// The `Contact` object is used to represent the customer, lead, or external user that a ticket is associated with.
//
// ### Usage Example
// TODO
type Contact struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The contact's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The contact's email address.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The contact's phone number.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The contact's details.
	Details *string `json:"details,omitempty" url:"details,omitempty"`
	// The contact's account.
	Account *ContactAccount `json:"account,omitempty" url:"account,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Contact) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *Contact) GetRemoteId() *string {
	if c == nil {
		return nil
	}
	return c.RemoteId
}

func (c *Contact) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *Contact) GetModifiedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ModifiedAt
}

func (c *Contact) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *Contact) GetEmailAddress() *string {
	if c == nil {
		return nil
	}
	return c.EmailAddress
}

func (c *Contact) GetPhoneNumber() *string {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *Contact) GetDetails() *string {
	if c == nil {
		return nil
	}
	return c.Details
}

func (c *Contact) GetAccount() *ContactAccount {
	if c == nil {
		return nil
	}
	return c.Account
}

func (c *Contact) GetRemoteWasDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.RemoteWasDeleted
}

func (c *Contact) GetFieldMappings() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FieldMappings
}

func (c *Contact) GetRemoteData() []*RemoteData {
	if c == nil {
		return nil
	}
	return c.RemoteData
}

func (c *Contact) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Contact) UnmarshalJSON(data []byte) error {
	type embed Contact
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Contact(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Contact) MarshalJSON() ([]byte, error) {
	type embed Contact
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*c),
		CreatedAt:  internal.NewOptionalDateTime(c.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(c.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Contact) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The contact's account.
type ContactAccount struct {
	String  string
	Account *Account

	typ string
}

func (c *ContactAccount) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *ContactAccount) GetAccount() *Account {
	if c == nil {
		return nil
	}
	return c.Account
}

func (c *ContactAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		c.typ = "Account"
		c.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ContactAccount) MarshalJSON() ([]byte, error) {
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	if c.typ == "Account" || c.Account != nil {
		return json.Marshal(c.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ContactAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (c *ContactAccount) Accept(visitor ContactAccountVisitor) error {
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	if c.typ == "Account" || c.Account != nil {
		return visitor.VisitAccount(c.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// # The DataPassthrough Object
// ### Description
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method" url:"method"`
	// The path of the request in the third party's platform.
	Path string `json:"path" url:"path"`
	// An optional override of the third party's base url for the request.
	BaseUrlOverride *string `json:"base_url_override,omitempty" url:"base_url_override,omitempty"`
	// The data with the request. You must include a `request_format` parameter matching the data's format
	Data *string `json:"data,omitempty" url:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty" url:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`
	RequestFormat *RequestFormatEnum     `json:"request_format,omitempty" url:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty" url:"normalize_response,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DataPassthroughRequest) GetMethod() MethodEnum {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DataPassthroughRequest) GetPath() string {
	if d == nil {
		return ""
	}
	return d.Path
}

func (d *DataPassthroughRequest) GetBaseUrlOverride() *string {
	if d == nil {
		return nil
	}
	return d.BaseUrlOverride
}

func (d *DataPassthroughRequest) GetData() *string {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DataPassthroughRequest) GetMultipartFormData() []*MultipartFormFieldRequest {
	if d == nil {
		return nil
	}
	return d.MultipartFormData
}

func (d *DataPassthroughRequest) GetHeaders() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Headers
}

func (d *DataPassthroughRequest) GetRequestFormat() *RequestFormatEnum {
	if d == nil {
		return nil
	}
	return d.RequestFormat
}

func (d *DataPassthroughRequest) GetNormalizeResponse() *bool {
	if d == nil {
		return nil
	}
	return d.NormalizeResponse
}

func (d *DataPassthroughRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DataPassthroughRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DataPassthroughRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataPassthroughRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataPassthroughRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModeLog struct {
	LogId         string                `json:"log_id" url:"log_id"`
	DashboardView string                `json:"dashboard_view" url:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary" url:"log_summary"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModeLog) GetLogId() string {
	if d == nil {
		return ""
	}
	return d.LogId
}

func (d *DebugModeLog) GetDashboardView() string {
	if d == nil {
		return ""
	}
	return d.DashboardView
}

func (d *DebugModeLog) GetLogSummary() *DebugModelLogSummary {
	if d == nil {
		return nil
	}
	return d.LogSummary
}

func (d *DebugModeLog) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModeLog) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModeLog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModeLog(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModeLog) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DebugModelLogSummary struct {
	Url        string `json:"url" url:"url"`
	Method     string `json:"method" url:"method"`
	StatusCode int    `json:"status_code" url:"status_code"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DebugModelLogSummary) GetUrl() string {
	if d == nil {
		return ""
	}
	return d.Url
}

func (d *DebugModelLogSummary) GetMethod() string {
	if d == nil {
		return ""
	}
	return d.Method
}

func (d *DebugModelLogSummary) GetStatusCode() int {
	if d == nil {
		return 0
	}
	return d.StatusCode
}

func (d *DebugModelLogSummary) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DebugModelLogSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler DebugModelLogSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DebugModelLogSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DebugModelLogSummary) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum string

const (
	EncodingEnumRaw        EncodingEnum = "RAW"
	EncodingEnumBase64     EncodingEnum = "BASE64"
	EncodingEnumGzipBase64 EncodingEnum = "GZIP_BASE64"
)

func NewEncodingEnumFromString(s string) (EncodingEnum, error) {
	switch s {
	case "RAW":
		return EncodingEnumRaw, nil
	case "BASE64":
		return EncodingEnumBase64, nil
	case "GZIP_BASE64":
		return EncodingEnumGzipBase64, nil
	}
	var t EncodingEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncodingEnum) Ptr() *EncodingEnum {
	return &e
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorValidationProblem) GetSource() *ValidationProblemSource {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *ErrorValidationProblem) GetTitle() string {
	if e == nil {
		return ""
	}
	return e.Title
}

func (e *ErrorValidationProblem) GetDetail() string {
	if e == nil {
		return ""
	}
	return e.Detail
}

func (e *ErrorValidationProblem) GetProblemType() string {
	if e == nil {
		return ""
	}
	return e.ProblemType
}

func (e *ErrorValidationProblem) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorValidationProblem) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type FieldFormatEnum string

const (
	FieldFormatEnumString   FieldFormatEnum = "string"
	FieldFormatEnumNumber   FieldFormatEnum = "number"
	FieldFormatEnumDate     FieldFormatEnum = "date"
	FieldFormatEnumDatetime FieldFormatEnum = "datetime"
	FieldFormatEnumBool     FieldFormatEnum = "bool"
	FieldFormatEnumList     FieldFormatEnum = "list"
)

func NewFieldFormatEnumFromString(s string) (FieldFormatEnum, error) {
	switch s {
	case "string":
		return FieldFormatEnumString, nil
	case "number":
		return FieldFormatEnumNumber, nil
	case "date":
		return FieldFormatEnumDate, nil
	case "datetime":
		return FieldFormatEnumDatetime, nil
	case "bool":
		return FieldFormatEnumBool, nil
	case "list":
		return FieldFormatEnumList, nil
	}
	var t FieldFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldFormatEnum) Ptr() *FieldFormatEnum {
	return &f
}

type FieldPermissionDeserializerRequest struct {
	EnabledFields  []interface{} `json:"enabled_fields,omitempty" url:"enabled_fields,omitempty"`
	DisabledFields []interface{} `json:"disabled_fields,omitempty" url:"disabled_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FieldPermissionDeserializerRequest) GetEnabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.EnabledFields
}

func (f *FieldPermissionDeserializerRequest) GetDisabledFields() []interface{} {
	if f == nil {
		return nil
	}
	return f.DisabledFields
}

func (f *FieldPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldPermissionDeserializerRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type FieldTypeEnum string

const (
	FieldTypeEnumString   FieldTypeEnum = "string"
	FieldTypeEnumNumber   FieldTypeEnum = "number"
	FieldTypeEnumDate     FieldTypeEnum = "date"
	FieldTypeEnumDatetime FieldTypeEnum = "datetime"
	FieldTypeEnumBool     FieldTypeEnum = "bool"
	FieldTypeEnumList     FieldTypeEnum = "list"
)

func NewFieldTypeEnumFromString(s string) (FieldTypeEnum, error) {
	switch s {
	case "string":
		return FieldTypeEnumString, nil
	case "number":
		return FieldTypeEnumNumber, nil
	case "date":
		return FieldTypeEnumDate, nil
	case "datetime":
		return FieldTypeEnumDatetime, nil
	case "bool":
		return FieldTypeEnumBool, nil
	case "list":
		return FieldTypeEnumList, nil
	}
	var t FieldTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldTypeEnum) Ptr() *FieldTypeEnum {
	return &f
}

type IndividualCommonModelScopeDeserializerRequest struct {
	ModelName        string                                         `json:"model_name" url:"model_name"`
	ModelPermissions map[string]*ModelPermissionDeserializerRequest `json:"model_permissions,omitempty" url:"model_permissions,omitempty"`
	FieldPermissions *FieldPermissionDeserializerRequest            `json:"field_permissions,omitempty" url:"field_permissions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelName() string {
	if i == nil {
		return ""
	}
	return i.ModelName
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetModelPermissions() map[string]*ModelPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.ModelPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetFieldPermissions() *FieldPermissionDeserializerRequest {
	if i == nil {
		return nil
	}
	return i.FieldPermissions
}

func (i *IndividualCommonModelScopeDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualCommonModelScopeDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualCommonModelScopeDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualCommonModelScopeDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualCommonModelScopeDeserializerRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// * `string` - uuid
// * `number` - url
// * `date` - email
// * `datetime` - phone
// * `bool` - currency
// * `list` - decimal
type ItemFormatEnum string

const (
	ItemFormatEnumString   ItemFormatEnum = "string"
	ItemFormatEnumNumber   ItemFormatEnum = "number"
	ItemFormatEnumDate     ItemFormatEnum = "date"
	ItemFormatEnumDatetime ItemFormatEnum = "datetime"
	ItemFormatEnumBool     ItemFormatEnum = "bool"
	ItemFormatEnumList     ItemFormatEnum = "list"
)

func NewItemFormatEnumFromString(s string) (ItemFormatEnum, error) {
	switch s {
	case "string":
		return ItemFormatEnumString, nil
	case "number":
		return ItemFormatEnumNumber, nil
	case "date":
		return ItemFormatEnumDate, nil
	case "datetime":
		return ItemFormatEnumDatetime, nil
	case "bool":
		return ItemFormatEnumBool, nil
	case "list":
		return ItemFormatEnumList, nil
	}
	var t ItemFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ItemFormatEnum) Ptr() *ItemFormatEnum {
	return &i
}

type ItemSchema struct {
	ItemType    *ItemTypeEnum   `json:"item_type,omitempty" url:"item_type,omitempty"`
	ItemFormat  *ItemFormatEnum `json:"item_format,omitempty" url:"item_format,omitempty"`
	ItemChoices []string        `json:"item_choices,omitempty" url:"item_choices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ItemSchema) GetItemType() *ItemTypeEnum {
	if i == nil {
		return nil
	}
	return i.ItemType
}

func (i *ItemSchema) GetItemFormat() *ItemFormatEnum {
	if i == nil {
		return nil
	}
	return i.ItemFormat
}

func (i *ItemSchema) GetItemChoices() []string {
	if i == nil {
		return nil
	}
	return i.ItemChoices
}

func (i *ItemSchema) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ItemSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemSchema) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type ItemTypeEnum string

const (
	ItemTypeEnumString   ItemTypeEnum = "string"
	ItemTypeEnumNumber   ItemTypeEnum = "number"
	ItemTypeEnumDate     ItemTypeEnum = "date"
	ItemTypeEnumDatetime ItemTypeEnum = "datetime"
	ItemTypeEnumBool     ItemTypeEnum = "bool"
	ItemTypeEnumList     ItemTypeEnum = "list"
)

func NewItemTypeEnumFromString(s string) (ItemTypeEnum, error) {
	switch s {
	case "string":
		return ItemTypeEnumString, nil
	case "number":
		return ItemTypeEnumNumber, nil
	case "date":
		return ItemTypeEnumDate, nil
	case "datetime":
		return ItemTypeEnumDatetime, nil
	case "bool":
		return ItemTypeEnumBool, nil
	case "list":
		return ItemTypeEnumList, nil
	}
	var t ItemTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ItemTypeEnum) Ptr() *ItemTypeEnum {
	return &i
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type LastSyncResultEnum string

const (
	LastSyncResultEnumSyncing         LastSyncResultEnum = "SYNCING"
	LastSyncResultEnumDone            LastSyncResultEnum = "DONE"
	LastSyncResultEnumFailed          LastSyncResultEnum = "FAILED"
	LastSyncResultEnumDisabled        LastSyncResultEnum = "DISABLED"
	LastSyncResultEnumPaused          LastSyncResultEnum = "PAUSED"
	LastSyncResultEnumPartiallySynced LastSyncResultEnum = "PARTIALLY_SYNCED"
)

func NewLastSyncResultEnumFromString(s string) (LastSyncResultEnum, error) {
	switch s {
	case "SYNCING":
		return LastSyncResultEnumSyncing, nil
	case "DONE":
		return LastSyncResultEnumDone, nil
	case "FAILED":
		return LastSyncResultEnumFailed, nil
	case "DISABLED":
		return LastSyncResultEnumDisabled, nil
	case "PAUSED":
		return LastSyncResultEnumPaused, nil
	case "PARTIALLY_SYNCED":
		return LastSyncResultEnumPartiallySynced, nil
	}
	var t LastSyncResultEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LastSyncResultEnum) Ptr() *LastSyncResultEnum {
	return &l
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status" url:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request" url:"can_make_request"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LinkedAccountStatus) GetLinkedAccountStatus() string {
	if l == nil {
		return ""
	}
	return l.LinkedAccountStatus
}

func (l *LinkedAccountStatus) GetCanMakeRequest() bool {
	if l == nil {
		return false
	}
	return l.CanMakeRequest
}

func (l *LinkedAccountStatus) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkedAccountStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkedAccountStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkedAccountStatus(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkedAccountStatus) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MetaResponse struct {
	RequestSchema                  map[string]interface{} `json:"request_schema" url:"request_schema"`
	RemoteFieldClasses             map[string]interface{} `json:"remote_field_classes,omitempty" url:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus   `json:"status,omitempty" url:"status,omitempty"`
	HasConditionalParams           bool                   `json:"has_conditional_params" url:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                   `json:"has_required_linked_account_params" url:"has_required_linked_account_params"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetaResponse) GetRequestSchema() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RequestSchema
}

func (m *MetaResponse) GetRemoteFieldClasses() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.RemoteFieldClasses
}

func (m *MetaResponse) GetStatus() *LinkedAccountStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

func (m *MetaResponse) GetHasConditionalParams() bool {
	if m == nil {
		return false
	}
	return m.HasConditionalParams
}

func (m *MetaResponse) GetHasRequiredLinkedAccountParams() bool {
	if m == nil {
		return false
	}
	return m.HasRequiredLinkedAccountParams
}

func (m *MetaResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetaResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// * `GET` - GET
// * `OPTIONS` - OPTIONS
// * `HEAD` - HEAD
// * `POST` - POST
// * `PUT` - PUT
// * `PATCH` - PATCH
// * `DELETE` - DELETE
type MethodEnum string

const (
	MethodEnumGet     MethodEnum = "GET"
	MethodEnumOptions MethodEnum = "OPTIONS"
	MethodEnumHead    MethodEnum = "HEAD"
	MethodEnumPost    MethodEnum = "POST"
	MethodEnumPut     MethodEnum = "PUT"
	MethodEnumPatch   MethodEnum = "PATCH"
	MethodEnumDelete  MethodEnum = "DELETE"
)

func NewMethodEnumFromString(s string) (MethodEnum, error) {
	switch s {
	case "GET":
		return MethodEnumGet, nil
	case "OPTIONS":
		return MethodEnumOptions, nil
	case "HEAD":
		return MethodEnumHead, nil
	case "POST":
		return MethodEnumPost, nil
	case "PUT":
		return MethodEnumPut, nil
	case "PATCH":
		return MethodEnumPatch, nil
	case "DELETE":
		return MethodEnumDelete, nil
	}
	var t MethodEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodEnum) Ptr() *MethodEnum {
	return &m
}

// # The ModelOperation Object
// ### Description
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name" url:"model_name"`
	AvailableOperations    []string `json:"available_operations" url:"available_operations"`
	RequiredPostParameters []string `json:"required_post_parameters" url:"required_post_parameters"`
	SupportedFields        []string `json:"supported_fields" url:"supported_fields"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelOperation) GetModelName() string {
	if m == nil {
		return ""
	}
	return m.ModelName
}

func (m *ModelOperation) GetAvailableOperations() []string {
	if m == nil {
		return nil
	}
	return m.AvailableOperations
}

func (m *ModelOperation) GetRequiredPostParameters() []string {
	if m == nil {
		return nil
	}
	return m.RequiredPostParameters
}

func (m *ModelOperation) GetSupportedFields() []string {
	if m == nil {
		return nil
	}
	return m.SupportedFields
}

func (m *ModelOperation) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelOperation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelOperation) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelPermissionDeserializerRequest struct {
	IsEnabled *bool `json:"is_enabled,omitempty" url:"is_enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelPermissionDeserializerRequest) GetIsEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.IsEnabled
}

func (m *ModelPermissionDeserializerRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelPermissionDeserializerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPermissionDeserializerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPermissionDeserializerRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPermissionDeserializerRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// # The MultipartFormField Object
// ### Description
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field
	Name string `json:"name" url:"name"`
	// The data for the form field.
	Data string `json:"data" url:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// * `RAW` - RAW
	// * `BASE64` - BASE64
	// * `GZIP_BASE64` - GZIP_BASE64
	Encoding *EncodingEnum `json:"encoding,omitempty" url:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MultipartFormFieldRequest) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MultipartFormFieldRequest) GetData() string {
	if m == nil {
		return ""
	}
	return m.Data
}

func (m *MultipartFormFieldRequest) GetEncoding() *EncodingEnum {
	if m == nil {
		return nil
	}
	return m.Encoding
}

func (m *MultipartFormFieldRequest) GetFileName() *string {
	if m == nil {
		return nil
	}
	return m.FileName
}

func (m *MultipartFormFieldRequest) GetContentType() *string {
	if m == nil {
		return nil
	}
	return m.ContentType
}

func (m *MultipartFormFieldRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultipartFormFieldRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MultipartFormFieldRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultipartFormFieldRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultipartFormFieldRequest) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PaginatedUserList struct {
	Next     *string `json:"next,omitempty" url:"next,omitempty"`
	Previous *string `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*User `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedUserList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedUserList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedUserList) GetResults() []*User {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedUserList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedUserList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedUserList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedUserList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedUserList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaginatedViewerList struct {
	Next     *string   `json:"next,omitempty" url:"next,omitempty"`
	Previous *string   `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*Viewer `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedViewerList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedViewerList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedViewerList) GetResults() []*Viewer {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedViewerList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedViewerList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedViewerList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedViewerList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedViewerList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// * `URGENT` - URGENT
// * `HIGH` - HIGH
// * `NORMAL` - NORMAL
// * `LOW` - LOW
type PriorityEnum string

const (
	PriorityEnumUrgent PriorityEnum = "URGENT"
	PriorityEnumHigh   PriorityEnum = "HIGH"
	PriorityEnumNormal PriorityEnum = "NORMAL"
	PriorityEnumLow    PriorityEnum = "LOW"
)

func NewPriorityEnumFromString(s string) (PriorityEnum, error) {
	switch s {
	case "URGENT":
		return PriorityEnumUrgent, nil
	case "HIGH":
		return PriorityEnumHigh, nil
	case "NORMAL":
		return PriorityEnumNormal, nil
	case "LOW":
		return PriorityEnumLow, nil
	}
	var t PriorityEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PriorityEnum) Ptr() *PriorityEnum {
	return &p
}

// # The RemoteData Object
// ### Description
// The `RemoteData` object is used to represent the full data pulled from the third-party API for an object.
//
// ### Usage Example
// TODO
type RemoteData struct {
	// The third-party API path that is being called.
	Path string      `json:"path" url:"path"`
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteData) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteData) GetData() interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RemoteData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteData) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteField struct {
	RemoteFieldClass *RemoteFieldRemoteFieldClass `json:"remote_field_class" url:"remote_field_class"`
	Value            interface{}                  `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteField) GetRemoteFieldClass() *RemoteFieldRemoteFieldClass {
	if r == nil {
		return nil
	}
	return r.RemoteFieldClass
}

func (r *RemoteField) GetValue() interface{} {
	if r == nil {
		return nil
	}
	return r.Value
}

func (r *RemoteField) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteField) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteField) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldClass struct {
	Id            *string                             `json:"id,omitempty" url:"id,omitempty"`
	DisplayName   *string                             `json:"display_name,omitempty" url:"display_name,omitempty"`
	RemoteKeyName *string                             `json:"remote_key_name,omitempty" url:"remote_key_name,omitempty"`
	Description   *string                             `json:"description,omitempty" url:"description,omitempty"`
	IsCustom      *bool                               `json:"is_custom,omitempty" url:"is_custom,omitempty"`
	IsRequired    *bool                               `json:"is_required,omitempty" url:"is_required,omitempty"`
	FieldType     *FieldTypeEnum                      `json:"field_type,omitempty" url:"field_type,omitempty"`
	FieldFormat   *FieldFormatEnum                    `json:"field_format,omitempty" url:"field_format,omitempty"`
	FieldChoices  []*RemoteFieldClassFieldChoicesItem `json:"field_choices,omitempty" url:"field_choices,omitempty"`
	ItemSchema    *ItemSchema                         `json:"item_schema,omitempty" url:"item_schema,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteFieldClass) GetId() *string {
	if r == nil {
		return nil
	}
	return r.Id
}

func (r *RemoteFieldClass) GetDisplayName() *string {
	if r == nil {
		return nil
	}
	return r.DisplayName
}

func (r *RemoteFieldClass) GetRemoteKeyName() *string {
	if r == nil {
		return nil
	}
	return r.RemoteKeyName
}

func (r *RemoteFieldClass) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RemoteFieldClass) GetIsCustom() *bool {
	if r == nil {
		return nil
	}
	return r.IsCustom
}

func (r *RemoteFieldClass) GetIsRequired() *bool {
	if r == nil {
		return nil
	}
	return r.IsRequired
}

func (r *RemoteFieldClass) GetFieldType() *FieldTypeEnum {
	if r == nil {
		return nil
	}
	return r.FieldType
}

func (r *RemoteFieldClass) GetFieldFormat() *FieldFormatEnum {
	if r == nil {
		return nil
	}
	return r.FieldFormat
}

func (r *RemoteFieldClass) GetFieldChoices() []*RemoteFieldClassFieldChoicesItem {
	if r == nil {
		return nil
	}
	return r.FieldChoices
}

func (r *RemoteFieldClass) GetItemSchema() *ItemSchema {
	if r == nil {
		return nil
	}
	return r.ItemSchema
}

func (r *RemoteFieldClass) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteFieldClass) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldClass
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldClass(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldClass) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldClassFieldChoicesItem struct {
	Value       interface{} `json:"value,omitempty" url:"value,omitempty"`
	DisplayName *string     `json:"display_name,omitempty" url:"display_name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteFieldClassFieldChoicesItem) GetValue() interface{} {
	if r == nil {
		return nil
	}
	return r.Value
}

func (r *RemoteFieldClassFieldChoicesItem) GetDisplayName() *string {
	if r == nil {
		return nil
	}
	return r.DisplayName
}

func (r *RemoteFieldClassFieldChoicesItem) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteFieldClassFieldChoicesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldClassFieldChoicesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldClassFieldChoicesItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteFieldClassFieldChoicesItem) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldRemoteFieldClass struct {
	String           string
	RemoteFieldClass *RemoteFieldClass

	typ string
}

func (r *RemoteFieldRemoteFieldClass) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *RemoteFieldRemoteFieldClass) GetRemoteFieldClass() *RemoteFieldClass {
	if r == nil {
		return nil
	}
	return r.RemoteFieldClass
}

func (r *RemoteFieldRemoteFieldClass) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	valueRemoteFieldClass := new(RemoteFieldClass)
	if err := json.Unmarshal(data, &valueRemoteFieldClass); err == nil {
		r.typ = "RemoteFieldClass"
		r.RemoteFieldClass = valueRemoteFieldClass
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldRemoteFieldClass) MarshalJSON() ([]byte, error) {
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	if r.typ == "RemoteFieldClass" || r.RemoteFieldClass != nil {
		return json.Marshal(r.RemoteFieldClass)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RemoteFieldRemoteFieldClassVisitor interface {
	VisitString(string) error
	VisitRemoteFieldClass(*RemoteFieldClass) error
}

func (r *RemoteFieldRemoteFieldClass) Accept(visitor RemoteFieldRemoteFieldClassVisitor) error {
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	if r.typ == "RemoteFieldClass" || r.RemoteFieldClass != nil {
		return visitor.VisitRemoteFieldClass(r.RemoteFieldClass)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

// # The RemoteKey Object
// ### Description
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name" url:"name"`
	Key  string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteKey) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

func (r *RemoteKey) GetKey() string {
	if r == nil {
		return ""
	}
	return r.Key
}

func (r *RemoteKey) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteKey) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteKey) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// # The RemoteResponse Object
// ### Description
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string                 `json:"method" url:"method"`
	Path            string                 `json:"path" url:"path"`
	Status          int                    `json:"status" url:"status"`
	Response        interface{}            `json:"response" url:"response"`
	ResponseHeaders map[string]interface{} `json:"response_headers,omitempty" url:"response_headers,omitempty"`
	ResponseType    *ResponseTypeEnum      `json:"response_type,omitempty" url:"response_type,omitempty"`
	Headers         map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoteResponse) GetMethod() string {
	if r == nil {
		return ""
	}
	return r.Method
}

func (r *RemoteResponse) GetPath() string {
	if r == nil {
		return ""
	}
	return r.Path
}

func (r *RemoteResponse) GetStatus() int {
	if r == nil {
		return 0
	}
	return r.Status
}

func (r *RemoteResponse) GetResponse() interface{} {
	if r == nil {
		return nil
	}
	return r.Response
}

func (r *RemoteResponse) GetResponseHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.ResponseHeaders
}

func (r *RemoteResponse) GetResponseType() *ResponseTypeEnum {
	if r == nil {
		return nil
	}
	return r.ResponseType
}

func (r *RemoteResponse) GetHeaders() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Headers
}

func (r *RemoteResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoteResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// * `JSON` - JSON
// * `XML` - XML
// * `MULTIPART` - MULTIPART
type RequestFormatEnum string

const (
	RequestFormatEnumJson      RequestFormatEnum = "JSON"
	RequestFormatEnumXml       RequestFormatEnum = "XML"
	RequestFormatEnumMultipart RequestFormatEnum = "MULTIPART"
)

func NewRequestFormatEnumFromString(s string) (RequestFormatEnum, error) {
	switch s {
	case "JSON":
		return RequestFormatEnumJson, nil
	case "XML":
		return RequestFormatEnumXml, nil
	case "MULTIPART":
		return RequestFormatEnumMultipart, nil
	}
	var t RequestFormatEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestFormatEnum) Ptr() *RequestFormatEnum {
	return &r
}

// * `JSON` - JSON
// * `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum string

const (
	ResponseTypeEnumJson       ResponseTypeEnum = "JSON"
	ResponseTypeEnumBase64Gzip ResponseTypeEnum = "BASE64_GZIP"
)

func NewResponseTypeEnumFromString(s string) (ResponseTypeEnum, error) {
	switch s {
	case "JSON":
		return ResponseTypeEnumJson, nil
	case "BASE64_GZIP":
		return ResponseTypeEnumBase64Gzip, nil
	}
	var t ResponseTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseTypeEnum) Ptr() *ResponseTypeEnum {
	return &r
}

// # The Role Object
// ### Description
// The `Role` object is used to represent the set of actions & access that a user with this role is allowed to perform.
//
// ### Usage Example
// TODO
type Role struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The name of the Role.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The set of actions that a User with this Role can perform. Possible enum values include: `VIEW`, `CREATE`, `EDIT`, `DELETE`, `CLOSE`, and `ASSIGN`.
	TicketActions []TicketActionsEnum `json:"ticket_actions,omitempty" url:"ticket_actions,omitempty"`
	// The level of Ticket access that a User with this Role can perform.
	//
	// * `ALL` - ALL
	// * `ASSIGNED_ONLY` - ASSIGNED_ONLY
	// * `TEAM_ONLY` - TEAM_ONLY
	TicketAccess *TicketAccessEnum `json:"ticket_access,omitempty" url:"ticket_access,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Role) GetId() *string {
	if r == nil {
		return nil
	}
	return r.Id
}

func (r *Role) GetRemoteId() *string {
	if r == nil {
		return nil
	}
	return r.RemoteId
}

func (r *Role) GetCreatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *Role) GetModifiedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.ModifiedAt
}

func (r *Role) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *Role) GetTicketActions() []TicketActionsEnum {
	if r == nil {
		return nil
	}
	return r.TicketActions
}

func (r *Role) GetTicketAccess() *TicketAccessEnum {
	if r == nil {
		return nil
	}
	return r.TicketAccess
}

func (r *Role) GetRemoteWasDeleted() *bool {
	if r == nil {
		return nil
	}
	return r.RemoteWasDeleted
}

func (r *Role) GetFieldMappings() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.FieldMappings
}

func (r *Role) GetRemoteData() []*RemoteData {
	if r == nil {
		return nil
	}
	return r.RemoteData
}

func (r *Role) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Role) UnmarshalJSON(data []byte) error {
	type embed Role
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = Role(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	r.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Role) MarshalJSON() ([]byte, error) {
	type embed Role
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*r),
		CreatedAt:  internal.NewOptionalDateTime(r.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(r.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (r *Role) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// * `IN_NEXT_SYNC` - IN_NEXT_SYNC
// * `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum string

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = "IN_NEXT_SYNC"
	SelectiveSyncConfigurationsUsageEnumInLastSync SelectiveSyncConfigurationsUsageEnum = "IN_LAST_SYNC"
)

func NewSelectiveSyncConfigurationsUsageEnumFromString(s string) (SelectiveSyncConfigurationsUsageEnum, error) {
	switch s {
	case "IN_NEXT_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInNextSync, nil
	case "IN_LAST_SYNC":
		return SelectiveSyncConfigurationsUsageEnumInLastSync, nil
	}
	var t SelectiveSyncConfigurationsUsageEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SelectiveSyncConfigurationsUsageEnum) Ptr() *SelectiveSyncConfigurationsUsageEnum {
	return &s
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type StatusFd5Enum string

const (
	StatusFd5EnumSyncing         StatusFd5Enum = "SYNCING"
	StatusFd5EnumDone            StatusFd5Enum = "DONE"
	StatusFd5EnumFailed          StatusFd5Enum = "FAILED"
	StatusFd5EnumDisabled        StatusFd5Enum = "DISABLED"
	StatusFd5EnumPaused          StatusFd5Enum = "PAUSED"
	StatusFd5EnumPartiallySynced StatusFd5Enum = "PARTIALLY_SYNCED"
)

func NewStatusFd5EnumFromString(s string) (StatusFd5Enum, error) {
	switch s {
	case "SYNCING":
		return StatusFd5EnumSyncing, nil
	case "DONE":
		return StatusFd5EnumDone, nil
	case "FAILED":
		return StatusFd5EnumFailed, nil
	case "DISABLED":
		return StatusFd5EnumDisabled, nil
	case "PAUSED":
		return StatusFd5EnumPaused, nil
	case "PARTIALLY_SYNCED":
		return StatusFd5EnumPartiallySynced, nil
	}
	var t StatusFd5Enum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusFd5Enum) Ptr() *StatusFd5Enum {
	return &s
}

// # The SyncStatus Object
// ### Description
// The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name" url:"model_name"`
	ModelId                          string                                `json:"model_id" url:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty" url:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty" url:"next_sync_start,omitempty"`
	LastSyncResult                   *LastSyncResultEnum                   `json:"last_sync_result,omitempty" url:"last_sync_result,omitempty"`
	LastSyncFinished                 *time.Time                            `json:"last_sync_finished,omitempty" url:"last_sync_finished,omitempty"`
	Status                           StatusFd5Enum                         `json:"status" url:"status"`
	IsInitialSync                    bool                                  `json:"is_initial_sync" url:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty" url:"selective_sync_configurations_usage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncStatus) GetModelName() string {
	if s == nil {
		return ""
	}
	return s.ModelName
}

func (s *SyncStatus) GetModelId() string {
	if s == nil {
		return ""
	}
	return s.ModelId
}

func (s *SyncStatus) GetLastSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncStart
}

func (s *SyncStatus) GetNextSyncStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.NextSyncStart
}

func (s *SyncStatus) GetLastSyncResult() *LastSyncResultEnum {
	if s == nil {
		return nil
	}
	return s.LastSyncResult
}

func (s *SyncStatus) GetLastSyncFinished() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastSyncFinished
}

func (s *SyncStatus) GetStatus() StatusFd5Enum {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SyncStatus) GetIsInitialSync() bool {
	if s == nil {
		return false
	}
	return s.IsInitialSync
}

func (s *SyncStatus) GetSelectiveSyncConfigurationsUsage() *SelectiveSyncConfigurationsUsageEnum {
	if s == nil {
		return nil
	}
	return s.SelectiveSyncConfigurationsUsage
}

func (s *SyncStatus) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncStatus) UnmarshalJSON(data []byte) error {
	type embed SyncStatus
	var unmarshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SyncStatus(unmarshaler.embed)
	s.LastSyncStart = unmarshaler.LastSyncStart.TimePtr()
	s.NextSyncStart = unmarshaler.NextSyncStart.TimePtr()
	s.LastSyncFinished = unmarshaler.LastSyncFinished.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatus) MarshalJSON() ([]byte, error) {
	type embed SyncStatus
	var marshaler = struct {
		embed
		LastSyncStart    *internal.DateTime `json:"last_sync_start,omitempty"`
		NextSyncStart    *internal.DateTime `json:"next_sync_start,omitempty"`
		LastSyncFinished *internal.DateTime `json:"last_sync_finished,omitempty"`
	}{
		embed:            embed(*s),
		LastSyncStart:    internal.NewOptionalDateTime(s.LastSyncStart),
		NextSyncStart:    internal.NewOptionalDateTime(s.NextSyncStart),
		LastSyncFinished: internal.NewOptionalDateTime(s.LastSyncFinished),
	}
	return json.Marshal(marshaler)
}

func (s *SyncStatus) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// # The Team Object
// ### Description
// The `Team` object is used to represent one or more `Users` within the company receiving the ticket.
//
// ### Usage Example
// TODO
type Team struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The team's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The team's description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Team) GetId() *string {
	if t == nil {
		return nil
	}
	return t.Id
}

func (t *Team) GetRemoteId() *string {
	if t == nil {
		return nil
	}
	return t.RemoteId
}

func (t *Team) GetCreatedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *Team) GetModifiedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.ModifiedAt
}

func (t *Team) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *Team) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *Team) GetRemoteWasDeleted() *bool {
	if t == nil {
		return nil
	}
	return t.RemoteWasDeleted
}

func (t *Team) GetFieldMappings() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.FieldMappings
}

func (t *Team) GetRemoteData() []*RemoteData {
	if t == nil {
		return nil
	}
	return t.RemoteData
}

func (t *Team) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Team) UnmarshalJSON(data []byte) error {
	type embed Team
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Team(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	t.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Team) MarshalJSON() ([]byte, error) {
	type embed Team
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*t),
		CreatedAt:  internal.NewOptionalDateTime(t.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(t.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (t *Team) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// # The Ticket Object
// ### Description
// The `Ticket` object is used to represent a ticket, issue, task or case.
// ### Usage Example
// TODO
type Ticket struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The ticket's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The individual `Users` who are assigned to this ticket. This does not include `Users` who just have view access to this ticket. To fetch all `Users` and `Teams` that can access the ticket, use the `GET /tickets/{ticket_id}/viewers` [endpoint](https://docs.merge.dev/ticketing/tickets/#tickets_viewers_list).
	Assignees []*TicketAssigneesItem `json:"assignees,omitempty" url:"assignees,omitempty"`
	// The `Teams` that are assigned to this ticket. This does not include `Teams` who just have view access to this ticket. To fetch all `Users` and `Teams` that can access this ticket, use the `GET /tickets/{ticket_id}/viewers` [endpoint](https://docs.merge.dev/ticketing/tickets/#tickets_viewers_list).
	AssignedTeams []*TicketAssignedTeamsItem `json:"assigned_teams,omitempty" url:"assigned_teams,omitempty"`
	// The user who created this ticket.
	Creator *TicketCreator `json:"creator,omitempty" url:"creator,omitempty"`
	// The ticket's due date.
	DueDate *time.Time `json:"due_date,omitempty" url:"due_date,omitempty"`
	// The current status of the ticket.
	//
	// * `OPEN` - OPEN
	// * `CLOSED` - CLOSED
	// * `IN_PROGRESS` - IN_PROGRESS
	// * `ON_HOLD` - ON_HOLD
	Status *TicketStatusEnum `json:"status,omitempty" url:"status,omitempty"`
	// The ticket’s description. HTML version of description is mapped if supported by the third-party platform.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The `Collections` that this `Ticket` is included in.
	Collections []*TicketCollectionsItem `json:"collections,omitempty" url:"collections,omitempty"`
	// The sub category of the ticket within the 3rd party system. Examples include incident, task, subtask or to-do.
	TicketType *string `json:"ticket_type,omitempty" url:"ticket_type,omitempty"`
	// The account associated with the ticket.
	Account *TicketAccount `json:"account,omitempty" url:"account,omitempty"`
	// The contact associated with the ticket.
	Contact *TicketContact `json:"contact,omitempty" url:"contact,omitempty"`
	// The ticket's parent ticket.
	ParentTicket *TicketParentTicket      `json:"parent_ticket,omitempty" url:"parent_ticket,omitempty"`
	Attachments  []*TicketAttachmentsItem `json:"attachments,omitempty" url:"attachments,omitempty"`
	Tags         []*string                `json:"tags,omitempty" url:"tags,omitempty"`
	Roles        []*string                `json:"roles,omitempty" url:"roles,omitempty"`
	// When the third party's ticket was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the third party's ticket was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// When the ticket was completed.
	CompletedAt *time.Time `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	// The 3rd party url of the Ticket.
	TicketUrl *string `json:"ticket_url,omitempty" url:"ticket_url,omitempty"`
	// The priority or urgency of the Ticket.
	//
	// * `URGENT` - URGENT
	// * `HIGH` - HIGH
	// * `NORMAL` - NORMAL
	// * `LOW` - LOW
	Priority      *PriorityEnum          `json:"priority,omitempty" url:"priority,omitempty"`
	FieldMappings map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData    []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`
	RemoteFields  []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Ticket) GetId() *string {
	if t == nil {
		return nil
	}
	return t.Id
}

func (t *Ticket) GetRemoteId() *string {
	if t == nil {
		return nil
	}
	return t.RemoteId
}

func (t *Ticket) GetCreatedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *Ticket) GetModifiedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.ModifiedAt
}

func (t *Ticket) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *Ticket) GetAssignees() []*TicketAssigneesItem {
	if t == nil {
		return nil
	}
	return t.Assignees
}

func (t *Ticket) GetAssignedTeams() []*TicketAssignedTeamsItem {
	if t == nil {
		return nil
	}
	return t.AssignedTeams
}

func (t *Ticket) GetCreator() *TicketCreator {
	if t == nil {
		return nil
	}
	return t.Creator
}

func (t *Ticket) GetDueDate() *time.Time {
	if t == nil {
		return nil
	}
	return t.DueDate
}

func (t *Ticket) GetStatus() *TicketStatusEnum {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *Ticket) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *Ticket) GetCollections() []*TicketCollectionsItem {
	if t == nil {
		return nil
	}
	return t.Collections
}

func (t *Ticket) GetTicketType() *string {
	if t == nil {
		return nil
	}
	return t.TicketType
}

func (t *Ticket) GetAccount() *TicketAccount {
	if t == nil {
		return nil
	}
	return t.Account
}

func (t *Ticket) GetContact() *TicketContact {
	if t == nil {
		return nil
	}
	return t.Contact
}

func (t *Ticket) GetParentTicket() *TicketParentTicket {
	if t == nil {
		return nil
	}
	return t.ParentTicket
}

func (t *Ticket) GetAttachments() []*TicketAttachmentsItem {
	if t == nil {
		return nil
	}
	return t.Attachments
}

func (t *Ticket) GetTags() []*string {
	if t == nil {
		return nil
	}
	return t.Tags
}

func (t *Ticket) GetRoles() []*string {
	if t == nil {
		return nil
	}
	return t.Roles
}

func (t *Ticket) GetRemoteCreatedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.RemoteCreatedAt
}

func (t *Ticket) GetRemoteUpdatedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.RemoteUpdatedAt
}

func (t *Ticket) GetCompletedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.CompletedAt
}

func (t *Ticket) GetRemoteWasDeleted() *bool {
	if t == nil {
		return nil
	}
	return t.RemoteWasDeleted
}

func (t *Ticket) GetTicketUrl() *string {
	if t == nil {
		return nil
	}
	return t.TicketUrl
}

func (t *Ticket) GetPriority() *PriorityEnum {
	if t == nil {
		return nil
	}
	return t.Priority
}

func (t *Ticket) GetFieldMappings() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.FieldMappings
}

func (t *Ticket) GetRemoteData() []*RemoteData {
	if t == nil {
		return nil
	}
	return t.RemoteData
}

func (t *Ticket) GetRemoteFields() []*RemoteField {
	if t == nil {
		return nil
	}
	return t.RemoteFields
}

func (t *Ticket) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Ticket) UnmarshalJSON(data []byte) error {
	type embed Ticket
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		DueDate         *internal.DateTime `json:"due_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
		CompletedAt     *internal.DateTime `json:"completed_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Ticket(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	t.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	t.DueDate = unmarshaler.DueDate.TimePtr()
	t.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	t.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	t.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Ticket) MarshalJSON() ([]byte, error) {
	type embed Ticket
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		DueDate         *internal.DateTime `json:"due_date,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
		CompletedAt     *internal.DateTime `json:"completed_at,omitempty"`
	}{
		embed:           embed(*t),
		CreatedAt:       internal.NewOptionalDateTime(t.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(t.ModifiedAt),
		DueDate:         internal.NewOptionalDateTime(t.DueDate),
		RemoteCreatedAt: internal.NewOptionalDateTime(t.RemoteCreatedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(t.RemoteUpdatedAt),
		CompletedAt:     internal.NewOptionalDateTime(t.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (t *Ticket) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// * `ALL` - ALL
// * `ASSIGNED_ONLY` - ASSIGNED_ONLY
// * `TEAM_ONLY` - TEAM_ONLY
type TicketAccessEnum string

const (
	TicketAccessEnumAll          TicketAccessEnum = "ALL"
	TicketAccessEnumAssignedOnly TicketAccessEnum = "ASSIGNED_ONLY"
	TicketAccessEnumTeamOnly     TicketAccessEnum = "TEAM_ONLY"
)

func NewTicketAccessEnumFromString(s string) (TicketAccessEnum, error) {
	switch s {
	case "ALL":
		return TicketAccessEnumAll, nil
	case "ASSIGNED_ONLY":
		return TicketAccessEnumAssignedOnly, nil
	case "TEAM_ONLY":
		return TicketAccessEnumTeamOnly, nil
	}
	var t TicketAccessEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TicketAccessEnum) Ptr() *TicketAccessEnum {
	return &t
}

// The account associated with the ticket.
type TicketAccount struct {
	String  string
	Account *Account

	typ string
}

func (t *TicketAccount) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TicketAccount) GetAccount() *Account {
	if t == nil {
		return nil
	}
	return t.Account
}

func (t *TicketAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		t.typ = "Account"
		t.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TicketAccount) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "Account" || t.Account != nil {
		return json.Marshal(t.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (t *TicketAccount) Accept(visitor TicketAccountVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "Account" || t.Account != nil {
		return visitor.VisitAccount(t.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// * `VIEW` - VIEW
// * `CREATE` - CREATE
// * `EDIT` - EDIT
// * `DELETE` - DELETE
// * `CLOSE` - CLOSE
// * `ASSIGN` - ASSIGN
type TicketActionsEnum string

const (
	TicketActionsEnumView   TicketActionsEnum = "VIEW"
	TicketActionsEnumCreate TicketActionsEnum = "CREATE"
	TicketActionsEnumEdit   TicketActionsEnum = "EDIT"
	TicketActionsEnumDelete TicketActionsEnum = "DELETE"
	TicketActionsEnumClose  TicketActionsEnum = "CLOSE"
	TicketActionsEnumAssign TicketActionsEnum = "ASSIGN"
)

func NewTicketActionsEnumFromString(s string) (TicketActionsEnum, error) {
	switch s {
	case "VIEW":
		return TicketActionsEnumView, nil
	case "CREATE":
		return TicketActionsEnumCreate, nil
	case "EDIT":
		return TicketActionsEnumEdit, nil
	case "DELETE":
		return TicketActionsEnumDelete, nil
	case "CLOSE":
		return TicketActionsEnumClose, nil
	case "ASSIGN":
		return TicketActionsEnumAssign, nil
	}
	var t TicketActionsEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TicketActionsEnum) Ptr() *TicketActionsEnum {
	return &t
}

type TicketAssignedTeamsItem struct {
	String string
	Team   *Team

	typ string
}

func (t *TicketAssignedTeamsItem) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TicketAssignedTeamsItem) GetTeam() *Team {
	if t == nil {
		return nil
	}
	return t.Team
}

func (t *TicketAssignedTeamsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		t.typ = "Team"
		t.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TicketAssignedTeamsItem) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "Team" || t.Team != nil {
		return json.Marshal(t.Team)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketAssignedTeamsItemVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (t *TicketAssignedTeamsItem) Accept(visitor TicketAssignedTeamsItemVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "Team" || t.Team != nil {
		return visitor.VisitTeam(t.Team)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketAssigneesItem struct {
	String string
	User   *User

	typ string
}

func (t *TicketAssigneesItem) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TicketAssigneesItem) GetUser() *User {
	if t == nil {
		return nil
	}
	return t.User
}

func (t *TicketAssigneesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		t.typ = "User"
		t.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TicketAssigneesItem) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "User" || t.User != nil {
		return json.Marshal(t.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketAssigneesItemVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (t *TicketAssigneesItem) Accept(visitor TicketAssigneesItemVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "User" || t.User != nil {
		return visitor.VisitUser(t.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketAttachmentsItem struct {
	String     string
	Attachment *Attachment

	typ string
}

func (t *TicketAttachmentsItem) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TicketAttachmentsItem) GetAttachment() *Attachment {
	if t == nil {
		return nil
	}
	return t.Attachment
}

func (t *TicketAttachmentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueAttachment := new(Attachment)
	if err := json.Unmarshal(data, &valueAttachment); err == nil {
		t.typ = "Attachment"
		t.Attachment = valueAttachment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TicketAttachmentsItem) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "Attachment" || t.Attachment != nil {
		return json.Marshal(t.Attachment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketAttachmentsItemVisitor interface {
	VisitString(string) error
	VisitAttachment(*Attachment) error
}

func (t *TicketAttachmentsItem) Accept(visitor TicketAttachmentsItemVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "Attachment" || t.Attachment != nil {
		return visitor.VisitAttachment(t.Attachment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketCollectionsItem struct {
	String     string
	Collection *Collection

	typ string
}

func (t *TicketCollectionsItem) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TicketCollectionsItem) GetCollection() *Collection {
	if t == nil {
		return nil
	}
	return t.Collection
}

func (t *TicketCollectionsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCollection := new(Collection)
	if err := json.Unmarshal(data, &valueCollection); err == nil {
		t.typ = "Collection"
		t.Collection = valueCollection
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TicketCollectionsItem) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "Collection" || t.Collection != nil {
		return json.Marshal(t.Collection)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketCollectionsItemVisitor interface {
	VisitString(string) error
	VisitCollection(*Collection) error
}

func (t *TicketCollectionsItem) Accept(visitor TicketCollectionsItemVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "Collection" || t.Collection != nil {
		return visitor.VisitCollection(t.Collection)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// The contact associated with the ticket.
type TicketContact struct {
	String  string
	Contact *Contact

	typ string
}

func (t *TicketContact) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TicketContact) GetContact() *Contact {
	if t == nil {
		return nil
	}
	return t.Contact
}

func (t *TicketContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		t.typ = "Contact"
		t.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TicketContact) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "Contact" || t.Contact != nil {
		return json.Marshal(t.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (t *TicketContact) Accept(visitor TicketContactVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "Contact" || t.Contact != nil {
		return visitor.VisitContact(t.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// The user who created this ticket.
type TicketCreator struct {
	String string
	User   *User

	typ string
}

func (t *TicketCreator) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TicketCreator) GetUser() *User {
	if t == nil {
		return nil
	}
	return t.User
}

func (t *TicketCreator) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		t.typ = "User"
		t.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TicketCreator) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "User" || t.User != nil {
		return json.Marshal(t.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketCreatorVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (t *TicketCreator) Accept(visitor TicketCreatorVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "User" || t.User != nil {
		return visitor.VisitUser(t.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// The ticket's parent ticket.
type TicketParentTicket struct {
	String string
	Ticket *Ticket

	typ string
}

func (t *TicketParentTicket) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TicketParentTicket) GetTicket() *Ticket {
	if t == nil {
		return nil
	}
	return t.Ticket
}

func (t *TicketParentTicket) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueTicket := new(Ticket)
	if err := json.Unmarshal(data, &valueTicket); err == nil {
		t.typ = "Ticket"
		t.Ticket = valueTicket
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TicketParentTicket) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "Ticket" || t.Ticket != nil {
		return json.Marshal(t.Ticket)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TicketParentTicketVisitor interface {
	VisitString(string) error
	VisitTicket(*Ticket) error
}

func (t *TicketParentTicket) Accept(visitor TicketParentTicketVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "Ticket" || t.Ticket != nil {
		return visitor.VisitTicket(t.Ticket)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// * `OPEN` - OPEN
// * `CLOSED` - CLOSED
// * `IN_PROGRESS` - IN_PROGRESS
// * `ON_HOLD` - ON_HOLD
type TicketStatusEnum string

const (
	TicketStatusEnumOpen       TicketStatusEnum = "OPEN"
	TicketStatusEnumClosed     TicketStatusEnum = "CLOSED"
	TicketStatusEnumInProgress TicketStatusEnum = "IN_PROGRESS"
	TicketStatusEnumOnHold     TicketStatusEnum = "ON_HOLD"
)

func NewTicketStatusEnumFromString(s string) (TicketStatusEnum, error) {
	switch s {
	case "OPEN":
		return TicketStatusEnumOpen, nil
	case "CLOSED":
		return TicketStatusEnumClosed, nil
	case "IN_PROGRESS":
		return TicketStatusEnumInProgress, nil
	case "ON_HOLD":
		return TicketStatusEnumOnHold, nil
	}
	var t TicketStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TicketStatusEnum) Ptr() *TicketStatusEnum {
	return &t
}

// # The User Object
// ### Description
// The `User` object is used to represent a user with a login to the ticketing system.
// Users are either assignees who are directly responsible or a viewer on a `Ticket`/ `Collection`.
//
// ### Usage Example
// TODO
type User struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The user's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The user's email address.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// Whether or not the user is active.
	IsActive *bool            `json:"is_active,omitempty" url:"is_active,omitempty"`
	Teams    []*UserTeamsItem `json:"teams,omitempty" url:"teams,omitempty"`
	Roles    []*UserRolesItem `json:"roles,omitempty" url:"roles,omitempty"`
	// The user's avatar picture.
	Avatar *string `json:"avatar,omitempty" url:"avatar,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *User) GetId() *string {
	if u == nil {
		return nil
	}
	return u.Id
}

func (u *User) GetRemoteId() *string {
	if u == nil {
		return nil
	}
	return u.RemoteId
}

func (u *User) GetCreatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *User) GetModifiedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.ModifiedAt
}

func (u *User) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *User) GetEmailAddress() *string {
	if u == nil {
		return nil
	}
	return u.EmailAddress
}

func (u *User) GetIsActive() *bool {
	if u == nil {
		return nil
	}
	return u.IsActive
}

func (u *User) GetTeams() []*UserTeamsItem {
	if u == nil {
		return nil
	}
	return u.Teams
}

func (u *User) GetRoles() []*UserRolesItem {
	if u == nil {
		return nil
	}
	return u.Roles
}

func (u *User) GetAvatar() *string {
	if u == nil {
		return nil
	}
	return u.Avatar
}

func (u *User) GetRemoteWasDeleted() *bool {
	if u == nil {
		return nil
	}
	return u.RemoteWasDeleted
}

func (u *User) GetFieldMappings() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.FieldMappings
}

func (u *User) GetRemoteData() []*RemoteData {
	if u == nil {
		return nil
	}
	return u.RemoteData
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type embed User
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = User(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	u.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*u),
		CreatedAt:  internal.NewOptionalDateTime(u.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(u.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (u *User) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRolesItem struct {
	String string
	Role   *Role

	typ string
}

func (u *UserRolesItem) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UserRolesItem) GetRole() *Role {
	if u == nil {
		return nil
	}
	return u.Role
}

func (u *UserRolesItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typ = "String"
		u.String = valueString
		return nil
	}
	valueRole := new(Role)
	if err := json.Unmarshal(data, &valueRole); err == nil {
		u.typ = "Role"
		u.Role = valueRole
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UserRolesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "String" || u.String != "" {
		return json.Marshal(u.String)
	}
	if u.typ == "Role" || u.Role != nil {
		return json.Marshal(u.Role)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UserRolesItemVisitor interface {
	VisitString(string) error
	VisitRole(*Role) error
}

func (u *UserRolesItem) Accept(visitor UserRolesItemVisitor) error {
	if u.typ == "String" || u.String != "" {
		return visitor.VisitString(u.String)
	}
	if u.typ == "Role" || u.Role != nil {
		return visitor.VisitRole(u.Role)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UserTeamsItem struct {
	String string
	Team   *Team

	typ string
}

func (u *UserTeamsItem) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UserTeamsItem) GetTeam() *Team {
	if u == nil {
		return nil
	}
	return u.Team
}

func (u *UserTeamsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typ = "String"
		u.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		u.typ = "Team"
		u.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UserTeamsItem) MarshalJSON() ([]byte, error) {
	if u.typ == "String" || u.String != "" {
		return json.Marshal(u.String)
	}
	if u.typ == "Team" || u.Team != nil {
		return json.Marshal(u.Team)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UserTeamsItemVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (u *UserTeamsItem) Accept(visitor UserTeamsItemVisitor) error {
	if u.typ == "String" || u.String != "" {
		return visitor.VisitString(u.String)
	}
	if u.typ == "Team" || u.Team != nil {
		return visitor.VisitTeam(u.Team)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer" url:"pointer"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValidationProblemSource) GetPointer() string {
	if v == nil {
		return ""
	}
	return v.Pointer
}

func (v *ValidationProblemSource) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationProblemSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationProblemSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationProblemSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationProblemSource) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// # The Viewer Object
// ### Description
// The `Viewer` object is used to represent a User or Team within a company.
//
// ### Usage Example
// TODO
type Viewer struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The Team this Viewer belongs to.
	Team *ViewerTeam `json:"team,omitempty" url:"team,omitempty"`
	// The User this Viewer belongs to.
	User *ViewerUser `json:"user,omitempty" url:"user,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *Viewer) GetId() *string {
	if v == nil {
		return nil
	}
	return v.Id
}

func (v *Viewer) GetRemoteId() *string {
	if v == nil {
		return nil
	}
	return v.RemoteId
}

func (v *Viewer) GetCreatedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.CreatedAt
}

func (v *Viewer) GetModifiedAt() *time.Time {
	if v == nil {
		return nil
	}
	return v.ModifiedAt
}

func (v *Viewer) GetTeam() *ViewerTeam {
	if v == nil {
		return nil
	}
	return v.Team
}

func (v *Viewer) GetUser() *ViewerUser {
	if v == nil {
		return nil
	}
	return v.User
}

func (v *Viewer) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *Viewer) UnmarshalJSON(data []byte) error {
	type embed Viewer
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = Viewer(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	v.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *Viewer) MarshalJSON() ([]byte, error) {
	type embed Viewer
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
	}{
		embed:      embed(*v),
		CreatedAt:  internal.NewOptionalDateTime(v.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(v.ModifiedAt),
	}
	return json.Marshal(marshaler)
}

func (v *Viewer) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The Team this Viewer belongs to.
type ViewerTeam struct {
	String string
	Team   *Team

	typ string
}

func (v *ViewerTeam) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *ViewerTeam) GetTeam() *Team {
	if v == nil {
		return nil
	}
	return v.Team
}

func (v *ViewerTeam) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueTeam := new(Team)
	if err := json.Unmarshal(data, &valueTeam); err == nil {
		v.typ = "Team"
		v.Team = valueTeam
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ViewerTeam) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Team" || v.Team != nil {
		return json.Marshal(v.Team)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type ViewerTeamVisitor interface {
	VisitString(string) error
	VisitTeam(*Team) error
}

func (v *ViewerTeam) Accept(visitor ViewerTeamVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Team" || v.Team != nil {
		return visitor.VisitTeam(v.Team)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// The User this Viewer belongs to.
type ViewerUser struct {
	String string
	User   *User

	typ string
}

func (v *ViewerUser) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *ViewerUser) GetUser() *User {
	if v == nil {
		return nil
	}
	return v.User
}

func (v *ViewerUser) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		v.typ = "User"
		v.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ViewerUser) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "User" || v.User != nil {
		return json.Marshal(v.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type ViewerUserVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (v *ViewerUser) Accept(visitor ViewerUserVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "User" || v.User != nil {
		return visitor.VisitUser(v.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty" url:"source,omitempty"`
	Title       string                   `json:"title" url:"title"`
	Detail      string                   `json:"detail" url:"detail"`
	ProblemType string                   `json:"problem_type" url:"problem_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WarningValidationProblem) GetSource() *ValidationProblemSource {
	if w == nil {
		return nil
	}
	return w.Source
}

func (w *WarningValidationProblem) GetTitle() string {
	if w == nil {
		return ""
	}
	return w.Title
}

func (w *WarningValidationProblem) GetDetail() string {
	if w == nil {
		return ""
	}
	return w.Detail
}

func (w *WarningValidationProblem) GetProblemType() string {
	if w == nil {
		return ""
	}
	return w.ProblemType
}

func (w *WarningValidationProblem) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WarningValidationProblem) UnmarshalJSON(data []byte) error {
	type unmarshaler WarningValidationProblem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WarningValidationProblem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WarningValidationProblem) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
