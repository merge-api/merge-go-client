// This file was auto-generated by Fern from our API Definition.

package crm

import (
	json "encoding/json"
	fmt "fmt"
	strconv "strconv"
	time "time"
)

// # The Account Object
// ### Description
// The `Account` object is used to represent a company in a CRM system.
// ### Usage Example
// TODO
type Account struct {
	// The account's owner.
	Owner *AccountOwner `json:"owner,omitempty"`
	// The account's name.
	Name *string `json:"name,omitempty"`
	// The account's description.
	Description *string `json:"description,omitempty"`
	// The account's industry.
	Industry *string `json:"industry,omitempty"`
	// The account's website.
	Website *string `json:"website,omitempty"`
	// The account's number of employees.
	NumberOfEmployees *int           `json:"number_of_employees,omitempty"`
	Addresses         []*Address     `json:"addresses,omitempty"`
	PhoneNumbers      []*PhoneNumber `json:"phone_numbers,omitempty"`
	// The last date (either most recent or furthest in the future) of when an activity occurs in an account.
	LastActivityAt *time.Time `json:"last_activity_at,omitempty"`
	// When the CRM system account data was last modified by a user with a login.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// When the third party's account was created.
	RemoteCreatedAt  *time.Time `json:"remote_created_at,omitempty"`
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	Id               *string    `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

type AccountDetails struct {
	Id                      *string       `json:"id,omitempty"`
	Integration             *string       `json:"integration,omitempty"`
	IntegrationSlug         *string       `json:"integration_slug,omitempty"`
	Category                *CategoryEnum `json:"category,omitempty"`
	EndUserOriginId         *string       `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName *string       `json:"end_user_organization_name,omitempty"`
	EndUserEmailAddress     *string       `json:"end_user_email_address,omitempty"`
	Status                  *string       `json:"status,omitempty"`
	WebhookListenerUrl      *string       `json:"webhook_listener_url,omitempty"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool `json:"is_duplicate,omitempty"`
}

// # The LinkedAccount Object
// ### Description
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                             `json:"id"`
	Category                *CategoryEnum                      `json:"category,omitempty"`
	Status                  AccountDetailsAndActionsStatusEnum `json:"status,omitempty"`
	StatusDetail            *string                            `json:"status_detail,omitempty"`
	EndUserOriginId         *string                            `json:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                             `json:"end_user_organization_name"`
	EndUserEmailAddress     string                             `json:"end_user_email_address"`
	WebhookListenerUrl      string                             `json:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty"`
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name"`
	Categories               []CategoriesEnum  `json:"categories,omitempty"`
	Image                    *string           `json:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty"`
	Color                    string            `json:"color"`
	Slug                     string            `json:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty"`
}

// * `COMPLETE` - COMPLETE
// * `INCOMPLETE` - INCOMPLETE
// * `RELINK_NEEDED` - RELINK_NEEDED
type AccountDetailsAndActionsStatusEnum uint

const (
	AccountDetailsAndActionsStatusEnumComplete AccountDetailsAndActionsStatusEnum = iota + 1
	AccountDetailsAndActionsStatusEnumIncomplete
	AccountDetailsAndActionsStatusEnumRelinkNeeded
)

func (a AccountDetailsAndActionsStatusEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AccountDetailsAndActionsStatusEnumComplete:
		return "COMPLETE"
	case AccountDetailsAndActionsStatusEnumIncomplete:
		return "INCOMPLETE"
	case AccountDetailsAndActionsStatusEnumRelinkNeeded:
		return "RELINK_NEEDED"
	}
}

func (a AccountDetailsAndActionsStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AccountDetailsAndActionsStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "COMPLETE":
		value := AccountDetailsAndActionsStatusEnumComplete
		*a = value
	case "INCOMPLETE":
		value := AccountDetailsAndActionsStatusEnumIncomplete
		*a = value
	case "RELINK_NEEDED":
		value := AccountDetailsAndActionsStatusEnumRelinkNeeded
		*a = value
	}
	return nil
}

type AccountIntegration struct {
	// Company name.
	Name string `json:"name"`
	// Category or categories this integration belongs to. Multiple categories should be comma separated, i.e. [ats, hris].
	Categories []CategoriesEnum `json:"categories,omitempty"`
	// Company logo in rectangular shape. <b>Upload an image with a clear background.</b>
	Image *string `json:"image,omitempty"`
	// Company logo in square shape. <b>Upload an image with a white background.</b>
	SquareImage *string `json:"square_image,omitempty"`
	// The color of this integration used for buttons and text throughout the app and landing pages. <b>Choose a darker, saturated color.</b> <span style="white-space: nowrap">`<= 18 characters`</span>
	Color *string `json:"color,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	// If checked, this integration will not appear in the linking flow, and will appear elsewhere with a Beta tag.
	IsInBeta *bool `json:"is_in_beta,omitempty"`
	// Mapping of API endpoints to documentation urls for support. Example: {'GET': [['/common-model-scopes', 'https://docs.merge.dev/accounting/common-model-scopes/#common_model_scopes_retrieve'],['/common-model-actions', 'https://docs.merge.dev/accounting/common-model-actions/#common_model_actions_retrieve']], 'POST': []}
	ApiEndpointsToDocumentationUrls map[string]any `json:"api_endpoints_to_documentation_urls,omitempty"`
}

// The account's owner.
type AccountOwner struct {
	typeName string
	String   string
	User     *User
}

func NewAccountOwnerFromString(value string) *AccountOwner {
	return &AccountOwner{typeName: "string", String: value}
}

func NewAccountOwnerFromUser(value *User) *AccountOwner {
	return &AccountOwner{typeName: "user", User: value}
}

func (a *AccountOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		a.typeName = "user"
		a.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountOwner) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "user":
		return json.Marshal(a.User)
	}
}

type AccountOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (a *AccountOwner) Accept(visitor AccountOwnerVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "user":
		return visitor.VisitUser(a.User)
	}
}

// # The Account Object
// ### Description
// The `Account` object is used to represent a company in a CRM system.
// ### Usage Example
// TODO
type AccountRequest struct {
	// The account's owner.
	Owner *AccountRequestOwner `json:"owner,omitempty"`
	// The account's name.
	Name *string `json:"name,omitempty"`
	// The account's description.
	Description *string `json:"description,omitempty"`
	// The account's industry.
	Industry *string `json:"industry,omitempty"`
	// The account's website.
	Website *string `json:"website,omitempty"`
	// The account's number of employees.
	NumberOfEmployees *int `json:"number_of_employees,omitempty"`
	// The last date (either most recent or furthest in the future) of when an activity occurs in an account.
	LastActivityAt      *time.Time            `json:"last_activity_at,omitempty"`
	IntegrationParams   map[string]any        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest `json:"remote_fields,omitempty"`
}

// The account's owner.
type AccountRequestOwner struct {
	typeName string
	String   string
	User     *User
}

func NewAccountRequestOwnerFromString(value string) *AccountRequestOwner {
	return &AccountRequestOwner{typeName: "string", String: value}
}

func NewAccountRequestOwnerFromUser(value *User) *AccountRequestOwner {
	return &AccountRequestOwner{typeName: "user", User: value}
}

func (a *AccountRequestOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		a.typeName = "user"
		a.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountRequestOwner) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "user":
		return json.Marshal(a.User)
	}
}

type AccountRequestOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (a *AccountRequestOwner) Accept(visitor AccountRequestOwnerVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "user":
		return visitor.VisitUser(a.User)
	}
}

type AccountToken struct {
	AccountToken string              `json:"account_token"`
	Integration  *AccountIntegration `json:"integration,omitempty"`
}

// * `CALL` - CALL
// * `MEETING` - MEETING
// * `EMAIL` - EMAIL
type ActivityTypeEnum uint

const (
	ActivityTypeEnumCall ActivityTypeEnum = iota + 1
	ActivityTypeEnumMeeting
	ActivityTypeEnumEmail
)

func (a ActivityTypeEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case ActivityTypeEnumCall:
		return "CALL"
	case ActivityTypeEnumMeeting:
		return "MEETING"
	case ActivityTypeEnumEmail:
		return "EMAIL"
	}
}

func (a ActivityTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *ActivityTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "CALL":
		value := ActivityTypeEnumCall
		*a = value
	case "MEETING":
		value := ActivityTypeEnumMeeting
		*a = value
	case "EMAIL":
		value := ActivityTypeEnumEmail
		*a = value
	}
	return nil
}

// # The Address Object
// ### Description
// The `Address` object is used to represent an entity's address.
// ### Usage Example
// TODO
type Address struct {
	// Line 1 of the address's street.
	Street1 *string `json:"street_1,omitempty"`
	// Line 2 of the address's street.
	Street2 *string `json:"street_2,omitempty"`
	// The address's city.
	City *string `json:"city,omitempty"`
	// The address's state.
	State *string `json:"state,omitempty"`
	// The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`
	// The address's country.
	//
	// * `AF` - Afghanistan
	// * `AX` - Åland Islands
	// * `AL` - Albania
	// * `DZ` - Algeria
	// * `AS` - American Samoa
	// * `AD` - Andorra
	// * `AO` - Angola
	// * `AI` - Anguilla
	// * `AQ` - Antarctica
	// * `AG` - Antigua and Barbuda
	// * `AR` - Argentina
	// * `AM` - Armenia
	// * `AW` - Aruba
	// * `AU` - Australia
	// * `AT` - Austria
	// * `AZ` - Azerbaijan
	// * `BS` - Bahamas
	// * `BH` - Bahrain
	// * `BD` - Bangladesh
	// * `BB` - Barbados
	// * `BY` - Belarus
	// * `BE` - Belgium
	// * `BZ` - Belize
	// * `BJ` - Benin
	// * `BM` - Bermuda
	// * `BT` - Bhutan
	// * `BO` - Bolivia
	// * `BQ` - Bonaire, Sint Eustatius and Saba
	// * `BA` - Bosnia and Herzegovina
	// * `BW` - Botswana
	// * `BV` - Bouvet Island
	// * `BR` - Brazil
	// * `IO` - British Indian Ocean Territory
	// * `BN` - Brunei
	// * `BG` - Bulgaria
	// * `BF` - Burkina Faso
	// * `BI` - Burundi
	// * `CV` - Cabo Verde
	// * `KH` - Cambodia
	// * `CM` - Cameroon
	// * `CA` - Canada
	// * `KY` - Cayman Islands
	// * `CF` - Central African Republic
	// * `TD` - Chad
	// * `CL` - Chile
	// * `CN` - China
	// * `CX` - Christmas Island
	// * `CC` - Cocos (Keeling) Islands
	// * `CO` - Colombia
	// * `KM` - Comoros
	// * `CG` - Congo
	// * `CD` - Congo (the Democratic Republic of the)
	// * `CK` - Cook Islands
	// * `CR` - Costa Rica
	// * `CI` - Côte d'Ivoire
	// * `HR` - Croatia
	// * `CU` - Cuba
	// * `CW` - Curaçao
	// * `CY` - Cyprus
	// * `CZ` - Czechia
	// * `DK` - Denmark
	// * `DJ` - Djibouti
	// * `DM` - Dominica
	// * `DO` - Dominican Republic
	// * `EC` - Ecuador
	// * `EG` - Egypt
	// * `SV` - El Salvador
	// * `GQ` - Equatorial Guinea
	// * `ER` - Eritrea
	// * `EE` - Estonia
	// * `SZ` - Eswatini
	// * `ET` - Ethiopia
	// * `FK` - Falkland Islands (Malvinas)
	// * `FO` - Faroe Islands
	// * `FJ` - Fiji
	// * `FI` - Finland
	// * `FR` - France
	// * `GF` - French Guiana
	// * `PF` - French Polynesia
	// * `TF` - French Southern Territories
	// * `GA` - Gabon
	// * `GM` - Gambia
	// * `GE` - Georgia
	// * `DE` - Germany
	// * `GH` - Ghana
	// * `GI` - Gibraltar
	// * `GR` - Greece
	// * `GL` - Greenland
	// * `GD` - Grenada
	// * `GP` - Guadeloupe
	// * `GU` - Guam
	// * `GT` - Guatemala
	// * `GG` - Guernsey
	// * `GN` - Guinea
	// * `GW` - Guinea-Bissau
	// * `GY` - Guyana
	// * `HT` - Haiti
	// * `HM` - Heard Island and McDonald Islands
	// * `VA` - Holy See
	// * `HN` - Honduras
	// * `HK` - Hong Kong
	// * `HU` - Hungary
	// * `IS` - Iceland
	// * `IN` - India
	// * `ID` - Indonesia
	// * `IR` - Iran
	// * `IQ` - Iraq
	// * `IE` - Ireland
	// * `IM` - Isle of Man
	// * `IL` - Israel
	// * `IT` - Italy
	// * `JM` - Jamaica
	// * `JP` - Japan
	// * `JE` - Jersey
	// * `JO` - Jordan
	// * `KZ` - Kazakhstan
	// * `KE` - Kenya
	// * `KI` - Kiribati
	// * `KW` - Kuwait
	// * `KG` - Kyrgyzstan
	// * `LA` - Laos
	// * `LV` - Latvia
	// * `LB` - Lebanon
	// * `LS` - Lesotho
	// * `LR` - Liberia
	// * `LY` - Libya
	// * `LI` - Liechtenstein
	// * `LT` - Lithuania
	// * `LU` - Luxembourg
	// * `MO` - Macao
	// * `MG` - Madagascar
	// * `MW` - Malawi
	// * `MY` - Malaysia
	// * `MV` - Maldives
	// * `ML` - Mali
	// * `MT` - Malta
	// * `MH` - Marshall Islands
	// * `MQ` - Martinique
	// * `MR` - Mauritania
	// * `MU` - Mauritius
	// * `YT` - Mayotte
	// * `MX` - Mexico
	// * `FM` - Micronesia (Federated States of)
	// * `MD` - Moldova
	// * `MC` - Monaco
	// * `MN` - Mongolia
	// * `ME` - Montenegro
	// * `MS` - Montserrat
	// * `MA` - Morocco
	// * `MZ` - Mozambique
	// * `MM` - Myanmar
	// * `NA` - Namibia
	// * `NR` - Nauru
	// * `NP` - Nepal
	// * `NL` - Netherlands
	// * `NC` - New Caledonia
	// * `NZ` - New Zealand
	// * `NI` - Nicaragua
	// * `NE` - Niger
	// * `NG` - Nigeria
	// * `NU` - Niue
	// * `NF` - Norfolk Island
	// * `KP` - North Korea
	// * `MK` - North Macedonia
	// * `MP` - Northern Mariana Islands
	// * `NO` - Norway
	// * `OM` - Oman
	// * `PK` - Pakistan
	// * `PW` - Palau
	// * `PS` - Palestine, State of
	// * `PA` - Panama
	// * `PG` - Papua New Guinea
	// * `PY` - Paraguay
	// * `PE` - Peru
	// * `PH` - Philippines
	// * `PN` - Pitcairn
	// * `PL` - Poland
	// * `PT` - Portugal
	// * `PR` - Puerto Rico
	// * `QA` - Qatar
	// * `RE` - Réunion
	// * `RO` - Romania
	// * `RU` - Russia
	// * `RW` - Rwanda
	// * `BL` - Saint Barthélemy
	// * `SH` - Saint Helena, Ascension and Tristan da Cunha
	// * `KN` - Saint Kitts and Nevis
	// * `LC` - Saint Lucia
	// * `MF` - Saint Martin (French part)
	// * `PM` - Saint Pierre and Miquelon
	// * `VC` - Saint Vincent and the Grenadines
	// * `WS` - Samoa
	// * `SM` - San Marino
	// * `ST` - Sao Tome and Principe
	// * `SA` - Saudi Arabia
	// * `SN` - Senegal
	// * `RS` - Serbia
	// * `SC` - Seychelles
	// * `SL` - Sierra Leone
	// * `SG` - Singapore
	// * `SX` - Sint Maarten (Dutch part)
	// * `SK` - Slovakia
	// * `SI` - Slovenia
	// * `SB` - Solomon Islands
	// * `SO` - Somalia
	// * `ZA` - South Africa
	// * `GS` - South Georgia and the South Sandwich Islands
	// * `KR` - South Korea
	// * `SS` - South Sudan
	// * `ES` - Spain
	// * `LK` - Sri Lanka
	// * `SD` - Sudan
	// * `SR` - Suriname
	// * `SJ` - Svalbard and Jan Mayen
	// * `SE` - Sweden
	// * `CH` - Switzerland
	// * `SY` - Syria
	// * `TW` - Taiwan
	// * `TJ` - Tajikistan
	// * `TZ` - Tanzania
	// * `TH` - Thailand
	// * `TL` - Timor-Leste
	// * `TG` - Togo
	// * `TK` - Tokelau
	// * `TO` - Tonga
	// * `TT` - Trinidad and Tobago
	// * `TN` - Tunisia
	// * `TR` - Turkey
	// * `TM` - Turkmenistan
	// * `TC` - Turks and Caicos Islands
	// * `TV` - Tuvalu
	// * `UG` - Uganda
	// * `UA` - Ukraine
	// * `AE` - United Arab Emirates
	// * `GB` - United Kingdom
	// * `UM` - United States Minor Outlying Islands
	// * `US` - United States of America
	// * `UY` - Uruguay
	// * `UZ` - Uzbekistan
	// * `VU` - Vanuatu
	// * `VE` - Venezuela
	// * `VN` - Vietnam
	// * `VG` - Virgin Islands (British)
	// * `VI` - Virgin Islands (U.S.)
	// * `WF` - Wallis and Futuna
	// * `EH` - Western Sahara
	// * `YE` - Yemen
	// * `ZM` - Zambia
	// * `ZW` - Zimbabwe
	Country *AddressCountry `json:"country,omitempty"`
	// The address type.
	//
	// * `BILLING` - BILLING
	// * `SHIPPING` - SHIPPING
	AddressType *AddressAddressType `json:"address_type,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// The address type.
//
// * `BILLING` - BILLING
// * `SHIPPING` - SHIPPING
type AddressAddressType struct {
	typeName        string
	AddressTypeEnum AddressTypeEnum
	String          string
}

func NewAddressAddressTypeFromAddressTypeEnum(value AddressTypeEnum) *AddressAddressType {
	return &AddressAddressType{typeName: "addressTypeEnum", AddressTypeEnum: value}
}

func NewAddressAddressTypeFromString(value string) *AddressAddressType {
	return &AddressAddressType{typeName: "string", String: value}
}

func (a *AddressAddressType) UnmarshalJSON(data []byte) error {
	var valueAddressTypeEnum AddressTypeEnum
	if err := json.Unmarshal(data, &valueAddressTypeEnum); err == nil {
		a.typeName = "addressTypeEnum"
		a.AddressTypeEnum = valueAddressTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AddressAddressType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "addressTypeEnum":
		return json.Marshal(a.AddressTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AddressAddressTypeVisitor interface {
	VisitAddressTypeEnum(AddressTypeEnum) error
	VisitString(string) error
}

func (a *AddressAddressType) Accept(visitor AddressAddressTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "addressTypeEnum":
		return visitor.VisitAddressTypeEnum(a.AddressTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The address's country.
//
// * `AF` - Afghanistan
// * `AX` - Åland Islands
// * `AL` - Albania
// * `DZ` - Algeria
// * `AS` - American Samoa
// * `AD` - Andorra
// * `AO` - Angola
// * `AI` - Anguilla
// * `AQ` - Antarctica
// * `AG` - Antigua and Barbuda
// * `AR` - Argentina
// * `AM` - Armenia
// * `AW` - Aruba
// * `AU` - Australia
// * `AT` - Austria
// * `AZ` - Azerbaijan
// * `BS` - Bahamas
// * `BH` - Bahrain
// * `BD` - Bangladesh
// * `BB` - Barbados
// * `BY` - Belarus
// * `BE` - Belgium
// * `BZ` - Belize
// * `BJ` - Benin
// * `BM` - Bermuda
// * `BT` - Bhutan
// * `BO` - Bolivia
// * `BQ` - Bonaire, Sint Eustatius and Saba
// * `BA` - Bosnia and Herzegovina
// * `BW` - Botswana
// * `BV` - Bouvet Island
// * `BR` - Brazil
// * `IO` - British Indian Ocean Territory
// * `BN` - Brunei
// * `BG` - Bulgaria
// * `BF` - Burkina Faso
// * `BI` - Burundi
// * `CV` - Cabo Verde
// * `KH` - Cambodia
// * `CM` - Cameroon
// * `CA` - Canada
// * `KY` - Cayman Islands
// * `CF` - Central African Republic
// * `TD` - Chad
// * `CL` - Chile
// * `CN` - China
// * `CX` - Christmas Island
// * `CC` - Cocos (Keeling) Islands
// * `CO` - Colombia
// * `KM` - Comoros
// * `CG` - Congo
// * `CD` - Congo (the Democratic Republic of the)
// * `CK` - Cook Islands
// * `CR` - Costa Rica
// * `CI` - Côte d'Ivoire
// * `HR` - Croatia
// * `CU` - Cuba
// * `CW` - Curaçao
// * `CY` - Cyprus
// * `CZ` - Czechia
// * `DK` - Denmark
// * `DJ` - Djibouti
// * `DM` - Dominica
// * `DO` - Dominican Republic
// * `EC` - Ecuador
// * `EG` - Egypt
// * `SV` - El Salvador
// * `GQ` - Equatorial Guinea
// * `ER` - Eritrea
// * `EE` - Estonia
// * `SZ` - Eswatini
// * `ET` - Ethiopia
// * `FK` - Falkland Islands (Malvinas)
// * `FO` - Faroe Islands
// * `FJ` - Fiji
// * `FI` - Finland
// * `FR` - France
// * `GF` - French Guiana
// * `PF` - French Polynesia
// * `TF` - French Southern Territories
// * `GA` - Gabon
// * `GM` - Gambia
// * `GE` - Georgia
// * `DE` - Germany
// * `GH` - Ghana
// * `GI` - Gibraltar
// * `GR` - Greece
// * `GL` - Greenland
// * `GD` - Grenada
// * `GP` - Guadeloupe
// * `GU` - Guam
// * `GT` - Guatemala
// * `GG` - Guernsey
// * `GN` - Guinea
// * `GW` - Guinea-Bissau
// * `GY` - Guyana
// * `HT` - Haiti
// * `HM` - Heard Island and McDonald Islands
// * `VA` - Holy See
// * `HN` - Honduras
// * `HK` - Hong Kong
// * `HU` - Hungary
// * `IS` - Iceland
// * `IN` - India
// * `ID` - Indonesia
// * `IR` - Iran
// * `IQ` - Iraq
// * `IE` - Ireland
// * `IM` - Isle of Man
// * `IL` - Israel
// * `IT` - Italy
// * `JM` - Jamaica
// * `JP` - Japan
// * `JE` - Jersey
// * `JO` - Jordan
// * `KZ` - Kazakhstan
// * `KE` - Kenya
// * `KI` - Kiribati
// * `KW` - Kuwait
// * `KG` - Kyrgyzstan
// * `LA` - Laos
// * `LV` - Latvia
// * `LB` - Lebanon
// * `LS` - Lesotho
// * `LR` - Liberia
// * `LY` - Libya
// * `LI` - Liechtenstein
// * `LT` - Lithuania
// * `LU` - Luxembourg
// * `MO` - Macao
// * `MG` - Madagascar
// * `MW` - Malawi
// * `MY` - Malaysia
// * `MV` - Maldives
// * `ML` - Mali
// * `MT` - Malta
// * `MH` - Marshall Islands
// * `MQ` - Martinique
// * `MR` - Mauritania
// * `MU` - Mauritius
// * `YT` - Mayotte
// * `MX` - Mexico
// * `FM` - Micronesia (Federated States of)
// * `MD` - Moldova
// * `MC` - Monaco
// * `MN` - Mongolia
// * `ME` - Montenegro
// * `MS` - Montserrat
// * `MA` - Morocco
// * `MZ` - Mozambique
// * `MM` - Myanmar
// * `NA` - Namibia
// * `NR` - Nauru
// * `NP` - Nepal
// * `NL` - Netherlands
// * `NC` - New Caledonia
// * `NZ` - New Zealand
// * `NI` - Nicaragua
// * `NE` - Niger
// * `NG` - Nigeria
// * `NU` - Niue
// * `NF` - Norfolk Island
// * `KP` - North Korea
// * `MK` - North Macedonia
// * `MP` - Northern Mariana Islands
// * `NO` - Norway
// * `OM` - Oman
// * `PK` - Pakistan
// * `PW` - Palau
// * `PS` - Palestine, State of
// * `PA` - Panama
// * `PG` - Papua New Guinea
// * `PY` - Paraguay
// * `PE` - Peru
// * `PH` - Philippines
// * `PN` - Pitcairn
// * `PL` - Poland
// * `PT` - Portugal
// * `PR` - Puerto Rico
// * `QA` - Qatar
// * `RE` - Réunion
// * `RO` - Romania
// * `RU` - Russia
// * `RW` - Rwanda
// * `BL` - Saint Barthélemy
// * `SH` - Saint Helena, Ascension and Tristan da Cunha
// * `KN` - Saint Kitts and Nevis
// * `LC` - Saint Lucia
// * `MF` - Saint Martin (French part)
// * `PM` - Saint Pierre and Miquelon
// * `VC` - Saint Vincent and the Grenadines
// * `WS` - Samoa
// * `SM` - San Marino
// * `ST` - Sao Tome and Principe
// * `SA` - Saudi Arabia
// * `SN` - Senegal
// * `RS` - Serbia
// * `SC` - Seychelles
// * `SL` - Sierra Leone
// * `SG` - Singapore
// * `SX` - Sint Maarten (Dutch part)
// * `SK` - Slovakia
// * `SI` - Slovenia
// * `SB` - Solomon Islands
// * `SO` - Somalia
// * `ZA` - South Africa
// * `GS` - South Georgia and the South Sandwich Islands
// * `KR` - South Korea
// * `SS` - South Sudan
// * `ES` - Spain
// * `LK` - Sri Lanka
// * `SD` - Sudan
// * `SR` - Suriname
// * `SJ` - Svalbard and Jan Mayen
// * `SE` - Sweden
// * `CH` - Switzerland
// * `SY` - Syria
// * `TW` - Taiwan
// * `TJ` - Tajikistan
// * `TZ` - Tanzania
// * `TH` - Thailand
// * `TL` - Timor-Leste
// * `TG` - Togo
// * `TK` - Tokelau
// * `TO` - Tonga
// * `TT` - Trinidad and Tobago
// * `TN` - Tunisia
// * `TR` - Turkey
// * `TM` - Turkmenistan
// * `TC` - Turks and Caicos Islands
// * `TV` - Tuvalu
// * `UG` - Uganda
// * `UA` - Ukraine
// * `AE` - United Arab Emirates
// * `GB` - United Kingdom
// * `UM` - United States Minor Outlying Islands
// * `US` - United States of America
// * `UY` - Uruguay
// * `UZ` - Uzbekistan
// * `VU` - Vanuatu
// * `VE` - Venezuela
// * `VN` - Vietnam
// * `VG` - Virgin Islands (British)
// * `VI` - Virgin Islands (U.S.)
// * `WF` - Wallis and Futuna
// * `EH` - Western Sahara
// * `YE` - Yemen
// * `ZM` - Zambia
// * `ZW` - Zimbabwe
type AddressCountry struct {
	typeName    string
	CountryEnum CountryEnum
	String      string
}

func NewAddressCountryFromCountryEnum(value CountryEnum) *AddressCountry {
	return &AddressCountry{typeName: "countryEnum", CountryEnum: value}
}

func NewAddressCountryFromString(value string) *AddressCountry {
	return &AddressCountry{typeName: "string", String: value}
}

func (a *AddressCountry) UnmarshalJSON(data []byte) error {
	var valueCountryEnum CountryEnum
	if err := json.Unmarshal(data, &valueCountryEnum); err == nil {
		a.typeName = "countryEnum"
		a.CountryEnum = valueCountryEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AddressCountry) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "countryEnum":
		return json.Marshal(a.CountryEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AddressCountryVisitor interface {
	VisitCountryEnum(CountryEnum) error
	VisitString(string) error
}

func (a *AddressCountry) Accept(visitor AddressCountryVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "countryEnum":
		return visitor.VisitCountryEnum(a.CountryEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// # The Address Object
// ### Description
// The `Address` object is used to represent an entity's address.
// ### Usage Example
// TODO
type AddressRequest struct {
	// Line 1 of the address's street.
	Street1 *string `json:"street_1,omitempty"`
	// Line 2 of the address's street.
	Street2 *string `json:"street_2,omitempty"`
	// The address's city.
	City *string `json:"city,omitempty"`
	// The address's state.
	State *string `json:"state,omitempty"`
	// The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`
	// The address's country.
	//
	// * `AF` - Afghanistan
	// * `AX` - Åland Islands
	// * `AL` - Albania
	// * `DZ` - Algeria
	// * `AS` - American Samoa
	// * `AD` - Andorra
	// * `AO` - Angola
	// * `AI` - Anguilla
	// * `AQ` - Antarctica
	// * `AG` - Antigua and Barbuda
	// * `AR` - Argentina
	// * `AM` - Armenia
	// * `AW` - Aruba
	// * `AU` - Australia
	// * `AT` - Austria
	// * `AZ` - Azerbaijan
	// * `BS` - Bahamas
	// * `BH` - Bahrain
	// * `BD` - Bangladesh
	// * `BB` - Barbados
	// * `BY` - Belarus
	// * `BE` - Belgium
	// * `BZ` - Belize
	// * `BJ` - Benin
	// * `BM` - Bermuda
	// * `BT` - Bhutan
	// * `BO` - Bolivia
	// * `BQ` - Bonaire, Sint Eustatius and Saba
	// * `BA` - Bosnia and Herzegovina
	// * `BW` - Botswana
	// * `BV` - Bouvet Island
	// * `BR` - Brazil
	// * `IO` - British Indian Ocean Territory
	// * `BN` - Brunei
	// * `BG` - Bulgaria
	// * `BF` - Burkina Faso
	// * `BI` - Burundi
	// * `CV` - Cabo Verde
	// * `KH` - Cambodia
	// * `CM` - Cameroon
	// * `CA` - Canada
	// * `KY` - Cayman Islands
	// * `CF` - Central African Republic
	// * `TD` - Chad
	// * `CL` - Chile
	// * `CN` - China
	// * `CX` - Christmas Island
	// * `CC` - Cocos (Keeling) Islands
	// * `CO` - Colombia
	// * `KM` - Comoros
	// * `CG` - Congo
	// * `CD` - Congo (the Democratic Republic of the)
	// * `CK` - Cook Islands
	// * `CR` - Costa Rica
	// * `CI` - Côte d'Ivoire
	// * `HR` - Croatia
	// * `CU` - Cuba
	// * `CW` - Curaçao
	// * `CY` - Cyprus
	// * `CZ` - Czechia
	// * `DK` - Denmark
	// * `DJ` - Djibouti
	// * `DM` - Dominica
	// * `DO` - Dominican Republic
	// * `EC` - Ecuador
	// * `EG` - Egypt
	// * `SV` - El Salvador
	// * `GQ` - Equatorial Guinea
	// * `ER` - Eritrea
	// * `EE` - Estonia
	// * `SZ` - Eswatini
	// * `ET` - Ethiopia
	// * `FK` - Falkland Islands (Malvinas)
	// * `FO` - Faroe Islands
	// * `FJ` - Fiji
	// * `FI` - Finland
	// * `FR` - France
	// * `GF` - French Guiana
	// * `PF` - French Polynesia
	// * `TF` - French Southern Territories
	// * `GA` - Gabon
	// * `GM` - Gambia
	// * `GE` - Georgia
	// * `DE` - Germany
	// * `GH` - Ghana
	// * `GI` - Gibraltar
	// * `GR` - Greece
	// * `GL` - Greenland
	// * `GD` - Grenada
	// * `GP` - Guadeloupe
	// * `GU` - Guam
	// * `GT` - Guatemala
	// * `GG` - Guernsey
	// * `GN` - Guinea
	// * `GW` - Guinea-Bissau
	// * `GY` - Guyana
	// * `HT` - Haiti
	// * `HM` - Heard Island and McDonald Islands
	// * `VA` - Holy See
	// * `HN` - Honduras
	// * `HK` - Hong Kong
	// * `HU` - Hungary
	// * `IS` - Iceland
	// * `IN` - India
	// * `ID` - Indonesia
	// * `IR` - Iran
	// * `IQ` - Iraq
	// * `IE` - Ireland
	// * `IM` - Isle of Man
	// * `IL` - Israel
	// * `IT` - Italy
	// * `JM` - Jamaica
	// * `JP` - Japan
	// * `JE` - Jersey
	// * `JO` - Jordan
	// * `KZ` - Kazakhstan
	// * `KE` - Kenya
	// * `KI` - Kiribati
	// * `KW` - Kuwait
	// * `KG` - Kyrgyzstan
	// * `LA` - Laos
	// * `LV` - Latvia
	// * `LB` - Lebanon
	// * `LS` - Lesotho
	// * `LR` - Liberia
	// * `LY` - Libya
	// * `LI` - Liechtenstein
	// * `LT` - Lithuania
	// * `LU` - Luxembourg
	// * `MO` - Macao
	// * `MG` - Madagascar
	// * `MW` - Malawi
	// * `MY` - Malaysia
	// * `MV` - Maldives
	// * `ML` - Mali
	// * `MT` - Malta
	// * `MH` - Marshall Islands
	// * `MQ` - Martinique
	// * `MR` - Mauritania
	// * `MU` - Mauritius
	// * `YT` - Mayotte
	// * `MX` - Mexico
	// * `FM` - Micronesia (Federated States of)
	// * `MD` - Moldova
	// * `MC` - Monaco
	// * `MN` - Mongolia
	// * `ME` - Montenegro
	// * `MS` - Montserrat
	// * `MA` - Morocco
	// * `MZ` - Mozambique
	// * `MM` - Myanmar
	// * `NA` - Namibia
	// * `NR` - Nauru
	// * `NP` - Nepal
	// * `NL` - Netherlands
	// * `NC` - New Caledonia
	// * `NZ` - New Zealand
	// * `NI` - Nicaragua
	// * `NE` - Niger
	// * `NG` - Nigeria
	// * `NU` - Niue
	// * `NF` - Norfolk Island
	// * `KP` - North Korea
	// * `MK` - North Macedonia
	// * `MP` - Northern Mariana Islands
	// * `NO` - Norway
	// * `OM` - Oman
	// * `PK` - Pakistan
	// * `PW` - Palau
	// * `PS` - Palestine, State of
	// * `PA` - Panama
	// * `PG` - Papua New Guinea
	// * `PY` - Paraguay
	// * `PE` - Peru
	// * `PH` - Philippines
	// * `PN` - Pitcairn
	// * `PL` - Poland
	// * `PT` - Portugal
	// * `PR` - Puerto Rico
	// * `QA` - Qatar
	// * `RE` - Réunion
	// * `RO` - Romania
	// * `RU` - Russia
	// * `RW` - Rwanda
	// * `BL` - Saint Barthélemy
	// * `SH` - Saint Helena, Ascension and Tristan da Cunha
	// * `KN` - Saint Kitts and Nevis
	// * `LC` - Saint Lucia
	// * `MF` - Saint Martin (French part)
	// * `PM` - Saint Pierre and Miquelon
	// * `VC` - Saint Vincent and the Grenadines
	// * `WS` - Samoa
	// * `SM` - San Marino
	// * `ST` - Sao Tome and Principe
	// * `SA` - Saudi Arabia
	// * `SN` - Senegal
	// * `RS` - Serbia
	// * `SC` - Seychelles
	// * `SL` - Sierra Leone
	// * `SG` - Singapore
	// * `SX` - Sint Maarten (Dutch part)
	// * `SK` - Slovakia
	// * `SI` - Slovenia
	// * `SB` - Solomon Islands
	// * `SO` - Somalia
	// * `ZA` - South Africa
	// * `GS` - South Georgia and the South Sandwich Islands
	// * `KR` - South Korea
	// * `SS` - South Sudan
	// * `ES` - Spain
	// * `LK` - Sri Lanka
	// * `SD` - Sudan
	// * `SR` - Suriname
	// * `SJ` - Svalbard and Jan Mayen
	// * `SE` - Sweden
	// * `CH` - Switzerland
	// * `SY` - Syria
	// * `TW` - Taiwan
	// * `TJ` - Tajikistan
	// * `TZ` - Tanzania
	// * `TH` - Thailand
	// * `TL` - Timor-Leste
	// * `TG` - Togo
	// * `TK` - Tokelau
	// * `TO` - Tonga
	// * `TT` - Trinidad and Tobago
	// * `TN` - Tunisia
	// * `TR` - Turkey
	// * `TM` - Turkmenistan
	// * `TC` - Turks and Caicos Islands
	// * `TV` - Tuvalu
	// * `UG` - Uganda
	// * `UA` - Ukraine
	// * `AE` - United Arab Emirates
	// * `GB` - United Kingdom
	// * `UM` - United States Minor Outlying Islands
	// * `US` - United States of America
	// * `UY` - Uruguay
	// * `UZ` - Uzbekistan
	// * `VU` - Vanuatu
	// * `VE` - Venezuela
	// * `VN` - Vietnam
	// * `VG` - Virgin Islands (British)
	// * `VI` - Virgin Islands (U.S.)
	// * `WF` - Wallis and Futuna
	// * `EH` - Western Sahara
	// * `YE` - Yemen
	// * `ZM` - Zambia
	// * `ZW` - Zimbabwe
	Country *AddressRequestCountry `json:"country,omitempty"`
	// The address type.
	//
	// * `BILLING` - BILLING
	// * `SHIPPING` - SHIPPING
	AddressType         *AddressRequestAddressType `json:"address_type,omitempty"`
	IntegrationParams   map[string]any             `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any             `json:"linked_account_params,omitempty"`
}

// The address type.
//
// * `BILLING` - BILLING
// * `SHIPPING` - SHIPPING
type AddressRequestAddressType struct {
	typeName        string
	AddressTypeEnum AddressTypeEnum
	String          string
}

func NewAddressRequestAddressTypeFromAddressTypeEnum(value AddressTypeEnum) *AddressRequestAddressType {
	return &AddressRequestAddressType{typeName: "addressTypeEnum", AddressTypeEnum: value}
}

func NewAddressRequestAddressTypeFromString(value string) *AddressRequestAddressType {
	return &AddressRequestAddressType{typeName: "string", String: value}
}

func (a *AddressRequestAddressType) UnmarshalJSON(data []byte) error {
	var valueAddressTypeEnum AddressTypeEnum
	if err := json.Unmarshal(data, &valueAddressTypeEnum); err == nil {
		a.typeName = "addressTypeEnum"
		a.AddressTypeEnum = valueAddressTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AddressRequestAddressType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "addressTypeEnum":
		return json.Marshal(a.AddressTypeEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AddressRequestAddressTypeVisitor interface {
	VisitAddressTypeEnum(AddressTypeEnum) error
	VisitString(string) error
}

func (a *AddressRequestAddressType) Accept(visitor AddressRequestAddressTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "addressTypeEnum":
		return visitor.VisitAddressTypeEnum(a.AddressTypeEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// The address's country.
//
// * `AF` - Afghanistan
// * `AX` - Åland Islands
// * `AL` - Albania
// * `DZ` - Algeria
// * `AS` - American Samoa
// * `AD` - Andorra
// * `AO` - Angola
// * `AI` - Anguilla
// * `AQ` - Antarctica
// * `AG` - Antigua and Barbuda
// * `AR` - Argentina
// * `AM` - Armenia
// * `AW` - Aruba
// * `AU` - Australia
// * `AT` - Austria
// * `AZ` - Azerbaijan
// * `BS` - Bahamas
// * `BH` - Bahrain
// * `BD` - Bangladesh
// * `BB` - Barbados
// * `BY` - Belarus
// * `BE` - Belgium
// * `BZ` - Belize
// * `BJ` - Benin
// * `BM` - Bermuda
// * `BT` - Bhutan
// * `BO` - Bolivia
// * `BQ` - Bonaire, Sint Eustatius and Saba
// * `BA` - Bosnia and Herzegovina
// * `BW` - Botswana
// * `BV` - Bouvet Island
// * `BR` - Brazil
// * `IO` - British Indian Ocean Territory
// * `BN` - Brunei
// * `BG` - Bulgaria
// * `BF` - Burkina Faso
// * `BI` - Burundi
// * `CV` - Cabo Verde
// * `KH` - Cambodia
// * `CM` - Cameroon
// * `CA` - Canada
// * `KY` - Cayman Islands
// * `CF` - Central African Republic
// * `TD` - Chad
// * `CL` - Chile
// * `CN` - China
// * `CX` - Christmas Island
// * `CC` - Cocos (Keeling) Islands
// * `CO` - Colombia
// * `KM` - Comoros
// * `CG` - Congo
// * `CD` - Congo (the Democratic Republic of the)
// * `CK` - Cook Islands
// * `CR` - Costa Rica
// * `CI` - Côte d'Ivoire
// * `HR` - Croatia
// * `CU` - Cuba
// * `CW` - Curaçao
// * `CY` - Cyprus
// * `CZ` - Czechia
// * `DK` - Denmark
// * `DJ` - Djibouti
// * `DM` - Dominica
// * `DO` - Dominican Republic
// * `EC` - Ecuador
// * `EG` - Egypt
// * `SV` - El Salvador
// * `GQ` - Equatorial Guinea
// * `ER` - Eritrea
// * `EE` - Estonia
// * `SZ` - Eswatini
// * `ET` - Ethiopia
// * `FK` - Falkland Islands (Malvinas)
// * `FO` - Faroe Islands
// * `FJ` - Fiji
// * `FI` - Finland
// * `FR` - France
// * `GF` - French Guiana
// * `PF` - French Polynesia
// * `TF` - French Southern Territories
// * `GA` - Gabon
// * `GM` - Gambia
// * `GE` - Georgia
// * `DE` - Germany
// * `GH` - Ghana
// * `GI` - Gibraltar
// * `GR` - Greece
// * `GL` - Greenland
// * `GD` - Grenada
// * `GP` - Guadeloupe
// * `GU` - Guam
// * `GT` - Guatemala
// * `GG` - Guernsey
// * `GN` - Guinea
// * `GW` - Guinea-Bissau
// * `GY` - Guyana
// * `HT` - Haiti
// * `HM` - Heard Island and McDonald Islands
// * `VA` - Holy See
// * `HN` - Honduras
// * `HK` - Hong Kong
// * `HU` - Hungary
// * `IS` - Iceland
// * `IN` - India
// * `ID` - Indonesia
// * `IR` - Iran
// * `IQ` - Iraq
// * `IE` - Ireland
// * `IM` - Isle of Man
// * `IL` - Israel
// * `IT` - Italy
// * `JM` - Jamaica
// * `JP` - Japan
// * `JE` - Jersey
// * `JO` - Jordan
// * `KZ` - Kazakhstan
// * `KE` - Kenya
// * `KI` - Kiribati
// * `KW` - Kuwait
// * `KG` - Kyrgyzstan
// * `LA` - Laos
// * `LV` - Latvia
// * `LB` - Lebanon
// * `LS` - Lesotho
// * `LR` - Liberia
// * `LY` - Libya
// * `LI` - Liechtenstein
// * `LT` - Lithuania
// * `LU` - Luxembourg
// * `MO` - Macao
// * `MG` - Madagascar
// * `MW` - Malawi
// * `MY` - Malaysia
// * `MV` - Maldives
// * `ML` - Mali
// * `MT` - Malta
// * `MH` - Marshall Islands
// * `MQ` - Martinique
// * `MR` - Mauritania
// * `MU` - Mauritius
// * `YT` - Mayotte
// * `MX` - Mexico
// * `FM` - Micronesia (Federated States of)
// * `MD` - Moldova
// * `MC` - Monaco
// * `MN` - Mongolia
// * `ME` - Montenegro
// * `MS` - Montserrat
// * `MA` - Morocco
// * `MZ` - Mozambique
// * `MM` - Myanmar
// * `NA` - Namibia
// * `NR` - Nauru
// * `NP` - Nepal
// * `NL` - Netherlands
// * `NC` - New Caledonia
// * `NZ` - New Zealand
// * `NI` - Nicaragua
// * `NE` - Niger
// * `NG` - Nigeria
// * `NU` - Niue
// * `NF` - Norfolk Island
// * `KP` - North Korea
// * `MK` - North Macedonia
// * `MP` - Northern Mariana Islands
// * `NO` - Norway
// * `OM` - Oman
// * `PK` - Pakistan
// * `PW` - Palau
// * `PS` - Palestine, State of
// * `PA` - Panama
// * `PG` - Papua New Guinea
// * `PY` - Paraguay
// * `PE` - Peru
// * `PH` - Philippines
// * `PN` - Pitcairn
// * `PL` - Poland
// * `PT` - Portugal
// * `PR` - Puerto Rico
// * `QA` - Qatar
// * `RE` - Réunion
// * `RO` - Romania
// * `RU` - Russia
// * `RW` - Rwanda
// * `BL` - Saint Barthélemy
// * `SH` - Saint Helena, Ascension and Tristan da Cunha
// * `KN` - Saint Kitts and Nevis
// * `LC` - Saint Lucia
// * `MF` - Saint Martin (French part)
// * `PM` - Saint Pierre and Miquelon
// * `VC` - Saint Vincent and the Grenadines
// * `WS` - Samoa
// * `SM` - San Marino
// * `ST` - Sao Tome and Principe
// * `SA` - Saudi Arabia
// * `SN` - Senegal
// * `RS` - Serbia
// * `SC` - Seychelles
// * `SL` - Sierra Leone
// * `SG` - Singapore
// * `SX` - Sint Maarten (Dutch part)
// * `SK` - Slovakia
// * `SI` - Slovenia
// * `SB` - Solomon Islands
// * `SO` - Somalia
// * `ZA` - South Africa
// * `GS` - South Georgia and the South Sandwich Islands
// * `KR` - South Korea
// * `SS` - South Sudan
// * `ES` - Spain
// * `LK` - Sri Lanka
// * `SD` - Sudan
// * `SR` - Suriname
// * `SJ` - Svalbard and Jan Mayen
// * `SE` - Sweden
// * `CH` - Switzerland
// * `SY` - Syria
// * `TW` - Taiwan
// * `TJ` - Tajikistan
// * `TZ` - Tanzania
// * `TH` - Thailand
// * `TL` - Timor-Leste
// * `TG` - Togo
// * `TK` - Tokelau
// * `TO` - Tonga
// * `TT` - Trinidad and Tobago
// * `TN` - Tunisia
// * `TR` - Turkey
// * `TM` - Turkmenistan
// * `TC` - Turks and Caicos Islands
// * `TV` - Tuvalu
// * `UG` - Uganda
// * `UA` - Ukraine
// * `AE` - United Arab Emirates
// * `GB` - United Kingdom
// * `UM` - United States Minor Outlying Islands
// * `US` - United States of America
// * `UY` - Uruguay
// * `UZ` - Uzbekistan
// * `VU` - Vanuatu
// * `VE` - Venezuela
// * `VN` - Vietnam
// * `VG` - Virgin Islands (British)
// * `VI` - Virgin Islands (U.S.)
// * `WF` - Wallis and Futuna
// * `EH` - Western Sahara
// * `YE` - Yemen
// * `ZM` - Zambia
// * `ZW` - Zimbabwe
type AddressRequestCountry struct {
	typeName    string
	CountryEnum CountryEnum
	String      string
}

func NewAddressRequestCountryFromCountryEnum(value CountryEnum) *AddressRequestCountry {
	return &AddressRequestCountry{typeName: "countryEnum", CountryEnum: value}
}

func NewAddressRequestCountryFromString(value string) *AddressRequestCountry {
	return &AddressRequestCountry{typeName: "string", String: value}
}

func (a *AddressRequestCountry) UnmarshalJSON(data []byte) error {
	var valueCountryEnum CountryEnum
	if err := json.Unmarshal(data, &valueCountryEnum); err == nil {
		a.typeName = "countryEnum"
		a.CountryEnum = valueCountryEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AddressRequestCountry) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "countryEnum":
		return json.Marshal(a.CountryEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AddressRequestCountryVisitor interface {
	VisitCountryEnum(CountryEnum) error
	VisitString(string) error
}

func (a *AddressRequestCountry) Accept(visitor AddressRequestCountryVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "countryEnum":
		return visitor.VisitCountryEnum(a.CountryEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

// * `BILLING` - BILLING
// * `SHIPPING` - SHIPPING
type AddressTypeEnum uint

const (
	AddressTypeEnumBilling AddressTypeEnum = iota + 1
	AddressTypeEnumShipping
)

func (a AddressTypeEnum) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AddressTypeEnumBilling:
		return "BILLING"
	case AddressTypeEnumShipping:
		return "SHIPPING"
	}
}

func (a AddressTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AddressTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "BILLING":
		value := AddressTypeEnumBilling
		*a = value
	case "SHIPPING":
		value := AddressTypeEnumShipping
		*a = value
	}
	return nil
}

// # The Association Object
// ### Description
// The `Association` record refers to an instance of an Association Type.
// ### Usage Example
// TODO
type Association struct {
	SourceObject    map[string]any              `json:"source_object,omitempty"`
	TargetObject    map[string]any              `json:"target_object,omitempty"`
	AssociationType *AssociationAssociationType `json:"association_type,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

type AssociationAssociationType struct {
	typeName        string
	String          string
	AssociationType *AssociationType
}

func NewAssociationAssociationTypeFromString(value string) *AssociationAssociationType {
	return &AssociationAssociationType{typeName: "string", String: value}
}

func NewAssociationAssociationTypeFromAssociationType(value *AssociationType) *AssociationAssociationType {
	return &AssociationAssociationType{typeName: "associationType", AssociationType: value}
}

func (a *AssociationAssociationType) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	valueAssociationType := new(AssociationType)
	if err := json.Unmarshal(data, &valueAssociationType); err == nil {
		a.typeName = "associationType"
		a.AssociationType = valueAssociationType
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssociationAssociationType) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "associationType":
		return json.Marshal(a.AssociationType)
	}
}

type AssociationAssociationTypeVisitor interface {
	VisitString(string) error
	VisitAssociationType(*AssociationType) error
}

func (a *AssociationAssociationType) Accept(visitor AssociationAssociationTypeVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "associationType":
		return visitor.VisitAssociationType(a.AssociationType)
	}
}

type AssociationSubType struct {
	Id         *string `json:"id,omitempty"`
	OriginType *string `json:"origin_type,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// # The AssociationType Object
// ### Description
// The `Association Type` object represents the relationship between two objects.
// ### Usage Example
// TODO
type AssociationType struct {
	SourceObjectClass   map[string]any              `json:"source_object_class,omitempty"`
	TargetObjectClasses []*AssociationSubType       `json:"target_object_classes,omitempty"`
	RemoteKeyName       *string                     `json:"remote_key_name,omitempty"`
	DisplayName         *string                     `json:"display_name,omitempty"`
	Cardinality         *AssociationTypeCardinality `json:"cardinality,omitempty"`
	IsRequired          *bool                       `json:"is_required,omitempty"`
	Id                  *string                     `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

type AssociationTypeCardinality struct {
	typeName        string
	CardinalityEnum CardinalityEnum
	String          string
}

func NewAssociationTypeCardinalityFromCardinalityEnum(value CardinalityEnum) *AssociationTypeCardinality {
	return &AssociationTypeCardinality{typeName: "cardinalityEnum", CardinalityEnum: value}
}

func NewAssociationTypeCardinalityFromString(value string) *AssociationTypeCardinality {
	return &AssociationTypeCardinality{typeName: "string", String: value}
}

func (a *AssociationTypeCardinality) UnmarshalJSON(data []byte) error {
	var valueCardinalityEnum CardinalityEnum
	if err := json.Unmarshal(data, &valueCardinalityEnum); err == nil {
		a.typeName = "cardinalityEnum"
		a.CardinalityEnum = valueCardinalityEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssociationTypeCardinality) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "cardinalityEnum":
		return json.Marshal(a.CardinalityEnum)
	case "string":
		return json.Marshal(a.String)
	}
}

type AssociationTypeCardinalityVisitor interface {
	VisitCardinalityEnum(CardinalityEnum) error
	VisitString(string) error
}

func (a *AssociationTypeCardinality) Accept(visitor AssociationTypeCardinalityVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "cardinalityEnum":
		return visitor.VisitCardinalityEnum(a.CardinalityEnum)
	case "string":
		return visitor.VisitString(a.String)
	}
}

type AssociationTypeRequestRequest struct {
	SourceObjectClass   *ObjectClassDescriptionRequest   `json:"source_object_class,omitempty"`
	TargetObjectClasses []*ObjectClassDescriptionRequest `json:"target_object_classes,omitempty"`
	// <span style="white-space: nowrap">`non-empty`</span>
	RemoteKeyName string `json:"remote_key_name"`
	// <span style="white-space: nowrap">`non-empty`</span>
	DisplayName *string          `json:"display_name,omitempty"`
	Cardinality *CardinalityEnum `json:"cardinality,omitempty"`
	IsRequired  *bool            `json:"is_required,omitempty"`
}

type AsyncPassthroughReciept struct {
	AsyncPassthroughReceiptId string `json:"async_passthrough_receipt_id"`
}

// # The AvailableActions Object
// ### Description
// The `Activity` object is used to see all available model/operation combinations for an integration.
//
// ### Usage Example
// Fetch all the actions available for the `Zenefits` integration.
type AvailableActions struct {
	Integration              *AccountIntegration `json:"integration,omitempty"`
	PassthroughAvailable     bool                `json:"passthrough_available"`
	AvailableModelOperations []*ModelOperation   `json:"available_model_operations,omitempty"`
}

// * `ONE_TO_ONE` - ONE_TO_ONE
// * `MANY_TO_ONE` - MANY_TO_ONE
// * `MANY_TO_MANY` - MANY_TO_MANY
// * `ONE_TO_MANY` - ONE_TO_MANY
type CardinalityEnum uint

const (
	CardinalityEnumOneToOne CardinalityEnum = iota + 1
	CardinalityEnumManyToOne
	CardinalityEnumManyToMany
	CardinalityEnumOneToMany
)

func (c CardinalityEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CardinalityEnumOneToOne:
		return "ONE_TO_ONE"
	case CardinalityEnumManyToOne:
		return "MANY_TO_ONE"
	case CardinalityEnumManyToMany:
		return "MANY_TO_MANY"
	case CardinalityEnumOneToMany:
		return "ONE_TO_MANY"
	}
}

func (c CardinalityEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CardinalityEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ONE_TO_ONE":
		value := CardinalityEnumOneToOne
		*c = value
	case "MANY_TO_ONE":
		value := CardinalityEnumManyToOne
		*c = value
	case "MANY_TO_MANY":
		value := CardinalityEnumManyToMany
		*c = value
	case "ONE_TO_MANY":
		value := CardinalityEnumOneToMany
		*c = value
	}
	return nil
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoriesEnum uint

const (
	CategoriesEnumHris CategoriesEnum = iota + 1
	CategoriesEnumAts
	CategoriesEnumAccounting
	CategoriesEnumTicketing
	CategoriesEnumCrm
	CategoriesEnumMktg
	CategoriesEnumFilestorage
)

func (c CategoriesEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoriesEnumHris:
		return "hris"
	case CategoriesEnumAts:
		return "ats"
	case CategoriesEnumAccounting:
		return "accounting"
	case CategoriesEnumTicketing:
		return "ticketing"
	case CategoriesEnumCrm:
		return "crm"
	case CategoriesEnumMktg:
		return "mktg"
	case CategoriesEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoriesEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoriesEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoriesEnumHris
		*c = value
	case "ats":
		value := CategoriesEnumAts
		*c = value
	case "accounting":
		value := CategoriesEnumAccounting
		*c = value
	case "ticketing":
		value := CategoriesEnumTicketing
		*c = value
	case "crm":
		value := CategoriesEnumCrm
		*c = value
	case "mktg":
		value := CategoriesEnumMktg
		*c = value
	case "filestorage":
		value := CategoriesEnumFilestorage
		*c = value
	}
	return nil
}

// * `hris` - hris
// * `ats` - ats
// * `accounting` - accounting
// * `ticketing` - ticketing
// * `crm` - crm
// * `mktg` - mktg
// * `filestorage` - filestorage
type CategoryEnum uint

const (
	CategoryEnumHris CategoryEnum = iota + 1
	CategoryEnumAts
	CategoryEnumAccounting
	CategoryEnumTicketing
	CategoryEnumCrm
	CategoryEnumMktg
	CategoryEnumFilestorage
)

func (c CategoryEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CategoryEnumHris:
		return "hris"
	case CategoryEnumAts:
		return "ats"
	case CategoryEnumAccounting:
		return "accounting"
	case CategoryEnumTicketing:
		return "ticketing"
	case CategoryEnumCrm:
		return "crm"
	case CategoryEnumMktg:
		return "mktg"
	case CategoryEnumFilestorage:
		return "filestorage"
	}
}

func (c CategoryEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CategoryEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hris":
		value := CategoryEnumHris
		*c = value
	case "ats":
		value := CategoryEnumAts
		*c = value
	case "accounting":
		value := CategoryEnumAccounting
		*c = value
	case "ticketing":
		value := CategoryEnumTicketing
		*c = value
	case "crm":
		value := CategoryEnumCrm
		*c = value
	case "mktg":
		value := CategoryEnumMktg
		*c = value
	case "filestorage":
		value := CategoryEnumFilestorage
		*c = value
	}
	return nil
}

type CommonModelScopesBodyRequest struct {
	// <span style="white-space: nowrap">`non-empty`</span>
	ModelId        string               `json:"model_id"`
	EnabledActions []EnabledActionsEnum `json:"enabled_actions,omitempty"`
	DisabledFields []string             `json:"disabled_fields,omitempty"`
}

type ConditionSchema struct {
	// The ID of the condition schema. This ID is used when updating selective syncs for a linked account.
	Id string `json:"id"`
	// The common model for which a condition schema is defined.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing *native condition* name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
	// Whether this condition can only be applied once. If false, the condition can be AND'd together multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
	// The type of value(s) that can be set for this condition.
	//
	// * `BOOLEAN` - BOOLEAN
	// * `DATE` - DATE
	// * `DATE_TIME` - DATE_TIME
	// * `INTEGER` - INTEGER
	// * `FLOAT` - FLOAT
	// * `STRING` - STRING
	// * `LIST_OF_STRINGS` - LIST_OF_STRINGS
	ConditionType *ConditionSchemaConditionType `json:"condition_type,omitempty"`
	// The schemas for the operators that can be used on a condition.
	Operators []*OperatorSchema `json:"operators,omitempty"`
}

// The type of value(s) that can be set for this condition.
//
// * `BOOLEAN` - BOOLEAN
// * `DATE` - DATE
// * `DATE_TIME` - DATE_TIME
// * `INTEGER` - INTEGER
// * `FLOAT` - FLOAT
// * `STRING` - STRING
// * `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionSchemaConditionType struct {
	typeName          string
	ConditionTypeEnum ConditionTypeEnum
	String            string
}

func NewConditionSchemaConditionTypeFromConditionTypeEnum(value ConditionTypeEnum) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "conditionTypeEnum", ConditionTypeEnum: value}
}

func NewConditionSchemaConditionTypeFromString(value string) *ConditionSchemaConditionType {
	return &ConditionSchemaConditionType{typeName: "string", String: value}
}

func (c *ConditionSchemaConditionType) UnmarshalJSON(data []byte) error {
	var valueConditionTypeEnum ConditionTypeEnum
	if err := json.Unmarshal(data, &valueConditionTypeEnum); err == nil {
		c.typeName = "conditionTypeEnum"
		c.ConditionTypeEnum = valueConditionTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConditionSchemaConditionType) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return json.Marshal(c.ConditionTypeEnum)
	case "string":
		return json.Marshal(c.String)
	}
}

type ConditionSchemaConditionTypeVisitor interface {
	VisitConditionTypeEnum(ConditionTypeEnum) error
	VisitString(string) error
}

func (c *ConditionSchemaConditionType) Accept(visitor ConditionSchemaConditionTypeVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "conditionTypeEnum":
		return visitor.VisitConditionTypeEnum(c.ConditionTypeEnum)
	case "string":
		return visitor.VisitString(c.String)
	}
}

// * `BOOLEAN` - BOOLEAN
// * `DATE` - DATE
// * `DATE_TIME` - DATE_TIME
// * `INTEGER` - INTEGER
// * `FLOAT` - FLOAT
// * `STRING` - STRING
// * `LIST_OF_STRINGS` - LIST_OF_STRINGS
type ConditionTypeEnum uint

const (
	ConditionTypeEnumBoolean ConditionTypeEnum = iota + 1
	ConditionTypeEnumDate
	ConditionTypeEnumDateTime
	ConditionTypeEnumInteger
	ConditionTypeEnumFloat
	ConditionTypeEnumString
	ConditionTypeEnumListOfStrings
)

func (c ConditionTypeEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case ConditionTypeEnumBoolean:
		return "BOOLEAN"
	case ConditionTypeEnumDate:
		return "DATE"
	case ConditionTypeEnumDateTime:
		return "DATE_TIME"
	case ConditionTypeEnumInteger:
		return "INTEGER"
	case ConditionTypeEnumFloat:
		return "FLOAT"
	case ConditionTypeEnumString:
		return "STRING"
	case ConditionTypeEnumListOfStrings:
		return "LIST_OF_STRINGS"
	}
}

func (c ConditionTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *ConditionTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "BOOLEAN":
		value := ConditionTypeEnumBoolean
		*c = value
	case "DATE":
		value := ConditionTypeEnumDate
		*c = value
	case "DATE_TIME":
		value := ConditionTypeEnumDateTime
		*c = value
	case "INTEGER":
		value := ConditionTypeEnumInteger
		*c = value
	case "FLOAT":
		value := ConditionTypeEnumFloat
		*c = value
	case "STRING":
		value := ConditionTypeEnumString
		*c = value
	case "LIST_OF_STRINGS":
		value := ConditionTypeEnumListOfStrings
		*c = value
	}
	return nil
}

// # The Contact Object
// ### Description
// The `Contact` object is used to represent an existing point of contact at a company in a CRM system.
// ### Usage Example
// TODO
type Contact struct {
	// The contact's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The contact's last name.
	LastName *string `json:"last_name,omitempty"`
	// The contact's account.
	Account        *ContactAccount `json:"account,omitempty"`
	Addresses      []*Address      `json:"addresses,omitempty"`
	EmailAddresses []*EmailAddress `json:"email_addresses,omitempty"`
	PhoneNumbers   []*PhoneNumber  `json:"phone_numbers,omitempty"`
	// When the contact's last activity occurred.
	LastActivityAt *time.Time `json:"last_activity_at,omitempty"`
	// When the third party's contact was created.
	RemoteCreatedAt  *time.Time `json:"remote_created_at,omitempty"`
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	Id               *string    `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

// The contact's account.
type ContactAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewContactAccountFromString(value string) *ContactAccount {
	return &ContactAccount{typeName: "string", String: value}
}

func NewContactAccountFromAccount(value *Account) *ContactAccount {
	return &ContactAccount{typeName: "account", Account: value}
}

func (c *ContactAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		c.typeName = "account"
		c.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ContactAccount) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "account":
		return json.Marshal(c.Account)
	}
}

type ContactAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (c *ContactAccount) Accept(visitor ContactAccountVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "account":
		return visitor.VisitAccount(c.Account)
	}
}

// # The Contact Object
// ### Description
// The `Contact` object is used to represent an existing point of contact at a company in a CRM system.
// ### Usage Example
// TODO
type ContactRequest struct {
	// The contact's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The contact's last name.
	LastName *string `json:"last_name,omitempty"`
	// The contact's account.
	Account        *ContactRequestAccount `json:"account,omitempty"`
	Addresses      []*AddressRequest      `json:"addresses,omitempty"`
	EmailAddresses []*EmailAddressRequest `json:"email_addresses,omitempty"`
	PhoneNumbers   []*PhoneNumberRequest  `json:"phone_numbers,omitempty"`
	// When the contact's last activity occurred.
	LastActivityAt      *time.Time            `json:"last_activity_at,omitempty"`
	IntegrationParams   map[string]any        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest `json:"remote_fields,omitempty"`
}

// The contact's account.
type ContactRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewContactRequestAccountFromString(value string) *ContactRequestAccount {
	return &ContactRequestAccount{typeName: "string", String: value}
}

func NewContactRequestAccountFromAccount(value *Account) *ContactRequestAccount {
	return &ContactRequestAccount{typeName: "account", Account: value}
}

func (c *ContactRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		c.typeName = "account"
		c.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ContactRequestAccount) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "account":
		return json.Marshal(c.Account)
	}
}

type ContactRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (c *ContactRequestAccount) Accept(visitor ContactRequestAccountVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "account":
		return visitor.VisitAccount(c.Account)
	}
}

// * `AF` - Afghanistan
// * `AX` - Åland Islands
// * `AL` - Albania
// * `DZ` - Algeria
// * `AS` - American Samoa
// * `AD` - Andorra
// * `AO` - Angola
// * `AI` - Anguilla
// * `AQ` - Antarctica
// * `AG` - Antigua and Barbuda
// * `AR` - Argentina
// * `AM` - Armenia
// * `AW` - Aruba
// * `AU` - Australia
// * `AT` - Austria
// * `AZ` - Azerbaijan
// * `BS` - Bahamas
// * `BH` - Bahrain
// * `BD` - Bangladesh
// * `BB` - Barbados
// * `BY` - Belarus
// * `BE` - Belgium
// * `BZ` - Belize
// * `BJ` - Benin
// * `BM` - Bermuda
// * `BT` - Bhutan
// * `BO` - Bolivia
// * `BQ` - Bonaire, Sint Eustatius and Saba
// * `BA` - Bosnia and Herzegovina
// * `BW` - Botswana
// * `BV` - Bouvet Island
// * `BR` - Brazil
// * `IO` - British Indian Ocean Territory
// * `BN` - Brunei
// * `BG` - Bulgaria
// * `BF` - Burkina Faso
// * `BI` - Burundi
// * `CV` - Cabo Verde
// * `KH` - Cambodia
// * `CM` - Cameroon
// * `CA` - Canada
// * `KY` - Cayman Islands
// * `CF` - Central African Republic
// * `TD` - Chad
// * `CL` - Chile
// * `CN` - China
// * `CX` - Christmas Island
// * `CC` - Cocos (Keeling) Islands
// * `CO` - Colombia
// * `KM` - Comoros
// * `CG` - Congo
// * `CD` - Congo (the Democratic Republic of the)
// * `CK` - Cook Islands
// * `CR` - Costa Rica
// * `CI` - Côte d'Ivoire
// * `HR` - Croatia
// * `CU` - Cuba
// * `CW` - Curaçao
// * `CY` - Cyprus
// * `CZ` - Czechia
// * `DK` - Denmark
// * `DJ` - Djibouti
// * `DM` - Dominica
// * `DO` - Dominican Republic
// * `EC` - Ecuador
// * `EG` - Egypt
// * `SV` - El Salvador
// * `GQ` - Equatorial Guinea
// * `ER` - Eritrea
// * `EE` - Estonia
// * `SZ` - Eswatini
// * `ET` - Ethiopia
// * `FK` - Falkland Islands (Malvinas)
// * `FO` - Faroe Islands
// * `FJ` - Fiji
// * `FI` - Finland
// * `FR` - France
// * `GF` - French Guiana
// * `PF` - French Polynesia
// * `TF` - French Southern Territories
// * `GA` - Gabon
// * `GM` - Gambia
// * `GE` - Georgia
// * `DE` - Germany
// * `GH` - Ghana
// * `GI` - Gibraltar
// * `GR` - Greece
// * `GL` - Greenland
// * `GD` - Grenada
// * `GP` - Guadeloupe
// * `GU` - Guam
// * `GT` - Guatemala
// * `GG` - Guernsey
// * `GN` - Guinea
// * `GW` - Guinea-Bissau
// * `GY` - Guyana
// * `HT` - Haiti
// * `HM` - Heard Island and McDonald Islands
// * `VA` - Holy See
// * `HN` - Honduras
// * `HK` - Hong Kong
// * `HU` - Hungary
// * `IS` - Iceland
// * `IN` - India
// * `ID` - Indonesia
// * `IR` - Iran
// * `IQ` - Iraq
// * `IE` - Ireland
// * `IM` - Isle of Man
// * `IL` - Israel
// * `IT` - Italy
// * `JM` - Jamaica
// * `JP` - Japan
// * `JE` - Jersey
// * `JO` - Jordan
// * `KZ` - Kazakhstan
// * `KE` - Kenya
// * `KI` - Kiribati
// * `KW` - Kuwait
// * `KG` - Kyrgyzstan
// * `LA` - Laos
// * `LV` - Latvia
// * `LB` - Lebanon
// * `LS` - Lesotho
// * `LR` - Liberia
// * `LY` - Libya
// * `LI` - Liechtenstein
// * `LT` - Lithuania
// * `LU` - Luxembourg
// * `MO` - Macao
// * `MG` - Madagascar
// * `MW` - Malawi
// * `MY` - Malaysia
// * `MV` - Maldives
// * `ML` - Mali
// * `MT` - Malta
// * `MH` - Marshall Islands
// * `MQ` - Martinique
// * `MR` - Mauritania
// * `MU` - Mauritius
// * `YT` - Mayotte
// * `MX` - Mexico
// * `FM` - Micronesia (Federated States of)
// * `MD` - Moldova
// * `MC` - Monaco
// * `MN` - Mongolia
// * `ME` - Montenegro
// * `MS` - Montserrat
// * `MA` - Morocco
// * `MZ` - Mozambique
// * `MM` - Myanmar
// * `NA` - Namibia
// * `NR` - Nauru
// * `NP` - Nepal
// * `NL` - Netherlands
// * `NC` - New Caledonia
// * `NZ` - New Zealand
// * `NI` - Nicaragua
// * `NE` - Niger
// * `NG` - Nigeria
// * `NU` - Niue
// * `NF` - Norfolk Island
// * `KP` - North Korea
// * `MK` - North Macedonia
// * `MP` - Northern Mariana Islands
// * `NO` - Norway
// * `OM` - Oman
// * `PK` - Pakistan
// * `PW` - Palau
// * `PS` - Palestine, State of
// * `PA` - Panama
// * `PG` - Papua New Guinea
// * `PY` - Paraguay
// * `PE` - Peru
// * `PH` - Philippines
// * `PN` - Pitcairn
// * `PL` - Poland
// * `PT` - Portugal
// * `PR` - Puerto Rico
// * `QA` - Qatar
// * `RE` - Réunion
// * `RO` - Romania
// * `RU` - Russia
// * `RW` - Rwanda
// * `BL` - Saint Barthélemy
// * `SH` - Saint Helena, Ascension and Tristan da Cunha
// * `KN` - Saint Kitts and Nevis
// * `LC` - Saint Lucia
// * `MF` - Saint Martin (French part)
// * `PM` - Saint Pierre and Miquelon
// * `VC` - Saint Vincent and the Grenadines
// * `WS` - Samoa
// * `SM` - San Marino
// * `ST` - Sao Tome and Principe
// * `SA` - Saudi Arabia
// * `SN` - Senegal
// * `RS` - Serbia
// * `SC` - Seychelles
// * `SL` - Sierra Leone
// * `SG` - Singapore
// * `SX` - Sint Maarten (Dutch part)
// * `SK` - Slovakia
// * `SI` - Slovenia
// * `SB` - Solomon Islands
// * `SO` - Somalia
// * `ZA` - South Africa
// * `GS` - South Georgia and the South Sandwich Islands
// * `KR` - South Korea
// * `SS` - South Sudan
// * `ES` - Spain
// * `LK` - Sri Lanka
// * `SD` - Sudan
// * `SR` - Suriname
// * `SJ` - Svalbard and Jan Mayen
// * `SE` - Sweden
// * `CH` - Switzerland
// * `SY` - Syria
// * `TW` - Taiwan
// * `TJ` - Tajikistan
// * `TZ` - Tanzania
// * `TH` - Thailand
// * `TL` - Timor-Leste
// * `TG` - Togo
// * `TK` - Tokelau
// * `TO` - Tonga
// * `TT` - Trinidad and Tobago
// * `TN` - Tunisia
// * `TR` - Turkey
// * `TM` - Turkmenistan
// * `TC` - Turks and Caicos Islands
// * `TV` - Tuvalu
// * `UG` - Uganda
// * `UA` - Ukraine
// * `AE` - United Arab Emirates
// * `GB` - United Kingdom
// * `UM` - United States Minor Outlying Islands
// * `US` - United States of America
// * `UY` - Uruguay
// * `UZ` - Uzbekistan
// * `VU` - Vanuatu
// * `VE` - Venezuela
// * `VN` - Vietnam
// * `VG` - Virgin Islands (British)
// * `VI` - Virgin Islands (U.S.)
// * `WF` - Wallis and Futuna
// * `EH` - Western Sahara
// * `YE` - Yemen
// * `ZM` - Zambia
// * `ZW` - Zimbabwe
type CountryEnum uint

const (
	CountryEnumAf CountryEnum = iota + 1
	CountryEnumAx
	CountryEnumAl
	CountryEnumDz
	CountryEnumAs
	CountryEnumAd
	CountryEnumAo
	CountryEnumAi
	CountryEnumAq
	CountryEnumAg
	CountryEnumAr
	CountryEnumAm
	CountryEnumAw
	CountryEnumAu
	CountryEnumAt
	CountryEnumAz
	CountryEnumBs
	CountryEnumBh
	CountryEnumBd
	CountryEnumBb
	CountryEnumBy
	CountryEnumBe
	CountryEnumBz
	CountryEnumBj
	CountryEnumBm
	CountryEnumBt
	CountryEnumBo
	CountryEnumBq
	CountryEnumBa
	CountryEnumBw
	CountryEnumBv
	CountryEnumBr
	CountryEnumIo
	CountryEnumBn
	CountryEnumBg
	CountryEnumBf
	CountryEnumBi
	CountryEnumCv
	CountryEnumKh
	CountryEnumCm
	CountryEnumCa
	CountryEnumKy
	CountryEnumCf
	CountryEnumTd
	CountryEnumCl
	CountryEnumCn
	CountryEnumCx
	CountryEnumCc
	CountryEnumCo
	CountryEnumKm
	CountryEnumCg
	CountryEnumCd
	CountryEnumCk
	CountryEnumCr
	CountryEnumCi
	CountryEnumHr
	CountryEnumCu
	CountryEnumCw
	CountryEnumCy
	CountryEnumCz
	CountryEnumDk
	CountryEnumDj
	CountryEnumDm
	CountryEnumDo
	CountryEnumEc
	CountryEnumEg
	CountryEnumSv
	CountryEnumGq
	CountryEnumEr
	CountryEnumEe
	CountryEnumSz
	CountryEnumEt
	CountryEnumFk
	CountryEnumFo
	CountryEnumFj
	CountryEnumFi
	CountryEnumFr
	CountryEnumGf
	CountryEnumPf
	CountryEnumTf
	CountryEnumGa
	CountryEnumGm
	CountryEnumGe
	CountryEnumDe
	CountryEnumGh
	CountryEnumGi
	CountryEnumGr
	CountryEnumGl
	CountryEnumGd
	CountryEnumGp
	CountryEnumGu
	CountryEnumGt
	CountryEnumGg
	CountryEnumGn
	CountryEnumGw
	CountryEnumGy
	CountryEnumHt
	CountryEnumHm
	CountryEnumVa
	CountryEnumHn
	CountryEnumHk
	CountryEnumHu
	CountryEnumIs
	CountryEnumIn
	CountryEnumId
	CountryEnumIr
	CountryEnumIq
	CountryEnumIe
	CountryEnumIm
	CountryEnumIl
	CountryEnumIt
	CountryEnumJm
	CountryEnumJp
	CountryEnumJe
	CountryEnumJo
	CountryEnumKz
	CountryEnumKe
	CountryEnumKi
	CountryEnumKw
	CountryEnumKg
	CountryEnumLa
	CountryEnumLv
	CountryEnumLb
	CountryEnumLs
	CountryEnumLr
	CountryEnumLy
	CountryEnumLi
	CountryEnumLt
	CountryEnumLu
	CountryEnumMo
	CountryEnumMg
	CountryEnumMw
	CountryEnumMy
	CountryEnumMv
	CountryEnumMl
	CountryEnumMt
	CountryEnumMh
	CountryEnumMq
	CountryEnumMr
	CountryEnumMu
	CountryEnumYt
	CountryEnumMx
	CountryEnumFm
	CountryEnumMd
	CountryEnumMc
	CountryEnumMn
	CountryEnumMe
	CountryEnumMs
	CountryEnumMa
	CountryEnumMz
	CountryEnumMm
	CountryEnumNa
	CountryEnumNr
	CountryEnumNp
	CountryEnumNl
	CountryEnumNc
	CountryEnumNz
	CountryEnumNi
	CountryEnumNe
	CountryEnumNg
	CountryEnumNu
	CountryEnumNf
	CountryEnumKp
	CountryEnumMk
	CountryEnumMp
	CountryEnumNo
	CountryEnumOm
	CountryEnumPk
	CountryEnumPw
	CountryEnumPs
	CountryEnumPa
	CountryEnumPg
	CountryEnumPy
	CountryEnumPe
	CountryEnumPh
	CountryEnumPn
	CountryEnumPl
	CountryEnumPt
	CountryEnumPr
	CountryEnumQa
	CountryEnumRe
	CountryEnumRo
	CountryEnumRu
	CountryEnumRw
	CountryEnumBl
	CountryEnumSh
	CountryEnumKn
	CountryEnumLc
	CountryEnumMf
	CountryEnumPm
	CountryEnumVc
	CountryEnumWs
	CountryEnumSm
	CountryEnumSt
	CountryEnumSa
	CountryEnumSn
	CountryEnumRs
	CountryEnumSc
	CountryEnumSl
	CountryEnumSg
	CountryEnumSx
	CountryEnumSk
	CountryEnumSi
	CountryEnumSb
	CountryEnumSo
	CountryEnumZa
	CountryEnumGs
	CountryEnumKr
	CountryEnumSs
	CountryEnumEs
	CountryEnumLk
	CountryEnumSd
	CountryEnumSr
	CountryEnumSj
	CountryEnumSe
	CountryEnumCh
	CountryEnumSy
	CountryEnumTw
	CountryEnumTj
	CountryEnumTz
	CountryEnumTh
	CountryEnumTl
	CountryEnumTg
	CountryEnumTk
	CountryEnumTo
	CountryEnumTt
	CountryEnumTn
	CountryEnumTr
	CountryEnumTm
	CountryEnumTc
	CountryEnumTv
	CountryEnumUg
	CountryEnumUa
	CountryEnumAe
	CountryEnumGb
	CountryEnumUm
	CountryEnumUs
	CountryEnumUy
	CountryEnumUz
	CountryEnumVu
	CountryEnumVe
	CountryEnumVn
	CountryEnumVg
	CountryEnumVi
	CountryEnumWf
	CountryEnumEh
	CountryEnumYe
	CountryEnumZm
	CountryEnumZw
)

func (c CountryEnum) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CountryEnumAf:
		return "AF"
	case CountryEnumAx:
		return "AX"
	case CountryEnumAl:
		return "AL"
	case CountryEnumDz:
		return "DZ"
	case CountryEnumAs:
		return "AS"
	case CountryEnumAd:
		return "AD"
	case CountryEnumAo:
		return "AO"
	case CountryEnumAi:
		return "AI"
	case CountryEnumAq:
		return "AQ"
	case CountryEnumAg:
		return "AG"
	case CountryEnumAr:
		return "AR"
	case CountryEnumAm:
		return "AM"
	case CountryEnumAw:
		return "AW"
	case CountryEnumAu:
		return "AU"
	case CountryEnumAt:
		return "AT"
	case CountryEnumAz:
		return "AZ"
	case CountryEnumBs:
		return "BS"
	case CountryEnumBh:
		return "BH"
	case CountryEnumBd:
		return "BD"
	case CountryEnumBb:
		return "BB"
	case CountryEnumBy:
		return "BY"
	case CountryEnumBe:
		return "BE"
	case CountryEnumBz:
		return "BZ"
	case CountryEnumBj:
		return "BJ"
	case CountryEnumBm:
		return "BM"
	case CountryEnumBt:
		return "BT"
	case CountryEnumBo:
		return "BO"
	case CountryEnumBq:
		return "BQ"
	case CountryEnumBa:
		return "BA"
	case CountryEnumBw:
		return "BW"
	case CountryEnumBv:
		return "BV"
	case CountryEnumBr:
		return "BR"
	case CountryEnumIo:
		return "IO"
	case CountryEnumBn:
		return "BN"
	case CountryEnumBg:
		return "BG"
	case CountryEnumBf:
		return "BF"
	case CountryEnumBi:
		return "BI"
	case CountryEnumCv:
		return "CV"
	case CountryEnumKh:
		return "KH"
	case CountryEnumCm:
		return "CM"
	case CountryEnumCa:
		return "CA"
	case CountryEnumKy:
		return "KY"
	case CountryEnumCf:
		return "CF"
	case CountryEnumTd:
		return "TD"
	case CountryEnumCl:
		return "CL"
	case CountryEnumCn:
		return "CN"
	case CountryEnumCx:
		return "CX"
	case CountryEnumCc:
		return "CC"
	case CountryEnumCo:
		return "CO"
	case CountryEnumKm:
		return "KM"
	case CountryEnumCg:
		return "CG"
	case CountryEnumCd:
		return "CD"
	case CountryEnumCk:
		return "CK"
	case CountryEnumCr:
		return "CR"
	case CountryEnumCi:
		return "CI"
	case CountryEnumHr:
		return "HR"
	case CountryEnumCu:
		return "CU"
	case CountryEnumCw:
		return "CW"
	case CountryEnumCy:
		return "CY"
	case CountryEnumCz:
		return "CZ"
	case CountryEnumDk:
		return "DK"
	case CountryEnumDj:
		return "DJ"
	case CountryEnumDm:
		return "DM"
	case CountryEnumDo:
		return "DO"
	case CountryEnumEc:
		return "EC"
	case CountryEnumEg:
		return "EG"
	case CountryEnumSv:
		return "SV"
	case CountryEnumGq:
		return "GQ"
	case CountryEnumEr:
		return "ER"
	case CountryEnumEe:
		return "EE"
	case CountryEnumSz:
		return "SZ"
	case CountryEnumEt:
		return "ET"
	case CountryEnumFk:
		return "FK"
	case CountryEnumFo:
		return "FO"
	case CountryEnumFj:
		return "FJ"
	case CountryEnumFi:
		return "FI"
	case CountryEnumFr:
		return "FR"
	case CountryEnumGf:
		return "GF"
	case CountryEnumPf:
		return "PF"
	case CountryEnumTf:
		return "TF"
	case CountryEnumGa:
		return "GA"
	case CountryEnumGm:
		return "GM"
	case CountryEnumGe:
		return "GE"
	case CountryEnumDe:
		return "DE"
	case CountryEnumGh:
		return "GH"
	case CountryEnumGi:
		return "GI"
	case CountryEnumGr:
		return "GR"
	case CountryEnumGl:
		return "GL"
	case CountryEnumGd:
		return "GD"
	case CountryEnumGp:
		return "GP"
	case CountryEnumGu:
		return "GU"
	case CountryEnumGt:
		return "GT"
	case CountryEnumGg:
		return "GG"
	case CountryEnumGn:
		return "GN"
	case CountryEnumGw:
		return "GW"
	case CountryEnumGy:
		return "GY"
	case CountryEnumHt:
		return "HT"
	case CountryEnumHm:
		return "HM"
	case CountryEnumVa:
		return "VA"
	case CountryEnumHn:
		return "HN"
	case CountryEnumHk:
		return "HK"
	case CountryEnumHu:
		return "HU"
	case CountryEnumIs:
		return "IS"
	case CountryEnumIn:
		return "IN"
	case CountryEnumId:
		return "ID"
	case CountryEnumIr:
		return "IR"
	case CountryEnumIq:
		return "IQ"
	case CountryEnumIe:
		return "IE"
	case CountryEnumIm:
		return "IM"
	case CountryEnumIl:
		return "IL"
	case CountryEnumIt:
		return "IT"
	case CountryEnumJm:
		return "JM"
	case CountryEnumJp:
		return "JP"
	case CountryEnumJe:
		return "JE"
	case CountryEnumJo:
		return "JO"
	case CountryEnumKz:
		return "KZ"
	case CountryEnumKe:
		return "KE"
	case CountryEnumKi:
		return "KI"
	case CountryEnumKw:
		return "KW"
	case CountryEnumKg:
		return "KG"
	case CountryEnumLa:
		return "LA"
	case CountryEnumLv:
		return "LV"
	case CountryEnumLb:
		return "LB"
	case CountryEnumLs:
		return "LS"
	case CountryEnumLr:
		return "LR"
	case CountryEnumLy:
		return "LY"
	case CountryEnumLi:
		return "LI"
	case CountryEnumLt:
		return "LT"
	case CountryEnumLu:
		return "LU"
	case CountryEnumMo:
		return "MO"
	case CountryEnumMg:
		return "MG"
	case CountryEnumMw:
		return "MW"
	case CountryEnumMy:
		return "MY"
	case CountryEnumMv:
		return "MV"
	case CountryEnumMl:
		return "ML"
	case CountryEnumMt:
		return "MT"
	case CountryEnumMh:
		return "MH"
	case CountryEnumMq:
		return "MQ"
	case CountryEnumMr:
		return "MR"
	case CountryEnumMu:
		return "MU"
	case CountryEnumYt:
		return "YT"
	case CountryEnumMx:
		return "MX"
	case CountryEnumFm:
		return "FM"
	case CountryEnumMd:
		return "MD"
	case CountryEnumMc:
		return "MC"
	case CountryEnumMn:
		return "MN"
	case CountryEnumMe:
		return "ME"
	case CountryEnumMs:
		return "MS"
	case CountryEnumMa:
		return "MA"
	case CountryEnumMz:
		return "MZ"
	case CountryEnumMm:
		return "MM"
	case CountryEnumNa:
		return "NA"
	case CountryEnumNr:
		return "NR"
	case CountryEnumNp:
		return "NP"
	case CountryEnumNl:
		return "NL"
	case CountryEnumNc:
		return "NC"
	case CountryEnumNz:
		return "NZ"
	case CountryEnumNi:
		return "NI"
	case CountryEnumNe:
		return "NE"
	case CountryEnumNg:
		return "NG"
	case CountryEnumNu:
		return "NU"
	case CountryEnumNf:
		return "NF"
	case CountryEnumKp:
		return "KP"
	case CountryEnumMk:
		return "MK"
	case CountryEnumMp:
		return "MP"
	case CountryEnumNo:
		return "NO"
	case CountryEnumOm:
		return "OM"
	case CountryEnumPk:
		return "PK"
	case CountryEnumPw:
		return "PW"
	case CountryEnumPs:
		return "PS"
	case CountryEnumPa:
		return "PA"
	case CountryEnumPg:
		return "PG"
	case CountryEnumPy:
		return "PY"
	case CountryEnumPe:
		return "PE"
	case CountryEnumPh:
		return "PH"
	case CountryEnumPn:
		return "PN"
	case CountryEnumPl:
		return "PL"
	case CountryEnumPt:
		return "PT"
	case CountryEnumPr:
		return "PR"
	case CountryEnumQa:
		return "QA"
	case CountryEnumRe:
		return "RE"
	case CountryEnumRo:
		return "RO"
	case CountryEnumRu:
		return "RU"
	case CountryEnumRw:
		return "RW"
	case CountryEnumBl:
		return "BL"
	case CountryEnumSh:
		return "SH"
	case CountryEnumKn:
		return "KN"
	case CountryEnumLc:
		return "LC"
	case CountryEnumMf:
		return "MF"
	case CountryEnumPm:
		return "PM"
	case CountryEnumVc:
		return "VC"
	case CountryEnumWs:
		return "WS"
	case CountryEnumSm:
		return "SM"
	case CountryEnumSt:
		return "ST"
	case CountryEnumSa:
		return "SA"
	case CountryEnumSn:
		return "SN"
	case CountryEnumRs:
		return "RS"
	case CountryEnumSc:
		return "SC"
	case CountryEnumSl:
		return "SL"
	case CountryEnumSg:
		return "SG"
	case CountryEnumSx:
		return "SX"
	case CountryEnumSk:
		return "SK"
	case CountryEnumSi:
		return "SI"
	case CountryEnumSb:
		return "SB"
	case CountryEnumSo:
		return "SO"
	case CountryEnumZa:
		return "ZA"
	case CountryEnumGs:
		return "GS"
	case CountryEnumKr:
		return "KR"
	case CountryEnumSs:
		return "SS"
	case CountryEnumEs:
		return "ES"
	case CountryEnumLk:
		return "LK"
	case CountryEnumSd:
		return "SD"
	case CountryEnumSr:
		return "SR"
	case CountryEnumSj:
		return "SJ"
	case CountryEnumSe:
		return "SE"
	case CountryEnumCh:
		return "CH"
	case CountryEnumSy:
		return "SY"
	case CountryEnumTw:
		return "TW"
	case CountryEnumTj:
		return "TJ"
	case CountryEnumTz:
		return "TZ"
	case CountryEnumTh:
		return "TH"
	case CountryEnumTl:
		return "TL"
	case CountryEnumTg:
		return "TG"
	case CountryEnumTk:
		return "TK"
	case CountryEnumTo:
		return "TO"
	case CountryEnumTt:
		return "TT"
	case CountryEnumTn:
		return "TN"
	case CountryEnumTr:
		return "TR"
	case CountryEnumTm:
		return "TM"
	case CountryEnumTc:
		return "TC"
	case CountryEnumTv:
		return "TV"
	case CountryEnumUg:
		return "UG"
	case CountryEnumUa:
		return "UA"
	case CountryEnumAe:
		return "AE"
	case CountryEnumGb:
		return "GB"
	case CountryEnumUm:
		return "UM"
	case CountryEnumUs:
		return "US"
	case CountryEnumUy:
		return "UY"
	case CountryEnumUz:
		return "UZ"
	case CountryEnumVu:
		return "VU"
	case CountryEnumVe:
		return "VE"
	case CountryEnumVn:
		return "VN"
	case CountryEnumVg:
		return "VG"
	case CountryEnumVi:
		return "VI"
	case CountryEnumWf:
		return "WF"
	case CountryEnumEh:
		return "EH"
	case CountryEnumYe:
		return "YE"
	case CountryEnumZm:
		return "ZM"
	case CountryEnumZw:
		return "ZW"
	}
}

func (c CountryEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CountryEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "AF":
		value := CountryEnumAf
		*c = value
	case "AX":
		value := CountryEnumAx
		*c = value
	case "AL":
		value := CountryEnumAl
		*c = value
	case "DZ":
		value := CountryEnumDz
		*c = value
	case "AS":
		value := CountryEnumAs
		*c = value
	case "AD":
		value := CountryEnumAd
		*c = value
	case "AO":
		value := CountryEnumAo
		*c = value
	case "AI":
		value := CountryEnumAi
		*c = value
	case "AQ":
		value := CountryEnumAq
		*c = value
	case "AG":
		value := CountryEnumAg
		*c = value
	case "AR":
		value := CountryEnumAr
		*c = value
	case "AM":
		value := CountryEnumAm
		*c = value
	case "AW":
		value := CountryEnumAw
		*c = value
	case "AU":
		value := CountryEnumAu
		*c = value
	case "AT":
		value := CountryEnumAt
		*c = value
	case "AZ":
		value := CountryEnumAz
		*c = value
	case "BS":
		value := CountryEnumBs
		*c = value
	case "BH":
		value := CountryEnumBh
		*c = value
	case "BD":
		value := CountryEnumBd
		*c = value
	case "BB":
		value := CountryEnumBb
		*c = value
	case "BY":
		value := CountryEnumBy
		*c = value
	case "BE":
		value := CountryEnumBe
		*c = value
	case "BZ":
		value := CountryEnumBz
		*c = value
	case "BJ":
		value := CountryEnumBj
		*c = value
	case "BM":
		value := CountryEnumBm
		*c = value
	case "BT":
		value := CountryEnumBt
		*c = value
	case "BO":
		value := CountryEnumBo
		*c = value
	case "BQ":
		value := CountryEnumBq
		*c = value
	case "BA":
		value := CountryEnumBa
		*c = value
	case "BW":
		value := CountryEnumBw
		*c = value
	case "BV":
		value := CountryEnumBv
		*c = value
	case "BR":
		value := CountryEnumBr
		*c = value
	case "IO":
		value := CountryEnumIo
		*c = value
	case "BN":
		value := CountryEnumBn
		*c = value
	case "BG":
		value := CountryEnumBg
		*c = value
	case "BF":
		value := CountryEnumBf
		*c = value
	case "BI":
		value := CountryEnumBi
		*c = value
	case "CV":
		value := CountryEnumCv
		*c = value
	case "KH":
		value := CountryEnumKh
		*c = value
	case "CM":
		value := CountryEnumCm
		*c = value
	case "CA":
		value := CountryEnumCa
		*c = value
	case "KY":
		value := CountryEnumKy
		*c = value
	case "CF":
		value := CountryEnumCf
		*c = value
	case "TD":
		value := CountryEnumTd
		*c = value
	case "CL":
		value := CountryEnumCl
		*c = value
	case "CN":
		value := CountryEnumCn
		*c = value
	case "CX":
		value := CountryEnumCx
		*c = value
	case "CC":
		value := CountryEnumCc
		*c = value
	case "CO":
		value := CountryEnumCo
		*c = value
	case "KM":
		value := CountryEnumKm
		*c = value
	case "CG":
		value := CountryEnumCg
		*c = value
	case "CD":
		value := CountryEnumCd
		*c = value
	case "CK":
		value := CountryEnumCk
		*c = value
	case "CR":
		value := CountryEnumCr
		*c = value
	case "CI":
		value := CountryEnumCi
		*c = value
	case "HR":
		value := CountryEnumHr
		*c = value
	case "CU":
		value := CountryEnumCu
		*c = value
	case "CW":
		value := CountryEnumCw
		*c = value
	case "CY":
		value := CountryEnumCy
		*c = value
	case "CZ":
		value := CountryEnumCz
		*c = value
	case "DK":
		value := CountryEnumDk
		*c = value
	case "DJ":
		value := CountryEnumDj
		*c = value
	case "DM":
		value := CountryEnumDm
		*c = value
	case "DO":
		value := CountryEnumDo
		*c = value
	case "EC":
		value := CountryEnumEc
		*c = value
	case "EG":
		value := CountryEnumEg
		*c = value
	case "SV":
		value := CountryEnumSv
		*c = value
	case "GQ":
		value := CountryEnumGq
		*c = value
	case "ER":
		value := CountryEnumEr
		*c = value
	case "EE":
		value := CountryEnumEe
		*c = value
	case "SZ":
		value := CountryEnumSz
		*c = value
	case "ET":
		value := CountryEnumEt
		*c = value
	case "FK":
		value := CountryEnumFk
		*c = value
	case "FO":
		value := CountryEnumFo
		*c = value
	case "FJ":
		value := CountryEnumFj
		*c = value
	case "FI":
		value := CountryEnumFi
		*c = value
	case "FR":
		value := CountryEnumFr
		*c = value
	case "GF":
		value := CountryEnumGf
		*c = value
	case "PF":
		value := CountryEnumPf
		*c = value
	case "TF":
		value := CountryEnumTf
		*c = value
	case "GA":
		value := CountryEnumGa
		*c = value
	case "GM":
		value := CountryEnumGm
		*c = value
	case "GE":
		value := CountryEnumGe
		*c = value
	case "DE":
		value := CountryEnumDe
		*c = value
	case "GH":
		value := CountryEnumGh
		*c = value
	case "GI":
		value := CountryEnumGi
		*c = value
	case "GR":
		value := CountryEnumGr
		*c = value
	case "GL":
		value := CountryEnumGl
		*c = value
	case "GD":
		value := CountryEnumGd
		*c = value
	case "GP":
		value := CountryEnumGp
		*c = value
	case "GU":
		value := CountryEnumGu
		*c = value
	case "GT":
		value := CountryEnumGt
		*c = value
	case "GG":
		value := CountryEnumGg
		*c = value
	case "GN":
		value := CountryEnumGn
		*c = value
	case "GW":
		value := CountryEnumGw
		*c = value
	case "GY":
		value := CountryEnumGy
		*c = value
	case "HT":
		value := CountryEnumHt
		*c = value
	case "HM":
		value := CountryEnumHm
		*c = value
	case "VA":
		value := CountryEnumVa
		*c = value
	case "HN":
		value := CountryEnumHn
		*c = value
	case "HK":
		value := CountryEnumHk
		*c = value
	case "HU":
		value := CountryEnumHu
		*c = value
	case "IS":
		value := CountryEnumIs
		*c = value
	case "IN":
		value := CountryEnumIn
		*c = value
	case "ID":
		value := CountryEnumId
		*c = value
	case "IR":
		value := CountryEnumIr
		*c = value
	case "IQ":
		value := CountryEnumIq
		*c = value
	case "IE":
		value := CountryEnumIe
		*c = value
	case "IM":
		value := CountryEnumIm
		*c = value
	case "IL":
		value := CountryEnumIl
		*c = value
	case "IT":
		value := CountryEnumIt
		*c = value
	case "JM":
		value := CountryEnumJm
		*c = value
	case "JP":
		value := CountryEnumJp
		*c = value
	case "JE":
		value := CountryEnumJe
		*c = value
	case "JO":
		value := CountryEnumJo
		*c = value
	case "KZ":
		value := CountryEnumKz
		*c = value
	case "KE":
		value := CountryEnumKe
		*c = value
	case "KI":
		value := CountryEnumKi
		*c = value
	case "KW":
		value := CountryEnumKw
		*c = value
	case "KG":
		value := CountryEnumKg
		*c = value
	case "LA":
		value := CountryEnumLa
		*c = value
	case "LV":
		value := CountryEnumLv
		*c = value
	case "LB":
		value := CountryEnumLb
		*c = value
	case "LS":
		value := CountryEnumLs
		*c = value
	case "LR":
		value := CountryEnumLr
		*c = value
	case "LY":
		value := CountryEnumLy
		*c = value
	case "LI":
		value := CountryEnumLi
		*c = value
	case "LT":
		value := CountryEnumLt
		*c = value
	case "LU":
		value := CountryEnumLu
		*c = value
	case "MO":
		value := CountryEnumMo
		*c = value
	case "MG":
		value := CountryEnumMg
		*c = value
	case "MW":
		value := CountryEnumMw
		*c = value
	case "MY":
		value := CountryEnumMy
		*c = value
	case "MV":
		value := CountryEnumMv
		*c = value
	case "ML":
		value := CountryEnumMl
		*c = value
	case "MT":
		value := CountryEnumMt
		*c = value
	case "MH":
		value := CountryEnumMh
		*c = value
	case "MQ":
		value := CountryEnumMq
		*c = value
	case "MR":
		value := CountryEnumMr
		*c = value
	case "MU":
		value := CountryEnumMu
		*c = value
	case "YT":
		value := CountryEnumYt
		*c = value
	case "MX":
		value := CountryEnumMx
		*c = value
	case "FM":
		value := CountryEnumFm
		*c = value
	case "MD":
		value := CountryEnumMd
		*c = value
	case "MC":
		value := CountryEnumMc
		*c = value
	case "MN":
		value := CountryEnumMn
		*c = value
	case "ME":
		value := CountryEnumMe
		*c = value
	case "MS":
		value := CountryEnumMs
		*c = value
	case "MA":
		value := CountryEnumMa
		*c = value
	case "MZ":
		value := CountryEnumMz
		*c = value
	case "MM":
		value := CountryEnumMm
		*c = value
	case "NA":
		value := CountryEnumNa
		*c = value
	case "NR":
		value := CountryEnumNr
		*c = value
	case "NP":
		value := CountryEnumNp
		*c = value
	case "NL":
		value := CountryEnumNl
		*c = value
	case "NC":
		value := CountryEnumNc
		*c = value
	case "NZ":
		value := CountryEnumNz
		*c = value
	case "NI":
		value := CountryEnumNi
		*c = value
	case "NE":
		value := CountryEnumNe
		*c = value
	case "NG":
		value := CountryEnumNg
		*c = value
	case "NU":
		value := CountryEnumNu
		*c = value
	case "NF":
		value := CountryEnumNf
		*c = value
	case "KP":
		value := CountryEnumKp
		*c = value
	case "MK":
		value := CountryEnumMk
		*c = value
	case "MP":
		value := CountryEnumMp
		*c = value
	case "NO":
		value := CountryEnumNo
		*c = value
	case "OM":
		value := CountryEnumOm
		*c = value
	case "PK":
		value := CountryEnumPk
		*c = value
	case "PW":
		value := CountryEnumPw
		*c = value
	case "PS":
		value := CountryEnumPs
		*c = value
	case "PA":
		value := CountryEnumPa
		*c = value
	case "PG":
		value := CountryEnumPg
		*c = value
	case "PY":
		value := CountryEnumPy
		*c = value
	case "PE":
		value := CountryEnumPe
		*c = value
	case "PH":
		value := CountryEnumPh
		*c = value
	case "PN":
		value := CountryEnumPn
		*c = value
	case "PL":
		value := CountryEnumPl
		*c = value
	case "PT":
		value := CountryEnumPt
		*c = value
	case "PR":
		value := CountryEnumPr
		*c = value
	case "QA":
		value := CountryEnumQa
		*c = value
	case "RE":
		value := CountryEnumRe
		*c = value
	case "RO":
		value := CountryEnumRo
		*c = value
	case "RU":
		value := CountryEnumRu
		*c = value
	case "RW":
		value := CountryEnumRw
		*c = value
	case "BL":
		value := CountryEnumBl
		*c = value
	case "SH":
		value := CountryEnumSh
		*c = value
	case "KN":
		value := CountryEnumKn
		*c = value
	case "LC":
		value := CountryEnumLc
		*c = value
	case "MF":
		value := CountryEnumMf
		*c = value
	case "PM":
		value := CountryEnumPm
		*c = value
	case "VC":
		value := CountryEnumVc
		*c = value
	case "WS":
		value := CountryEnumWs
		*c = value
	case "SM":
		value := CountryEnumSm
		*c = value
	case "ST":
		value := CountryEnumSt
		*c = value
	case "SA":
		value := CountryEnumSa
		*c = value
	case "SN":
		value := CountryEnumSn
		*c = value
	case "RS":
		value := CountryEnumRs
		*c = value
	case "SC":
		value := CountryEnumSc
		*c = value
	case "SL":
		value := CountryEnumSl
		*c = value
	case "SG":
		value := CountryEnumSg
		*c = value
	case "SX":
		value := CountryEnumSx
		*c = value
	case "SK":
		value := CountryEnumSk
		*c = value
	case "SI":
		value := CountryEnumSi
		*c = value
	case "SB":
		value := CountryEnumSb
		*c = value
	case "SO":
		value := CountryEnumSo
		*c = value
	case "ZA":
		value := CountryEnumZa
		*c = value
	case "GS":
		value := CountryEnumGs
		*c = value
	case "KR":
		value := CountryEnumKr
		*c = value
	case "SS":
		value := CountryEnumSs
		*c = value
	case "ES":
		value := CountryEnumEs
		*c = value
	case "LK":
		value := CountryEnumLk
		*c = value
	case "SD":
		value := CountryEnumSd
		*c = value
	case "SR":
		value := CountryEnumSr
		*c = value
	case "SJ":
		value := CountryEnumSj
		*c = value
	case "SE":
		value := CountryEnumSe
		*c = value
	case "CH":
		value := CountryEnumCh
		*c = value
	case "SY":
		value := CountryEnumSy
		*c = value
	case "TW":
		value := CountryEnumTw
		*c = value
	case "TJ":
		value := CountryEnumTj
		*c = value
	case "TZ":
		value := CountryEnumTz
		*c = value
	case "TH":
		value := CountryEnumTh
		*c = value
	case "TL":
		value := CountryEnumTl
		*c = value
	case "TG":
		value := CountryEnumTg
		*c = value
	case "TK":
		value := CountryEnumTk
		*c = value
	case "TO":
		value := CountryEnumTo
		*c = value
	case "TT":
		value := CountryEnumTt
		*c = value
	case "TN":
		value := CountryEnumTn
		*c = value
	case "TR":
		value := CountryEnumTr
		*c = value
	case "TM":
		value := CountryEnumTm
		*c = value
	case "TC":
		value := CountryEnumTc
		*c = value
	case "TV":
		value := CountryEnumTv
		*c = value
	case "UG":
		value := CountryEnumUg
		*c = value
	case "UA":
		value := CountryEnumUa
		*c = value
	case "AE":
		value := CountryEnumAe
		*c = value
	case "GB":
		value := CountryEnumGb
		*c = value
	case "UM":
		value := CountryEnumUm
		*c = value
	case "US":
		value := CountryEnumUs
		*c = value
	case "UY":
		value := CountryEnumUy
		*c = value
	case "UZ":
		value := CountryEnumUz
		*c = value
	case "VU":
		value := CountryEnumVu
		*c = value
	case "VE":
		value := CountryEnumVe
		*c = value
	case "VN":
		value := CountryEnumVn
		*c = value
	case "VG":
		value := CountryEnumVg
		*c = value
	case "VI":
		value := CountryEnumVi
		*c = value
	case "WF":
		value := CountryEnumWf
		*c = value
	case "EH":
		value := CountryEnumEh
		*c = value
	case "YE":
		value := CountryEnumYe
		*c = value
	case "ZM":
		value := CountryEnumZm
		*c = value
	case "ZW":
		value := CountryEnumZw
		*c = value
	}
	return nil
}

type CrmAccountResponse struct {
	Model    *Account                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type CrmAssociationTypeResponse struct {
	Model    *AssociationType            `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type CrmContactResponse struct {
	Model    *Contact                    `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type CrmCustomObjectResponse struct {
	Model    *CustomObject               `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// # The CustomObject Object
// ### Description
// The `Custom Object` record refers to an instance of a Custom Object Class.
// ### Usage Example
// TODO
type CustomObject struct {
	ObjectClass *string        `json:"object_class,omitempty"`
	Fields      map[string]any `json:"fields,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	Id       *string `json:"id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt   *time.Time     `json:"modified_at,omitempty"`
	RemoteFields []*RemoteField `json:"remote_fields,omitempty"`
}

// # The Custom Object Class Object
// ### Description
// The `Custom Object Class` object is used to represent a Custom Object Schema in the remote system.
// ### Usage Example
// TODO
type CustomObjectClass struct {
	Name             *string                                 `json:"name,omitempty"`
	Description      *string                                 `json:"description,omitempty"`
	Labels           map[string]*string                      `json:"labels,omitempty"`
	Fields           []*RemoteFieldClassForCustomObjectClass `json:"fields,omitempty"`
	AssociationTypes []map[string]any                        `json:"association_types,omitempty"`
	Id               *string                                 `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId   *string    `json:"remote_id,omitempty"`
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

type CustomObjectRequest struct {
	Fields map[string]any `json:"fields,omitempty"`
}

// # The DataPassthrough Object
// ### Description
// The `DataPassthrough` object is used to send information to an otherwise-unsupported third-party endpoint.
//
// ### Usage Example
// Create a `DataPassthrough` to get team hierarchies from your Rippling integration.
type DataPassthroughRequest struct {
	Method MethodEnum `json:"method,omitempty"`
	// <span style="white-space: nowrap">`non-empty`</span>
	Path string `json:"path"`
	// <span style="white-space: nowrap">`non-empty`</span>
	BaseUrlOverride *string `json:"base_url_override,omitempty"`
	// <span style="white-space: nowrap">`non-empty`</span>
	Data *string `json:"data,omitempty"`
	// Pass an array of `MultipartFormField` objects in here instead of using the `data` param if `request_format` is set to `MULTIPART`.
	MultipartFormData []*MultipartFormFieldRequest `json:"multipart_form_data,omitempty"`
	// The headers to use for the request (Merge will handle the account's authorization headers). `Content-Type` header is required for passthrough. Choose content type corresponding to expected format of receiving server.
	Headers       map[string]any     `json:"headers,omitempty"`
	RequestFormat *RequestFormatEnum `json:"request_format,omitempty"`
	// Optional. If true, the response will always be an object of the form `{"type": T, "value": ...}` where `T` will be one of `string, boolean, number, null, array, object`.
	NormalizeResponse *bool `json:"normalize_response,omitempty"`
}

type DebugModeLog struct {
	LogId         string                `json:"log_id"`
	DashboardView string                `json:"dashboard_view"`
	LogSummary    *DebugModelLogSummary `json:"log_summary,omitempty"`
}

type DebugModelLogSummary struct {
	Url        string `json:"url"`
	Method     string `json:"method"`
	StatusCode int    `json:"status_code"`
}

// * `INBOUND` - INBOUND
// * `OUTBOUND` - OUTBOUND
type DirectionEnum uint

const (
	DirectionEnumInbound DirectionEnum = iota + 1
	DirectionEnumOutbound
)

func (d DirectionEnum) String() string {
	switch d {
	default:
		return strconv.Itoa(int(d))
	case DirectionEnumInbound:
		return "INBOUND"
	case DirectionEnumOutbound:
		return "OUTBOUND"
	}
}

func (d DirectionEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", d.String())), nil
}

func (d *DirectionEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "INBOUND":
		value := DirectionEnumInbound
		*d = value
	case "OUTBOUND":
		value := DirectionEnumOutbound
		*d = value
	}
	return nil
}

// # The EmailAddress Object
// ### Description
// The `EmailAddress` object is used to represent an entity's email address.
// ### Usage Example
// Fetch from the `GET Contact` endpoint and view their email addresses.
type EmailAddress struct {
	// The email address.
	EmailAddress *string `json:"email_address,omitempty"`
	// The email address's type.
	EmailAddressType *string `json:"email_address_type,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// # The EmailAddress Object
// ### Description
// The `EmailAddress` object is used to represent an entity's email address.
// ### Usage Example
// Fetch from the `GET Contact` endpoint and view their email addresses.
type EmailAddressRequest struct {
	// The email address.
	EmailAddress *string `json:"email_address,omitempty"`
	// The email address's type.
	EmailAddressType    *string        `json:"email_address_type,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

// * `READ` - READ
// * `WRITE` - WRITE
type EnabledActionsEnum uint

const (
	EnabledActionsEnumRead EnabledActionsEnum = iota + 1
	EnabledActionsEnumWrite
)

func (e EnabledActionsEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EnabledActionsEnumRead:
		return "READ"
	case EnabledActionsEnumWrite:
		return "WRITE"
	}
}

func (e EnabledActionsEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EnabledActionsEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "READ":
		value := EnabledActionsEnumRead
		*e = value
	case "WRITE":
		value := EnabledActionsEnumWrite
		*e = value
	}
	return nil
}

// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type EncodingEnum uint

const (
	EncodingEnumRaw EncodingEnum = iota + 1
	EncodingEnumBase64
	EncodingEnumGzipBase64
)

func (e EncodingEnum) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EncodingEnumRaw:
		return "RAW"
	case EncodingEnumBase64:
		return "BASE64"
	case EncodingEnumGzipBase64:
		return "GZIP_BASE64"
	}
}

func (e EncodingEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EncodingEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "RAW":
		value := EncodingEnumRaw
		*e = value
	case "BASE64":
		value := EncodingEnumBase64
		*e = value
	case "GZIP_BASE64":
		value := EncodingEnumGzipBase64
		*e = value
	}
	return nil
}

// # The Engagement Object
// ### Description
// The `Engagement` object is used to represent an interaction noted in a CRM system.
// ### Usage Example
// TODO
type Engagement struct {
	// The engagement's owner.
	Owner *EngagementOwner `json:"owner,omitempty"`
	// The engagement's content.
	Content *string `json:"content,omitempty"`
	// The engagement's subject.
	Subject *string `json:"subject,omitempty"`
	// The engagement's direction.
	//
	// * `INBOUND` - INBOUND
	// * `OUTBOUND` - OUTBOUND
	Direction *EngagementDirection `json:"direction,omitempty"`
	// The engagement type of the engagement.
	EngagementType *EngagementEngagementType `json:"engagement_type,omitempty"`
	// The time at which the engagement started.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The time at which the engagement ended.
	EndTime *time.Time `json:"end_time,omitempty"`
	// The account of the engagement.
	Account  *EngagementAccount        `json:"account,omitempty"`
	Contacts []*EngagementContactsItem `json:"contacts,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool   `json:"remote_was_deleted,omitempty"`
	Id               *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

// The account of the engagement.
type EngagementAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewEngagementAccountFromString(value string) *EngagementAccount {
	return &EngagementAccount{typeName: "string", String: value}
}

func NewEngagementAccountFromAccount(value *Account) *EngagementAccount {
	return &EngagementAccount{typeName: "account", Account: value}
}

func (e *EngagementAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		e.typeName = "account"
		e.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementAccount) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "account":
		return json.Marshal(e.Account)
	}
}

type EngagementAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (e *EngagementAccount) Accept(visitor EngagementAccountVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "account":
		return visitor.VisitAccount(e.Account)
	}
}

type EngagementContactsItem struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewEngagementContactsItemFromString(value string) *EngagementContactsItem {
	return &EngagementContactsItem{typeName: "string", String: value}
}

func NewEngagementContactsItemFromContact(value *Contact) *EngagementContactsItem {
	return &EngagementContactsItem{typeName: "contact", Contact: value}
}

func (e *EngagementContactsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		e.typeName = "contact"
		e.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementContactsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "contact":
		return json.Marshal(e.Contact)
	}
}

type EngagementContactsItemVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (e *EngagementContactsItem) Accept(visitor EngagementContactsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "contact":
		return visitor.VisitContact(e.Contact)
	}
}

// The engagement's direction.
//
// * `INBOUND` - INBOUND
// * `OUTBOUND` - OUTBOUND
type EngagementDirection struct {
	typeName      string
	DirectionEnum DirectionEnum
	String        string
}

func NewEngagementDirectionFromDirectionEnum(value DirectionEnum) *EngagementDirection {
	return &EngagementDirection{typeName: "directionEnum", DirectionEnum: value}
}

func NewEngagementDirectionFromString(value string) *EngagementDirection {
	return &EngagementDirection{typeName: "string", String: value}
}

func (e *EngagementDirection) UnmarshalJSON(data []byte) error {
	var valueDirectionEnum DirectionEnum
	if err := json.Unmarshal(data, &valueDirectionEnum); err == nil {
		e.typeName = "directionEnum"
		e.DirectionEnum = valueDirectionEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementDirection) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "directionEnum":
		return json.Marshal(e.DirectionEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EngagementDirectionVisitor interface {
	VisitDirectionEnum(DirectionEnum) error
	VisitString(string) error
}

func (e *EngagementDirection) Accept(visitor EngagementDirectionVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "directionEnum":
		return visitor.VisitDirectionEnum(e.DirectionEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The engagement type of the engagement.
type EngagementEngagementType struct {
	typeName       string
	String         string
	EngagementType *EngagementType
}

func NewEngagementEngagementTypeFromString(value string) *EngagementEngagementType {
	return &EngagementEngagementType{typeName: "string", String: value}
}

func NewEngagementEngagementTypeFromEngagementType(value *EngagementType) *EngagementEngagementType {
	return &EngagementEngagementType{typeName: "engagementType", EngagementType: value}
}

func (e *EngagementEngagementType) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEngagementType := new(EngagementType)
	if err := json.Unmarshal(data, &valueEngagementType); err == nil {
		e.typeName = "engagementType"
		e.EngagementType = valueEngagementType
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementEngagementType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "engagementType":
		return json.Marshal(e.EngagementType)
	}
}

type EngagementEngagementTypeVisitor interface {
	VisitString(string) error
	VisitEngagementType(*EngagementType) error
}

func (e *EngagementEngagementType) Accept(visitor EngagementEngagementTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "engagementType":
		return visitor.VisitEngagementType(e.EngagementType)
	}
}

// The engagement's owner.
type EngagementOwner struct {
	typeName string
	String   string
	User     *User
}

func NewEngagementOwnerFromString(value string) *EngagementOwner {
	return &EngagementOwner{typeName: "string", String: value}
}

func NewEngagementOwnerFromUser(value *User) *EngagementOwner {
	return &EngagementOwner{typeName: "user", User: value}
}

func (e *EngagementOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		e.typeName = "user"
		e.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementOwner) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "user":
		return json.Marshal(e.User)
	}
}

type EngagementOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (e *EngagementOwner) Accept(visitor EngagementOwnerVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "user":
		return visitor.VisitUser(e.User)
	}
}

// # The Engagement Object
// ### Description
// The `Engagement` object is used to represent an interaction noted in a CRM system.
// ### Usage Example
// TODO
type EngagementRequest struct {
	// The engagement's owner.
	Owner *EngagementRequestOwner `json:"owner,omitempty"`
	// The engagement's content.
	Content *string `json:"content,omitempty"`
	// The engagement's subject.
	Subject *string `json:"subject,omitempty"`
	// The engagement's direction.
	//
	// * `INBOUND` - INBOUND
	// * `OUTBOUND` - OUTBOUND
	Direction *EngagementRequestDirection `json:"direction,omitempty"`
	// The engagement type of the engagement.
	EngagementType *EngagementRequestEngagementType `json:"engagement_type,omitempty"`
	// The time at which the engagement started.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The time at which the engagement ended.
	EndTime *time.Time `json:"end_time,omitempty"`
	// The account of the engagement.
	Account             *EngagementRequestAccount        `json:"account,omitempty"`
	Contacts            []*EngagementRequestContactsItem `json:"contacts,omitempty"`
	IntegrationParams   map[string]any                   `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any                   `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest            `json:"remote_fields,omitempty"`
}

// The account of the engagement.
type EngagementRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewEngagementRequestAccountFromString(value string) *EngagementRequestAccount {
	return &EngagementRequestAccount{typeName: "string", String: value}
}

func NewEngagementRequestAccountFromAccount(value *Account) *EngagementRequestAccount {
	return &EngagementRequestAccount{typeName: "account", Account: value}
}

func (e *EngagementRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		e.typeName = "account"
		e.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestAccount) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "account":
		return json.Marshal(e.Account)
	}
}

type EngagementRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (e *EngagementRequestAccount) Accept(visitor EngagementRequestAccountVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "account":
		return visitor.VisitAccount(e.Account)
	}
}

type EngagementRequestContactsItem struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewEngagementRequestContactsItemFromString(value string) *EngagementRequestContactsItem {
	return &EngagementRequestContactsItem{typeName: "string", String: value}
}

func NewEngagementRequestContactsItemFromContact(value *Contact) *EngagementRequestContactsItem {
	return &EngagementRequestContactsItem{typeName: "contact", Contact: value}
}

func (e *EngagementRequestContactsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		e.typeName = "contact"
		e.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestContactsItem) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "contact":
		return json.Marshal(e.Contact)
	}
}

type EngagementRequestContactsItemVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (e *EngagementRequestContactsItem) Accept(visitor EngagementRequestContactsItemVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "contact":
		return visitor.VisitContact(e.Contact)
	}
}

// The engagement's direction.
//
// * `INBOUND` - INBOUND
// * `OUTBOUND` - OUTBOUND
type EngagementRequestDirection struct {
	typeName      string
	DirectionEnum DirectionEnum
	String        string
}

func NewEngagementRequestDirectionFromDirectionEnum(value DirectionEnum) *EngagementRequestDirection {
	return &EngagementRequestDirection{typeName: "directionEnum", DirectionEnum: value}
}

func NewEngagementRequestDirectionFromString(value string) *EngagementRequestDirection {
	return &EngagementRequestDirection{typeName: "string", String: value}
}

func (e *EngagementRequestDirection) UnmarshalJSON(data []byte) error {
	var valueDirectionEnum DirectionEnum
	if err := json.Unmarshal(data, &valueDirectionEnum); err == nil {
		e.typeName = "directionEnum"
		e.DirectionEnum = valueDirectionEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestDirection) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "directionEnum":
		return json.Marshal(e.DirectionEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EngagementRequestDirectionVisitor interface {
	VisitDirectionEnum(DirectionEnum) error
	VisitString(string) error
}

func (e *EngagementRequestDirection) Accept(visitor EngagementRequestDirectionVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "directionEnum":
		return visitor.VisitDirectionEnum(e.DirectionEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

// The engagement type of the engagement.
type EngagementRequestEngagementType struct {
	typeName       string
	String         string
	EngagementType *EngagementType
}

func NewEngagementRequestEngagementTypeFromString(value string) *EngagementRequestEngagementType {
	return &EngagementRequestEngagementType{typeName: "string", String: value}
}

func NewEngagementRequestEngagementTypeFromEngagementType(value *EngagementType) *EngagementRequestEngagementType {
	return &EngagementRequestEngagementType{typeName: "engagementType", EngagementType: value}
}

func (e *EngagementRequestEngagementType) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEngagementType := new(EngagementType)
	if err := json.Unmarshal(data, &valueEngagementType); err == nil {
		e.typeName = "engagementType"
		e.EngagementType = valueEngagementType
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestEngagementType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "engagementType":
		return json.Marshal(e.EngagementType)
	}
}

type EngagementRequestEngagementTypeVisitor interface {
	VisitString(string) error
	VisitEngagementType(*EngagementType) error
}

func (e *EngagementRequestEngagementType) Accept(visitor EngagementRequestEngagementTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "engagementType":
		return visitor.VisitEngagementType(e.EngagementType)
	}
}

// The engagement's owner.
type EngagementRequestOwner struct {
	typeName string
	String   string
	User     *User
}

func NewEngagementRequestOwnerFromString(value string) *EngagementRequestOwner {
	return &EngagementRequestOwner{typeName: "string", String: value}
}

func NewEngagementRequestOwnerFromUser(value *User) *EngagementRequestOwner {
	return &EngagementRequestOwner{typeName: "user", User: value}
}

func (e *EngagementRequestOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		e.typeName = "user"
		e.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestOwner) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "user":
		return json.Marshal(e.User)
	}
}

type EngagementRequestOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (e *EngagementRequestOwner) Accept(visitor EngagementRequestOwnerVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "user":
		return visitor.VisitUser(e.User)
	}
}

type EngagementResponse struct {
	Model    *Engagement                 `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// # The Engagement Type Object
// ### Description
// The `Engagement Type` object is used to represent an interaction activity. A given `Engagement` typically has an `Engagement Type` object represented in the engagement_type field.
// ### Usage Example
// TODO
type EngagementType struct {
	// The engagement type's activity type.
	//
	// * `CALL` - CALL
	// * `MEETING` - MEETING
	// * `EMAIL` - EMAIL
	ActivityType *EngagementTypeActivityType `json:"activity_type,omitempty"`
	// The engagement type's name.
	Name *string `json:"name,omitempty"`
	Id   *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt   *time.Time     `json:"modified_at,omitempty"`
	RemoteFields []*RemoteField `json:"remote_fields,omitempty"`
}

// The engagement type's activity type.
//
// * `CALL` - CALL
// * `MEETING` - MEETING
// * `EMAIL` - EMAIL
type EngagementTypeActivityType struct {
	typeName         string
	ActivityTypeEnum ActivityTypeEnum
	String           string
}

func NewEngagementTypeActivityTypeFromActivityTypeEnum(value ActivityTypeEnum) *EngagementTypeActivityType {
	return &EngagementTypeActivityType{typeName: "activityTypeEnum", ActivityTypeEnum: value}
}

func NewEngagementTypeActivityTypeFromString(value string) *EngagementTypeActivityType {
	return &EngagementTypeActivityType{typeName: "string", String: value}
}

func (e *EngagementTypeActivityType) UnmarshalJSON(data []byte) error {
	var valueActivityTypeEnum ActivityTypeEnum
	if err := json.Unmarshal(data, &valueActivityTypeEnum); err == nil {
		e.typeName = "activityTypeEnum"
		e.ActivityTypeEnum = valueActivityTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementTypeActivityType) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "activityTypeEnum":
		return json.Marshal(e.ActivityTypeEnum)
	case "string":
		return json.Marshal(e.String)
	}
}

type EngagementTypeActivityTypeVisitor interface {
	VisitActivityTypeEnum(ActivityTypeEnum) error
	VisitString(string) error
}

func (e *EngagementTypeActivityType) Accept(visitor EngagementTypeActivityTypeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "activityTypeEnum":
		return visitor.VisitActivityTypeEnum(e.ActivityTypeEnum)
	case "string":
		return visitor.VisitString(e.String)
	}
}

type EngagementsListRequestExpand uint

const (
	EngagementsListRequestExpandAccount EngagementsListRequestExpand = iota + 1
	EngagementsListRequestExpandAccountEngagementType
	EngagementsListRequestExpandContacts
	EngagementsListRequestExpandContactsAccount
	EngagementsListRequestExpandContactsAccountEngagementType
	EngagementsListRequestExpandContactsEngagementType
	EngagementsListRequestExpandContactsOwner
	EngagementsListRequestExpandContactsOwnerAccount
	EngagementsListRequestExpandContactsOwnerAccountEngagementType
	EngagementsListRequestExpandContactsOwnerEngagementType
	EngagementsListRequestExpandEngagementType
	EngagementsListRequestExpandOwner
	EngagementsListRequestExpandOwnerAccount
	EngagementsListRequestExpandOwnerAccountEngagementType
	EngagementsListRequestExpandOwnerEngagementType
)

func (e EngagementsListRequestExpand) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EngagementsListRequestExpandAccount:
		return "account"
	case EngagementsListRequestExpandAccountEngagementType:
		return "account,engagement_type"
	case EngagementsListRequestExpandContacts:
		return "contacts"
	case EngagementsListRequestExpandContactsAccount:
		return "contacts,account"
	case EngagementsListRequestExpandContactsAccountEngagementType:
		return "contacts,account,engagement_type"
	case EngagementsListRequestExpandContactsEngagementType:
		return "contacts,engagement_type"
	case EngagementsListRequestExpandContactsOwner:
		return "contacts,owner"
	case EngagementsListRequestExpandContactsOwnerAccount:
		return "contacts,owner,account"
	case EngagementsListRequestExpandContactsOwnerAccountEngagementType:
		return "contacts,owner,account,engagement_type"
	case EngagementsListRequestExpandContactsOwnerEngagementType:
		return "contacts,owner,engagement_type"
	case EngagementsListRequestExpandEngagementType:
		return "engagement_type"
	case EngagementsListRequestExpandOwner:
		return "owner"
	case EngagementsListRequestExpandOwnerAccount:
		return "owner,account"
	case EngagementsListRequestExpandOwnerAccountEngagementType:
		return "owner,account,engagement_type"
	case EngagementsListRequestExpandOwnerEngagementType:
		return "owner,engagement_type"
	}
}

func (e EngagementsListRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EngagementsListRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "account":
		value := EngagementsListRequestExpandAccount
		*e = value
	case "account,engagement_type":
		value := EngagementsListRequestExpandAccountEngagementType
		*e = value
	case "contacts":
		value := EngagementsListRequestExpandContacts
		*e = value
	case "contacts,account":
		value := EngagementsListRequestExpandContactsAccount
		*e = value
	case "contacts,account,engagement_type":
		value := EngagementsListRequestExpandContactsAccountEngagementType
		*e = value
	case "contacts,engagement_type":
		value := EngagementsListRequestExpandContactsEngagementType
		*e = value
	case "contacts,owner":
		value := EngagementsListRequestExpandContactsOwner
		*e = value
	case "contacts,owner,account":
		value := EngagementsListRequestExpandContactsOwnerAccount
		*e = value
	case "contacts,owner,account,engagement_type":
		value := EngagementsListRequestExpandContactsOwnerAccountEngagementType
		*e = value
	case "contacts,owner,engagement_type":
		value := EngagementsListRequestExpandContactsOwnerEngagementType
		*e = value
	case "engagement_type":
		value := EngagementsListRequestExpandEngagementType
		*e = value
	case "owner":
		value := EngagementsListRequestExpandOwner
		*e = value
	case "owner,account":
		value := EngagementsListRequestExpandOwnerAccount
		*e = value
	case "owner,account,engagement_type":
		value := EngagementsListRequestExpandOwnerAccountEngagementType
		*e = value
	case "owner,engagement_type":
		value := EngagementsListRequestExpandOwnerEngagementType
		*e = value
	}
	return nil
}

type EngagementsRetrieveRequestExpand uint

const (
	EngagementsRetrieveRequestExpandAccount EngagementsRetrieveRequestExpand = iota + 1
	EngagementsRetrieveRequestExpandAccountEngagementType
	EngagementsRetrieveRequestExpandContacts
	EngagementsRetrieveRequestExpandContactsAccount
	EngagementsRetrieveRequestExpandContactsAccountEngagementType
	EngagementsRetrieveRequestExpandContactsEngagementType
	EngagementsRetrieveRequestExpandContactsOwner
	EngagementsRetrieveRequestExpandContactsOwnerAccount
	EngagementsRetrieveRequestExpandContactsOwnerAccountEngagementType
	EngagementsRetrieveRequestExpandContactsOwnerEngagementType
	EngagementsRetrieveRequestExpandEngagementType
	EngagementsRetrieveRequestExpandOwner
	EngagementsRetrieveRequestExpandOwnerAccount
	EngagementsRetrieveRequestExpandOwnerAccountEngagementType
	EngagementsRetrieveRequestExpandOwnerEngagementType
)

func (e EngagementsRetrieveRequestExpand) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EngagementsRetrieveRequestExpandAccount:
		return "account"
	case EngagementsRetrieveRequestExpandAccountEngagementType:
		return "account,engagement_type"
	case EngagementsRetrieveRequestExpandContacts:
		return "contacts"
	case EngagementsRetrieveRequestExpandContactsAccount:
		return "contacts,account"
	case EngagementsRetrieveRequestExpandContactsAccountEngagementType:
		return "contacts,account,engagement_type"
	case EngagementsRetrieveRequestExpandContactsEngagementType:
		return "contacts,engagement_type"
	case EngagementsRetrieveRequestExpandContactsOwner:
		return "contacts,owner"
	case EngagementsRetrieveRequestExpandContactsOwnerAccount:
		return "contacts,owner,account"
	case EngagementsRetrieveRequestExpandContactsOwnerAccountEngagementType:
		return "contacts,owner,account,engagement_type"
	case EngagementsRetrieveRequestExpandContactsOwnerEngagementType:
		return "contacts,owner,engagement_type"
	case EngagementsRetrieveRequestExpandEngagementType:
		return "engagement_type"
	case EngagementsRetrieveRequestExpandOwner:
		return "owner"
	case EngagementsRetrieveRequestExpandOwnerAccount:
		return "owner,account"
	case EngagementsRetrieveRequestExpandOwnerAccountEngagementType:
		return "owner,account,engagement_type"
	case EngagementsRetrieveRequestExpandOwnerEngagementType:
		return "owner,engagement_type"
	}
}

func (e EngagementsRetrieveRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EngagementsRetrieveRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "account":
		value := EngagementsRetrieveRequestExpandAccount
		*e = value
	case "account,engagement_type":
		value := EngagementsRetrieveRequestExpandAccountEngagementType
		*e = value
	case "contacts":
		value := EngagementsRetrieveRequestExpandContacts
		*e = value
	case "contacts,account":
		value := EngagementsRetrieveRequestExpandContactsAccount
		*e = value
	case "contacts,account,engagement_type":
		value := EngagementsRetrieveRequestExpandContactsAccountEngagementType
		*e = value
	case "contacts,engagement_type":
		value := EngagementsRetrieveRequestExpandContactsEngagementType
		*e = value
	case "contacts,owner":
		value := EngagementsRetrieveRequestExpandContactsOwner
		*e = value
	case "contacts,owner,account":
		value := EngagementsRetrieveRequestExpandContactsOwnerAccount
		*e = value
	case "contacts,owner,account,engagement_type":
		value := EngagementsRetrieveRequestExpandContactsOwnerAccountEngagementType
		*e = value
	case "contacts,owner,engagement_type":
		value := EngagementsRetrieveRequestExpandContactsOwnerEngagementType
		*e = value
	case "engagement_type":
		value := EngagementsRetrieveRequestExpandEngagementType
		*e = value
	case "owner":
		value := EngagementsRetrieveRequestExpandOwner
		*e = value
	case "owner,account":
		value := EngagementsRetrieveRequestExpandOwnerAccount
		*e = value
	case "owner,account,engagement_type":
		value := EngagementsRetrieveRequestExpandOwnerAccountEngagementType
		*e = value
	case "owner,engagement_type":
		value := EngagementsRetrieveRequestExpandOwnerEngagementType
		*e = value
	}
	return nil
}

type ErrorValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type FieldFormatEnum uint

const (
	FieldFormatEnumString FieldFormatEnum = iota + 1
	FieldFormatEnumNumber
	FieldFormatEnumDate
	FieldFormatEnumDatetime
	FieldFormatEnumBool
	FieldFormatEnumList
)

func (f FieldFormatEnum) String() string {
	switch f {
	default:
		return strconv.Itoa(int(f))
	case FieldFormatEnumString:
		return "string"
	case FieldFormatEnumNumber:
		return "number"
	case FieldFormatEnumDate:
		return "date"
	case FieldFormatEnumDatetime:
		return "datetime"
	case FieldFormatEnumBool:
		return "bool"
	case FieldFormatEnumList:
		return "list"
	}
}

func (f FieldFormatEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", f.String())), nil
}

func (f *FieldFormatEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "string":
		value := FieldFormatEnumString
		*f = value
	case "number":
		value := FieldFormatEnumNumber
		*f = value
	case "date":
		value := FieldFormatEnumDate
		*f = value
	case "datetime":
		value := FieldFormatEnumDatetime
		*f = value
	case "bool":
		value := FieldFormatEnumBool
		*f = value
	case "list":
		value := FieldFormatEnumList
		*f = value
	}
	return nil
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type FieldTypeEnum uint

const (
	FieldTypeEnumString FieldTypeEnum = iota + 1
	FieldTypeEnumNumber
	FieldTypeEnumDate
	FieldTypeEnumDatetime
	FieldTypeEnumBool
	FieldTypeEnumList
)

func (f FieldTypeEnum) String() string {
	switch f {
	default:
		return strconv.Itoa(int(f))
	case FieldTypeEnumString:
		return "string"
	case FieldTypeEnumNumber:
		return "number"
	case FieldTypeEnumDate:
		return "date"
	case FieldTypeEnumDatetime:
		return "datetime"
	case FieldTypeEnumBool:
		return "bool"
	case FieldTypeEnumList:
		return "list"
	}
}

func (f FieldTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", f.String())), nil
}

func (f *FieldTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "string":
		value := FieldTypeEnumString
		*f = value
	case "number":
		value := FieldTypeEnumNumber
		*f = value
	case "date":
		value := FieldTypeEnumDate
		*f = value
	case "datetime":
		value := FieldTypeEnumDatetime
		*f = value
	case "bool":
		value := FieldTypeEnumBool
		*f = value
	case "list":
		value := FieldTypeEnumList
		*f = value
	}
	return nil
}

type IgnoreCommonModelRequest struct {
	Reason ReasonEnum `json:"reason,omitempty"`
	// <span style="white-space: nowrap">`non-empty`</span> <span style="white-space: nowrap">`<= 256 characters`</span>
	Message *string `json:"message,omitempty"`
}

type Issue struct {
	Id *string `json:"id,omitempty"`
	// Status of the issue. Options: ('ONGOING', 'RESOLVED')
	//
	// * `ONGOING` - ONGOING
	// * `RESOLVED` - RESOLVED
	Status            *IssueStatus   `json:"status,omitempty"`
	ErrorDescription  string         `json:"error_description"`
	EndUser           map[string]any `json:"end_user,omitempty"`
	FirstIncidentTime *time.Time     `json:"first_incident_time,omitempty"`
	LastIncidentTime  *time.Time     `json:"last_incident_time,omitempty"`
	IsMuted           *bool          `json:"is_muted,omitempty"`
	ErrorDetails      []string       `json:"error_details,omitempty"`
}

// Status of the issue. Options: ('ONGOING', 'RESOLVED')
//
// * `ONGOING` - ONGOING
// * `RESOLVED` - RESOLVED
type IssueStatus struct {
	typeName        string
	IssueStatusEnum IssueStatusEnum
	String          string
}

func NewIssueStatusFromIssueStatusEnum(value IssueStatusEnum) *IssueStatus {
	return &IssueStatus{typeName: "issueStatusEnum", IssueStatusEnum: value}
}

func NewIssueStatusFromString(value string) *IssueStatus {
	return &IssueStatus{typeName: "string", String: value}
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var valueIssueStatusEnum IssueStatusEnum
	if err := json.Unmarshal(data, &valueIssueStatusEnum); err == nil {
		i.typeName = "issueStatusEnum"
		i.IssueStatusEnum = valueIssueStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return json.Marshal(i.IssueStatusEnum)
	case "string":
		return json.Marshal(i.String)
	}
}

type IssueStatusVisitor interface {
	VisitIssueStatusEnum(IssueStatusEnum) error
	VisitString(string) error
}

func (i *IssueStatus) Accept(visitor IssueStatusVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueStatusEnum":
		return visitor.VisitIssueStatusEnum(i.IssueStatusEnum)
	case "string":
		return visitor.VisitString(i.String)
	}
}

// * `ONGOING` - ONGOING
// * `RESOLVED` - RESOLVED
type IssueStatusEnum uint

const (
	IssueStatusEnumOngoing IssueStatusEnum = iota + 1
	IssueStatusEnumResolved
)

func (i IssueStatusEnum) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssueStatusEnumOngoing:
		return "ONGOING"
	case IssueStatusEnumResolved:
		return "RESOLVED"
	}
}

func (i IssueStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssueStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ONGOING":
		value := IssueStatusEnumOngoing
		*i = value
	case "RESOLVED":
		value := IssueStatusEnumResolved
		*i = value
	}
	return nil
}

type IssuesListRequestStatus uint

const (
	IssuesListRequestStatusOngoing IssuesListRequestStatus = iota + 1
	IssuesListRequestStatusResolved
)

func (i IssuesListRequestStatus) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssuesListRequestStatusOngoing:
		return "ONGOING"
	case IssuesListRequestStatusResolved:
		return "RESOLVED"
	}
}

func (i IssuesListRequestStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssuesListRequestStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ONGOING":
		value := IssuesListRequestStatusOngoing
		*i = value
	case "RESOLVED":
		value := IssuesListRequestStatusResolved
		*i = value
	}
	return nil
}

// * `string` - uuid
// * `number` - url
// * `date` - email
// * `datetime` - phone
// * `bool` - currency
// * `list` - decimal
type ItemFormatEnum uint

const (
	ItemFormatEnumString ItemFormatEnum = iota + 1
	ItemFormatEnumNumber
	ItemFormatEnumDate
	ItemFormatEnumDatetime
	ItemFormatEnumBool
	ItemFormatEnumList
)

func (i ItemFormatEnum) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case ItemFormatEnumString:
		return "string"
	case ItemFormatEnumNumber:
		return "number"
	case ItemFormatEnumDate:
		return "date"
	case ItemFormatEnumDatetime:
		return "datetime"
	case ItemFormatEnumBool:
		return "bool"
	case ItemFormatEnumList:
		return "list"
	}
}

func (i ItemFormatEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *ItemFormatEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "string":
		value := ItemFormatEnumString
		*i = value
	case "number":
		value := ItemFormatEnumNumber
		*i = value
	case "date":
		value := ItemFormatEnumDate
		*i = value
	case "datetime":
		value := ItemFormatEnumDatetime
		*i = value
	case "bool":
		value := ItemFormatEnumBool
		*i = value
	case "list":
		value := ItemFormatEnumList
		*i = value
	}
	return nil
}

type ItemSchema struct {
	ItemType    *ItemTypeEnum   `json:"item_type,omitempty"`
	ItemFormat  *ItemFormatEnum `json:"item_format,omitempty"`
	ItemChoices []string        `json:"item_choices,omitempty"`
}

// * `string` - string
// * `number` - number
// * `date` - date
// * `datetime` - datetime
// * `bool` - bool
// * `list` - list
type ItemTypeEnum uint

const (
	ItemTypeEnumString ItemTypeEnum = iota + 1
	ItemTypeEnumNumber
	ItemTypeEnumDate
	ItemTypeEnumDatetime
	ItemTypeEnumBool
	ItemTypeEnumList
)

func (i ItemTypeEnum) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case ItemTypeEnumString:
		return "string"
	case ItemTypeEnumNumber:
		return "number"
	case ItemTypeEnumDate:
		return "date"
	case ItemTypeEnumDatetime:
		return "datetime"
	case ItemTypeEnumBool:
		return "bool"
	case ItemTypeEnumList:
		return "list"
	}
}

func (i ItemTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *ItemTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "string":
		value := ItemTypeEnumString
		*i = value
	case "number":
		value := ItemTypeEnumNumber
		*i = value
	case "date":
		value := ItemTypeEnumDate
		*i = value
	case "datetime":
		value := ItemTypeEnumDatetime
		*i = value
	case "bool":
		value := ItemTypeEnumBool
		*i = value
	case "list":
		value := ItemTypeEnumList
		*i = value
	}
	return nil
}

// # The Lead Object
// ### Description
// The `Lead` object is used to represent an individual who is a potential customer.
// ### Usage Example
// TODO
type Lead struct {
	// The lead's owner.
	Owner *LeadOwner `json:"owner,omitempty"`
	// The lead's source.
	LeadSource *string `json:"lead_source,omitempty"`
	// The lead's title.
	Title *string `json:"title,omitempty"`
	// The lead's company.
	Company *string `json:"company,omitempty"`
	// The lead's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The lead's last name.
	LastName       *string         `json:"last_name,omitempty"`
	Addresses      []*Address      `json:"addresses,omitempty"`
	EmailAddresses []*EmailAddress `json:"email_addresses,omitempty"`
	PhoneNumbers   []*PhoneNumber  `json:"phone_numbers,omitempty"`
	// When the third party's lead was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// When the third party's lead was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty"`
	// When the lead was converted.
	ConvertedDate *time.Time `json:"converted_date,omitempty"`
	// The contact of the converted lead.
	ConvertedContact *LeadConvertedContact `json:"converted_contact,omitempty"`
	// The account of the converted lead.
	ConvertedAccount *LeadConvertedAccount `json:"converted_account,omitempty"`
	RemoteWasDeleted *bool                 `json:"remote_was_deleted,omitempty"`
	Id               *string               `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

// The account of the converted lead.
type LeadConvertedAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewLeadConvertedAccountFromString(value string) *LeadConvertedAccount {
	return &LeadConvertedAccount{typeName: "string", String: value}
}

func NewLeadConvertedAccountFromAccount(value *Account) *LeadConvertedAccount {
	return &LeadConvertedAccount{typeName: "account", Account: value}
}

func (l *LeadConvertedAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		l.typeName = "account"
		l.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadConvertedAccount) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return json.Marshal(l.String)
	case "account":
		return json.Marshal(l.Account)
	}
}

type LeadConvertedAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (l *LeadConvertedAccount) Accept(visitor LeadConvertedAccountVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return visitor.VisitString(l.String)
	case "account":
		return visitor.VisitAccount(l.Account)
	}
}

// The contact of the converted lead.
type LeadConvertedContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewLeadConvertedContactFromString(value string) *LeadConvertedContact {
	return &LeadConvertedContact{typeName: "string", String: value}
}

func NewLeadConvertedContactFromContact(value *Contact) *LeadConvertedContact {
	return &LeadConvertedContact{typeName: "contact", Contact: value}
}

func (l *LeadConvertedContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		l.typeName = "contact"
		l.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadConvertedContact) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return json.Marshal(l.String)
	case "contact":
		return json.Marshal(l.Contact)
	}
}

type LeadConvertedContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (l *LeadConvertedContact) Accept(visitor LeadConvertedContactVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return visitor.VisitString(l.String)
	case "contact":
		return visitor.VisitContact(l.Contact)
	}
}

// The lead's owner.
type LeadOwner struct {
	typeName string
	String   string
	User     *User
}

func NewLeadOwnerFromString(value string) *LeadOwner {
	return &LeadOwner{typeName: "string", String: value}
}

func NewLeadOwnerFromUser(value *User) *LeadOwner {
	return &LeadOwner{typeName: "user", User: value}
}

func (l *LeadOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		l.typeName = "user"
		l.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadOwner) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return json.Marshal(l.String)
	case "user":
		return json.Marshal(l.User)
	}
}

type LeadOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (l *LeadOwner) Accept(visitor LeadOwnerVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return visitor.VisitString(l.String)
	case "user":
		return visitor.VisitUser(l.User)
	}
}

// # The Lead Object
// ### Description
// The `Lead` object is used to represent an individual who is a potential customer.
// ### Usage Example
// TODO
type LeadRequest struct {
	// The lead's owner.
	Owner *LeadRequestOwner `json:"owner,omitempty"`
	// The lead's source.
	LeadSource *string `json:"lead_source,omitempty"`
	// The lead's title.
	Title *string `json:"title,omitempty"`
	// The lead's company.
	Company *string `json:"company,omitempty"`
	// The lead's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The lead's last name.
	LastName       *string                `json:"last_name,omitempty"`
	Addresses      []*AddressRequest      `json:"addresses,omitempty"`
	EmailAddresses []*EmailAddressRequest `json:"email_addresses,omitempty"`
	PhoneNumbers   []*PhoneNumberRequest  `json:"phone_numbers,omitempty"`
	// When the lead was converted.
	ConvertedDate *time.Time `json:"converted_date,omitempty"`
	// The contact of the converted lead.
	ConvertedContact *LeadRequestConvertedContact `json:"converted_contact,omitempty"`
	// The account of the converted lead.
	ConvertedAccount    *LeadRequestConvertedAccount `json:"converted_account,omitempty"`
	IntegrationParams   map[string]any               `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any               `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest        `json:"remote_fields,omitempty"`
}

// The account of the converted lead.
type LeadRequestConvertedAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewLeadRequestConvertedAccountFromString(value string) *LeadRequestConvertedAccount {
	return &LeadRequestConvertedAccount{typeName: "string", String: value}
}

func NewLeadRequestConvertedAccountFromAccount(value *Account) *LeadRequestConvertedAccount {
	return &LeadRequestConvertedAccount{typeName: "account", Account: value}
}

func (l *LeadRequestConvertedAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		l.typeName = "account"
		l.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadRequestConvertedAccount) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return json.Marshal(l.String)
	case "account":
		return json.Marshal(l.Account)
	}
}

type LeadRequestConvertedAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (l *LeadRequestConvertedAccount) Accept(visitor LeadRequestConvertedAccountVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return visitor.VisitString(l.String)
	case "account":
		return visitor.VisitAccount(l.Account)
	}
}

// The contact of the converted lead.
type LeadRequestConvertedContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewLeadRequestConvertedContactFromString(value string) *LeadRequestConvertedContact {
	return &LeadRequestConvertedContact{typeName: "string", String: value}
}

func NewLeadRequestConvertedContactFromContact(value *Contact) *LeadRequestConvertedContact {
	return &LeadRequestConvertedContact{typeName: "contact", Contact: value}
}

func (l *LeadRequestConvertedContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		l.typeName = "contact"
		l.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadRequestConvertedContact) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return json.Marshal(l.String)
	case "contact":
		return json.Marshal(l.Contact)
	}
}

type LeadRequestConvertedContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (l *LeadRequestConvertedContact) Accept(visitor LeadRequestConvertedContactVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return visitor.VisitString(l.String)
	case "contact":
		return visitor.VisitContact(l.Contact)
	}
}

// The lead's owner.
type LeadRequestOwner struct {
	typeName string
	String   string
	User     *User
}

func NewLeadRequestOwnerFromString(value string) *LeadRequestOwner {
	return &LeadRequestOwner{typeName: "string", String: value}
}

func NewLeadRequestOwnerFromUser(value *User) *LeadRequestOwner {
	return &LeadRequestOwner{typeName: "user", User: value}
}

func (l *LeadRequestOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		l.typeName = "user"
		l.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadRequestOwner) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return json.Marshal(l.String)
	case "user":
		return json.Marshal(l.User)
	}
}

type LeadRequestOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (l *LeadRequestOwner) Accept(visitor LeadRequestOwnerVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return visitor.VisitString(l.String)
	case "user":
		return visitor.VisitUser(l.User)
	}
}

type LeadResponse struct {
	Model    *Lead                       `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type LeadsListRequestExpand uint

const (
	LeadsListRequestExpandConvertedAccount LeadsListRequestExpand = iota + 1
	LeadsListRequestExpandConvertedContact
	LeadsListRequestExpandConvertedContactConvertedAccount
	LeadsListRequestExpandOwner
	LeadsListRequestExpandOwnerConvertedAccount
	LeadsListRequestExpandOwnerConvertedContact
	LeadsListRequestExpandOwnerConvertedContactConvertedAccount
)

func (l LeadsListRequestExpand) String() string {
	switch l {
	default:
		return strconv.Itoa(int(l))
	case LeadsListRequestExpandConvertedAccount:
		return "converted_account"
	case LeadsListRequestExpandConvertedContact:
		return "converted_contact"
	case LeadsListRequestExpandConvertedContactConvertedAccount:
		return "converted_contact,converted_account"
	case LeadsListRequestExpandOwner:
		return "owner"
	case LeadsListRequestExpandOwnerConvertedAccount:
		return "owner,converted_account"
	case LeadsListRequestExpandOwnerConvertedContact:
		return "owner,converted_contact"
	case LeadsListRequestExpandOwnerConvertedContactConvertedAccount:
		return "owner,converted_contact,converted_account"
	}
}

func (l LeadsListRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", l.String())), nil
}

func (l *LeadsListRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "converted_account":
		value := LeadsListRequestExpandConvertedAccount
		*l = value
	case "converted_contact":
		value := LeadsListRequestExpandConvertedContact
		*l = value
	case "converted_contact,converted_account":
		value := LeadsListRequestExpandConvertedContactConvertedAccount
		*l = value
	case "owner":
		value := LeadsListRequestExpandOwner
		*l = value
	case "owner,converted_account":
		value := LeadsListRequestExpandOwnerConvertedAccount
		*l = value
	case "owner,converted_contact":
		value := LeadsListRequestExpandOwnerConvertedContact
		*l = value
	case "owner,converted_contact,converted_account":
		value := LeadsListRequestExpandOwnerConvertedContactConvertedAccount
		*l = value
	}
	return nil
}

type LeadsRetrieveRequestExpand uint

const (
	LeadsRetrieveRequestExpandConvertedAccount LeadsRetrieveRequestExpand = iota + 1
	LeadsRetrieveRequestExpandConvertedContact
	LeadsRetrieveRequestExpandConvertedContactConvertedAccount
	LeadsRetrieveRequestExpandOwner
	LeadsRetrieveRequestExpandOwnerConvertedAccount
	LeadsRetrieveRequestExpandOwnerConvertedContact
	LeadsRetrieveRequestExpandOwnerConvertedContactConvertedAccount
)

func (l LeadsRetrieveRequestExpand) String() string {
	switch l {
	default:
		return strconv.Itoa(int(l))
	case LeadsRetrieveRequestExpandConvertedAccount:
		return "converted_account"
	case LeadsRetrieveRequestExpandConvertedContact:
		return "converted_contact"
	case LeadsRetrieveRequestExpandConvertedContactConvertedAccount:
		return "converted_contact,converted_account"
	case LeadsRetrieveRequestExpandOwner:
		return "owner"
	case LeadsRetrieveRequestExpandOwnerConvertedAccount:
		return "owner,converted_account"
	case LeadsRetrieveRequestExpandOwnerConvertedContact:
		return "owner,converted_contact"
	case LeadsRetrieveRequestExpandOwnerConvertedContactConvertedAccount:
		return "owner,converted_contact,converted_account"
	}
}

func (l LeadsRetrieveRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", l.String())), nil
}

func (l *LeadsRetrieveRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "converted_account":
		value := LeadsRetrieveRequestExpandConvertedAccount
		*l = value
	case "converted_contact":
		value := LeadsRetrieveRequestExpandConvertedContact
		*l = value
	case "converted_contact,converted_account":
		value := LeadsRetrieveRequestExpandConvertedContactConvertedAccount
		*l = value
	case "owner":
		value := LeadsRetrieveRequestExpandOwner
		*l = value
	case "owner,converted_account":
		value := LeadsRetrieveRequestExpandOwnerConvertedAccount
		*l = value
	case "owner,converted_contact":
		value := LeadsRetrieveRequestExpandOwnerConvertedContact
		*l = value
	case "owner,converted_contact,converted_account":
		value := LeadsRetrieveRequestExpandOwnerConvertedContactConvertedAccount
		*l = value
	}
	return nil
}

type LinkToken struct {
	LinkToken       string  `json:"link_token"`
	IntegrationName *string `json:"integration_name,omitempty"`
	MagicLinkUrl    *string `json:"magic_link_url,omitempty"`
}

type LinkedAccountCondition struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The common model for a specific condition.
	CommonModel *string `json:"common_model,omitempty"`
	// User-facing *native condition* name. e.g. "Skip Manager".
	NativeName *string `json:"native_name,omitempty"`
	// The operator for a specific condition.
	Operator string `json:"operator"`
	Value    *any   `json:"value,omitempty"`
	// The name of the field on the common model that this condition corresponds to, if they conceptually match. e.g. "location_type".
	FieldName *string `json:"field_name,omitempty"`
}

type LinkedAccountConditionRequest struct {
	// The ID indicating which condition schema to use for a specific condition.
	ConditionSchemaId string `json:"condition_schema_id"`
	// The operator for a specific condition. <span style="white-space: nowrap">`non-empty`</span>
	Operator string `json:"operator"`
	Value    any    `json:"value,omitempty"`
}

type LinkedAccountSelectiveSyncConfiguration struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountCondition `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountSelectiveSyncConfigurationRequest struct {
	// The conditions belonging to a selective sync.
	LinkedAccountConditions []*LinkedAccountConditionRequest `json:"linked_account_conditions,omitempty"`
}

type LinkedAccountStatus struct {
	LinkedAccountStatus string `json:"linked_account_status"`
	CanMakeRequest      bool   `json:"can_make_request"`
}

type LinkedAccountsListRequestCategory uint

const (
	LinkedAccountsListRequestCategoryAccounting LinkedAccountsListRequestCategory = iota + 1
	LinkedAccountsListRequestCategoryAts
	LinkedAccountsListRequestCategoryCrm
	LinkedAccountsListRequestCategoryFilestorage
	LinkedAccountsListRequestCategoryHris
	LinkedAccountsListRequestCategoryMktg
	LinkedAccountsListRequestCategoryTicketing
)

func (l LinkedAccountsListRequestCategory) String() string {
	switch l {
	default:
		return strconv.Itoa(int(l))
	case LinkedAccountsListRequestCategoryAccounting:
		return "accounting"
	case LinkedAccountsListRequestCategoryAts:
		return "ats"
	case LinkedAccountsListRequestCategoryCrm:
		return "crm"
	case LinkedAccountsListRequestCategoryFilestorage:
		return "filestorage"
	case LinkedAccountsListRequestCategoryHris:
		return "hris"
	case LinkedAccountsListRequestCategoryMktg:
		return "mktg"
	case LinkedAccountsListRequestCategoryTicketing:
		return "ticketing"
	}
}

func (l LinkedAccountsListRequestCategory) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", l.String())), nil
}

func (l *LinkedAccountsListRequestCategory) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "accounting":
		value := LinkedAccountsListRequestCategoryAccounting
		*l = value
	case "ats":
		value := LinkedAccountsListRequestCategoryAts
		*l = value
	case "crm":
		value := LinkedAccountsListRequestCategoryCrm
		*l = value
	case "filestorage":
		value := LinkedAccountsListRequestCategoryFilestorage
		*l = value
	case "hris":
		value := LinkedAccountsListRequestCategoryHris
		*l = value
	case "mktg":
		value := LinkedAccountsListRequestCategoryMktg
		*l = value
	case "ticketing":
		value := LinkedAccountsListRequestCategoryTicketing
		*l = value
	}
	return nil
}

type MetaResponse struct {
	RequestSchema                  map[string]any       `json:"request_schema,omitempty"`
	RemoteFieldClasses             map[string]any       `json:"remote_field_classes,omitempty"`
	Status                         *LinkedAccountStatus `json:"status,omitempty"`
	HasConditionalParams           bool                 `json:"has_conditional_params"`
	HasRequiredLinkedAccountParams bool                 `json:"has_required_linked_account_params"`
}

// * `GET` - GET
// * `OPTIONS` - OPTIONS
// * `HEAD` - HEAD
// * `POST` - POST
// * `PUT` - PUT
// * `PATCH` - PATCH
// * `DELETE` - DELETE
type MethodEnum uint

const (
	MethodEnumGet MethodEnum = iota + 1
	MethodEnumOptions
	MethodEnumHead
	MethodEnumPost
	MethodEnumPut
	MethodEnumPatch
	MethodEnumDelete
)

func (m MethodEnum) String() string {
	switch m {
	default:
		return strconv.Itoa(int(m))
	case MethodEnumGet:
		return "GET"
	case MethodEnumOptions:
		return "OPTIONS"
	case MethodEnumHead:
		return "HEAD"
	case MethodEnumPost:
		return "POST"
	case MethodEnumPut:
		return "PUT"
	case MethodEnumPatch:
		return "PATCH"
	case MethodEnumDelete:
		return "DELETE"
	}
}

func (m MethodEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", m.String())), nil
}

func (m *MethodEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GET":
		value := MethodEnumGet
		*m = value
	case "OPTIONS":
		value := MethodEnumOptions
		*m = value
	case "HEAD":
		value := MethodEnumHead
		*m = value
	case "POST":
		value := MethodEnumPost
		*m = value
	case "PUT":
		value := MethodEnumPut
		*m = value
	case "PATCH":
		value := MethodEnumPatch
		*m = value
	case "DELETE":
		value := MethodEnumDelete
		*m = value
	}
	return nil
}

// # The ModelOperation Object
// ### Description
// The `ModelOperation` object is used to represent the operations that are currently supported for a given model.
//
// ### Usage Example
// View what operations are supported for the `Candidate` endpoint.
type ModelOperation struct {
	ModelName              string   `json:"model_name"`
	AvailableOperations    []string `json:"available_operations,omitempty"`
	RequiredPostParameters []string `json:"required_post_parameters,omitempty"`
	SupportedFields        []string `json:"supported_fields,omitempty"`
}

// # The MultipartFormField Object
// ### Description
// The `MultipartFormField` object is used to represent fields in an HTTP request using `multipart/form-data`.
//
// ### Usage Example
// Create a `MultipartFormField` to define a multipart form entry.
type MultipartFormFieldRequest struct {
	// The name of the form field <span style="white-space: nowrap">`non-empty`</span>
	Name string `json:"name"`
	// The data for the form field. <span style="white-space: nowrap">`non-empty`</span>
	Data string `json:"data"`
	// The encoding of the value of `data`. Defaults to `RAW` if not defined.
	//
	// * `RAW` - RAW
	// * `BASE64` - BASE64
	// * `GZIP_BASE64` - GZIP_BASE64
	Encoding *MultipartFormFieldRequestEncoding `json:"encoding,omitempty"`
	// The file name of the form field, if the field is for a file.
	FileName *string `json:"file_name,omitempty"`
	// The MIME type of the file, if the field is for a file.
	ContentType *string `json:"content_type,omitempty"`
}

// The encoding of the value of `data`. Defaults to `RAW` if not defined.
//
// * `RAW` - RAW
// * `BASE64` - BASE64
// * `GZIP_BASE64` - GZIP_BASE64
type MultipartFormFieldRequestEncoding struct {
	typeName     string
	EncodingEnum EncodingEnum
	String       string
}

func NewMultipartFormFieldRequestEncodingFromEncodingEnum(value EncodingEnum) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "encodingEnum", EncodingEnum: value}
}

func NewMultipartFormFieldRequestEncodingFromString(value string) *MultipartFormFieldRequestEncoding {
	return &MultipartFormFieldRequestEncoding{typeName: "string", String: value}
}

func (m *MultipartFormFieldRequestEncoding) UnmarshalJSON(data []byte) error {
	var valueEncodingEnum EncodingEnum
	if err := json.Unmarshal(data, &valueEncodingEnum); err == nil {
		m.typeName = "encodingEnum"
		m.EncodingEnum = valueEncodingEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MultipartFormFieldRequestEncoding) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return json.Marshal(m.EncodingEnum)
	case "string":
		return json.Marshal(m.String)
	}
}

type MultipartFormFieldRequestEncodingVisitor interface {
	VisitEncodingEnum(EncodingEnum) error
	VisitString(string) error
}

func (m *MultipartFormFieldRequestEncoding) Accept(visitor MultipartFormFieldRequestEncodingVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "encodingEnum":
		return visitor.VisitEncodingEnum(m.EncodingEnum)
	case "string":
		return visitor.VisitString(m.String)
	}
}

// # The Note Object
// ### Description
// The `Note` object is used to represent a note on another object.
// ### Usage Example
// TODO
type Note struct {
	// The note's owner.
	Owner *NoteOwner `json:"owner,omitempty"`
	// The note's content.
	Content *string `json:"content,omitempty"`
	// The note's contact.
	Contact *NoteContact `json:"contact,omitempty"`
	// The note's account.
	Account *NoteAccount `json:"account,omitempty"`
	// The note's opportunity.
	Opportunity *NoteOpportunity `json:"opportunity,omitempty"`
	// When the third party's lead was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty"`
	// When the third party's lead was created.
	RemoteCreatedAt  *time.Time `json:"remote_created_at,omitempty"`
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	Id               *string    `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

// The note's account.
type NoteAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewNoteAccountFromString(value string) *NoteAccount {
	return &NoteAccount{typeName: "string", String: value}
}

func NewNoteAccountFromAccount(value *Account) *NoteAccount {
	return &NoteAccount{typeName: "account", Account: value}
}

func (n *NoteAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		n.typeName = "account"
		n.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NoteAccount) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "account":
		return json.Marshal(n.Account)
	}
}

type NoteAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (n *NoteAccount) Accept(visitor NoteAccountVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "account":
		return visitor.VisitAccount(n.Account)
	}
}

// The note's contact.
type NoteContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewNoteContactFromString(value string) *NoteContact {
	return &NoteContact{typeName: "string", String: value}
}

func NewNoteContactFromContact(value *Contact) *NoteContact {
	return &NoteContact{typeName: "contact", Contact: value}
}

func (n *NoteContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		n.typeName = "contact"
		n.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NoteContact) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "contact":
		return json.Marshal(n.Contact)
	}
}

type NoteContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (n *NoteContact) Accept(visitor NoteContactVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "contact":
		return visitor.VisitContact(n.Contact)
	}
}

// The note's opportunity.
type NoteOpportunity struct {
	typeName    string
	String      string
	Opportunity *Opportunity
}

func NewNoteOpportunityFromString(value string) *NoteOpportunity {
	return &NoteOpportunity{typeName: "string", String: value}
}

func NewNoteOpportunityFromOpportunity(value *Opportunity) *NoteOpportunity {
	return &NoteOpportunity{typeName: "opportunity", Opportunity: value}
}

func (n *NoteOpportunity) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueOpportunity := new(Opportunity)
	if err := json.Unmarshal(data, &valueOpportunity); err == nil {
		n.typeName = "opportunity"
		n.Opportunity = valueOpportunity
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NoteOpportunity) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "opportunity":
		return json.Marshal(n.Opportunity)
	}
}

type NoteOpportunityVisitor interface {
	VisitString(string) error
	VisitOpportunity(*Opportunity) error
}

func (n *NoteOpportunity) Accept(visitor NoteOpportunityVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "opportunity":
		return visitor.VisitOpportunity(n.Opportunity)
	}
}

// The note's owner.
type NoteOwner struct {
	typeName string
	String   string
	User     *User
}

func NewNoteOwnerFromString(value string) *NoteOwner {
	return &NoteOwner{typeName: "string", String: value}
}

func NewNoteOwnerFromUser(value *User) *NoteOwner {
	return &NoteOwner{typeName: "user", User: value}
}

func (n *NoteOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		n.typeName = "user"
		n.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NoteOwner) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "user":
		return json.Marshal(n.User)
	}
}

type NoteOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (n *NoteOwner) Accept(visitor NoteOwnerVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "user":
		return visitor.VisitUser(n.User)
	}
}

// # The Note Object
// ### Description
// The `Note` object is used to represent a note on another object.
// ### Usage Example
// TODO
type NoteRequest struct {
	// The note's owner.
	Owner *NoteRequestOwner `json:"owner,omitempty"`
	// The note's content.
	Content *string `json:"content,omitempty"`
	// The note's contact.
	Contact *NoteRequestContact `json:"contact,omitempty"`
	// The note's account.
	Account *NoteRequestAccount `json:"account,omitempty"`
	// The note's opportunity.
	Opportunity         *NoteRequestOpportunity `json:"opportunity,omitempty"`
	IntegrationParams   map[string]any          `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any          `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest   `json:"remote_fields,omitempty"`
}

// The note's account.
type NoteRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewNoteRequestAccountFromString(value string) *NoteRequestAccount {
	return &NoteRequestAccount{typeName: "string", String: value}
}

func NewNoteRequestAccountFromAccount(value *Account) *NoteRequestAccount {
	return &NoteRequestAccount{typeName: "account", Account: value}
}

func (n *NoteRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		n.typeName = "account"
		n.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NoteRequestAccount) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "account":
		return json.Marshal(n.Account)
	}
}

type NoteRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (n *NoteRequestAccount) Accept(visitor NoteRequestAccountVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "account":
		return visitor.VisitAccount(n.Account)
	}
}

// The note's contact.
type NoteRequestContact struct {
	typeName string
	String   string
	Contact  *Contact
}

func NewNoteRequestContactFromString(value string) *NoteRequestContact {
	return &NoteRequestContact{typeName: "string", String: value}
}

func NewNoteRequestContactFromContact(value *Contact) *NoteRequestContact {
	return &NoteRequestContact{typeName: "contact", Contact: value}
}

func (n *NoteRequestContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		n.typeName = "contact"
		n.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NoteRequestContact) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "contact":
		return json.Marshal(n.Contact)
	}
}

type NoteRequestContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (n *NoteRequestContact) Accept(visitor NoteRequestContactVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "contact":
		return visitor.VisitContact(n.Contact)
	}
}

// The note's opportunity.
type NoteRequestOpportunity struct {
	typeName    string
	String      string
	Opportunity *Opportunity
}

func NewNoteRequestOpportunityFromString(value string) *NoteRequestOpportunity {
	return &NoteRequestOpportunity{typeName: "string", String: value}
}

func NewNoteRequestOpportunityFromOpportunity(value *Opportunity) *NoteRequestOpportunity {
	return &NoteRequestOpportunity{typeName: "opportunity", Opportunity: value}
}

func (n *NoteRequestOpportunity) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueOpportunity := new(Opportunity)
	if err := json.Unmarshal(data, &valueOpportunity); err == nil {
		n.typeName = "opportunity"
		n.Opportunity = valueOpportunity
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NoteRequestOpportunity) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "opportunity":
		return json.Marshal(n.Opportunity)
	}
}

type NoteRequestOpportunityVisitor interface {
	VisitString(string) error
	VisitOpportunity(*Opportunity) error
}

func (n *NoteRequestOpportunity) Accept(visitor NoteRequestOpportunityVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "opportunity":
		return visitor.VisitOpportunity(n.Opportunity)
	}
}

// The note's owner.
type NoteRequestOwner struct {
	typeName string
	String   string
	User     *User
}

func NewNoteRequestOwnerFromString(value string) *NoteRequestOwner {
	return &NoteRequestOwner{typeName: "string", String: value}
}

func NewNoteRequestOwnerFromUser(value *User) *NoteRequestOwner {
	return &NoteRequestOwner{typeName: "user", User: value}
}

func (n *NoteRequestOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typeName = "string"
		n.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		n.typeName = "user"
		n.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NoteRequestOwner) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return json.Marshal(n.String)
	case "user":
		return json.Marshal(n.User)
	}
}

type NoteRequestOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (n *NoteRequestOwner) Accept(visitor NoteRequestOwnerVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "string":
		return visitor.VisitString(n.String)
	case "user":
		return visitor.VisitUser(n.User)
	}
}

type NoteResponse struct {
	Model    *Note                       `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

type NotesListRequestExpand uint

const (
	NotesListRequestExpandAccount NotesListRequestExpand = iota + 1
	NotesListRequestExpandAccountOpportunity
	NotesListRequestExpandContact
	NotesListRequestExpandContactAccount
	NotesListRequestExpandContactAccountOpportunity
	NotesListRequestExpandContactOpportunity
	NotesListRequestExpandOpportunity
	NotesListRequestExpandOwner
	NotesListRequestExpandOwnerAccount
	NotesListRequestExpandOwnerAccountOpportunity
	NotesListRequestExpandOwnerContact
	NotesListRequestExpandOwnerContactAccount
	NotesListRequestExpandOwnerContactAccountOpportunity
	NotesListRequestExpandOwnerContactOpportunity
	NotesListRequestExpandOwnerOpportunity
)

func (n NotesListRequestExpand) String() string {
	switch n {
	default:
		return strconv.Itoa(int(n))
	case NotesListRequestExpandAccount:
		return "account"
	case NotesListRequestExpandAccountOpportunity:
		return "account,opportunity"
	case NotesListRequestExpandContact:
		return "contact"
	case NotesListRequestExpandContactAccount:
		return "contact,account"
	case NotesListRequestExpandContactAccountOpportunity:
		return "contact,account,opportunity"
	case NotesListRequestExpandContactOpportunity:
		return "contact,opportunity"
	case NotesListRequestExpandOpportunity:
		return "opportunity"
	case NotesListRequestExpandOwner:
		return "owner"
	case NotesListRequestExpandOwnerAccount:
		return "owner,account"
	case NotesListRequestExpandOwnerAccountOpportunity:
		return "owner,account,opportunity"
	case NotesListRequestExpandOwnerContact:
		return "owner,contact"
	case NotesListRequestExpandOwnerContactAccount:
		return "owner,contact,account"
	case NotesListRequestExpandOwnerContactAccountOpportunity:
		return "owner,contact,account,opportunity"
	case NotesListRequestExpandOwnerContactOpportunity:
		return "owner,contact,opportunity"
	case NotesListRequestExpandOwnerOpportunity:
		return "owner,opportunity"
	}
}

func (n NotesListRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", n.String())), nil
}

func (n *NotesListRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "account":
		value := NotesListRequestExpandAccount
		*n = value
	case "account,opportunity":
		value := NotesListRequestExpandAccountOpportunity
		*n = value
	case "contact":
		value := NotesListRequestExpandContact
		*n = value
	case "contact,account":
		value := NotesListRequestExpandContactAccount
		*n = value
	case "contact,account,opportunity":
		value := NotesListRequestExpandContactAccountOpportunity
		*n = value
	case "contact,opportunity":
		value := NotesListRequestExpandContactOpportunity
		*n = value
	case "opportunity":
		value := NotesListRequestExpandOpportunity
		*n = value
	case "owner":
		value := NotesListRequestExpandOwner
		*n = value
	case "owner,account":
		value := NotesListRequestExpandOwnerAccount
		*n = value
	case "owner,account,opportunity":
		value := NotesListRequestExpandOwnerAccountOpportunity
		*n = value
	case "owner,contact":
		value := NotesListRequestExpandOwnerContact
		*n = value
	case "owner,contact,account":
		value := NotesListRequestExpandOwnerContactAccount
		*n = value
	case "owner,contact,account,opportunity":
		value := NotesListRequestExpandOwnerContactAccountOpportunity
		*n = value
	case "owner,contact,opportunity":
		value := NotesListRequestExpandOwnerContactOpportunity
		*n = value
	case "owner,opportunity":
		value := NotesListRequestExpandOwnerOpportunity
		*n = value
	}
	return nil
}

type NotesRetrieveRequestExpand uint

const (
	NotesRetrieveRequestExpandAccount NotesRetrieveRequestExpand = iota + 1
	NotesRetrieveRequestExpandAccountOpportunity
	NotesRetrieveRequestExpandContact
	NotesRetrieveRequestExpandContactAccount
	NotesRetrieveRequestExpandContactAccountOpportunity
	NotesRetrieveRequestExpandContactOpportunity
	NotesRetrieveRequestExpandOpportunity
	NotesRetrieveRequestExpandOwner
	NotesRetrieveRequestExpandOwnerAccount
	NotesRetrieveRequestExpandOwnerAccountOpportunity
	NotesRetrieveRequestExpandOwnerContact
	NotesRetrieveRequestExpandOwnerContactAccount
	NotesRetrieveRequestExpandOwnerContactAccountOpportunity
	NotesRetrieveRequestExpandOwnerContactOpportunity
	NotesRetrieveRequestExpandOwnerOpportunity
)

func (n NotesRetrieveRequestExpand) String() string {
	switch n {
	default:
		return strconv.Itoa(int(n))
	case NotesRetrieveRequestExpandAccount:
		return "account"
	case NotesRetrieveRequestExpandAccountOpportunity:
		return "account,opportunity"
	case NotesRetrieveRequestExpandContact:
		return "contact"
	case NotesRetrieveRequestExpandContactAccount:
		return "contact,account"
	case NotesRetrieveRequestExpandContactAccountOpportunity:
		return "contact,account,opportunity"
	case NotesRetrieveRequestExpandContactOpportunity:
		return "contact,opportunity"
	case NotesRetrieveRequestExpandOpportunity:
		return "opportunity"
	case NotesRetrieveRequestExpandOwner:
		return "owner"
	case NotesRetrieveRequestExpandOwnerAccount:
		return "owner,account"
	case NotesRetrieveRequestExpandOwnerAccountOpportunity:
		return "owner,account,opportunity"
	case NotesRetrieveRequestExpandOwnerContact:
		return "owner,contact"
	case NotesRetrieveRequestExpandOwnerContactAccount:
		return "owner,contact,account"
	case NotesRetrieveRequestExpandOwnerContactAccountOpportunity:
		return "owner,contact,account,opportunity"
	case NotesRetrieveRequestExpandOwnerContactOpportunity:
		return "owner,contact,opportunity"
	case NotesRetrieveRequestExpandOwnerOpportunity:
		return "owner,opportunity"
	}
}

func (n NotesRetrieveRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", n.String())), nil
}

func (n *NotesRetrieveRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "account":
		value := NotesRetrieveRequestExpandAccount
		*n = value
	case "account,opportunity":
		value := NotesRetrieveRequestExpandAccountOpportunity
		*n = value
	case "contact":
		value := NotesRetrieveRequestExpandContact
		*n = value
	case "contact,account":
		value := NotesRetrieveRequestExpandContactAccount
		*n = value
	case "contact,account,opportunity":
		value := NotesRetrieveRequestExpandContactAccountOpportunity
		*n = value
	case "contact,opportunity":
		value := NotesRetrieveRequestExpandContactOpportunity
		*n = value
	case "opportunity":
		value := NotesRetrieveRequestExpandOpportunity
		*n = value
	case "owner":
		value := NotesRetrieveRequestExpandOwner
		*n = value
	case "owner,account":
		value := NotesRetrieveRequestExpandOwnerAccount
		*n = value
	case "owner,account,opportunity":
		value := NotesRetrieveRequestExpandOwnerAccountOpportunity
		*n = value
	case "owner,contact":
		value := NotesRetrieveRequestExpandOwnerContact
		*n = value
	case "owner,contact,account":
		value := NotesRetrieveRequestExpandOwnerContactAccount
		*n = value
	case "owner,contact,account,opportunity":
		value := NotesRetrieveRequestExpandOwnerContactAccountOpportunity
		*n = value
	case "owner,contact,opportunity":
		value := NotesRetrieveRequestExpandOwnerContactOpportunity
		*n = value
	case "owner,opportunity":
		value := NotesRetrieveRequestExpandOwnerOpportunity
		*n = value
	}
	return nil
}

type ObjectClassDescriptionRequest struct {
	// <span style="white-space: nowrap">`non-empty`</span>
	Id         string         `json:"id"`
	OriginType OriginTypeEnum `json:"origin_type,omitempty"`
}

type OperatorSchema struct {
	// The operator for which an operator schema is defined.
	Operator *string `json:"operator,omitempty"`
	// Whether the operator can be repeated multiple times.
	IsUnique *bool `json:"is_unique,omitempty"`
}

type OpportunitiesListRequestExpand uint

const (
	OpportunitiesListRequestExpandAccount OpportunitiesListRequestExpand = iota + 1
	OpportunitiesListRequestExpandOwner
	OpportunitiesListRequestExpandOwnerAccount
	OpportunitiesListRequestExpandOwnerStage
	OpportunitiesListRequestExpandOwnerStageAccount
	OpportunitiesListRequestExpandStage
	OpportunitiesListRequestExpandStageAccount
)

func (o OpportunitiesListRequestExpand) String() string {
	switch o {
	default:
		return strconv.Itoa(int(o))
	case OpportunitiesListRequestExpandAccount:
		return "account"
	case OpportunitiesListRequestExpandOwner:
		return "owner"
	case OpportunitiesListRequestExpandOwnerAccount:
		return "owner,account"
	case OpportunitiesListRequestExpandOwnerStage:
		return "owner,stage"
	case OpportunitiesListRequestExpandOwnerStageAccount:
		return "owner,stage,account"
	case OpportunitiesListRequestExpandStage:
		return "stage"
	case OpportunitiesListRequestExpandStageAccount:
		return "stage,account"
	}
}

func (o OpportunitiesListRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", o.String())), nil
}

func (o *OpportunitiesListRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "account":
		value := OpportunitiesListRequestExpandAccount
		*o = value
	case "owner":
		value := OpportunitiesListRequestExpandOwner
		*o = value
	case "owner,account":
		value := OpportunitiesListRequestExpandOwnerAccount
		*o = value
	case "owner,stage":
		value := OpportunitiesListRequestExpandOwnerStage
		*o = value
	case "owner,stage,account":
		value := OpportunitiesListRequestExpandOwnerStageAccount
		*o = value
	case "stage":
		value := OpportunitiesListRequestExpandStage
		*o = value
	case "stage,account":
		value := OpportunitiesListRequestExpandStageAccount
		*o = value
	}
	return nil
}

type OpportunitiesListRequestStatus uint

const (
	OpportunitiesListRequestStatusLost OpportunitiesListRequestStatus = iota + 1
	OpportunitiesListRequestStatusOpen
	OpportunitiesListRequestStatusWon
)

func (o OpportunitiesListRequestStatus) String() string {
	switch o {
	default:
		return strconv.Itoa(int(o))
	case OpportunitiesListRequestStatusLost:
		return "LOST"
	case OpportunitiesListRequestStatusOpen:
		return "OPEN"
	case OpportunitiesListRequestStatusWon:
		return "WON"
	}
}

func (o OpportunitiesListRequestStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", o.String())), nil
}

func (o *OpportunitiesListRequestStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "LOST":
		value := OpportunitiesListRequestStatusLost
		*o = value
	case "OPEN":
		value := OpportunitiesListRequestStatusOpen
		*o = value
	case "WON":
		value := OpportunitiesListRequestStatusWon
		*o = value
	}
	return nil
}

type OpportunitiesRetrieveRequestExpand uint

const (
	OpportunitiesRetrieveRequestExpandAccount OpportunitiesRetrieveRequestExpand = iota + 1
	OpportunitiesRetrieveRequestExpandOwner
	OpportunitiesRetrieveRequestExpandOwnerAccount
	OpportunitiesRetrieveRequestExpandOwnerStage
	OpportunitiesRetrieveRequestExpandOwnerStageAccount
	OpportunitiesRetrieveRequestExpandStage
	OpportunitiesRetrieveRequestExpandStageAccount
)

func (o OpportunitiesRetrieveRequestExpand) String() string {
	switch o {
	default:
		return strconv.Itoa(int(o))
	case OpportunitiesRetrieveRequestExpandAccount:
		return "account"
	case OpportunitiesRetrieveRequestExpandOwner:
		return "owner"
	case OpportunitiesRetrieveRequestExpandOwnerAccount:
		return "owner,account"
	case OpportunitiesRetrieveRequestExpandOwnerStage:
		return "owner,stage"
	case OpportunitiesRetrieveRequestExpandOwnerStageAccount:
		return "owner,stage,account"
	case OpportunitiesRetrieveRequestExpandStage:
		return "stage"
	case OpportunitiesRetrieveRequestExpandStageAccount:
		return "stage,account"
	}
}

func (o OpportunitiesRetrieveRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", o.String())), nil
}

func (o *OpportunitiesRetrieveRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "account":
		value := OpportunitiesRetrieveRequestExpandAccount
		*o = value
	case "owner":
		value := OpportunitiesRetrieveRequestExpandOwner
		*o = value
	case "owner,account":
		value := OpportunitiesRetrieveRequestExpandOwnerAccount
		*o = value
	case "owner,stage":
		value := OpportunitiesRetrieveRequestExpandOwnerStage
		*o = value
	case "owner,stage,account":
		value := OpportunitiesRetrieveRequestExpandOwnerStageAccount
		*o = value
	case "stage":
		value := OpportunitiesRetrieveRequestExpandStage
		*o = value
	case "stage,account":
		value := OpportunitiesRetrieveRequestExpandStageAccount
		*o = value
	}
	return nil
}

// # The Opportunity Object
// ### Description
// The `Opportunity` object is used to represent a deal opportunity in a CRM system.
// ### Usage Example
// TODO
type Opportunity struct {
	// The opportunity's name.
	Name *string `json:"name,omitempty"`
	// The opportunity's description.
	Description *string `json:"description,omitempty"`
	// The opportunity's amount.
	Amount *int `json:"amount,omitempty"`
	// The opportunity's owner.
	Owner *OpportunityOwner `json:"owner,omitempty"`
	// The account of the opportunity.
	Account *OpportunityAccount `json:"account,omitempty"`
	// The stage of the opportunity.
	Stage *OpportunityStage `json:"stage,omitempty"`
	// The opportunity's status.
	//
	// * `OPEN` - OPEN
	// * `WON` - WON
	// * `LOST` - LOST
	Status *OpportunityStatus `json:"status,omitempty"`
	// When the opportunity's last activity occurred.
	LastActivityAt *time.Time `json:"last_activity_at,omitempty"`
	// When the opportunity was closed.
	CloseDate *time.Time `json:"close_date,omitempty"`
	// When the third party's opportunity was created.
	RemoteCreatedAt  *time.Time `json:"remote_created_at,omitempty"`
	RemoteWasDeleted *bool      `json:"remote_was_deleted,omitempty"`
	Id               *string    `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

// The account of the opportunity.
type OpportunityAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewOpportunityAccountFromString(value string) *OpportunityAccount {
	return &OpportunityAccount{typeName: "string", String: value}
}

func NewOpportunityAccountFromAccount(value *Account) *OpportunityAccount {
	return &OpportunityAccount{typeName: "account", Account: value}
}

func (o *OpportunityAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		o.typeName = "account"
		o.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpportunityAccount) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "account":
		return json.Marshal(o.Account)
	}
}

type OpportunityAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (o *OpportunityAccount) Accept(visitor OpportunityAccountVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "account":
		return visitor.VisitAccount(o.Account)
	}
}

// The opportunity's owner.
type OpportunityOwner struct {
	typeName string
	String   string
	User     *User
}

func NewOpportunityOwnerFromString(value string) *OpportunityOwner {
	return &OpportunityOwner{typeName: "string", String: value}
}

func NewOpportunityOwnerFromUser(value *User) *OpportunityOwner {
	return &OpportunityOwner{typeName: "user", User: value}
}

func (o *OpportunityOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		o.typeName = "user"
		o.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpportunityOwner) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "user":
		return json.Marshal(o.User)
	}
}

type OpportunityOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (o *OpportunityOwner) Accept(visitor OpportunityOwnerVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "user":
		return visitor.VisitUser(o.User)
	}
}

// # The Opportunity Object
// ### Description
// The `Opportunity` object is used to represent a deal opportunity in a CRM system.
// ### Usage Example
// TODO
type OpportunityRequest struct {
	// The opportunity's name.
	Name *string `json:"name,omitempty"`
	// The opportunity's description.
	Description *string `json:"description,omitempty"`
	// The opportunity's amount.
	Amount *int `json:"amount,omitempty"`
	// The opportunity's owner.
	Owner *OpportunityRequestOwner `json:"owner,omitempty"`
	// The account of the opportunity.
	Account *OpportunityRequestAccount `json:"account,omitempty"`
	// The stage of the opportunity.
	Stage *OpportunityRequestStage `json:"stage,omitempty"`
	// The opportunity's status.
	//
	// * `OPEN` - OPEN
	// * `WON` - WON
	// * `LOST` - LOST
	Status *OpportunityRequestStatus `json:"status,omitempty"`
	// When the opportunity's last activity occurred.
	LastActivityAt *time.Time `json:"last_activity_at,omitempty"`
	// When the opportunity was closed.
	CloseDate           *time.Time            `json:"close_date,omitempty"`
	IntegrationParams   map[string]any        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest `json:"remote_fields,omitempty"`
}

// The account of the opportunity.
type OpportunityRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewOpportunityRequestAccountFromString(value string) *OpportunityRequestAccount {
	return &OpportunityRequestAccount{typeName: "string", String: value}
}

func NewOpportunityRequestAccountFromAccount(value *Account) *OpportunityRequestAccount {
	return &OpportunityRequestAccount{typeName: "account", Account: value}
}

func (o *OpportunityRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		o.typeName = "account"
		o.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpportunityRequestAccount) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "account":
		return json.Marshal(o.Account)
	}
}

type OpportunityRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (o *OpportunityRequestAccount) Accept(visitor OpportunityRequestAccountVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "account":
		return visitor.VisitAccount(o.Account)
	}
}

// The opportunity's owner.
type OpportunityRequestOwner struct {
	typeName string
	String   string
	User     *User
}

func NewOpportunityRequestOwnerFromString(value string) *OpportunityRequestOwner {
	return &OpportunityRequestOwner{typeName: "string", String: value}
}

func NewOpportunityRequestOwnerFromUser(value *User) *OpportunityRequestOwner {
	return &OpportunityRequestOwner{typeName: "user", User: value}
}

func (o *OpportunityRequestOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		o.typeName = "user"
		o.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpportunityRequestOwner) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "user":
		return json.Marshal(o.User)
	}
}

type OpportunityRequestOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (o *OpportunityRequestOwner) Accept(visitor OpportunityRequestOwnerVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "user":
		return visitor.VisitUser(o.User)
	}
}

// The stage of the opportunity.
type OpportunityRequestStage struct {
	typeName string
	String   string
	Stage    *Stage
}

func NewOpportunityRequestStageFromString(value string) *OpportunityRequestStage {
	return &OpportunityRequestStage{typeName: "string", String: value}
}

func NewOpportunityRequestStageFromStage(value *Stage) *OpportunityRequestStage {
	return &OpportunityRequestStage{typeName: "stage", Stage: value}
}

func (o *OpportunityRequestStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	valueStage := new(Stage)
	if err := json.Unmarshal(data, &valueStage); err == nil {
		o.typeName = "stage"
		o.Stage = valueStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpportunityRequestStage) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "stage":
		return json.Marshal(o.Stage)
	}
}

type OpportunityRequestStageVisitor interface {
	VisitString(string) error
	VisitStage(*Stage) error
}

func (o *OpportunityRequestStage) Accept(visitor OpportunityRequestStageVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "stage":
		return visitor.VisitStage(o.Stage)
	}
}

// The opportunity's status.
//
// * `OPEN` - OPEN
// * `WON` - WON
// * `LOST` - LOST
type OpportunityRequestStatus struct {
	typeName              string
	OpportunityStatusEnum OpportunityStatusEnum
	String                string
}

func NewOpportunityRequestStatusFromOpportunityStatusEnum(value OpportunityStatusEnum) *OpportunityRequestStatus {
	return &OpportunityRequestStatus{typeName: "opportunityStatusEnum", OpportunityStatusEnum: value}
}

func NewOpportunityRequestStatusFromString(value string) *OpportunityRequestStatus {
	return &OpportunityRequestStatus{typeName: "string", String: value}
}

func (o *OpportunityRequestStatus) UnmarshalJSON(data []byte) error {
	var valueOpportunityStatusEnum OpportunityStatusEnum
	if err := json.Unmarshal(data, &valueOpportunityStatusEnum); err == nil {
		o.typeName = "opportunityStatusEnum"
		o.OpportunityStatusEnum = valueOpportunityStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpportunityRequestStatus) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "opportunityStatusEnum":
		return json.Marshal(o.OpportunityStatusEnum)
	case "string":
		return json.Marshal(o.String)
	}
}

type OpportunityRequestStatusVisitor interface {
	VisitOpportunityStatusEnum(OpportunityStatusEnum) error
	VisitString(string) error
}

func (o *OpportunityRequestStatus) Accept(visitor OpportunityRequestStatusVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "opportunityStatusEnum":
		return visitor.VisitOpportunityStatusEnum(o.OpportunityStatusEnum)
	case "string":
		return visitor.VisitString(o.String)
	}
}

type OpportunityResponse struct {
	Model    *Opportunity                `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// The stage of the opportunity.
type OpportunityStage struct {
	typeName string
	String   string
	Stage    *Stage
}

func NewOpportunityStageFromString(value string) *OpportunityStage {
	return &OpportunityStage{typeName: "string", String: value}
}

func NewOpportunityStageFromStage(value *Stage) *OpportunityStage {
	return &OpportunityStage{typeName: "stage", Stage: value}
}

func (o *OpportunityStage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	valueStage := new(Stage)
	if err := json.Unmarshal(data, &valueStage); err == nil {
		o.typeName = "stage"
		o.Stage = valueStage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpportunityStage) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return json.Marshal(o.String)
	case "stage":
		return json.Marshal(o.Stage)
	}
}

type OpportunityStageVisitor interface {
	VisitString(string) error
	VisitStage(*Stage) error
}

func (o *OpportunityStage) Accept(visitor OpportunityStageVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "string":
		return visitor.VisitString(o.String)
	case "stage":
		return visitor.VisitStage(o.Stage)
	}
}

// The opportunity's status.
//
// * `OPEN` - OPEN
// * `WON` - WON
// * `LOST` - LOST
type OpportunityStatus struct {
	typeName              string
	OpportunityStatusEnum OpportunityStatusEnum
	String                string
}

func NewOpportunityStatusFromOpportunityStatusEnum(value OpportunityStatusEnum) *OpportunityStatus {
	return &OpportunityStatus{typeName: "opportunityStatusEnum", OpportunityStatusEnum: value}
}

func NewOpportunityStatusFromString(value string) *OpportunityStatus {
	return &OpportunityStatus{typeName: "string", String: value}
}

func (o *OpportunityStatus) UnmarshalJSON(data []byte) error {
	var valueOpportunityStatusEnum OpportunityStatusEnum
	if err := json.Unmarshal(data, &valueOpportunityStatusEnum); err == nil {
		o.typeName = "opportunityStatusEnum"
		o.OpportunityStatusEnum = valueOpportunityStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typeName = "string"
		o.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpportunityStatus) MarshalJSON() ([]byte, error) {
	switch o.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "opportunityStatusEnum":
		return json.Marshal(o.OpportunityStatusEnum)
	case "string":
		return json.Marshal(o.String)
	}
}

type OpportunityStatusVisitor interface {
	VisitOpportunityStatusEnum(OpportunityStatusEnum) error
	VisitString(string) error
}

func (o *OpportunityStatus) Accept(visitor OpportunityStatusVisitor) error {
	switch o.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", o.typeName, o)
	case "opportunityStatusEnum":
		return visitor.VisitOpportunityStatusEnum(o.OpportunityStatusEnum)
	case "string":
		return visitor.VisitString(o.String)
	}
}

// * `OPEN` - OPEN
// * `WON` - WON
// * `LOST` - LOST
type OpportunityStatusEnum uint

const (
	OpportunityStatusEnumOpen OpportunityStatusEnum = iota + 1
	OpportunityStatusEnumWon
	OpportunityStatusEnumLost
)

func (o OpportunityStatusEnum) String() string {
	switch o {
	default:
		return strconv.Itoa(int(o))
	case OpportunityStatusEnumOpen:
		return "OPEN"
	case OpportunityStatusEnumWon:
		return "WON"
	case OpportunityStatusEnumLost:
		return "LOST"
	}
}

func (o OpportunityStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", o.String())), nil
}

func (o *OpportunityStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "OPEN":
		value := OpportunityStatusEnumOpen
		*o = value
	case "WON":
		value := OpportunityStatusEnumWon
		*o = value
	case "LOST":
		value := OpportunityStatusEnumLost
		*o = value
	}
	return nil
}

// * `CUSTOM_OBJECT` - CUSTOM_OBJECT
// * `COMMON_MODEL` - COMMON_MODEL
// * `REMOTE_ONLY_MODEL` - REMOTE_ONLY_MODEL
type OriginTypeEnum uint

const (
	OriginTypeEnumCustomObject OriginTypeEnum = iota + 1
	OriginTypeEnumCommonModel
	OriginTypeEnumRemoteOnlyModel
)

func (o OriginTypeEnum) String() string {
	switch o {
	default:
		return strconv.Itoa(int(o))
	case OriginTypeEnumCustomObject:
		return "CUSTOM_OBJECT"
	case OriginTypeEnumCommonModel:
		return "COMMON_MODEL"
	case OriginTypeEnumRemoteOnlyModel:
		return "REMOTE_ONLY_MODEL"
	}
}

func (o OriginTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", o.String())), nil
}

func (o *OriginTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "CUSTOM_OBJECT":
		value := OriginTypeEnumCustomObject
		*o = value
	case "COMMON_MODEL":
		value := OriginTypeEnumCommonModel
		*o = value
	case "REMOTE_ONLY_MODEL":
		value := OriginTypeEnumRemoteOnlyModel
		*o = value
	}
	return nil
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty"`
}

type PaginatedAccountList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Account `json:"results,omitempty"`
}

type PaginatedAssociationList struct {
	Next     *string        `json:"next,omitempty"`
	Previous *string        `json:"previous,omitempty"`
	Results  []*Association `json:"results,omitempty"`
}

type PaginatedAssociationTypeList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*AssociationType `json:"results,omitempty"`
}

type PaginatedConditionSchemaList struct {
	Next     *string            `json:"next,omitempty"`
	Previous *string            `json:"previous,omitempty"`
	Results  []*ConditionSchema `json:"results,omitempty"`
}

type PaginatedContactList struct {
	Next     *string    `json:"next,omitempty"`
	Previous *string    `json:"previous,omitempty"`
	Results  []*Contact `json:"results,omitempty"`
}

type PaginatedCustomObjectClassList struct {
	Next     *string              `json:"next,omitempty"`
	Previous *string              `json:"previous,omitempty"`
	Results  []*CustomObjectClass `json:"results,omitempty"`
}

type PaginatedCustomObjectList struct {
	Next     *string         `json:"next,omitempty"`
	Previous *string         `json:"previous,omitempty"`
	Results  []*CustomObject `json:"results,omitempty"`
}

type PaginatedEngagementList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*Engagement `json:"results,omitempty"`
}

type PaginatedEngagementTypeList struct {
	Next     *string           `json:"next,omitempty"`
	Previous *string           `json:"previous,omitempty"`
	Results  []*EngagementType `json:"results,omitempty"`
}

type PaginatedIssueList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Issue `json:"results,omitempty"`
}

type PaginatedLeadList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Lead `json:"results,omitempty"`
}

type PaginatedNoteList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Note `json:"results,omitempty"`
}

type PaginatedOpportunityList struct {
	Next     *string        `json:"next,omitempty"`
	Previous *string        `json:"previous,omitempty"`
	Results  []*Opportunity `json:"results,omitempty"`
}

type PaginatedRemoteFieldClassList struct {
	Next     *string             `json:"next,omitempty"`
	Previous *string             `json:"previous,omitempty"`
	Results  []*RemoteFieldClass `json:"results,omitempty"`
}

type PaginatedStageList struct {
	Next     *string  `json:"next,omitempty"`
	Previous *string  `json:"previous,omitempty"`
	Results  []*Stage `json:"results,omitempty"`
}

type PaginatedSyncStatusList struct {
	Next     *string       `json:"next,omitempty"`
	Previous *string       `json:"previous,omitempty"`
	Results  []*SyncStatus `json:"results,omitempty"`
}

type PaginatedTaskList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*Task `json:"results,omitempty"`
}

type PaginatedUserList struct {
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
	Results  []*User `json:"results,omitempty"`
}

// # The Account Object
// ### Description
// The `Account` object is used to represent a company in a CRM system.
// ### Usage Example
// TODO
type PatchedAccountRequest struct {
	// The account's owner.
	Owner *string `json:"owner,omitempty"`
	// The account's name.
	Name *string `json:"name,omitempty"`
	// The account's description.
	Description *string `json:"description,omitempty"`
	// The account's industry.
	Industry *string `json:"industry,omitempty"`
	// The account's website.
	Website *string `json:"website,omitempty"`
	// The account's number of employees.
	NumberOfEmployees *int `json:"number_of_employees,omitempty"`
	// The last date (either most recent or furthest in the future) of when an activity occurs in an account.
	LastActivityAt      *time.Time            `json:"last_activity_at,omitempty"`
	IntegrationParams   map[string]any        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest `json:"remote_fields,omitempty"`
}

// # The Contact Object
// ### Description
// The `Contact` object is used to represent an existing point of contact at a company in a CRM system.
// ### Usage Example
// TODO
type PatchedContactRequest struct {
	// The contact's first name.
	FirstName *string `json:"first_name,omitempty"`
	// The contact's last name.
	LastName *string `json:"last_name,omitempty"`
	// The contact's account.
	Account        *string                `json:"account,omitempty"`
	Addresses      []*AddressRequest      `json:"addresses,omitempty"`
	EmailAddresses []*EmailAddressRequest `json:"email_addresses,omitempty"`
	PhoneNumbers   []*PhoneNumberRequest  `json:"phone_numbers,omitempty"`
	// When the contact's last activity occurred.
	LastActivityAt      *time.Time            `json:"last_activity_at,omitempty"`
	IntegrationParams   map[string]any        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest `json:"remote_fields,omitempty"`
}

// # The Engagement Object
// ### Description
// The `Engagement` object is used to represent an interaction noted in a CRM system.
// ### Usage Example
// TODO
type PatchedEngagementRequest struct {
	// The engagement's owner.
	Owner *string `json:"owner,omitempty"`
	// The engagement's content.
	Content *string `json:"content,omitempty"`
	// The engagement's subject.
	Subject *string `json:"subject,omitempty"`
	// The engagement's direction.
	//
	// * `INBOUND` - INBOUND
	// * `OUTBOUND` - OUTBOUND
	Direction *PatchedEngagementRequestDirection `json:"direction,omitempty"`
	// The engagement type of the engagement.
	EngagementType *string `json:"engagement_type,omitempty"`
	// The time at which the engagement started.
	StartTime *time.Time `json:"start_time,omitempty"`
	// The time at which the engagement ended.
	EndTime *time.Time `json:"end_time,omitempty"`
	// The account of the engagement.
	Account             *string               `json:"account,omitempty"`
	Contacts            []*string             `json:"contacts,omitempty"`
	IntegrationParams   map[string]any        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest `json:"remote_fields,omitempty"`
}

// The engagement's direction.
//
// * `INBOUND` - INBOUND
// * `OUTBOUND` - OUTBOUND
type PatchedEngagementRequestDirection struct {
	typeName      string
	DirectionEnum DirectionEnum
	String        string
}

func NewPatchedEngagementRequestDirectionFromDirectionEnum(value DirectionEnum) *PatchedEngagementRequestDirection {
	return &PatchedEngagementRequestDirection{typeName: "directionEnum", DirectionEnum: value}
}

func NewPatchedEngagementRequestDirectionFromString(value string) *PatchedEngagementRequestDirection {
	return &PatchedEngagementRequestDirection{typeName: "string", String: value}
}

func (p *PatchedEngagementRequestDirection) UnmarshalJSON(data []byte) error {
	var valueDirectionEnum DirectionEnum
	if err := json.Unmarshal(data, &valueDirectionEnum); err == nil {
		p.typeName = "directionEnum"
		p.DirectionEnum = valueDirectionEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedEngagementRequestDirection) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "directionEnum":
		return json.Marshal(p.DirectionEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PatchedEngagementRequestDirectionVisitor interface {
	VisitDirectionEnum(DirectionEnum) error
	VisitString(string) error
}

func (p *PatchedEngagementRequestDirection) Accept(visitor PatchedEngagementRequestDirectionVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "directionEnum":
		return visitor.VisitDirectionEnum(p.DirectionEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// # The Opportunity Object
// ### Description
// The `Opportunity` object is used to represent a deal opportunity in a CRM system.
// ### Usage Example
// TODO
type PatchedOpportunityRequest struct {
	// The opportunity's name.
	Name *string `json:"name,omitempty"`
	// The opportunity's description.
	Description *string `json:"description,omitempty"`
	// The opportunity's amount.
	Amount *int `json:"amount,omitempty"`
	// The opportunity's owner.
	Owner *string `json:"owner,omitempty"`
	// The account of the opportunity.
	Account *string `json:"account,omitempty"`
	// The stage of the opportunity.
	Stage *string `json:"stage,omitempty"`
	// The opportunity's status.
	//
	// * `OPEN` - OPEN
	// * `WON` - WON
	// * `LOST` - LOST
	Status *PatchedOpportunityRequestStatus `json:"status,omitempty"`
	// When the opportunity's last activity occurred.
	LastActivityAt *time.Time `json:"last_activity_at,omitempty"`
	// When the opportunity was closed.
	CloseDate           *time.Time            `json:"close_date,omitempty"`
	IntegrationParams   map[string]any        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest `json:"remote_fields,omitempty"`
}

// The opportunity's status.
//
// * `OPEN` - OPEN
// * `WON` - WON
// * `LOST` - LOST
type PatchedOpportunityRequestStatus struct {
	typeName              string
	OpportunityStatusEnum OpportunityStatusEnum
	String                string
}

func NewPatchedOpportunityRequestStatusFromOpportunityStatusEnum(value OpportunityStatusEnum) *PatchedOpportunityRequestStatus {
	return &PatchedOpportunityRequestStatus{typeName: "opportunityStatusEnum", OpportunityStatusEnum: value}
}

func NewPatchedOpportunityRequestStatusFromString(value string) *PatchedOpportunityRequestStatus {
	return &PatchedOpportunityRequestStatus{typeName: "string", String: value}
}

func (p *PatchedOpportunityRequestStatus) UnmarshalJSON(data []byte) error {
	var valueOpportunityStatusEnum OpportunityStatusEnum
	if err := json.Unmarshal(data, &valueOpportunityStatusEnum); err == nil {
		p.typeName = "opportunityStatusEnum"
		p.OpportunityStatusEnum = valueOpportunityStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedOpportunityRequestStatus) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "opportunityStatusEnum":
		return json.Marshal(p.OpportunityStatusEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PatchedOpportunityRequestStatusVisitor interface {
	VisitOpportunityStatusEnum(OpportunityStatusEnum) error
	VisitString(string) error
}

func (p *PatchedOpportunityRequestStatus) Accept(visitor PatchedOpportunityRequestStatusVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "opportunityStatusEnum":
		return visitor.VisitOpportunityStatusEnum(p.OpportunityStatusEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// # The Task Object
// ### Description
// The `Task` object is used to represent a task, such as a to-do item.
// ### Usage Example
// TODO
type PatchedTaskRequest struct {
	// The task's subject.
	Subject *string `json:"subject,omitempty"`
	// The task's content.
	Content *string `json:"content,omitempty"`
	// The task's owner.
	Owner *string `json:"owner,omitempty"`
	// The task's account.
	Account *string `json:"account,omitempty"`
	// The task's opportunity.
	Opportunity *string `json:"opportunity,omitempty"`
	// When the task is completed.
	CompletedDate *time.Time `json:"completed_date,omitempty"`
	// When the task is due.
	DueDate *time.Time `json:"due_date,omitempty"`
	// The task's status.
	//
	// * `OPEN` - OPEN
	// * `CLOSED` - CLOSED
	Status              *PatchedTaskRequestStatus `json:"status,omitempty"`
	IntegrationParams   map[string]any            `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any            `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest     `json:"remote_fields,omitempty"`
}

// The task's status.
//
// * `OPEN` - OPEN
// * `CLOSED` - CLOSED
type PatchedTaskRequestStatus struct {
	typeName       string
	TaskStatusEnum TaskStatusEnum
	String         string
}

func NewPatchedTaskRequestStatusFromTaskStatusEnum(value TaskStatusEnum) *PatchedTaskRequestStatus {
	return &PatchedTaskRequestStatus{typeName: "taskStatusEnum", TaskStatusEnum: value}
}

func NewPatchedTaskRequestStatusFromString(value string) *PatchedTaskRequestStatus {
	return &PatchedTaskRequestStatus{typeName: "string", String: value}
}

func (p *PatchedTaskRequestStatus) UnmarshalJSON(data []byte) error {
	var valueTaskStatusEnum TaskStatusEnum
	if err := json.Unmarshal(data, &valueTaskStatusEnum); err == nil {
		p.typeName = "taskStatusEnum"
		p.TaskStatusEnum = valueTaskStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typeName = "string"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PatchedTaskRequestStatus) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "taskStatusEnum":
		return json.Marshal(p.TaskStatusEnum)
	case "string":
		return json.Marshal(p.String)
	}
}

type PatchedTaskRequestStatusVisitor interface {
	VisitTaskStatusEnum(TaskStatusEnum) error
	VisitString(string) error
}

func (p *PatchedTaskRequestStatus) Accept(visitor PatchedTaskRequestStatusVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "taskStatusEnum":
		return visitor.VisitTaskStatusEnum(p.TaskStatusEnum)
	case "string":
		return visitor.VisitString(p.String)
	}
}

// # The PhoneNumber Object
// ### Description
// The `PhoneNumber` object is used to represent an entity's phone number.
// ### Usage Example
// Fetch from the `GET Contact` endpoint and view their phone numbers.
type PhoneNumber struct {
	// The phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`
	// The phone number's type.
	PhoneNumberType *string `json:"phone_number_type,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

// # The PhoneNumber Object
// ### Description
// The `PhoneNumber` object is used to represent an entity's phone number.
// ### Usage Example
// Fetch from the `GET Contact` endpoint and view their phone numbers.
type PhoneNumberRequest struct {
	// The phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`
	// The phone number's type.
	PhoneNumberType     *string        `json:"phone_number_type,omitempty"`
	IntegrationParams   map[string]any `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any `json:"linked_account_params,omitempty"`
}

// * `GENERAL_CUSTOMER_REQUEST` - GENERAL_CUSTOMER_REQUEST
// * `GDPR` - GDPR
// * `OTHER` - OTHER
type ReasonEnum uint

const (
	ReasonEnumGeneralCustomerRequest ReasonEnum = iota + 1
	ReasonEnumGdpr
	ReasonEnumOther
)

func (r ReasonEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case ReasonEnumGeneralCustomerRequest:
		return "GENERAL_CUSTOMER_REQUEST"
	case ReasonEnumGdpr:
		return "GDPR"
	case ReasonEnumOther:
		return "OTHER"
	}
}

func (r ReasonEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *ReasonEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GENERAL_CUSTOMER_REQUEST":
		value := ReasonEnumGeneralCustomerRequest
		*r = value
	case "GDPR":
		value := ReasonEnumGdpr
		*r = value
	case "OTHER":
		value := ReasonEnumOther
		*r = value
	}
	return nil
}

type RemoteData struct {
	Path string         `json:"path"`
	Data map[string]any `json:"data,omitempty"`
}

type RemoteField struct {
	RemoteFieldClass *RemoteFieldClass `json:"remote_field_class,omitempty"`
	Value            map[string]any    `json:"value,omitempty"`
}

type RemoteFieldClass struct {
	Id            *string          `json:"id,omitempty"`
	DisplayName   *string          `json:"display_name,omitempty"`
	RemoteKeyName *string          `json:"remote_key_name,omitempty"`
	Description   *string          `json:"description,omitempty"`
	IsCustom      *bool            `json:"is_custom,omitempty"`
	IsRequired    *bool            `json:"is_required,omitempty"`
	FieldType     *FieldTypeEnum   `json:"field_type,omitempty"`
	FieldFormat   *FieldFormatEnum `json:"field_format,omitempty"`
	FieldChoices  []string         `json:"field_choices,omitempty"`
	ItemSchema    *ItemSchema      `json:"item_schema,omitempty"`
}

type RemoteFieldClassForCustomObjectClass struct {
	DisplayName   *string                                          `json:"display_name,omitempty"`
	RemoteKeyName *string                                          `json:"remote_key_name,omitempty"`
	Description   *string                                          `json:"description,omitempty"`
	IsRequired    *bool                                            `json:"is_required,omitempty"`
	FieldType     *RemoteFieldClassForCustomObjectClassFieldType   `json:"field_type,omitempty"`
	FieldFormat   *RemoteFieldClassForCustomObjectClassFieldFormat `json:"field_format,omitempty"`
	FieldChoices  []*string                                        `json:"field_choices,omitempty"`
	ItemSchema    *RemoteFieldClassForCustomObjectClassItemSchema  `json:"item_schema,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt *time.Time `json:"modified_at,omitempty"`
}

type RemoteFieldClassForCustomObjectClassFieldFormat struct {
	typeName        string
	FieldFormatEnum FieldFormatEnum
	String          string
}

func NewRemoteFieldClassForCustomObjectClassFieldFormatFromFieldFormatEnum(value FieldFormatEnum) *RemoteFieldClassForCustomObjectClassFieldFormat {
	return &RemoteFieldClassForCustomObjectClassFieldFormat{typeName: "fieldFormatEnum", FieldFormatEnum: value}
}

func NewRemoteFieldClassForCustomObjectClassFieldFormatFromString(value string) *RemoteFieldClassForCustomObjectClassFieldFormat {
	return &RemoteFieldClassForCustomObjectClassFieldFormat{typeName: "string", String: value}
}

func (r *RemoteFieldClassForCustomObjectClassFieldFormat) UnmarshalJSON(data []byte) error {
	var valueFieldFormatEnum FieldFormatEnum
	if err := json.Unmarshal(data, &valueFieldFormatEnum); err == nil {
		r.typeName = "fieldFormatEnum"
		r.FieldFormatEnum = valueFieldFormatEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldClassForCustomObjectClassFieldFormat) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "fieldFormatEnum":
		return json.Marshal(r.FieldFormatEnum)
	case "string":
		return json.Marshal(r.String)
	}
}

type RemoteFieldClassForCustomObjectClassFieldFormatVisitor interface {
	VisitFieldFormatEnum(FieldFormatEnum) error
	VisitString(string) error
}

func (r *RemoteFieldClassForCustomObjectClassFieldFormat) Accept(visitor RemoteFieldClassForCustomObjectClassFieldFormatVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "fieldFormatEnum":
		return visitor.VisitFieldFormatEnum(r.FieldFormatEnum)
	case "string":
		return visitor.VisitString(r.String)
	}
}

type RemoteFieldClassForCustomObjectClassFieldType struct {
	typeName      string
	FieldTypeEnum FieldTypeEnum
	String        string
}

func NewRemoteFieldClassForCustomObjectClassFieldTypeFromFieldTypeEnum(value FieldTypeEnum) *RemoteFieldClassForCustomObjectClassFieldType {
	return &RemoteFieldClassForCustomObjectClassFieldType{typeName: "fieldTypeEnum", FieldTypeEnum: value}
}

func NewRemoteFieldClassForCustomObjectClassFieldTypeFromString(value string) *RemoteFieldClassForCustomObjectClassFieldType {
	return &RemoteFieldClassForCustomObjectClassFieldType{typeName: "string", String: value}
}

func (r *RemoteFieldClassForCustomObjectClassFieldType) UnmarshalJSON(data []byte) error {
	var valueFieldTypeEnum FieldTypeEnum
	if err := json.Unmarshal(data, &valueFieldTypeEnum); err == nil {
		r.typeName = "fieldTypeEnum"
		r.FieldTypeEnum = valueFieldTypeEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldClassForCustomObjectClassFieldType) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "fieldTypeEnum":
		return json.Marshal(r.FieldTypeEnum)
	case "string":
		return json.Marshal(r.String)
	}
}

type RemoteFieldClassForCustomObjectClassFieldTypeVisitor interface {
	VisitFieldTypeEnum(FieldTypeEnum) error
	VisitString(string) error
}

func (r *RemoteFieldClassForCustomObjectClassFieldType) Accept(visitor RemoteFieldClassForCustomObjectClassFieldTypeVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "fieldTypeEnum":
		return visitor.VisitFieldTypeEnum(r.FieldTypeEnum)
	case "string":
		return visitor.VisitString(r.String)
	}
}

type RemoteFieldClassForCustomObjectClassItemSchema struct {
	ItemType    *string   `json:"item_type,omitempty"`
	ItemFormat  *string   `json:"item_format,omitempty"`
	ItemChoices []*string `json:"item_choices,omitempty"`
}

type RemoteFieldRequest struct {
	RemoteFieldClass *RemoteFieldRequestRemoteFieldClass `json:"remote_field_class,omitempty"`
	Value            map[string]any                      `json:"value,omitempty"`
}

type RemoteFieldRequestRemoteFieldClass struct {
	typeName         string
	String           string
	RemoteFieldClass *RemoteFieldClass
}

func NewRemoteFieldRequestRemoteFieldClassFromString(value string) *RemoteFieldRequestRemoteFieldClass {
	return &RemoteFieldRequestRemoteFieldClass{typeName: "string", String: value}
}

func NewRemoteFieldRequestRemoteFieldClassFromRemoteFieldClass(value *RemoteFieldClass) *RemoteFieldRequestRemoteFieldClass {
	return &RemoteFieldRequestRemoteFieldClass{typeName: "remoteFieldClass", RemoteFieldClass: value}
}

func (r *RemoteFieldRequestRemoteFieldClass) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRemoteFieldClass := new(RemoteFieldClass)
	if err := json.Unmarshal(data, &valueRemoteFieldClass); err == nil {
		r.typeName = "remoteFieldClass"
		r.RemoteFieldClass = valueRemoteFieldClass
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RemoteFieldRequestRemoteFieldClass) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "remoteFieldClass":
		return json.Marshal(r.RemoteFieldClass)
	}
}

type RemoteFieldRequestRemoteFieldClassVisitor interface {
	VisitString(string) error
	VisitRemoteFieldClass(*RemoteFieldClass) error
}

func (r *RemoteFieldRequestRemoteFieldClass) Accept(visitor RemoteFieldRequestRemoteFieldClassVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "remoteFieldClass":
		return visitor.VisitRemoteFieldClass(r.RemoteFieldClass)
	}
}

// # The RemoteKey Object
// ### Description
// The `RemoteKey` object is used to represent a request for a new remote key.
//
// ### Usage Example
// Post a `GenerateRemoteKey` to receive a new `RemoteKey`.
type RemoteKey struct {
	Name string `json:"name"`
	Key  string `json:"key"`
}

// # The RemoteResponse Object
// ### Description
// The `RemoteResponse` object is used to represent information returned from a third-party endpoint.
//
// ### Usage Example
// View the `RemoteResponse` returned from your `DataPassthrough`.
type RemoteResponse struct {
	Method          string            `json:"method"`
	Path            string            `json:"path"`
	Status          int               `json:"status"`
	Response        any               `json:"response,omitempty"`
	ResponseHeaders map[string]any    `json:"response_headers,omitempty"`
	ResponseType    *ResponseTypeEnum `json:"response_type,omitempty"`
	Headers         map[string]any    `json:"headers,omitempty"`
}

// * `JSON` - JSON
// * `XML` - XML
// * `MULTIPART` - MULTIPART
type RequestFormatEnum uint

const (
	RequestFormatEnumJson RequestFormatEnum = iota + 1
	RequestFormatEnumXml
	RequestFormatEnumMultipart
)

func (r RequestFormatEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RequestFormatEnumJson:
		return "JSON"
	case RequestFormatEnumXml:
		return "XML"
	case RequestFormatEnumMultipart:
		return "MULTIPART"
	}
}

func (r RequestFormatEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RequestFormatEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := RequestFormatEnumJson
		*r = value
	case "XML":
		value := RequestFormatEnumXml
		*r = value
	case "MULTIPART":
		value := RequestFormatEnumMultipart
		*r = value
	}
	return nil
}

// * `JSON` - JSON
// * `BASE64_GZIP` - BASE64_GZIP
type ResponseTypeEnum uint

const (
	ResponseTypeEnumJson ResponseTypeEnum = iota + 1
	ResponseTypeEnumBase64Gzip
)

func (r ResponseTypeEnum) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case ResponseTypeEnumJson:
		return "JSON"
	case ResponseTypeEnumBase64Gzip:
		return "BASE64_GZIP"
	}
}

func (r ResponseTypeEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *ResponseTypeEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "JSON":
		value := ResponseTypeEnumJson
		*r = value
	case "BASE64_GZIP":
		value := ResponseTypeEnumBase64Gzip
		*r = value
	}
	return nil
}

// * `IN_NEXT_SYNC` - IN_NEXT_SYNC
// * `IN_LAST_SYNC` - IN_LAST_SYNC
type SelectiveSyncConfigurationsUsageEnum uint

const (
	SelectiveSyncConfigurationsUsageEnumInNextSync SelectiveSyncConfigurationsUsageEnum = iota + 1
	SelectiveSyncConfigurationsUsageEnumInLastSync
)

func (s SelectiveSyncConfigurationsUsageEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SelectiveSyncConfigurationsUsageEnumInNextSync:
		return "IN_NEXT_SYNC"
	case SelectiveSyncConfigurationsUsageEnumInLastSync:
		return "IN_LAST_SYNC"
	}
}

func (s SelectiveSyncConfigurationsUsageEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SelectiveSyncConfigurationsUsageEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "IN_NEXT_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInNextSync
		*s = value
	case "IN_LAST_SYNC":
		value := SelectiveSyncConfigurationsUsageEnumInLastSync
		*s = value
	}
	return nil
}

// # The Stage Object
// ### Description
// The `Stage` object is used to represent the stage of an opportunity.
// ### Usage Example
// TODO
type Stage struct {
	// The stage's name.
	Name *string `json:"name,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool   `json:"remote_was_deleted,omitempty"`
	Id               *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

// # The SyncStatus Object
// ### Description
// The `SyncStatus` object is used to represent the syncing state of an account
//
// ### Usage Example
// View the `SyncStatus` for an account to see how recently its models were synced.
type SyncStatus struct {
	ModelName                        string                                `json:"model_name"`
	ModelId                          string                                `json:"model_id"`
	LastSyncStart                    *time.Time                            `json:"last_sync_start,omitempty"`
	NextSyncStart                    *time.Time                            `json:"next_sync_start,omitempty"`
	Status                           SyncStatusStatusEnum                  `json:"status,omitempty"`
	IsInitialSync                    bool                                  `json:"is_initial_sync"`
	SelectiveSyncConfigurationsUsage *SelectiveSyncConfigurationsUsageEnum `json:"selective_sync_configurations_usage,omitempty"`
}

// * `SYNCING` - SYNCING
// * `DONE` - DONE
// * `FAILED` - FAILED
// * `DISABLED` - DISABLED
// * `PAUSED` - PAUSED
// * `PARTIALLY_SYNCED` - PARTIALLY_SYNCED
type SyncStatusStatusEnum uint

const (
	SyncStatusStatusEnumSyncing SyncStatusStatusEnum = iota + 1
	SyncStatusStatusEnumDone
	SyncStatusStatusEnumFailed
	SyncStatusStatusEnumDisabled
	SyncStatusStatusEnumPaused
	SyncStatusStatusEnumPartiallySynced
)

func (s SyncStatusStatusEnum) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SyncStatusStatusEnumSyncing:
		return "SYNCING"
	case SyncStatusStatusEnumDone:
		return "DONE"
	case SyncStatusStatusEnumFailed:
		return "FAILED"
	case SyncStatusStatusEnumDisabled:
		return "DISABLED"
	case SyncStatusStatusEnumPaused:
		return "PAUSED"
	case SyncStatusStatusEnumPartiallySynced:
		return "PARTIALLY_SYNCED"
	}
}

func (s SyncStatusStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SyncStatusStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SYNCING":
		value := SyncStatusStatusEnumSyncing
		*s = value
	case "DONE":
		value := SyncStatusStatusEnumDone
		*s = value
	case "FAILED":
		value := SyncStatusStatusEnumFailed
		*s = value
	case "DISABLED":
		value := SyncStatusStatusEnumDisabled
		*s = value
	case "PAUSED":
		value := SyncStatusStatusEnumPaused
		*s = value
	case "PARTIALLY_SYNCED":
		value := SyncStatusStatusEnumPartiallySynced
		*s = value
	}
	return nil
}

// # The Task Object
// ### Description
// The `Task` object is used to represent a task, such as a to-do item.
// ### Usage Example
// TODO
type Task struct {
	// The task's subject.
	Subject *string `json:"subject,omitempty"`
	// The task's content.
	Content *string `json:"content,omitempty"`
	// The task's owner.
	Owner *TaskOwner `json:"owner,omitempty"`
	// The task's account.
	Account *TaskAccount `json:"account,omitempty"`
	// The task's opportunity.
	Opportunity *TaskOpportunity `json:"opportunity,omitempty"`
	// When the task is completed.
	CompletedDate *time.Time `json:"completed_date,omitempty"`
	// When the task is due.
	DueDate *time.Time `json:"due_date,omitempty"`
	// The task's status.
	//
	// * `OPEN` - OPEN
	// * `CLOSED` - CLOSED
	Status *TaskStatus `json:"status,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool   `json:"remote_was_deleted,omitempty"`
	Id               *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

// The task's account.
type TaskAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewTaskAccountFromString(value string) *TaskAccount {
	return &TaskAccount{typeName: "string", String: value}
}

func NewTaskAccountFromAccount(value *Account) *TaskAccount {
	return &TaskAccount{typeName: "account", Account: value}
}

func (t *TaskAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		t.typeName = "account"
		t.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaskAccount) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "account":
		return json.Marshal(t.Account)
	}
}

type TaskAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (t *TaskAccount) Accept(visitor TaskAccountVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "account":
		return visitor.VisitAccount(t.Account)
	}
}

// The task's opportunity.
type TaskOpportunity struct {
	typeName    string
	String      string
	Opportunity *Opportunity
}

func NewTaskOpportunityFromString(value string) *TaskOpportunity {
	return &TaskOpportunity{typeName: "string", String: value}
}

func NewTaskOpportunityFromOpportunity(value *Opportunity) *TaskOpportunity {
	return &TaskOpportunity{typeName: "opportunity", Opportunity: value}
}

func (t *TaskOpportunity) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueOpportunity := new(Opportunity)
	if err := json.Unmarshal(data, &valueOpportunity); err == nil {
		t.typeName = "opportunity"
		t.Opportunity = valueOpportunity
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaskOpportunity) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "opportunity":
		return json.Marshal(t.Opportunity)
	}
}

type TaskOpportunityVisitor interface {
	VisitString(string) error
	VisitOpportunity(*Opportunity) error
}

func (t *TaskOpportunity) Accept(visitor TaskOpportunityVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "opportunity":
		return visitor.VisitOpportunity(t.Opportunity)
	}
}

// The task's owner.
type TaskOwner struct {
	typeName string
	String   string
	User     *User
}

func NewTaskOwnerFromString(value string) *TaskOwner {
	return &TaskOwner{typeName: "string", String: value}
}

func NewTaskOwnerFromUser(value *User) *TaskOwner {
	return &TaskOwner{typeName: "user", User: value}
}

func (t *TaskOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		t.typeName = "user"
		t.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaskOwner) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "user":
		return json.Marshal(t.User)
	}
}

type TaskOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (t *TaskOwner) Accept(visitor TaskOwnerVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "user":
		return visitor.VisitUser(t.User)
	}
}

// # The Task Object
// ### Description
// The `Task` object is used to represent a task, such as a to-do item.
// ### Usage Example
// TODO
type TaskRequest struct {
	// The task's subject.
	Subject *string `json:"subject,omitempty"`
	// The task's content.
	Content *string `json:"content,omitempty"`
	// The task's owner.
	Owner *TaskRequestOwner `json:"owner,omitempty"`
	// The task's account.
	Account *TaskRequestAccount `json:"account,omitempty"`
	// The task's opportunity.
	Opportunity *TaskRequestOpportunity `json:"opportunity,omitempty"`
	// When the task is completed.
	CompletedDate *time.Time `json:"completed_date,omitempty"`
	// When the task is due.
	DueDate *time.Time `json:"due_date,omitempty"`
	// The task's status.
	//
	// * `OPEN` - OPEN
	// * `CLOSED` - CLOSED
	Status              *TaskRequestStatus    `json:"status,omitempty"`
	IntegrationParams   map[string]any        `json:"integration_params,omitempty"`
	LinkedAccountParams map[string]any        `json:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest `json:"remote_fields,omitempty"`
}

// The task's account.
type TaskRequestAccount struct {
	typeName string
	String   string
	Account  *Account
}

func NewTaskRequestAccountFromString(value string) *TaskRequestAccount {
	return &TaskRequestAccount{typeName: "string", String: value}
}

func NewTaskRequestAccountFromAccount(value *Account) *TaskRequestAccount {
	return &TaskRequestAccount{typeName: "account", Account: value}
}

func (t *TaskRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		t.typeName = "account"
		t.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaskRequestAccount) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "account":
		return json.Marshal(t.Account)
	}
}

type TaskRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (t *TaskRequestAccount) Accept(visitor TaskRequestAccountVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "account":
		return visitor.VisitAccount(t.Account)
	}
}

// The task's opportunity.
type TaskRequestOpportunity struct {
	typeName    string
	String      string
	Opportunity *Opportunity
}

func NewTaskRequestOpportunityFromString(value string) *TaskRequestOpportunity {
	return &TaskRequestOpportunity{typeName: "string", String: value}
}

func NewTaskRequestOpportunityFromOpportunity(value *Opportunity) *TaskRequestOpportunity {
	return &TaskRequestOpportunity{typeName: "opportunity", Opportunity: value}
}

func (t *TaskRequestOpportunity) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueOpportunity := new(Opportunity)
	if err := json.Unmarshal(data, &valueOpportunity); err == nil {
		t.typeName = "opportunity"
		t.Opportunity = valueOpportunity
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaskRequestOpportunity) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "opportunity":
		return json.Marshal(t.Opportunity)
	}
}

type TaskRequestOpportunityVisitor interface {
	VisitString(string) error
	VisitOpportunity(*Opportunity) error
}

func (t *TaskRequestOpportunity) Accept(visitor TaskRequestOpportunityVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "opportunity":
		return visitor.VisitOpportunity(t.Opportunity)
	}
}

// The task's owner.
type TaskRequestOwner struct {
	typeName string
	String   string
	User     *User
}

func NewTaskRequestOwnerFromString(value string) *TaskRequestOwner {
	return &TaskRequestOwner{typeName: "string", String: value}
}

func NewTaskRequestOwnerFromUser(value *User) *TaskRequestOwner {
	return &TaskRequestOwner{typeName: "user", User: value}
}

func (t *TaskRequestOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		t.typeName = "user"
		t.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaskRequestOwner) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "user":
		return json.Marshal(t.User)
	}
}

type TaskRequestOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (t *TaskRequestOwner) Accept(visitor TaskRequestOwnerVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "user":
		return visitor.VisitUser(t.User)
	}
}

// The task's status.
//
// * `OPEN` - OPEN
// * `CLOSED` - CLOSED
type TaskRequestStatus struct {
	typeName       string
	TaskStatusEnum TaskStatusEnum
	String         string
}

func NewTaskRequestStatusFromTaskStatusEnum(value TaskStatusEnum) *TaskRequestStatus {
	return &TaskRequestStatus{typeName: "taskStatusEnum", TaskStatusEnum: value}
}

func NewTaskRequestStatusFromString(value string) *TaskRequestStatus {
	return &TaskRequestStatus{typeName: "string", String: value}
}

func (t *TaskRequestStatus) UnmarshalJSON(data []byte) error {
	var valueTaskStatusEnum TaskStatusEnum
	if err := json.Unmarshal(data, &valueTaskStatusEnum); err == nil {
		t.typeName = "taskStatusEnum"
		t.TaskStatusEnum = valueTaskStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaskRequestStatus) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "taskStatusEnum":
		return json.Marshal(t.TaskStatusEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TaskRequestStatusVisitor interface {
	VisitTaskStatusEnum(TaskStatusEnum) error
	VisitString(string) error
}

func (t *TaskRequestStatus) Accept(visitor TaskRequestStatusVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "taskStatusEnum":
		return visitor.VisitTaskStatusEnum(t.TaskStatusEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TaskResponse struct {
	Model    *Task                       `json:"model,omitempty"`
	Warnings []*WarningValidationProblem `json:"warnings,omitempty"`
	Errors   []*ErrorValidationProblem   `json:"errors,omitempty"`
	Logs     []*DebugModeLog             `json:"logs,omitempty"`
}

// The task's status.
//
// * `OPEN` - OPEN
// * `CLOSED` - CLOSED
type TaskStatus struct {
	typeName       string
	TaskStatusEnum TaskStatusEnum
	String         string
}

func NewTaskStatusFromTaskStatusEnum(value TaskStatusEnum) *TaskStatus {
	return &TaskStatus{typeName: "taskStatusEnum", TaskStatusEnum: value}
}

func NewTaskStatusFromString(value string) *TaskStatus {
	return &TaskStatus{typeName: "string", String: value}
}

func (t *TaskStatus) UnmarshalJSON(data []byte) error {
	var valueTaskStatusEnum TaskStatusEnum
	if err := json.Unmarshal(data, &valueTaskStatusEnum); err == nil {
		t.typeName = "taskStatusEnum"
		t.TaskStatusEnum = valueTaskStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TaskStatus) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "taskStatusEnum":
		return json.Marshal(t.TaskStatusEnum)
	case "string":
		return json.Marshal(t.String)
	}
}

type TaskStatusVisitor interface {
	VisitTaskStatusEnum(TaskStatusEnum) error
	VisitString(string) error
}

func (t *TaskStatus) Accept(visitor TaskStatusVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "taskStatusEnum":
		return visitor.VisitTaskStatusEnum(t.TaskStatusEnum)
	case "string":
		return visitor.VisitString(t.String)
	}
}

// * `OPEN` - OPEN
// * `CLOSED` - CLOSED
type TaskStatusEnum uint

const (
	TaskStatusEnumOpen TaskStatusEnum = iota + 1
	TaskStatusEnumClosed
)

func (t TaskStatusEnum) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TaskStatusEnumOpen:
		return "OPEN"
	case TaskStatusEnumClosed:
		return "CLOSED"
	}
}

func (t TaskStatusEnum) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TaskStatusEnum) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "OPEN":
		value := TaskStatusEnumOpen
		*t = value
	case "CLOSED":
		value := TaskStatusEnumClosed
		*t = value
	}
	return nil
}

type TasksListRequestExpand uint

const (
	TasksListRequestExpandAccount TasksListRequestExpand = iota + 1
	TasksListRequestExpandAccountOpportunity
	TasksListRequestExpandOpportunity
	TasksListRequestExpandOwner
	TasksListRequestExpandOwnerAccount
	TasksListRequestExpandOwnerAccountOpportunity
	TasksListRequestExpandOwnerOpportunity
)

func (t TasksListRequestExpand) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TasksListRequestExpandAccount:
		return "account"
	case TasksListRequestExpandAccountOpportunity:
		return "account,opportunity"
	case TasksListRequestExpandOpportunity:
		return "opportunity"
	case TasksListRequestExpandOwner:
		return "owner"
	case TasksListRequestExpandOwnerAccount:
		return "owner,account"
	case TasksListRequestExpandOwnerAccountOpportunity:
		return "owner,account,opportunity"
	case TasksListRequestExpandOwnerOpportunity:
		return "owner,opportunity"
	}
}

func (t TasksListRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TasksListRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "account":
		value := TasksListRequestExpandAccount
		*t = value
	case "account,opportunity":
		value := TasksListRequestExpandAccountOpportunity
		*t = value
	case "opportunity":
		value := TasksListRequestExpandOpportunity
		*t = value
	case "owner":
		value := TasksListRequestExpandOwner
		*t = value
	case "owner,account":
		value := TasksListRequestExpandOwnerAccount
		*t = value
	case "owner,account,opportunity":
		value := TasksListRequestExpandOwnerAccountOpportunity
		*t = value
	case "owner,opportunity":
		value := TasksListRequestExpandOwnerOpportunity
		*t = value
	}
	return nil
}

type TasksRetrieveRequestExpand uint

const (
	TasksRetrieveRequestExpandAccount TasksRetrieveRequestExpand = iota + 1
	TasksRetrieveRequestExpandAccountOpportunity
	TasksRetrieveRequestExpandOpportunity
	TasksRetrieveRequestExpandOwner
	TasksRetrieveRequestExpandOwnerAccount
	TasksRetrieveRequestExpandOwnerAccountOpportunity
	TasksRetrieveRequestExpandOwnerOpportunity
)

func (t TasksRetrieveRequestExpand) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TasksRetrieveRequestExpandAccount:
		return "account"
	case TasksRetrieveRequestExpandAccountOpportunity:
		return "account,opportunity"
	case TasksRetrieveRequestExpandOpportunity:
		return "opportunity"
	case TasksRetrieveRequestExpandOwner:
		return "owner"
	case TasksRetrieveRequestExpandOwnerAccount:
		return "owner,account"
	case TasksRetrieveRequestExpandOwnerAccountOpportunity:
		return "owner,account,opportunity"
	case TasksRetrieveRequestExpandOwnerOpportunity:
		return "owner,opportunity"
	}
}

func (t TasksRetrieveRequestExpand) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TasksRetrieveRequestExpand) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "account":
		value := TasksRetrieveRequestExpandAccount
		*t = value
	case "account,opportunity":
		value := TasksRetrieveRequestExpandAccountOpportunity
		*t = value
	case "opportunity":
		value := TasksRetrieveRequestExpandOpportunity
		*t = value
	case "owner":
		value := TasksRetrieveRequestExpandOwner
		*t = value
	case "owner,account":
		value := TasksRetrieveRequestExpandOwnerAccount
		*t = value
	case "owner,account,opportunity":
		value := TasksRetrieveRequestExpandOwnerAccountOpportunity
		*t = value
	case "owner,opportunity":
		value := TasksRetrieveRequestExpandOwnerOpportunity
		*t = value
	}
	return nil
}

// # The User Object
// ### Description
// The `User` object is used to represent a user with a login to the CRM system.
// ### Usage Example
// TODO
type User struct {
	// The user's name.
	Name *string `json:"name,omitempty"`
	// The user's email address.
	Email *string `json:"email,omitempty"`
	// Whether or not the user is active.
	IsActive *bool `json:"is_active,omitempty"`
	// Indicates whether or not this object has been deleted by third party webhooks.
	RemoteWasDeleted *bool   `json:"remote_was_deleted,omitempty"`
	Id               *string `json:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty"`
	// This is the datetime that this object was last updated by Merge
	ModifiedAt    *time.Time     `json:"modified_at,omitempty"`
	FieldMappings map[string]any `json:"field_mappings,omitempty"`
	RemoteData    []*RemoteData  `json:"remote_data,omitempty"`
	RemoteFields  []*RemoteField `json:"remote_fields,omitempty"`
}

type ValidationProblemSource struct {
	Pointer string `json:"pointer"`
}

type WarningValidationProblem struct {
	Source      *ValidationProblemSource `json:"source,omitempty"`
	Title       string                   `json:"title"`
	Detail      string                   `json:"detail"`
	ProblemType string                   `json:"problem_type"`
}

type WebhookReceiver struct {
	Event    string  `json:"event"`
	IsActive bool    `json:"is_active"`
	Key      *string `json:"key,omitempty"`
}
