// Code generated by Fern. DO NOT EDIT.

package crm

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type EngagementEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool              `json:"-" url:"run_async,omitempty"`
	Model    *EngagementRequest `json:"model,omitempty" url:"-"`
}

type EngagementsListRequest struct {
	// If provided, will only return objects created after this datetime.
	CreatedAfter *time.Time `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *time.Time `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*EngagementsListRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, only objects synced by Merge after this date time will be returned.
	ModifiedAfter *time.Time `json:"-" url:"modified_after,omitempty"`
	// If provided, only objects synced by Merge before this date time will be returned.
	ModifiedBefore *time.Time `json:"-" url:"modified_before,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// The API provider's ID for the given object.
	RemoteId *string `json:"-" url:"remote_id,omitempty"`
	// If provided, will only return engagements started after this datetime.
	StartedAfter *time.Time `json:"-" url:"started_after,omitempty"`
	// If provided, will only return engagements started before this datetime.
	StartedBefore *time.Time `json:"-" url:"started_before,omitempty"`
}

type PatchedEngagementEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool                     `json:"-" url:"run_async,omitempty"`
	Model    *PatchedEngagementRequest `json:"model,omitempty" url:"-"`
}

type EngagementsRemoteFieldClassesListRequest struct {
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return remote field classes with this is_common_model_field value
	IsCommonModelField *bool `json:"-" url:"is_common_model_field,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
}

type EngagementsRetrieveRequest struct {
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*EngagementsRetrieveRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
}

type EngagementsListRequestExpandItem string

const (
	EngagementsListRequestExpandItemAccount        EngagementsListRequestExpandItem = "account"
	EngagementsListRequestExpandItemContacts       EngagementsListRequestExpandItem = "contacts"
	EngagementsListRequestExpandItemEngagementType EngagementsListRequestExpandItem = "engagement_type"
	EngagementsListRequestExpandItemOwner          EngagementsListRequestExpandItem = "owner"
)

func NewEngagementsListRequestExpandItemFromString(s string) (EngagementsListRequestExpandItem, error) {
	switch s {
	case "account":
		return EngagementsListRequestExpandItemAccount, nil
	case "contacts":
		return EngagementsListRequestExpandItemContacts, nil
	case "engagement_type":
		return EngagementsListRequestExpandItemEngagementType, nil
	case "owner":
		return EngagementsListRequestExpandItemOwner, nil
	}
	var t EngagementsListRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EngagementsListRequestExpandItem) Ptr() *EngagementsListRequestExpandItem {
	return &e
}

type EngagementsRetrieveRequestExpandItem string

const (
	EngagementsRetrieveRequestExpandItemAccount        EngagementsRetrieveRequestExpandItem = "account"
	EngagementsRetrieveRequestExpandItemContacts       EngagementsRetrieveRequestExpandItem = "contacts"
	EngagementsRetrieveRequestExpandItemEngagementType EngagementsRetrieveRequestExpandItem = "engagement_type"
	EngagementsRetrieveRequestExpandItemOwner          EngagementsRetrieveRequestExpandItem = "owner"
)

func NewEngagementsRetrieveRequestExpandItemFromString(s string) (EngagementsRetrieveRequestExpandItem, error) {
	switch s {
	case "account":
		return EngagementsRetrieveRequestExpandItemAccount, nil
	case "contacts":
		return EngagementsRetrieveRequestExpandItemContacts, nil
	case "engagement_type":
		return EngagementsRetrieveRequestExpandItemEngagementType, nil
	case "owner":
		return EngagementsRetrieveRequestExpandItemOwner, nil
	}
	var t EngagementsRetrieveRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EngagementsRetrieveRequestExpandItem) Ptr() *EngagementsRetrieveRequestExpandItem {
	return &e
}

// * `INBOUND` - INBOUND
// * `OUTBOUND` - OUTBOUND
type DirectionEnum string

const (
	DirectionEnumInbound  DirectionEnum = "INBOUND"
	DirectionEnumOutbound DirectionEnum = "OUTBOUND"
)

func NewDirectionEnumFromString(s string) (DirectionEnum, error) {
	switch s {
	case "INBOUND":
		return DirectionEnumInbound, nil
	case "OUTBOUND":
		return DirectionEnumOutbound, nil
	}
	var t DirectionEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DirectionEnum) Ptr() *DirectionEnum {
	return &d
}

// # The Engagement Object
// ### Description
// The `Engagement` object is used to represent an interaction noted in a CRM system.
// ### Usage Example
// TODO
type Engagement struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The engagement's owner.
	Owner *EngagementOwner `json:"owner,omitempty" url:"owner,omitempty"`
	// The engagement's content.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// The engagement's subject.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The engagement's direction.
	//
	// * `INBOUND` - INBOUND
	// * `OUTBOUND` - OUTBOUND
	Direction *DirectionEnum `json:"direction,omitempty" url:"direction,omitempty"`
	// The engagement type of the engagement.
	EngagementType *EngagementEngagementType `json:"engagement_type,omitempty" url:"engagement_type,omitempty"`
	// The time at which the engagement started.
	StartTime *time.Time `json:"start_time,omitempty" url:"start_time,omitempty"`
	// The time at which the engagement ended.
	EndTime *time.Time `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The account of the engagement.
	Account  *EngagementAccount        `json:"account,omitempty" url:"account,omitempty"`
	Contacts []*EngagementContactsItem `json:"contacts,omitempty" url:"contacts,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Engagement) GetId() *string {
	if e == nil {
		return nil
	}
	return e.Id
}

func (e *Engagement) GetRemoteId() *string {
	if e == nil {
		return nil
	}
	return e.RemoteId
}

func (e *Engagement) GetCreatedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *Engagement) GetModifiedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.ModifiedAt
}

func (e *Engagement) GetOwner() *EngagementOwner {
	if e == nil {
		return nil
	}
	return e.Owner
}

func (e *Engagement) GetContent() *string {
	if e == nil {
		return nil
	}
	return e.Content
}

func (e *Engagement) GetSubject() *string {
	if e == nil {
		return nil
	}
	return e.Subject
}

func (e *Engagement) GetDirection() *DirectionEnum {
	if e == nil {
		return nil
	}
	return e.Direction
}

func (e *Engagement) GetEngagementType() *EngagementEngagementType {
	if e == nil {
		return nil
	}
	return e.EngagementType
}

func (e *Engagement) GetStartTime() *time.Time {
	if e == nil {
		return nil
	}
	return e.StartTime
}

func (e *Engagement) GetEndTime() *time.Time {
	if e == nil {
		return nil
	}
	return e.EndTime
}

func (e *Engagement) GetAccount() *EngagementAccount {
	if e == nil {
		return nil
	}
	return e.Account
}

func (e *Engagement) GetContacts() []*EngagementContactsItem {
	if e == nil {
		return nil
	}
	return e.Contacts
}

func (e *Engagement) GetRemoteWasDeleted() *bool {
	if e == nil {
		return nil
	}
	return e.RemoteWasDeleted
}

func (e *Engagement) GetFieldMappings() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.FieldMappings
}

func (e *Engagement) GetRemoteData() []*RemoteData {
	if e == nil {
		return nil
	}
	return e.RemoteData
}

func (e *Engagement) GetRemoteFields() []*RemoteField {
	if e == nil {
		return nil
	}
	return e.RemoteFields
}

func (e *Engagement) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Engagement) UnmarshalJSON(data []byte) error {
	type embed Engagement
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
		StartTime  *internal.DateTime `json:"start_time,omitempty"`
		EndTime    *internal.DateTime `json:"end_time,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Engagement(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	e.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	e.StartTime = unmarshaler.StartTime.TimePtr()
	e.EndTime = unmarshaler.EndTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Engagement) MarshalJSON() ([]byte, error) {
	type embed Engagement
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt *internal.DateTime `json:"modified_at,omitempty"`
		StartTime  *internal.DateTime `json:"start_time,omitempty"`
		EndTime    *internal.DateTime `json:"end_time,omitempty"`
	}{
		embed:      embed(*e),
		CreatedAt:  internal.NewOptionalDateTime(e.CreatedAt),
		ModifiedAt: internal.NewOptionalDateTime(e.ModifiedAt),
		StartTime:  internal.NewOptionalDateTime(e.StartTime),
		EndTime:    internal.NewOptionalDateTime(e.EndTime),
	}
	return json.Marshal(marshaler)
}

func (e *Engagement) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The account of the engagement.
type EngagementAccount struct {
	String  string
	Account *Account

	typ string
}

func (e *EngagementAccount) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EngagementAccount) GetAccount() *Account {
	if e == nil {
		return nil
	}
	return e.Account
}

func (e *EngagementAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		e.typ = "Account"
		e.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementAccount) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Account" || e.Account != nil {
		return json.Marshal(e.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (e *EngagementAccount) Accept(visitor EngagementAccountVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Account" || e.Account != nil {
		return visitor.VisitAccount(e.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementContactsItem struct {
	String  string
	Contact *Contact

	typ string
}

func (e *EngagementContactsItem) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EngagementContactsItem) GetContact() *Contact {
	if e == nil {
		return nil
	}
	return e.Contact
}

func (e *EngagementContactsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		e.typ = "Contact"
		e.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementContactsItem) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Contact" || e.Contact != nil {
		return json.Marshal(e.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementContactsItemVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (e *EngagementContactsItem) Accept(visitor EngagementContactsItemVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Contact" || e.Contact != nil {
		return visitor.VisitContact(e.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The engagement type of the engagement.
type EngagementEngagementType struct {
	String         string
	EngagementType *EngagementType

	typ string
}

func (e *EngagementEngagementType) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EngagementEngagementType) GetEngagementType() *EngagementType {
	if e == nil {
		return nil
	}
	return e.EngagementType
}

func (e *EngagementEngagementType) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueEngagementType := new(EngagementType)
	if err := json.Unmarshal(data, &valueEngagementType); err == nil {
		e.typ = "EngagementType"
		e.EngagementType = valueEngagementType
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementEngagementType) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "EngagementType" || e.EngagementType != nil {
		return json.Marshal(e.EngagementType)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementEngagementTypeVisitor interface {
	VisitString(string) error
	VisitEngagementType(*EngagementType) error
}

func (e *EngagementEngagementType) Accept(visitor EngagementEngagementTypeVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "EngagementType" || e.EngagementType != nil {
		return visitor.VisitEngagementType(e.EngagementType)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The engagement's owner.
type EngagementOwner struct {
	String string
	User   *User

	typ string
}

func (e *EngagementOwner) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EngagementOwner) GetUser() *User {
	if e == nil {
		return nil
	}
	return e.User
}

func (e *EngagementOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		e.typ = "User"
		e.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementOwner) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "User" || e.User != nil {
		return json.Marshal(e.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (e *EngagementOwner) Accept(visitor EngagementOwnerVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "User" || e.User != nil {
		return visitor.VisitUser(e.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// # The Engagement Object
// ### Description
// The `Engagement` object is used to represent an interaction noted in a CRM system.
// ### Usage Example
// TODO
type EngagementRequest struct {
	// The engagement's owner.
	Owner *EngagementRequestOwner `json:"owner,omitempty" url:"owner,omitempty"`
	// The engagement's content.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// The engagement's subject.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The engagement's direction.
	//
	// * `INBOUND` - INBOUND
	// * `OUTBOUND` - OUTBOUND
	Direction *DirectionEnum `json:"direction,omitempty" url:"direction,omitempty"`
	// The engagement type of the engagement.
	EngagementType *EngagementRequestEngagementType `json:"engagement_type,omitempty" url:"engagement_type,omitempty"`
	// The time at which the engagement started.
	StartTime *time.Time `json:"start_time,omitempty" url:"start_time,omitempty"`
	// The time at which the engagement ended.
	EndTime *time.Time `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The account of the engagement.
	Account             *EngagementRequestAccount        `json:"account,omitempty" url:"account,omitempty"`
	Contacts            []*EngagementRequestContactsItem `json:"contacts,omitempty" url:"contacts,omitempty"`
	IntegrationParams   map[string]interface{}           `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}           `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest            `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EngagementRequest) GetOwner() *EngagementRequestOwner {
	if e == nil {
		return nil
	}
	return e.Owner
}

func (e *EngagementRequest) GetContent() *string {
	if e == nil {
		return nil
	}
	return e.Content
}

func (e *EngagementRequest) GetSubject() *string {
	if e == nil {
		return nil
	}
	return e.Subject
}

func (e *EngagementRequest) GetDirection() *DirectionEnum {
	if e == nil {
		return nil
	}
	return e.Direction
}

func (e *EngagementRequest) GetEngagementType() *EngagementRequestEngagementType {
	if e == nil {
		return nil
	}
	return e.EngagementType
}

func (e *EngagementRequest) GetStartTime() *time.Time {
	if e == nil {
		return nil
	}
	return e.StartTime
}

func (e *EngagementRequest) GetEndTime() *time.Time {
	if e == nil {
		return nil
	}
	return e.EndTime
}

func (e *EngagementRequest) GetAccount() *EngagementRequestAccount {
	if e == nil {
		return nil
	}
	return e.Account
}

func (e *EngagementRequest) GetContacts() []*EngagementRequestContactsItem {
	if e == nil {
		return nil
	}
	return e.Contacts
}

func (e *EngagementRequest) GetIntegrationParams() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.IntegrationParams
}

func (e *EngagementRequest) GetLinkedAccountParams() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.LinkedAccountParams
}

func (e *EngagementRequest) GetRemoteFields() []*RemoteFieldRequest {
	if e == nil {
		return nil
	}
	return e.RemoteFields
}

func (e *EngagementRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EngagementRequest) UnmarshalJSON(data []byte) error {
	type embed EngagementRequest
	var unmarshaler = struct {
		embed
		StartTime *internal.DateTime `json:"start_time,omitempty"`
		EndTime   *internal.DateTime `json:"end_time,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EngagementRequest(unmarshaler.embed)
	e.StartTime = unmarshaler.StartTime.TimePtr()
	e.EndTime = unmarshaler.EndTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EngagementRequest) MarshalJSON() ([]byte, error) {
	type embed EngagementRequest
	var marshaler = struct {
		embed
		StartTime *internal.DateTime `json:"start_time,omitempty"`
		EndTime   *internal.DateTime `json:"end_time,omitempty"`
	}{
		embed:     embed(*e),
		StartTime: internal.NewOptionalDateTime(e.StartTime),
		EndTime:   internal.NewOptionalDateTime(e.EndTime),
	}
	return json.Marshal(marshaler)
}

func (e *EngagementRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The account of the engagement.
type EngagementRequestAccount struct {
	String  string
	Account *Account

	typ string
}

func (e *EngagementRequestAccount) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EngagementRequestAccount) GetAccount() *Account {
	if e == nil {
		return nil
	}
	return e.Account
}

func (e *EngagementRequestAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		e.typ = "Account"
		e.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestAccount) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Account" || e.Account != nil {
		return json.Marshal(e.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementRequestAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (e *EngagementRequestAccount) Accept(visitor EngagementRequestAccountVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Account" || e.Account != nil {
		return visitor.VisitAccount(e.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementRequestContactsItem struct {
	String  string
	Contact *Contact

	typ string
}

func (e *EngagementRequestContactsItem) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EngagementRequestContactsItem) GetContact() *Contact {
	if e == nil {
		return nil
	}
	return e.Contact
}

func (e *EngagementRequestContactsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		e.typ = "Contact"
		e.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestContactsItem) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "Contact" || e.Contact != nil {
		return json.Marshal(e.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementRequestContactsItemVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (e *EngagementRequestContactsItem) Accept(visitor EngagementRequestContactsItemVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "Contact" || e.Contact != nil {
		return visitor.VisitContact(e.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The engagement type of the engagement.
type EngagementRequestEngagementType struct {
	String         string
	EngagementType *EngagementType

	typ string
}

func (e *EngagementRequestEngagementType) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EngagementRequestEngagementType) GetEngagementType() *EngagementType {
	if e == nil {
		return nil
	}
	return e.EngagementType
}

func (e *EngagementRequestEngagementType) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueEngagementType := new(EngagementType)
	if err := json.Unmarshal(data, &valueEngagementType); err == nil {
		e.typ = "EngagementType"
		e.EngagementType = valueEngagementType
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestEngagementType) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "EngagementType" || e.EngagementType != nil {
		return json.Marshal(e.EngagementType)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementRequestEngagementTypeVisitor interface {
	VisitString(string) error
	VisitEngagementType(*EngagementType) error
}

func (e *EngagementRequestEngagementType) Accept(visitor EngagementRequestEngagementTypeVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "EngagementType" || e.EngagementType != nil {
		return visitor.VisitEngagementType(e.EngagementType)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

// The engagement's owner.
type EngagementRequestOwner struct {
	String string
	User   *User

	typ string
}

func (e *EngagementRequestOwner) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *EngagementRequestOwner) GetUser() *User {
	if e == nil {
		return nil
	}
	return e.User
}

func (e *EngagementRequestOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		e.typ = "User"
		e.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EngagementRequestOwner) MarshalJSON() ([]byte, error) {
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	if e.typ == "User" || e.User != nil {
		return json.Marshal(e.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementRequestOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (e *EngagementRequestOwner) Accept(visitor EngagementRequestOwnerVisitor) error {
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	if e.typ == "User" || e.User != nil {
		return visitor.VisitUser(e.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EngagementResponse struct {
	Model    *Engagement                 `json:"model" url:"model"`
	Warnings []*WarningValidationProblem `json:"warnings" url:"warnings"`
	Errors   []*ErrorValidationProblem   `json:"errors" url:"errors"`
	Logs     []*DebugModeLog             `json:"logs,omitempty" url:"logs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EngagementResponse) GetModel() *Engagement {
	if e == nil {
		return nil
	}
	return e.Model
}

func (e *EngagementResponse) GetWarnings() []*WarningValidationProblem {
	if e == nil {
		return nil
	}
	return e.Warnings
}

func (e *EngagementResponse) GetErrors() []*ErrorValidationProblem {
	if e == nil {
		return nil
	}
	return e.Errors
}

func (e *EngagementResponse) GetLogs() []*DebugModeLog {
	if e == nil {
		return nil
	}
	return e.Logs
}

func (e *EngagementResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EngagementResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EngagementResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EngagementResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EngagementResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type PaginatedEngagementList struct {
	Next     *string       `json:"next,omitempty" url:"next,omitempty"`
	Previous *string       `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*Engagement `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedEngagementList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedEngagementList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedEngagementList) GetResults() []*Engagement {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedEngagementList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedEngagementList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedEngagementList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedEngagementList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedEngagementList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// # The Engagement Object
// ### Description
// The `Engagement` object is used to represent an interaction noted in a CRM system.
// ### Usage Example
// TODO
type PatchedEngagementRequest struct {
	// The engagement's owner.
	Owner *string `json:"owner,omitempty" url:"owner,omitempty"`
	// The engagement's content.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// The engagement's subject.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The engagement's direction.
	//
	// * `INBOUND` - INBOUND
	// * `OUTBOUND` - OUTBOUND
	Direction *DirectionEnum `json:"direction,omitempty" url:"direction,omitempty"`
	// The engagement type of the engagement.
	EngagementType *string `json:"engagement_type,omitempty" url:"engagement_type,omitempty"`
	// The time at which the engagement started.
	StartTime *time.Time `json:"start_time,omitempty" url:"start_time,omitempty"`
	// The time at which the engagement ended.
	EndTime *time.Time `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The account of the engagement.
	Account             *string                `json:"account,omitempty" url:"account,omitempty"`
	Contacts            []*string              `json:"contacts,omitempty" url:"contacts,omitempty"`
	IntegrationParams   map[string]interface{} `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{} `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest  `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchedEngagementRequest) GetOwner() *string {
	if p == nil {
		return nil
	}
	return p.Owner
}

func (p *PatchedEngagementRequest) GetContent() *string {
	if p == nil {
		return nil
	}
	return p.Content
}

func (p *PatchedEngagementRequest) GetSubject() *string {
	if p == nil {
		return nil
	}
	return p.Subject
}

func (p *PatchedEngagementRequest) GetDirection() *DirectionEnum {
	if p == nil {
		return nil
	}
	return p.Direction
}

func (p *PatchedEngagementRequest) GetEngagementType() *string {
	if p == nil {
		return nil
	}
	return p.EngagementType
}

func (p *PatchedEngagementRequest) GetStartTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.StartTime
}

func (p *PatchedEngagementRequest) GetEndTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.EndTime
}

func (p *PatchedEngagementRequest) GetAccount() *string {
	if p == nil {
		return nil
	}
	return p.Account
}

func (p *PatchedEngagementRequest) GetContacts() []*string {
	if p == nil {
		return nil
	}
	return p.Contacts
}

func (p *PatchedEngagementRequest) GetIntegrationParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.IntegrationParams
}

func (p *PatchedEngagementRequest) GetLinkedAccountParams() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.LinkedAccountParams
}

func (p *PatchedEngagementRequest) GetRemoteFields() []*RemoteFieldRequest {
	if p == nil {
		return nil
	}
	return p.RemoteFields
}

func (p *PatchedEngagementRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchedEngagementRequest) UnmarshalJSON(data []byte) error {
	type embed PatchedEngagementRequest
	var unmarshaler = struct {
		embed
		StartTime *internal.DateTime `json:"start_time,omitempty"`
		EndTime   *internal.DateTime `json:"end_time,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PatchedEngagementRequest(unmarshaler.embed)
	p.StartTime = unmarshaler.StartTime.TimePtr()
	p.EndTime = unmarshaler.EndTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchedEngagementRequest) MarshalJSON() ([]byte, error) {
	type embed PatchedEngagementRequest
	var marshaler = struct {
		embed
		StartTime *internal.DateTime `json:"start_time,omitempty"`
		EndTime   *internal.DateTime `json:"end_time,omitempty"`
	}{
		embed:     embed(*p),
		StartTime: internal.NewOptionalDateTime(p.StartTime),
		EndTime:   internal.NewOptionalDateTime(p.EndTime),
	}
	return json.Marshal(marshaler)
}

func (p *PatchedEngagementRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
