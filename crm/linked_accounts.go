// Code generated by Fern. DO NOT EDIT.

package crm

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type LinkedAccountsListRequest struct {
	// Options: `accounting`, `ats`, `crm`, `filestorage`, `hris`, `mktg`, `ticketing`
	//
	// * `hris` - hris
	// * `ats` - ats
	// * `accounting` - accounting
	// * `ticketing` - ticketing
	// * `crm` - crm
	// * `mktg` - mktg
	// * `filestorage` - filestorage
	Category *LinkedAccountsListRequestCategory `json:"-" url:"category,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// If provided, will only return linked accounts associated with the given email address.
	EndUserEmailAddress *string `json:"-" url:"end_user_email_address,omitempty"`
	// If provided, will only return linked accounts associated with the given organization name.
	EndUserOrganizationName *string `json:"-" url:"end_user_organization_name,omitempty"`
	// If provided, will only return linked accounts associated with the given origin ID.
	EndUserOriginId *string `json:"-" url:"end_user_origin_id,omitempty"`
	// Comma-separated list of EndUser origin IDs, making it possible to specify multiple EndUsers at once.
	EndUserOriginIds *string `json:"-" url:"end_user_origin_ids,omitempty"`
	Id               *string `json:"-" url:"id,omitempty"`
	// Comma-separated list of LinkedAccount IDs, making it possible to specify multiple LinkedAccounts at once.
	Ids *string `json:"-" url:"ids,omitempty"`
	// If `true`, will include complete production duplicates of the account specified by the `id` query parameter in the response. `id` must be for a complete production linked account.
	IncludeDuplicates *bool `json:"-" url:"include_duplicates,omitempty"`
	// If provided, will only return linked accounts associated with the given integration name.
	IntegrationName *string `json:"-" url:"integration_name,omitempty"`
	// If included, will only include test linked accounts. If not included, will only include non-test linked accounts.
	IsTestAccount *string `json:"-" url:"is_test_account,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// Filter by status. Options: `COMPLETE`, `IDLE`, `INCOMPLETE`, `RELINK_NEEDED`
	Status *string `json:"-" url:"status,omitempty"`
}

type LinkedAccountsListRequestCategory string

const (
	LinkedAccountsListRequestCategoryAccounting  LinkedAccountsListRequestCategory = "accounting"
	LinkedAccountsListRequestCategoryAts         LinkedAccountsListRequestCategory = "ats"
	LinkedAccountsListRequestCategoryCrm         LinkedAccountsListRequestCategory = "crm"
	LinkedAccountsListRequestCategoryFilestorage LinkedAccountsListRequestCategory = "filestorage"
	LinkedAccountsListRequestCategoryHris        LinkedAccountsListRequestCategory = "hris"
	LinkedAccountsListRequestCategoryMktg        LinkedAccountsListRequestCategory = "mktg"
	LinkedAccountsListRequestCategoryTicketing   LinkedAccountsListRequestCategory = "ticketing"
)

func NewLinkedAccountsListRequestCategoryFromString(s string) (LinkedAccountsListRequestCategory, error) {
	switch s {
	case "accounting":
		return LinkedAccountsListRequestCategoryAccounting, nil
	case "ats":
		return LinkedAccountsListRequestCategoryAts, nil
	case "crm":
		return LinkedAccountsListRequestCategoryCrm, nil
	case "filestorage":
		return LinkedAccountsListRequestCategoryFilestorage, nil
	case "hris":
		return LinkedAccountsListRequestCategoryHris, nil
	case "mktg":
		return LinkedAccountsListRequestCategoryMktg, nil
	case "ticketing":
		return LinkedAccountsListRequestCategoryTicketing, nil
	}
	var t LinkedAccountsListRequestCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LinkedAccountsListRequestCategory) Ptr() *LinkedAccountsListRequestCategory {
	return &l
}

// # The LinkedAccount Object
// ### Description
// The `LinkedAccount` object is used to represent an end user's link with a specific integration.
//
// ### Usage Example
// View a list of your organization's `LinkedAccount` objects.
type AccountDetailsAndActions struct {
	Id                      string                            `json:"id" url:"id"`
	Category                *AccountDetailsAndActionsCategory `json:"category,omitempty" url:"category,omitempty"`
	Status                  *AccountDetailsAndActionsStatus   `json:"status" url:"status"`
	StatusDetail            *string                           `json:"status_detail,omitempty" url:"status_detail,omitempty"`
	EndUserOriginId         *string                           `json:"end_user_origin_id,omitempty" url:"end_user_origin_id,omitempty"`
	EndUserOrganizationName string                            `json:"end_user_organization_name" url:"end_user_organization_name"`
	EndUserEmailAddress     string                            `json:"end_user_email_address" url:"end_user_email_address"`
	// The tenant or domain the customer has provided access to.
	Subdomain          *string `json:"subdomain,omitempty" url:"subdomain,omitempty"`
	WebhookListenerUrl string  `json:"webhook_listener_url" url:"webhook_listener_url"`
	// Whether a Production Linked Account's credentials match another existing Production Linked Account. This field is `null` for Test Linked Accounts, incomplete Production Linked Accounts, and ignored duplicate Production Linked Account sets.
	IsDuplicate *bool                                `json:"is_duplicate,omitempty" url:"is_duplicate,omitempty"`
	Integration *AccountDetailsAndActionsIntegration `json:"integration,omitempty" url:"integration,omitempty"`
	AccountType string                               `json:"account_type" url:"account_type"`
	CompletedAt time.Time                            `json:"completed_at" url:"completed_at"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountDetailsAndActions) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AccountDetailsAndActions) GetCategory() *AccountDetailsAndActionsCategory {
	if a == nil {
		return nil
	}
	return a.Category
}

func (a *AccountDetailsAndActions) GetStatus() *AccountDetailsAndActionsStatus {
	if a == nil {
		return nil
	}
	return a.Status
}

func (a *AccountDetailsAndActions) GetStatusDetail() *string {
	if a == nil {
		return nil
	}
	return a.StatusDetail
}

func (a *AccountDetailsAndActions) GetEndUserOriginId() *string {
	if a == nil {
		return nil
	}
	return a.EndUserOriginId
}

func (a *AccountDetailsAndActions) GetEndUserOrganizationName() string {
	if a == nil {
		return ""
	}
	return a.EndUserOrganizationName
}

func (a *AccountDetailsAndActions) GetEndUserEmailAddress() string {
	if a == nil {
		return ""
	}
	return a.EndUserEmailAddress
}

func (a *AccountDetailsAndActions) GetSubdomain() *string {
	if a == nil {
		return nil
	}
	return a.Subdomain
}

func (a *AccountDetailsAndActions) GetWebhookListenerUrl() string {
	if a == nil {
		return ""
	}
	return a.WebhookListenerUrl
}

func (a *AccountDetailsAndActions) GetIsDuplicate() *bool {
	if a == nil {
		return nil
	}
	return a.IsDuplicate
}

func (a *AccountDetailsAndActions) GetIntegration() *AccountDetailsAndActionsIntegration {
	if a == nil {
		return nil
	}
	return a.Integration
}

func (a *AccountDetailsAndActions) GetAccountType() string {
	if a == nil {
		return ""
	}
	return a.AccountType
}

func (a *AccountDetailsAndActions) GetCompletedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CompletedAt
}

func (a *AccountDetailsAndActions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountDetailsAndActions) UnmarshalJSON(data []byte) error {
	type embed AccountDetailsAndActions
	var unmarshaler = struct {
		embed
		CompletedAt *internal.DateTime `json:"completed_at"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AccountDetailsAndActions(unmarshaler.embed)
	a.CompletedAt = unmarshaler.CompletedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetailsAndActions) MarshalJSON() ([]byte, error) {
	type embed AccountDetailsAndActions
	var marshaler = struct {
		embed
		CompletedAt *internal.DateTime `json:"completed_at"`
	}{
		embed:       embed(*a),
		CompletedAt: internal.NewDateTime(a.CompletedAt),
	}
	return json.Marshal(marshaler)
}

func (a *AccountDetailsAndActions) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountDetailsAndActionsCategory struct {
	CategoryEnum CategoryEnum
	String       string

	typ string
}

func (a *AccountDetailsAndActionsCategory) GetCategoryEnum() CategoryEnum {
	if a == nil {
		return ""
	}
	return a.CategoryEnum
}

func (a *AccountDetailsAndActionsCategory) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *AccountDetailsAndActionsCategory) UnmarshalJSON(data []byte) error {
	var valueCategoryEnum CategoryEnum
	if err := json.Unmarshal(data, &valueCategoryEnum); err == nil {
		a.typ = "CategoryEnum"
		a.CategoryEnum = valueCategoryEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountDetailsAndActionsCategory) MarshalJSON() ([]byte, error) {
	if a.typ == "CategoryEnum" || a.CategoryEnum != "" {
		return json.Marshal(a.CategoryEnum)
	}
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AccountDetailsAndActionsCategoryVisitor interface {
	VisitCategoryEnum(CategoryEnum) error
	VisitString(string) error
}

func (a *AccountDetailsAndActionsCategory) Accept(visitor AccountDetailsAndActionsCategoryVisitor) error {
	if a.typ == "CategoryEnum" || a.CategoryEnum != "" {
		return visitor.VisitCategoryEnum(a.CategoryEnum)
	}
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AccountDetailsAndActionsIntegration struct {
	Name                     string            `json:"name" url:"name"`
	Categories               []CategoriesEnum  `json:"categories" url:"categories"`
	Image                    *string           `json:"image,omitempty" url:"image,omitempty"`
	SquareImage              *string           `json:"square_image,omitempty" url:"square_image,omitempty"`
	Color                    string            `json:"color" url:"color"`
	Slug                     string            `json:"slug" url:"slug"`
	PassthroughAvailable     bool              `json:"passthrough_available" url:"passthrough_available"`
	AvailableModelOperations []*ModelOperation `json:"available_model_operations,omitempty" url:"available_model_operations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccountDetailsAndActionsIntegration) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AccountDetailsAndActionsIntegration) GetCategories() []CategoriesEnum {
	if a == nil {
		return nil
	}
	return a.Categories
}

func (a *AccountDetailsAndActionsIntegration) GetImage() *string {
	if a == nil {
		return nil
	}
	return a.Image
}

func (a *AccountDetailsAndActionsIntegration) GetSquareImage() *string {
	if a == nil {
		return nil
	}
	return a.SquareImage
}

func (a *AccountDetailsAndActionsIntegration) GetColor() string {
	if a == nil {
		return ""
	}
	return a.Color
}

func (a *AccountDetailsAndActionsIntegration) GetSlug() string {
	if a == nil {
		return ""
	}
	return a.Slug
}

func (a *AccountDetailsAndActionsIntegration) GetPassthroughAvailable() bool {
	if a == nil {
		return false
	}
	return a.PassthroughAvailable
}

func (a *AccountDetailsAndActionsIntegration) GetAvailableModelOperations() []*ModelOperation {
	if a == nil {
		return nil
	}
	return a.AvailableModelOperations
}

func (a *AccountDetailsAndActionsIntegration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountDetailsAndActionsIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountDetailsAndActionsIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountDetailsAndActionsIntegration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountDetailsAndActionsIntegration) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountDetailsAndActionsStatus struct {
	AccountDetailsAndActionsStatusEnum AccountDetailsAndActionsStatusEnum
	String                             string

	typ string
}

func (a *AccountDetailsAndActionsStatus) GetAccountDetailsAndActionsStatusEnum() AccountDetailsAndActionsStatusEnum {
	if a == nil {
		return ""
	}
	return a.AccountDetailsAndActionsStatusEnum
}

func (a *AccountDetailsAndActionsStatus) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *AccountDetailsAndActionsStatus) UnmarshalJSON(data []byte) error {
	var valueAccountDetailsAndActionsStatusEnum AccountDetailsAndActionsStatusEnum
	if err := json.Unmarshal(data, &valueAccountDetailsAndActionsStatusEnum); err == nil {
		a.typ = "AccountDetailsAndActionsStatusEnum"
		a.AccountDetailsAndActionsStatusEnum = valueAccountDetailsAndActionsStatusEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AccountDetailsAndActionsStatus) MarshalJSON() ([]byte, error) {
	if a.typ == "AccountDetailsAndActionsStatusEnum" || a.AccountDetailsAndActionsStatusEnum != "" {
		return json.Marshal(a.AccountDetailsAndActionsStatusEnum)
	}
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AccountDetailsAndActionsStatusVisitor interface {
	VisitAccountDetailsAndActionsStatusEnum(AccountDetailsAndActionsStatusEnum) error
	VisitString(string) error
}

func (a *AccountDetailsAndActionsStatus) Accept(visitor AccountDetailsAndActionsStatusVisitor) error {
	if a.typ == "AccountDetailsAndActionsStatusEnum" || a.AccountDetailsAndActionsStatusEnum != "" {
		return visitor.VisitAccountDetailsAndActionsStatusEnum(a.AccountDetailsAndActionsStatusEnum)
	}
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// * `COMPLETE` - COMPLETE
// * `INCOMPLETE` - INCOMPLETE
// * `RELINK_NEEDED` - RELINK_NEEDED
// * `IDLE` - IDLE
type AccountDetailsAndActionsStatusEnum string

const (
	AccountDetailsAndActionsStatusEnumComplete     AccountDetailsAndActionsStatusEnum = "COMPLETE"
	AccountDetailsAndActionsStatusEnumIncomplete   AccountDetailsAndActionsStatusEnum = "INCOMPLETE"
	AccountDetailsAndActionsStatusEnumRelinkNeeded AccountDetailsAndActionsStatusEnum = "RELINK_NEEDED"
	AccountDetailsAndActionsStatusEnumIdle         AccountDetailsAndActionsStatusEnum = "IDLE"
)

func NewAccountDetailsAndActionsStatusEnumFromString(s string) (AccountDetailsAndActionsStatusEnum, error) {
	switch s {
	case "COMPLETE":
		return AccountDetailsAndActionsStatusEnumComplete, nil
	case "INCOMPLETE":
		return AccountDetailsAndActionsStatusEnumIncomplete, nil
	case "RELINK_NEEDED":
		return AccountDetailsAndActionsStatusEnumRelinkNeeded, nil
	case "IDLE":
		return AccountDetailsAndActionsStatusEnumIdle, nil
	}
	var t AccountDetailsAndActionsStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountDetailsAndActionsStatusEnum) Ptr() *AccountDetailsAndActionsStatusEnum {
	return &a
}

type PaginatedAccountDetailsAndActionsList struct {
	Next     *string                     `json:"next,omitempty" url:"next,omitempty"`
	Previous *string                     `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*AccountDetailsAndActions `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedAccountDetailsAndActionsList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedAccountDetailsAndActionsList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedAccountDetailsAndActionsList) GetResults() []*AccountDetailsAndActions {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedAccountDetailsAndActionsList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedAccountDetailsAndActionsList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedAccountDetailsAndActionsList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedAccountDetailsAndActionsList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedAccountDetailsAndActionsList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
