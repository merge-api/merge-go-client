// Code generated by Fern. DO NOT EDIT.

package crm

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/merge-api/merge-go-client/v2/internal"
	time "time"
)

type LeadEndpointRequest struct {
	// Whether to include debug fields (such as log file links) in the response.
	IsDebugMode *bool `json:"-" url:"is_debug_mode,omitempty"`
	// Whether or not third-party updates should be run asynchronously.
	RunAsync *bool        `json:"-" url:"run_async,omitempty"`
	Model    *LeadRequest `json:"model,omitempty" url:"-"`
}

type LeadsListRequest struct {
	// If provided, will only return leads with this account.
	ConvertedAccountId *string `json:"-" url:"converted_account_id,omitempty"`
	// If provided, will only return leads with this contact.
	ConvertedContactId *string `json:"-" url:"converted_contact_id,omitempty"`
	// If provided, will only return objects created after this datetime.
	CreatedAfter *time.Time `json:"-" url:"created_after,omitempty"`
	// If provided, will only return objects created before this datetime.
	CreatedBefore *time.Time `json:"-" url:"created_before,omitempty"`
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// If provided, will only return contacts matching the email addresses; multiple email_addresses can be separated by commas.
	EmailAddresses *string `json:"-" url:"email_addresses,omitempty"`
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*LeadsListRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, only objects synced by Merge after this date time will be returned.
	ModifiedAfter *time.Time `json:"-" url:"modified_after,omitempty"`
	// If provided, only objects synced by Merge before this date time will be returned.
	ModifiedBefore *time.Time `json:"-" url:"modified_before,omitempty"`
	// If provided, will only return leads with this owner.
	OwnerId *string `json:"-" url:"owner_id,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// If provided, will only return contacts matching the phone numbers; multiple phone numbers can be separated by commas.
	PhoneNumbers *string `json:"-" url:"phone_numbers,omitempty"`
	// The API provider's ID for the given object.
	RemoteId *string `json:"-" url:"remote_id,omitempty"`
}

type LeadsRemoteFieldClassesListRequest struct {
	// The pagination cursor value.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	IncludeDeletedData *bool `json:"-" url:"include_deleted_data,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
	// If provided, will only return remote field classes with this is_common_model_field value
	IsCommonModelField *bool `json:"-" url:"is_common_model_field,omitempty"`
	// If provided, will only return remote fields classes with this is_custom value
	IsCustom *bool `json:"-" url:"is_custom,omitempty"`
	// Number of results to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
}

type LeadsRetrieveRequest struct {
	// Which relations should be returned in expanded form. Multiple relation names should be comma separated without spaces.
	Expand []*LeadsRetrieveRequestExpandItem `json:"-" url:"expand,omitempty"`
	// Whether to include the original data Merge fetched from the third-party to produce these models.
	IncludeRemoteData *bool `json:"-" url:"include_remote_data,omitempty"`
	// Whether to include all remote fields, including fields that Merge did not map to common models, in a normalized format.
	IncludeRemoteFields *bool `json:"-" url:"include_remote_fields,omitempty"`
	// Whether to include shell records. Shell records are empty records (they may contain some metadata but all other fields are null).
	IncludeShellData *bool `json:"-" url:"include_shell_data,omitempty"`
}

type LeadsListRequestExpandItem string

const (
	LeadsListRequestExpandItemConvertedAccount LeadsListRequestExpandItem = "converted_account"
	LeadsListRequestExpandItemConvertedContact LeadsListRequestExpandItem = "converted_contact"
	LeadsListRequestExpandItemOwner            LeadsListRequestExpandItem = "owner"
)

func NewLeadsListRequestExpandItemFromString(s string) (LeadsListRequestExpandItem, error) {
	switch s {
	case "converted_account":
		return LeadsListRequestExpandItemConvertedAccount, nil
	case "converted_contact":
		return LeadsListRequestExpandItemConvertedContact, nil
	case "owner":
		return LeadsListRequestExpandItemOwner, nil
	}
	var t LeadsListRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LeadsListRequestExpandItem) Ptr() *LeadsListRequestExpandItem {
	return &l
}

type LeadsRetrieveRequestExpandItem string

const (
	LeadsRetrieveRequestExpandItemConvertedAccount LeadsRetrieveRequestExpandItem = "converted_account"
	LeadsRetrieveRequestExpandItemConvertedContact LeadsRetrieveRequestExpandItem = "converted_contact"
	LeadsRetrieveRequestExpandItemOwner            LeadsRetrieveRequestExpandItem = "owner"
)

func NewLeadsRetrieveRequestExpandItemFromString(s string) (LeadsRetrieveRequestExpandItem, error) {
	switch s {
	case "converted_account":
		return LeadsRetrieveRequestExpandItemConvertedAccount, nil
	case "converted_contact":
		return LeadsRetrieveRequestExpandItemConvertedContact, nil
	case "owner":
		return LeadsRetrieveRequestExpandItemOwner, nil
	}
	var t LeadsRetrieveRequestExpandItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LeadsRetrieveRequestExpandItem) Ptr() *LeadsRetrieveRequestExpandItem {
	return &l
}

// # The Lead Object
// ### Description
// The `Lead` object is used to represent an individual who is a potential customer.
// ### Usage Example
// TODO
type Lead struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The third-party API ID of the matching object.
	RemoteId *string `json:"remote_id,omitempty" url:"remote_id,omitempty"`
	// The datetime that this object was created by Merge.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The datetime that this object was modified by Merge.
	ModifiedAt *time.Time `json:"modified_at,omitempty" url:"modified_at,omitempty"`
	// The lead's owner.
	Owner *LeadOwner `json:"owner,omitempty" url:"owner,omitempty"`
	// The lead's source.
	LeadSource *string `json:"lead_source,omitempty" url:"lead_source,omitempty"`
	// The lead's title.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// The lead's company.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// The lead's first name.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// The lead's last name.
	LastName       *string         `json:"last_name,omitempty" url:"last_name,omitempty"`
	Addresses      []*Address      `json:"addresses,omitempty" url:"addresses,omitempty"`
	EmailAddresses []*EmailAddress `json:"email_addresses,omitempty" url:"email_addresses,omitempty"`
	PhoneNumbers   []*PhoneNumber  `json:"phone_numbers,omitempty" url:"phone_numbers,omitempty"`
	// When the third party's lead was updated.
	RemoteUpdatedAt *time.Time `json:"remote_updated_at,omitempty" url:"remote_updated_at,omitempty"`
	// When the third party's lead was created.
	RemoteCreatedAt *time.Time `json:"remote_created_at,omitempty" url:"remote_created_at,omitempty"`
	// When the lead was converted.
	ConvertedDate *time.Time `json:"converted_date,omitempty" url:"converted_date,omitempty"`
	// The contact of the converted lead.
	ConvertedContact *LeadConvertedContact `json:"converted_contact,omitempty" url:"converted_contact,omitempty"`
	// The account of the converted lead.
	ConvertedAccount *LeadConvertedAccount `json:"converted_account,omitempty" url:"converted_account,omitempty"`
	// Indicates whether or not this object has been deleted in the third party platform. Full coverage deletion detection is a premium add-on. Native deletion detection is offered for free with limited coverage. [Learn more](https://docs.merge.dev/integrations/hris/supported-features/).
	RemoteWasDeleted *bool                  `json:"remote_was_deleted,omitempty" url:"remote_was_deleted,omitempty"`
	FieldMappings    map[string]interface{} `json:"field_mappings,omitempty" url:"field_mappings,omitempty"`
	RemoteData       []*RemoteData          `json:"remote_data,omitempty" url:"remote_data,omitempty"`
	RemoteFields     []*RemoteField         `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *Lead) GetId() *string {
	if l == nil {
		return nil
	}
	return l.Id
}

func (l *Lead) GetRemoteId() *string {
	if l == nil {
		return nil
	}
	return l.RemoteId
}

func (l *Lead) GetCreatedAt() *time.Time {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *Lead) GetModifiedAt() *time.Time {
	if l == nil {
		return nil
	}
	return l.ModifiedAt
}

func (l *Lead) GetOwner() *LeadOwner {
	if l == nil {
		return nil
	}
	return l.Owner
}

func (l *Lead) GetLeadSource() *string {
	if l == nil {
		return nil
	}
	return l.LeadSource
}

func (l *Lead) GetTitle() *string {
	if l == nil {
		return nil
	}
	return l.Title
}

func (l *Lead) GetCompany() *string {
	if l == nil {
		return nil
	}
	return l.Company
}

func (l *Lead) GetFirstName() *string {
	if l == nil {
		return nil
	}
	return l.FirstName
}

func (l *Lead) GetLastName() *string {
	if l == nil {
		return nil
	}
	return l.LastName
}

func (l *Lead) GetAddresses() []*Address {
	if l == nil {
		return nil
	}
	return l.Addresses
}

func (l *Lead) GetEmailAddresses() []*EmailAddress {
	if l == nil {
		return nil
	}
	return l.EmailAddresses
}

func (l *Lead) GetPhoneNumbers() []*PhoneNumber {
	if l == nil {
		return nil
	}
	return l.PhoneNumbers
}

func (l *Lead) GetRemoteUpdatedAt() *time.Time {
	if l == nil {
		return nil
	}
	return l.RemoteUpdatedAt
}

func (l *Lead) GetRemoteCreatedAt() *time.Time {
	if l == nil {
		return nil
	}
	return l.RemoteCreatedAt
}

func (l *Lead) GetConvertedDate() *time.Time {
	if l == nil {
		return nil
	}
	return l.ConvertedDate
}

func (l *Lead) GetConvertedContact() *LeadConvertedContact {
	if l == nil {
		return nil
	}
	return l.ConvertedContact
}

func (l *Lead) GetConvertedAccount() *LeadConvertedAccount {
	if l == nil {
		return nil
	}
	return l.ConvertedAccount
}

func (l *Lead) GetRemoteWasDeleted() *bool {
	if l == nil {
		return nil
	}
	return l.RemoteWasDeleted
}

func (l *Lead) GetFieldMappings() map[string]interface{} {
	if l == nil {
		return nil
	}
	return l.FieldMappings
}

func (l *Lead) GetRemoteData() []*RemoteData {
	if l == nil {
		return nil
	}
	return l.RemoteData
}

func (l *Lead) GetRemoteFields() []*RemoteField {
	if l == nil {
		return nil
	}
	return l.RemoteFields
}

func (l *Lead) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Lead) UnmarshalJSON(data []byte) error {
	type embed Lead
	var unmarshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		ConvertedDate   *internal.DateTime `json:"converted_date,omitempty"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = Lead(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	l.ModifiedAt = unmarshaler.ModifiedAt.TimePtr()
	l.RemoteUpdatedAt = unmarshaler.RemoteUpdatedAt.TimePtr()
	l.RemoteCreatedAt = unmarshaler.RemoteCreatedAt.TimePtr()
	l.ConvertedDate = unmarshaler.ConvertedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *Lead) MarshalJSON() ([]byte, error) {
	type embed Lead
	var marshaler = struct {
		embed
		CreatedAt       *internal.DateTime `json:"created_at,omitempty"`
		ModifiedAt      *internal.DateTime `json:"modified_at,omitempty"`
		RemoteUpdatedAt *internal.DateTime `json:"remote_updated_at,omitempty"`
		RemoteCreatedAt *internal.DateTime `json:"remote_created_at,omitempty"`
		ConvertedDate   *internal.DateTime `json:"converted_date,omitempty"`
	}{
		embed:           embed(*l),
		CreatedAt:       internal.NewOptionalDateTime(l.CreatedAt),
		ModifiedAt:      internal.NewOptionalDateTime(l.ModifiedAt),
		RemoteUpdatedAt: internal.NewOptionalDateTime(l.RemoteUpdatedAt),
		RemoteCreatedAt: internal.NewOptionalDateTime(l.RemoteCreatedAt),
		ConvertedDate:   internal.NewOptionalDateTime(l.ConvertedDate),
	}
	return json.Marshal(marshaler)
}

func (l *Lead) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The account of the converted lead.
type LeadConvertedAccount struct {
	String  string
	Account *Account

	typ string
}

func (l *LeadConvertedAccount) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LeadConvertedAccount) GetAccount() *Account {
	if l == nil {
		return nil
	}
	return l.Account
}

func (l *LeadConvertedAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		l.typ = "Account"
		l.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadConvertedAccount) MarshalJSON() ([]byte, error) {
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	if l.typ == "Account" || l.Account != nil {
		return json.Marshal(l.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LeadConvertedAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (l *LeadConvertedAccount) Accept(visitor LeadConvertedAccountVisitor) error {
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	if l.typ == "Account" || l.Account != nil {
		return visitor.VisitAccount(l.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// The contact of the converted lead.
type LeadConvertedContact struct {
	String  string
	Contact *Contact

	typ string
}

func (l *LeadConvertedContact) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LeadConvertedContact) GetContact() *Contact {
	if l == nil {
		return nil
	}
	return l.Contact
}

func (l *LeadConvertedContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		l.typ = "Contact"
		l.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadConvertedContact) MarshalJSON() ([]byte, error) {
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	if l.typ == "Contact" || l.Contact != nil {
		return json.Marshal(l.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LeadConvertedContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (l *LeadConvertedContact) Accept(visitor LeadConvertedContactVisitor) error {
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	if l.typ == "Contact" || l.Contact != nil {
		return visitor.VisitContact(l.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// The lead's owner.
type LeadOwner struct {
	String string
	User   *User

	typ string
}

func (l *LeadOwner) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LeadOwner) GetUser() *User {
	if l == nil {
		return nil
	}
	return l.User
}

func (l *LeadOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		l.typ = "User"
		l.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadOwner) MarshalJSON() ([]byte, error) {
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	if l.typ == "User" || l.User != nil {
		return json.Marshal(l.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LeadOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (l *LeadOwner) Accept(visitor LeadOwnerVisitor) error {
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	if l.typ == "User" || l.User != nil {
		return visitor.VisitUser(l.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// # The Lead Object
// ### Description
// The `Lead` object is used to represent an individual who is a potential customer.
// ### Usage Example
// TODO
type LeadRequest struct {
	// The lead's owner.
	Owner *LeadRequestOwner `json:"owner,omitempty" url:"owner,omitempty"`
	// The lead's source.
	LeadSource *string `json:"lead_source,omitempty" url:"lead_source,omitempty"`
	// The lead's title.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// The lead's company.
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// The lead's first name.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// The lead's last name.
	LastName       *string                `json:"last_name,omitempty" url:"last_name,omitempty"`
	Addresses      []*AddressRequest      `json:"addresses,omitempty" url:"addresses,omitempty"`
	EmailAddresses []*EmailAddressRequest `json:"email_addresses,omitempty" url:"email_addresses,omitempty"`
	PhoneNumbers   []*PhoneNumberRequest  `json:"phone_numbers,omitempty" url:"phone_numbers,omitempty"`
	// When the lead was converted.
	ConvertedDate *time.Time `json:"converted_date,omitempty" url:"converted_date,omitempty"`
	// The contact of the converted lead.
	ConvertedContact *LeadRequestConvertedContact `json:"converted_contact,omitempty" url:"converted_contact,omitempty"`
	// The account of the converted lead.
	ConvertedAccount    *LeadRequestConvertedAccount `json:"converted_account,omitempty" url:"converted_account,omitempty"`
	IntegrationParams   map[string]interface{}       `json:"integration_params,omitempty" url:"integration_params,omitempty"`
	LinkedAccountParams map[string]interface{}       `json:"linked_account_params,omitempty" url:"linked_account_params,omitempty"`
	RemoteFields        []*RemoteFieldRequest        `json:"remote_fields,omitempty" url:"remote_fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LeadRequest) GetOwner() *LeadRequestOwner {
	if l == nil {
		return nil
	}
	return l.Owner
}

func (l *LeadRequest) GetLeadSource() *string {
	if l == nil {
		return nil
	}
	return l.LeadSource
}

func (l *LeadRequest) GetTitle() *string {
	if l == nil {
		return nil
	}
	return l.Title
}

func (l *LeadRequest) GetCompany() *string {
	if l == nil {
		return nil
	}
	return l.Company
}

func (l *LeadRequest) GetFirstName() *string {
	if l == nil {
		return nil
	}
	return l.FirstName
}

func (l *LeadRequest) GetLastName() *string {
	if l == nil {
		return nil
	}
	return l.LastName
}

func (l *LeadRequest) GetAddresses() []*AddressRequest {
	if l == nil {
		return nil
	}
	return l.Addresses
}

func (l *LeadRequest) GetEmailAddresses() []*EmailAddressRequest {
	if l == nil {
		return nil
	}
	return l.EmailAddresses
}

func (l *LeadRequest) GetPhoneNumbers() []*PhoneNumberRequest {
	if l == nil {
		return nil
	}
	return l.PhoneNumbers
}

func (l *LeadRequest) GetConvertedDate() *time.Time {
	if l == nil {
		return nil
	}
	return l.ConvertedDate
}

func (l *LeadRequest) GetConvertedContact() *LeadRequestConvertedContact {
	if l == nil {
		return nil
	}
	return l.ConvertedContact
}

func (l *LeadRequest) GetConvertedAccount() *LeadRequestConvertedAccount {
	if l == nil {
		return nil
	}
	return l.ConvertedAccount
}

func (l *LeadRequest) GetIntegrationParams() map[string]interface{} {
	if l == nil {
		return nil
	}
	return l.IntegrationParams
}

func (l *LeadRequest) GetLinkedAccountParams() map[string]interface{} {
	if l == nil {
		return nil
	}
	return l.LinkedAccountParams
}

func (l *LeadRequest) GetRemoteFields() []*RemoteFieldRequest {
	if l == nil {
		return nil
	}
	return l.RemoteFields
}

func (l *LeadRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LeadRequest) UnmarshalJSON(data []byte) error {
	type embed LeadRequest
	var unmarshaler = struct {
		embed
		ConvertedDate *internal.DateTime `json:"converted_date,omitempty"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LeadRequest(unmarshaler.embed)
	l.ConvertedDate = unmarshaler.ConvertedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LeadRequest) MarshalJSON() ([]byte, error) {
	type embed LeadRequest
	var marshaler = struct {
		embed
		ConvertedDate *internal.DateTime `json:"converted_date,omitempty"`
	}{
		embed:         embed(*l),
		ConvertedDate: internal.NewOptionalDateTime(l.ConvertedDate),
	}
	return json.Marshal(marshaler)
}

func (l *LeadRequest) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The account of the converted lead.
type LeadRequestConvertedAccount struct {
	String  string
	Account *Account

	typ string
}

func (l *LeadRequestConvertedAccount) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LeadRequestConvertedAccount) GetAccount() *Account {
	if l == nil {
		return nil
	}
	return l.Account
}

func (l *LeadRequestConvertedAccount) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	valueAccount := new(Account)
	if err := json.Unmarshal(data, &valueAccount); err == nil {
		l.typ = "Account"
		l.Account = valueAccount
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadRequestConvertedAccount) MarshalJSON() ([]byte, error) {
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	if l.typ == "Account" || l.Account != nil {
		return json.Marshal(l.Account)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LeadRequestConvertedAccountVisitor interface {
	VisitString(string) error
	VisitAccount(*Account) error
}

func (l *LeadRequestConvertedAccount) Accept(visitor LeadRequestConvertedAccountVisitor) error {
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	if l.typ == "Account" || l.Account != nil {
		return visitor.VisitAccount(l.Account)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// The contact of the converted lead.
type LeadRequestConvertedContact struct {
	String  string
	Contact *Contact

	typ string
}

func (l *LeadRequestConvertedContact) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LeadRequestConvertedContact) GetContact() *Contact {
	if l == nil {
		return nil
	}
	return l.Contact
}

func (l *LeadRequestConvertedContact) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	valueContact := new(Contact)
	if err := json.Unmarshal(data, &valueContact); err == nil {
		l.typ = "Contact"
		l.Contact = valueContact
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadRequestConvertedContact) MarshalJSON() ([]byte, error) {
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	if l.typ == "Contact" || l.Contact != nil {
		return json.Marshal(l.Contact)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LeadRequestConvertedContactVisitor interface {
	VisitString(string) error
	VisitContact(*Contact) error
}

func (l *LeadRequestConvertedContact) Accept(visitor LeadRequestConvertedContactVisitor) error {
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	if l.typ == "Contact" || l.Contact != nil {
		return visitor.VisitContact(l.Contact)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// The lead's owner.
type LeadRequestOwner struct {
	String string
	User   *User

	typ string
}

func (l *LeadRequestOwner) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LeadRequestOwner) GetUser() *User {
	if l == nil {
		return nil
	}
	return l.User
}

func (l *LeadRequestOwner) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	valueUser := new(User)
	if err := json.Unmarshal(data, &valueUser); err == nil {
		l.typ = "User"
		l.User = valueUser
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LeadRequestOwner) MarshalJSON() ([]byte, error) {
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	if l.typ == "User" || l.User != nil {
		return json.Marshal(l.User)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LeadRequestOwnerVisitor interface {
	VisitString(string) error
	VisitUser(*User) error
}

func (l *LeadRequestOwner) Accept(visitor LeadRequestOwnerVisitor) error {
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	if l.typ == "User" || l.User != nil {
		return visitor.VisitUser(l.User)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LeadResponse struct {
	Model    *Lead                       `json:"model" url:"model"`
	Warnings []*WarningValidationProblem `json:"warnings" url:"warnings"`
	Errors   []*ErrorValidationProblem   `json:"errors" url:"errors"`
	Logs     []*DebugModeLog             `json:"logs,omitempty" url:"logs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LeadResponse) GetModel() *Lead {
	if l == nil {
		return nil
	}
	return l.Model
}

func (l *LeadResponse) GetWarnings() []*WarningValidationProblem {
	if l == nil {
		return nil
	}
	return l.Warnings
}

func (l *LeadResponse) GetErrors() []*ErrorValidationProblem {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *LeadResponse) GetLogs() []*DebugModeLog {
	if l == nil {
		return nil
	}
	return l.Logs
}

func (l *LeadResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LeadResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LeadResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LeadResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LeadResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type PaginatedLeadList struct {
	Next     *string `json:"next,omitempty" url:"next,omitempty"`
	Previous *string `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*Lead `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedLeadList) GetNext() *string {
	if p == nil {
		return nil
	}
	return p.Next
}

func (p *PaginatedLeadList) GetPrevious() *string {
	if p == nil {
		return nil
	}
	return p.Previous
}

func (p *PaginatedLeadList) GetResults() []*Lead {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PaginatedLeadList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedLeadList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedLeadList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedLeadList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedLeadList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
